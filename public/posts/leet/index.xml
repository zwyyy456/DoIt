<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on My New Hugo Site</title>
    <link>http://localhost:1313/posts/leet/</link>
    <description>Recent content in Leetcode on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Oct 2023 11:17:11 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/leet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>798.smallest Rotation With Highest Score</title>
      <link>http://localhost:1313/posts/leet/798.smallest-rotation-with-highest-score/</link>
      <pubDate>Mon, 23 Oct 2023 11:17:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/798.smallest-rotation-with-highest-score/</guid>
      <description>Description 798. Smallest Rotation with Highest Score (Hard) You are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point.&#xA;For example, if we have nums = [2,4,1,3,0], and we rotate by k = 2, it becomes [1,3,0,2,4].</description>
    </item>
    <item>
      <title>798. 得分最高的最小轮调 (Hard)</title>
      <link>http://localhost:1313/posts/leet/798.smallest-rotation-with-highest-score.zh/</link>
      <pubDate>Mon, 23 Oct 2023 11:17:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/798.smallest-rotation-with-highest-score.zh/</guid>
      <description>问题描述 798. 得分最高的最小轮调 (Hard)&#xA;给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]] 的形式。此后，任何值小于或等于其索 引的项都可以记作一分。&#xA;例如，数组为 nums = [2,4,1,3,0]，我们按 k = 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 &amp;gt; 0 [不计分]、 3 &amp;gt; 1 [不计分]、 0 &amp;lt;= 2 [计 1 分]、 2 &amp;lt;= 3 [计 1 分]， 4 &amp;lt;= 4 [计 1 分]。 在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最 小的下标 k 。&#xA;示例 1：&#xA;输入：nums = [2,3,1,4,0] 输出：3 解释： 下面列出了每个 k 的得分： k = 0, nums = [2,3,1,4,0], score 2 k = 1, nums = [3,1,4,0,2], score 3 k = 2, nums = [1,4,0,2,3], score 3 k = 3, nums = [4,0,2,3,1], score 4 k = 4, nums = [0,2,3,1,4], score 3 所以我们应当选择 k = 3，得分最高。 示例 2：</description>
    </item>
    <item>
      <title>1201. Ugly Number III (Medium)</title>
      <link>http://localhost:1313/posts/leet/1201.ugly-number-iii/</link>
      <pubDate>Tue, 17 Oct 2023 11:10:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1201.ugly-number-iii/</guid>
      <description>Description 1201. Ugly Number III (Medium)&#xA;An ugly number is a positive integer that is divisible by a, b, or c.&#xA;Given four integers n, a, b, and c, return the nᵗʰ ugly number.&#xA;Example 1:&#xA;Input: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3ʳᵈ is 4. Example 2:</description>
    </item>
    <item>
      <title>1201. 丑数 III (Medium)</title>
      <link>http://localhost:1313/posts/leet/1201.ugly-number-iii.zh/</link>
      <pubDate>Tue, 17 Oct 2023 11:10:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1201.ugly-number-iii.zh/</guid>
      <description>问题描述 1201. 丑数 III (Medium)&#xA;给你四个整数： n 、 a 、 b 、 c ，请你设计一个算法来找出第 n 个丑数。&#xA;丑数是可以被 a 或 b 或 c 整除的 正整数 。&#xA;示例 1：&#xA;输入：n = 3, a = 2, b = 3, c = 5 输出：4 解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2：&#xA;输入：n = 4, a = 2, b = 3, c = 4 输出：6 解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12.</description>
    </item>
    <item>
      <title>2652. Sum Multiples (Easy)</title>
      <link>http://localhost:1313/posts/leet/2652.sum-multiples/</link>
      <pubDate>Tue, 17 Oct 2023 10:59:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2652.sum-multiples/</guid>
      <description>Description 2652. Sum Multiples (Easy)&#xA;Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.&#xA;Return an integer denoting the sum of all numbers in the given range satisfying the constraint.&#xA;Example 1:&#xA;Input: n = 7 Output: 21 Explanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7.</description>
    </item>
    <item>
      <title>2652. 倍数求和 (Easy)</title>
      <link>http://localhost:1313/posts/leet/2652.sum-multiples.zh/</link>
      <pubDate>Tue, 17 Oct 2023 10:59:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2652.sum-multiples.zh/</guid>
      <description>问题描述 2652. 倍数求和 (Easy) 给你一个正整数 n ，请你计算在 [1，n] 范围内能被 3、 5、 7 整除的所有整数之和。&#xA;返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。&#xA;示例 1：&#xA;输入：n = 7 输出：21 解释：在 [1, 7] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7 。数字之和为 21 。 示例 2：&#xA;输入：n = 10 输出：40 解释：在 [1, 10] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9、10 。数字之和为 40 。 示例 3：&#xA;输入：n = 9 输出：30 解释：在 [1, 9] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9 。数字之和为 30 。 提示：&#xA;1 &amp;lt;= n &amp;lt;= 10³ 解题思路 这题由于数据范围给的小，暴力就能过，但是也有非暴力的方法。</description>
    </item>
    <item>
      <title>446. Arithmetic Slices II - Subsequence (Hard)</title>
      <link>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence/</link>
      <pubDate>Tue, 17 Oct 2023 10:27:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence/</guid>
      <description>Description 446. Arithmetic Slices II - Subsequence (Hard)&#xA;Given an integer array nums, return the number of all the arithmetic subsequences of nums.&#xA;A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.&#xA;For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences. For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.</description>
    </item>
    <item>
      <title>446. 等差数列划分 II - 子序列 (Hard)</title>
      <link>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence.zh/</link>
      <pubDate>Tue, 17 Oct 2023 10:27:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence.zh/</guid>
      <description>问题描述 446. 等差数列划分 II - 子序列 (Hard)&#xA;给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。&#xA;如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。&#xA;例如， [1, 3, 5, 7, 9]、 [7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。 再例如， [1, 1, 2, 5, 7] 不是等差序列。 数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。&#xA;例如， [2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 题目数据保证答案是一个 32-bit 整数。&#xA;示例 1：&#xA;输入：nums = [2,4,6,8,10] 输出：7 解释：所有的等差子序列为： [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10] 示例 2：&#xA;输入：nums = [7,7,7,7,7] 输出：16 解释：数组中的任意子序列都是等差子序列。 提示：</description>
    </item>
    <item>
      <title>260. Single Number III (Medium)</title>
      <link>http://localhost:1313/posts/leet/260.single-number-iii/</link>
      <pubDate>Mon, 16 Oct 2023 10:53:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/260.single-number-iii/</guid>
      <description>Description 260. Single Number III (Medium)&#xA;Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.&#xA;You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.&#xA;Example 1:&#xA;Input: nums = [1,2,1,3,2,5] Output: [3,5] Explanation: [5, 3] is also a valid answer.</description>
    </item>
    <item>
      <title>260. 只出现一次的数字 III (Medium)</title>
      <link>http://localhost:1313/posts/leet/260.single-number-iii.zh/</link>
      <pubDate>Mon, 16 Oct 2023 10:53:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/260.single-number-iii.zh/</guid>
      <description>问题描述 260. 只出现一次的数字 III (Medium)&#xA;给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两 个元素。你可以按 任意顺序 返回答案。&#xA;你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。&#xA;示例 1：&#xA;输入：nums = [1,2,1,3,2,5] 输出：[3,5] 解释：[5, 3] 也是有效的答案。 示例 2：&#xA;输入：nums = [-1,0] 输出：[-1,0] 示例 3：&#xA;输入：nums = [0,1] 输出：[1,0] 提示：&#xA;2 &amp;lt;= nums.length &amp;lt;= 3 * 10⁴ -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 除两个只出现一次的整数外， nums 中的其他数字都出现两次 解题思路 首先对所有数取异或，假设要找出来的元素分别为 $a$ 和 $b$，那么异或的结果就是 $c = a \oplus b$，我们考虑求 $c$ 的 lowbit，即 $c &amp;amp; (-c)$，那么我们就可以把所有元素分成两类，一类是 $nums[i] &amp;amp; lowbit = 0$，另一类是不为 $0$，$a$ 和 $b$ 一定是各属于一类，如果第一类元素的所有值的异或就是 $a$，那么第二类所有元素的异或值就是 $b$。</description>
    </item>
    <item>
      <title>137. Single Number II (Medium)</title>
      <link>http://localhost:1313/posts/leet/137.single-number-ii/</link>
      <pubDate>Mon, 16 Oct 2023 10:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/137.single-number-ii/</guid>
      <description>Description 137. Single Number II (Medium)&#xA;Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.&#xA;You must implement a solution with a linear runtime complexity and use only constant extra space.&#xA;Example 1:&#xA;Input: nums = [2,2,3,2] Output: 3 Example 2:&#xA;Input: nums = [0,1,0,1,0,1,99] Output: 99 Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 3 * 10⁴ -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 Each element in nums appears exactly three times except for one element which appears once.</description>
    </item>
    <item>
      <title>137. 只出现一次的数字 II (Medium)</title>
      <link>http://localhost:1313/posts/leet/137.single-number-ii.zh/</link>
      <pubDate>Mon, 16 Oct 2023 10:43:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/137.single-number-ii.zh/</guid>
      <description>问题描述 137. 只出现一次的数字 II (Medium) 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。 请你找出并 返回那个只出现了一次的元素。&#xA;你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。&#xA;示例 1：&#xA;输入：nums = [2,2,3,2] 输出：3 示例 2：&#xA;输入：nums = [0,1,0,1,0,1,99] 输出：99 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 3 * 10⁴ -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 解题思路 要想保证空间复杂度为 $O(1)$，我们需要考虑 nums 的二进制表示，即统计 nums[i] 的每一位上的数的和，由于只有一个元素出现一次，其他都出现了三次，那么我们对这个和 $ \mod 3$，得到的结果就是待找出的元素的每一位上的数。&#xA;代码 class Solution { public: int singleNumber(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; cnt(32); int n = nums.</description>
    </item>
    <item>
      <title>2906. Construct Product Matrix (Medium)</title>
      <link>http://localhost:1313/posts/leet/2906.construct-product-matrix/</link>
      <pubDate>Mon, 16 Oct 2023 10:37:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2906.construct-product-matrix/</guid>
      <description>Description 2906. Construct Product Matrix (Medium)&#xA;Given a 0-indexed 2D integer matrix grid of size n * m, we define a 0-indexed 2D matrix p of size n * m as the product matrix of grid if the following condition is met:&#xA;Each element p[i][j] is calculated as the product of all elements in grid except for the element grid[i][j]. This product is then taken modulo 12345. Return the product matrix of grid.</description>
    </item>
    <item>
      <title>2906. 构造乘积矩阵 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2906.construct-product-matrix.zh/</link>
      <pubDate>Mon, 16 Oct 2023 10:36:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2906.construct-product-matrix.zh/</guid>
      <description>问题描述 2906. 构造乘积矩阵 (Medium)&#xA;给你一个下标从 0 开始、大小为 n * m 的二维整数矩阵 grid ，定义一个下标从 0 开始、大小为 n * m 的的二维矩阵 p。如果满足以下条件，则称 p 为 grid 的 乘积矩阵 ：&#xA;对于每个元素 p[i][j] ，它的值等于除了 grid[i][j] 外所有元素的乘积。乘积对 12345 取余数。 返回 grid 的乘积矩阵。&#xA;示例 1：&#xA;输入：grid = [[1,2],[3,4]] 输出：[[24,12],[8,6]] 解释：p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24 p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12 p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8 p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6 所以答案是 [[24,12],[8,6]] 。 示例 2：</description>
    </item>
    <item>
      <title>1074. Number of Submatrices That Sum to Target (Hard)</title>
      <link>http://localhost:1313/posts/leet/1074.number-of-submatrices-that-sum-to-target/</link>
      <pubDate>Fri, 13 Oct 2023 11:28:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1074.number-of-submatrices-that-sum-to-target/</guid>
      <description>Description 1074. Number of Submatrices That Sum to Target (Hard)&#xA;Given a matrix and a target, return the number of non-empty submatrices that sum to target.&#xA;A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 &amp;lt;= x &amp;lt;= x2 and y1 &amp;lt;= y &amp;lt;= y2.&#xA;Two submatrices (x1, y1, x2, y2) and (x1&#39;, y1&#39;, x2&#39;, y2&#39;) are different if they have some coordinate that is different: for example, if x1 !</description>
    </item>
    <item>
      <title>1074. 元素和为目标值的子矩阵数量 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1074.number-of-submatrices-that-sum-to-target.zh/</link>
      <pubDate>Fri, 13 Oct 2023 11:27:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1074.number-of-submatrices-that-sum-to-target.zh/</guid>
      <description>问题描述 1074. 元素和为目标值的子矩阵数量 (Hard)&#xA;给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。&#xA;子矩阵 x1, y1, x2, y2 是满足 x1 &amp;lt;= x &amp;lt;= x2 且 y1 &amp;lt;= y &amp;lt;= y2 的所有单元 matrix[x][y] 的集合。&#xA;如果 (x1, y1, x2, y2) 和 (x1&#39;, y1&#39;, x2&#39;, y2&#39;) 两个子矩阵中部分坐标不同（如： x1 != x1&#39;），那么 这两个子矩阵也不同。&#xA;示例 1：&#xA;输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 输出：4 解释：四个只含 0 的 1x1 子矩阵。 示例 2：&#xA;输入：matrix = [[1,-1],[-1,1]], target = 0 输出：5 解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。 示例 3：</description>
    </item>
    <item>
      <title>2251. Number of Flowers in Full Bloom (Hard)</title>
      <link>http://localhost:1313/posts/leet/2251.number-of-flowers-in-full-bloom/</link>
      <pubDate>Fri, 06 Oct 2023 20:33:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2251.number-of-flowers-in-full-bloom/</guid>
      <description>Descriptio 2251. Number of Flowers in Full Bloom (Hard)&#xA;You are given a 0-indexed 2D integer array flowers, where flowers[i] = [startᵢ, endᵢ] means the iᵗʰ flower will be in full bloom from startᵢ to endᵢ ( inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the iᵗʰ person will arrive to see the flowers.&#xA;Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the iᵗʰ person arrives.</description>
    </item>
    <item>
      <title>2251. 花期内花的数目 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2251.number-of-flowers-in-full-bloom.zh/</link>
      <pubDate>Fri, 06 Oct 2023 20:25:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2251.number-of-flowers-in-full-bloom.zh/</guid>
      <description>问题描述 2251. 花期内花的数目 (Hard)&#xA;给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [startᵢ, endᵢ] 表示第 i 朵 花的 花期 从 startᵢ 到 endᵢ （都 包含）。同时给你一个下标从 0 开始大小为 n 的整数 数组 people ， people[i] 是第 i 个人来看花的时间。&#xA;请你返回一个大小为 n 的整数数组 answer ，其中 answer[i] 是第 i 个人到达时在花期内花的 **数目 ** 。&#xA;示例 1：&#xA;输入：flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11] 输出：[1,2,2,2] 解释：上图展示了每朵花的花期时间，和每个人的到达时间。 对每个人，我们返回他们到达时在花期内花的数目。 示例 2：&#xA;输入：flowers = [[1,10],[3,3]], people = [3,3,2] 输出：[2,2,1] 解释：上图展示了每朵花的花期时间，和每个人的到达时间。 对每个人，我们返回他们到达时在花期内花的数目。 提示：</description>
    </item>
    <item>
      <title>2136.earliest Possible Day of Full Bloom</title>
      <link>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom/</link>
      <pubDate>Thu, 05 Oct 2023 18:28:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom/</guid>
      <description>Descriptio 2136. Earliest Possible Day of Full Bloom (Hard) You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:&#xA;plantTime[i] is the number of full days it takes you to plant the iᵗʰ seed. Every day, you can work on planting exactly one seed.</description>
    </item>
    <item>
      <title>2136. 全部开花的最早一天 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom.zh/</link>
      <pubDate>Thu, 05 Oct 2023 18:28:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom.zh/</guid>
      <description>问题描述 2136. 全部开花的最早一天 (Hard)&#xA;你有 n 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你 两个下标从 0 开始的整数数组 plantTime 和 growTime ，每个数组的长度都是 n ：&#xA;plantTime[i] 是 播种 第 i 枚种子所需的 完整天数 。每天，你只能为播种某一枚种子而劳作。 无须 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 plantTime[i] 之后才算完成。 growTime[i] 是第 i 枚种子完全种下后生长所需的 完整天数。在它生长的最后一天 之后 ，将会 开花并且永远 绽放 。 从第 0 开始，你可以按 任意 顺序播种种子。&#xA;返回所有种子都开花的 最早 一天是第几天。&#xA;示例 1：&#xA;输入：plantTime = [1,4,3], growTime = [2,3,1] 输出：9 解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 一种最优方案是： 第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。 第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。 第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。 因此，在第 9 天，所有种子都开花。 示例 2：</description>
    </item>
    <item>
      <title>188. Best Time to Buy and Sell Stock IV (Hard)</title>
      <link>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv/</link>
      <pubDate>Thu, 05 Oct 2023 16:16:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv/</guid>
      <description>Description 188. Best Time to Buy and Sell Stock IV (Hard)&#xA;You are given an integer array prices where prices[i] is the price of a given stock on the iᵗʰ day, and an integer k.&#xA;Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.&#xA;Note: You may not engage in multiple transactions simultaneously (i.</description>
    </item>
    <item>
      <title>188. 买卖股票的最佳时机 IV (Hard)</title>
      <link>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv.zh/</link>
      <pubDate>Thu, 05 Oct 2023 16:16:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv.zh/</guid>
      <description>问题描述 188. 买卖股票的最佳时机 IV (Hard)&#xA;给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。&#xA;设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。&#xA;注意： 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&#xA;示例 1：&#xA;输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2：&#xA;输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获 得利润 = 3-0 = 3 。 提示：</description>
    </item>
    <item>
      <title>310. Minimum Height Trees (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees/</guid>
      <description>Description 310. Minimum Height Trees (Medium)&#xA;A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.&#xA;Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [aᵢ, bᵢ] indicates that there is an undirected edge between the two nodes aᵢ and bᵢ in the tree, you can choose any node of the tree as the root.</description>
    </item>
    <item>
      <title>310. 最小高度树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</guid>
      <description>问题描述 310. 最小高度树 (Medium)&#xA;树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵 树。&#xA;给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条无 向边。&#xA;可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中， 具有最小高度的树（即， min(h)）被称为 最小高度树 。&#xA;请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。&#xA;树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。&#xA;示例 1：&#xA;输入：n = 4, edges = [[1,0],[1,2],[1,3]] 输出：[1] 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 示例 2：&#xA;输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] 输出：[3,4] 提示：</description>
    </item>
    <item>
      <title>331. Verify Preorder Serialization of a Binary Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree/</link>
      <pubDate>Wed, 13 Sep 2023 11:10:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree/</guid>
      <description>Description 331. Verify Preorder Serialization of a Binary Tree (Medium)&#xA;One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node&amp;rsquo;s value. If it is a null node, we record using a sentinel value such as &#39;#&#39;.&#xA;For example, the above binary tree can be serialized to the string &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;, where &#39;#&#39; represents a null node.&#xA;Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.</description>
    </item>
    <item>
      <title>331.verify Preorder Serialization of a Binary Tree</title>
      <link>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree.zh/</link>
      <pubDate>Wed, 13 Sep 2023 11:10:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree.zh/</guid>
      <description>问题描述 331. 验证二叉树的前序序列化 (Medium)&#xA;序列化二叉树的一种方法是使用 前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如 果它是一个空节点，我们可以使用一个标记值记录，例如 #。&#xA;例如，上面的二叉树可以被序列化为字符串 &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;，其中 # 代表一个空节点。&#xA;给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法 。&#xA;保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &#39;#&#39; 。&#xA;你可以认为输入格式总是有效的&#xA;例如它永远不会包含两个连续的逗号，比如 &amp;quot;1,,3&amp;quot; 。 注意： 不允许重建树。&#xA;示例 1:&#xA;输入: preorder = &amp;#34;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;#34; 输出: true 示例 2:&#xA;输入: preorder = &amp;#34;1,#&amp;#34; 输出: false 示例 3:&#xA;输入: preorder = &amp;#34;9,#,#,1&amp;#34; 输出: false 提示:&#xA;1 &amp;lt;= preorder.length &amp;lt;= 10⁴ preorder 由以逗号 “，” 分隔的 [0,100] 范围内的整数和 “#” 组成 解题思路 归约 本质上还是一种递归的思想，在前序遍历时，我们可以注意到，每个叶子结点必定跟随两个 null，因此，我们可以反过来，将连续的一个非空结点和两个空结点，归约为一个空结点，这个过程有点像消消乐，可以利用栈来实现这个过程，最后根据栈是否只剩下一个空结点来判断。&#xA;递归 递归的思路参照 剑指 Offer 37.</description>
    </item>
    <item>
      <title>1462.course Schedule Iv</title>
      <link>http://localhost:1313/posts/leet/1462.course-schedule-iv/</link>
      <pubDate>Tue, 12 Sep 2023 20:14:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1462.course-schedule-iv/</guid>
      <description>Description 1462. Course Schedule IV (Medium)&#xA;There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [aᵢ, bᵢ] indicates that you must take course aᵢ first if you want to take course bᵢ.&#xA;For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1. Prerequisites can also be indirect.</description>
    </item>
    <item>
      <title>1462. 课程表 IV (Medium)</title>
      <link>http://localhost:1313/posts/leet/1462.course-schedule-iv.zh/</link>
      <pubDate>Tue, 12 Sep 2023 20:14:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1462.course-schedule-iv.zh/</guid>
      <description>问题描述 1462. 课程表 IV (Medium)&#xA;你总共需要上 numCourses 门课，课程编号依次为 0 到 numCourses-1 。你会得到一个数组 prerequisit e ，其中 prerequisites[i] = [aᵢ, bᵢ] 表示如果你想选 bᵢ 课程，你 必须 先选 aᵢ 课程。&#xA;有的课会有直接的先修课程，比如如果想上课程 1 ，你必须先上课程 0 ，那么会以 [0,1] 数对的形式 给出先修课程数对。 先决条件也可以是 间接 的。如果课程 a 是课程 b 的先决条件，课程 b 是课程 c 的先决条件，那 么课程 a 就是课程 c 的先决条件。&#xA;你也得到一个数组 queries ，其中 queries[j] = [uⱼ, vⱼ]。对于第 j 个查询，您应该回答课程 uⱼ 是 否是课程 vⱼ 的先决条件。&#xA;返回一个布尔数组 answer ，其中 answer[j] 是第 j 个查询的答案。</description>
    </item>
    <item>
      <title>109. Convert Sorted List to Binary Search Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Mon, 11 Sep 2023 14:40:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree/</guid>
      <description>Description 109. Convert Sorted List to Binary Search Tree (Medium)&#xA;Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balancedbinary search tree.&#xA;Example 1:&#xA;Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST. Example 2:&#xA;Input: head = [] Output: [] Constraints:&#xA;The number of nodes in head is in the range [0, 2 * 10⁴].</description>
    </item>
    <item>
      <title>109. 有序链表转换二叉搜索树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree.zh/</link>
      <pubDate>Mon, 11 Sep 2023 14:40:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree.zh/</guid>
      <description>问题描述 109. 有序链表转换二叉搜索树 (Medium)&#xA;给定一个单链表的头节点 head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。&#xA;本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。&#xA;示例 1:&#xA;输入: head = [-10,-3,0,5,9] 输出: [0,-3,9,-10,null,5] 解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。 示例 2:&#xA;输入: head = [] 输出: [] 提示:&#xA;head 中的节点数在 [0, 2 * 10⁴] 范围内 -10⁵ &amp;lt;= Node.val &amp;lt;= 10⁵ 解题思路 首先，如果将链表换成数组，可以很方便地在 $O(n)$ 时间内完成，然后由于链表无法像数组那样在 $O(1)$ 时间内实现随机访问，因此不能套用数组的思路。&#xA;我们首先要想到，对二叉搜索树进行中序遍历，就能得到一个升序链表，那么我们也可以通过一个类似中序遍历的过程，得到二叉搜索树。即先计算左子结点，根结点就是当前遍历到的链表结点，然后计算右子结点。&#xA;代码 class Solution { public: TreeNode *dfs(int l, int r, ListNode **head) { if (l &amp;gt;= r) { return nullptr; } int mid = l + (r - l) / 2; TreeNode *left = dfs(l, mid, head); TreeNode *root = new TreeNode((*head)-&amp;gt;val); root-&amp;gt;left = left; *head = (*head)-&amp;gt;next; root-&amp;gt;right = dfs(mid + 1, r, head); return root; } TreeNode *sortedListToBST(ListNode *head) { // 牢记，二叉搜索树的中序遍历结果是一个升序数组 ListNode *tail = head; int cnt = 0; while (tail !</description>
    </item>
    <item>
      <title>99. 恢复二叉搜索树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/99.recover-binary-search-tree.zh/</link>
      <pubDate>Fri, 08 Sep 2023 10:15:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/99.recover-binary-search-tree.zh/</guid>
      <description>问题描述 99. 恢复二叉搜索树 (Medium)&#xA;给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下 ，恢复这棵树 。&#xA;示例 1：&#xA;输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 的左孩子，因为 3 &amp;gt; 1 。交换 1 和 3 使二叉搜索树有效。 示例 2：&#xA;输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 &amp;lt; 3 。交换 2 和 3 使二叉搜索树有效。 提示：&#xA;树上节点的数目在范围 [2, 1000] 内 -2³¹ &amp;lt;= Node.val &amp;lt;= 2³¹ - 1 进阶： 使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用 O(1) 空间的解决方案吗？&#xA;解题思路 这里就直接考虑 $O(1)$ 时间复杂度的解法了，首先我们知道，对二叉搜索树进行中序遍历，其结点值是严格递增的，因此，我们可以利用这一点来找出被交换的两个节点。&#xA;我们考虑一个递增序列，然后交换序列中任意两个元素，如果这两个元素是相邻的，那么当我们遍历时，会出现一次 $a_{i} &amp;lt; a_{i - 1}$ 的情况；而如果这两个元素不相邻，那么会出现两次 $a_{i} &amp;lt; a_{i - 1}$ 的情况。我们将出现 $a_{i} &amp;lt; a_{i - 1}$ 的元素对都存入数组 vec，那么 vec.</description>
    </item>
    <item>
      <title>99. Recover Binary Search Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/99.recover-binary-search-tree/</link>
      <pubDate>Fri, 08 Sep 2023 10:15:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/99.recover-binary-search-tree/</guid>
      <description>Description 99. Recover Binary Search Tree (Medium)&#xA;You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.&#xA;Example 1:&#xA;Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 &amp;gt; 1. Swapping 1 and 3 makes the BST valid. Example 2:</description>
    </item>
    <item>
      <title>31.next Permutation</title>
      <link>http://localhost:1313/posts/leet/31.next-permutation/</link>
      <pubDate>Tue, 08 Aug 2023 13:32:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/31.next-permutation/</guid>
      <description></description>
    </item>
    <item>
      <title>31. 下一个排列 (Medium)</title>
      <link>http://localhost:1313/posts/leet/31.next-permutation.zh/</link>
      <pubDate>Tue, 08 Aug 2023 13:32:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/31.next-permutation.zh/</guid>
      <description>问题描述 31. 下一个排列 (Medium)&#xA;整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。&#xA;例如， arr = [1,2,3] ，以下这些都可以视作 arr 的排列： [1,2,3]、 [1,3,2]、 [3,1,2]、 [2 ,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典 顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如 果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。&#xA;例如， arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地， arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。&#xA;必须 原地 修改，只允许使用 额外常数空间。&#xA;示例 1：&#xA;输入：nums = [1,2,3] 输出：[1,3,2] 示例 2：&#xA;输入：nums = [3,2,1] 输出：[1,2,3] 示例 3：</description>
    </item>
    <item>
      <title>287.find the Duplicate Number</title>
      <link>http://localhost:1313/posts/leet/287.find-the-duplicate-number/</link>
      <pubDate>Fri, 04 Aug 2023 10:59:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/287.find-the-duplicate-number/</guid>
      <description>Solution Binary search The duality of this section is somewhat convoluted. Let us assume that the repeated digit is denoted by $k$. For the array nums, there are more than $k$ occurrences of numbers between $1$ and $k$. Therefore, for a given $mid$, if the count of numbers between $1$ and $mid$ exceeds $mid$, this indicates that $mid \geq k$, otherwise $mid &amp;lt; k$.&#xA;Two pointers Here, we can visualize the array as a singly-linked list.</description>
    </item>
    <item>
      <title>287. 寻找重复数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/287.find-the-duplicate-number.zh/</link>
      <pubDate>Fri, 04 Aug 2023 10:59:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/287.find-the-duplicate-number.zh/</guid>
      <description>问题描述 287. 寻找重复数 (Medium)&#xA;给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存 在一个重复的整数。&#xA;假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。&#xA;你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。&#xA;示例 1：&#xA;输入：nums = [1,3,4,2,2] 输出：2 示例 2：&#xA;输入：nums = [3,1,3,4,2] 输出：3 提示：&#xA;1 &amp;lt;= n &amp;lt;= 10⁵ nums.length == n + 1 1 &amp;lt;= nums[i] &amp;lt;= n nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 进阶：&#xA;如何证明 nums 中至少存在一个重复的数字?</description>
    </item>
    <item>
      <title>2050. Parallel Courses III (Hard)</title>
      <link>http://localhost:1313/posts/leet/2050.parallel-courses-iii/</link>
      <pubDate>Fri, 28 Jul 2023 15:59:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2050.parallel-courses-iii/</guid>
      <description>Description 2050. Parallel Courses III (Hard)&#xA;Solution The approach to this problem is quite evident, and it requires the utilization of topological sorting. During the process oftopological sorting, the longest required time should be calculated.&#xA;Code class Solution { public: int minimumTime(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;relations, vector&amp;lt;int&amp;gt; &amp;amp;time) { vector&amp;lt;int&amp;gt; cnt(n + 1); vector&amp;lt;unordered_set&amp;lt;int&amp;gt;&amp;gt; next(n + 1); for (auto &amp;amp;vec : relations) { ++cnt[vec[1]]; next[vec[0]].insert(vec[1]); } queue&amp;lt;int&amp;gt; zero; // vector&amp;lt;int&amp;gt; res; vector&amp;lt;int&amp;gt; ans(n + 1); for (int i = 1; i &amp;lt;= n; ++i) { if (cnt[i] == 0) { zero.</description>
    </item>
    <item>
      <title>2050. 并行课程 III (Hard)</title>
      <link>http://localhost:1313/posts/leet/2050.parallel-courses-iii.zh/</link>
      <pubDate>Fri, 28 Jul 2023 15:59:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2050.parallel-courses-iii.zh/</guid>
      <description>问题描述 2050. 并行课程 III (Hard)&#xA;给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ， 其中 relations[j] = [prevCourseⱼ, nextCourseⱼ] ，表示课程 prevCourseⱼ 必须在课程 nextCourseⱼ * 之前* 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完 成第 (i+1) 门课程需要花费的 月份 数。&#xA;请你根据以下规则算出完成所有课程所需要的 最少 月份数：&#xA;如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。 你可以 同时 上 任意门课程 。 请你返回完成所有课程所需要的 最少 月份数。&#xA;注意： 测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。&#xA;示例 1:&#xA;输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5] 输出：8 解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。 你可以在月份 0 同时开始课程 1 和 2 。 课程 1 花费 3 个月，课程 2 花费 2 个月。 所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。 示例 2：</description>
    </item>
    <item>
      <title>335. Self Crossing (Hard)</title>
      <link>http://localhost:1313/posts/leet/335.self-crossing/</link>
      <pubDate>Fri, 28 Jul 2023 14:16:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/335.self-crossing/</guid>
      <description>Description 335. Self Crossing (Hard)&#xA;Solution We can simulate the movement of the robot and consider the possible collisions with other tracks. For example, when moving north, the robot may intersect with tracks moving west, east, or north. Similarly, when moving west, the robot may collide with tracks moving north, south, or west. We can continue this process for other directions as well.&#xA;For instance, when moving west, we can consider the conditions for collisions with tracks moving north, south, or west.</description>
    </item>
    <item>
      <title>335. 路径交叉 (Hard)</title>
      <link>http://localhost:1313/posts/leet/335.self-crossing.zh/</link>
      <pubDate>Fri, 28 Jul 2023 14:15:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/335.self-crossing.zh/</guid>
      <description>问题描述 335. 路径交叉 (Hard)&#xA;给你一个整数数组 distance。&#xA;从 X-Y 平面上的点 (0,0) 开始，先向北移动 distance[0] 米，然后向西移动 distance[1] 米，向南 移动 distance[2] 米，向东移动 distance[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针 变化。&#xA;判断你所经过的路径是否相交。如果相交，返回 true ；否则，返回 false 。&#xA;示例 1：&#xA;输入：distance = [2,1,1,2] 输出：true 示例 2：&#xA;输入：distance = [1,2,3,4] 输出：false 示例 3：&#xA;输入：distance = [1,1,1,1] 输出：true 提示：&#xA;1 &amp;lt;= distance.length &amp;lt;= 10⁵ 1 &amp;lt;= distance[i] &amp;lt;= 10⁵ 解题思路 模拟，以向北为例，可能与向西、向东、或者向北的轨迹发生交叉；向西，则可能会与向北、向南、向西的方向发生碰撞；依次类推。&#xA;再以向西为例，分别考虑与向北、向南、向西轨迹发生碰撞时的条件。&#xA;代码 class Solution { public: bool isSelfCrossing(vector&amp;lt;int&amp;gt; &amp;amp;distance) { int n = distance.</description>
    </item>
    <item>
      <title>828. Count Unique Characters of All Substrings of a Given String (Hard)</title>
      <link>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string/</link>
      <pubDate>Thu, 27 Jul 2023 09:30:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string/</guid>
      <description>Description 828. Count Unique Characters of All Substrings of a Given String (Hard)&#xA;Solution DP This problem can be easily solved using dynamic programming. Let&amp;rsquo;s define $dp[i]$ as the sum of countUniqueChar(t) values for substrings $t$ ending at $s[i]$. The next step is to find the recurrence relation:&#xA;Suppose the character corresponding to $s[i]$ is $c$. For substrings ending at $s[i-1]$, if the substring does not contain $c$, then the countUniqueChar value for the substring ending at $s[i]$ is equal to the value for the substring ending at $s[i-1]$ (i.</description>
    </item>
    <item>
      <title>[828. 统计子串中的唯一字符] (Hard)</title>
      <link>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/</link>
      <pubDate>Thu, 27 Jul 2023 09:30:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/</guid>
      <description>问题描述 828. 统计子串中的唯一字符 (Hard)&#xA;我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。&#xA;例如： s = &amp;quot;LEETCODE&amp;quot; ，则其中 &amp;quot;L&amp;quot;, &amp;quot;T&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;O&amp;quot;, &amp;quot;D&amp;quot; 都是唯一字符，因为它们只出现一次 ，所以 countUniqueChars(s) = 5 。&#xA;本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。 输入用例保证返回值为 32 位整数。&#xA;注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的 所有子字符串中的唯一字符）。&#xA;示例 1：&#xA;输入: s = &amp;#34;ABC&amp;#34; 输出: 10 解释: 所有可能的子串为：&amp;#34;A&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;AB&amp;#34;,&amp;#34;BC&amp;#34; 和 &amp;#34;ABC&amp;#34;。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2：&#xA;输入: s = &amp;#34;ABA&amp;#34; 输出: 8 解释: 除了 countUniqueChars(&amp;#34;ABA&amp;#34;) = 1 之外，其余与示例 1 相同。 示例 3：</description>
    </item>
    <item>
      <title>918. Maximum Sum Circular Subarray (Medium)</title>
      <link>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray/</link>
      <pubDate>Thu, 20 Jul 2023 14:07:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray/</guid>
      <description>Description 918. Maximum Sum Circular Subarray (Medium)&#xA;Solution We define $dp[i]$ to represent the maximum sum of subarrays that end at $nums[i]$. Then, we can discuss two cases:&#xA;The subarray is a continuous segment, i.e., $tail \geq head$. The subarray is divided into two segments, i.e., $tail &amp;lt; head$. In each case, we can update the $dp[i]$ value accordingly to find the maximum sum of subarrays that end at each element $nums[i]$.</description>
    </item>
    <item>
      <title>918. 环形子数组的最大和 (Medium)</title>
      <link>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray.zh/</link>
      <pubDate>Thu, 20 Jul 2023 14:07:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray.zh/</guid>
      <description>问题描述 918. 环形子数组的最大和 (Medium)&#xA;给定一个长度为 n 的 环形整数数组 nums ，返回nums 的非空 子数组 的最大可能和 。&#xA;环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。&#xA;子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i &amp;lt;= k1, k2 &amp;lt;= j 其中 k1 % n == k2 % n 。&#xA;示例 1：&#xA;输入：nums = [1,-2,3,-2] 输出：3 解释：从子数组 [3] 得到最大和 3 示例 2：</description>
    </item>
    <item>
      <title>950. Reveal Cards In Increasing Order (Medium)</title>
      <link>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order/</link>
      <pubDate>Thu, 20 Jul 2023 10:25:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order/</guid>
      <description>Description 950. Reveal Cards In Increasing Order (Medium)&#xA;Solution This problem can be solved through direct simulation according to the given instructions. The use of recursion is not necessary. Since the problem involves popping the first element, a double-ended queue (deque) is a suitable data structure to use. The deque will store the indices of elements, and we can proceed with the simulation accordingly.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; deckRevealedIncreasing(vector&amp;lt;int&amp;gt;&amp;amp; deck) { sort(deck.</description>
    </item>
    <item>
      <title>950. 按递增顺序显示卡牌 (Medium)</title>
      <link>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order.zh/</link>
      <pubDate>Thu, 20 Jul 2023 10:25:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order.zh/</guid>
      <description>问题描述 950. 按递增顺序显示卡牌 (Medium)&#xA;牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。&#xA;最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。&#xA;现在，重复执行以下步骤，直到显示所有卡牌为止：&#xA;从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。 如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。 如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。 返回能以 递增顺序 显示卡牌的牌组顺序。&#xA;答案中的第一张牌被认为处于牌堆顶部。&#xA;示例：&#xA;输入：[17,13,11,2,3,5,7] 输出：[2,13,3,11,5,17,7] 解释： 我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。 重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。 我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。 我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。 我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。 我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。 我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。 我们展示 13，然后将 17 移到底部。牌组现在是 [17]。 我们显示 17。 由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。 提示：&#xA;1 &amp;lt;= A.length &amp;lt;= 1000 1 &amp;lt;= A[i] &amp;lt;= 10^6 对于所有的 i !</description>
    </item>
    <item>
      <title>2069. Walking Robot Simulation II (Medium)</title>
      <link>http://localhost:1313/posts/leet/2069.walking-robot-simulation-ii/</link>
      <pubDate>Wed, 19 Jul 2023 09:57:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2069.walking-robot-simulation-ii/</guid>
      <description>Description 2069. Walking Robot Simulation II (Medium)&#xA;Explanation Robot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East. robot.step(2); // It moves two steps East to (2, 0), and faces East. robot.step(2); // It moves two steps East to (4, 0), and faces East. robot.getPos(); // return [4, 0] robot.getDir(); // return &amp;quot;East&amp;quot; robot.step(2); // It moves one step East to (5, 0), and faces East.</description>
    </item>
    <item>
      <title>2069. 模拟行走机器人 II (Medium)</title>
      <link>http://localhost:1313/posts/leet/2069.walking-robot-simulation-ii.zh/</link>
      <pubDate>Wed, 19 Jul 2023 09:57:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2069.walking-robot-simulation-ii.zh/</guid>
      <description>问题描述 2069. 模拟行走机器人 II (Medium)&#xA;给你一个在 XY 平面上的 width x height 的网格图， 左下角 的格子为 (0, 0) ， 右上角 的格子 为 (width - 1, height - 1) 。网格图中相邻格子为四个基本方向之一（ &amp;quot;North&amp;quot;， &amp;quot;East&amp;quot;， &amp;quot;South&amp;quot; 和 &amp;quot;West&amp;quot;）。一个机器人 初始 在格子 (0, 0) ，方向为 &amp;quot;East&amp;quot; 。&#xA;机器人可以根据指令移动指定的 步数 。每一步，它可以执行以下操作。&#xA;沿着当前方向尝试 往前一步 。 如果机器人下一步将到达的格子 超出了边界 ，机器人会 逆时针 转 90 度，然后再尝试往前一步。 如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。&#xA;请你实现 Robot 类：&#xA;Robot(int width, int height) 初始化一个 width x height 的网格图，机器人初始在 (0, 0) ，方向 朝 &amp;quot;East&amp;quot; 。 void step(int num) 给机器人下达前进 num 步的指令。 int[] getPos() 返回机器人当前所处的格子位置，用一个长度为 2 的数组 [x, y] 表示。 String getDir() 返回当前机器人的朝向，为 &amp;quot;North&amp;quot; ， &amp;quot;East&amp;quot; ， &amp;quot;South&amp;quot; 或者 &amp;quot;West&amp;quot; 。 示例 1：</description>
    </item>
    <item>
      <title>1851. Minimum Interval to Include Each Query (Hard)</title>
      <link>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query/</link>
      <pubDate>Tue, 18 Jul 2023 22:19:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query/</guid>
      <description>Description 1851. Minimum Interval to Include Each Query (Hard)&#xA;Solution First, it should be noted that sorting the intervals array will not affect the result. Secondly, sorting the queries array will not have a significant impact on the answer. It merely changes the order of the answers. We just need to associate the result of each query with its corresponding index in the original queries array.&#xA;For convenience, let&amp;rsquo;s convert the queries array into a vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; qrs; where the first element represents the value to be queried, and the second element represents its index in the queries array.</description>
    </item>
    <item>
      <title>1851. 包含每个查询的最小区间 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query.zh/</link>
      <pubDate>Tue, 18 Jul 2023 22:19:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query.zh/</guid>
      <description>问题描述 [1851. 包含每个查询的最小区间] (Hard)&#xA;给你一个二维整数数组 intervals ，其中 intervals[i] = [leftᵢ, rightᵢ] 表示第 i 个区间开始于 le ftᵢ 、结束于 rightᵢ（包含两侧取值， 闭区间）。区间的 长度 定义为区间中包含的整数数目，更 正式地表达是 rightᵢ - leftᵢ + 1 。&#xA;再给你一个整数数组 queries 。第 j 个查询的答案是满足 leftᵢ &amp;lt;= queries[j] &amp;lt;= rightᵢ 的 长度最 小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。&#xA;以数组形式返回对应查询的所有答案。&#xA;示例 1：&#xA;输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] 输出：[3,3,1,4] 解释：查询处理如下： - Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。 - Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。 示例 2：</description>
    </item>
    <item>
      <title>834. Sum of Distances in Tree (Hard)</title>
      <link>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree/</link>
      <pubDate>Tue, 18 Jul 2023 10:09:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree/</guid>
      <description>Description 834. Sum of Distances in Tree (Hard)&#xA;Solution To find the sum of distances to a single node (e.g., $0$) denoted as $dp[0]$, we can easily use DFS to compute it with a time complexity of $O(n)$. However, finding the sum of distances for all $n$ nodes would take $O(n^2)$ time, which would obviously result in a timeout for large graphs.&#xA;However, we notice that there exists a recurrence relationship between the parent node $j$&amp;rsquo;s $dp[j]$ and the child node $i$&amp;rsquo;s $dp[i]$.</description>
    </item>
    <item>
      <title>834. 树中距离之和 (Hard)</title>
      <link>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree.zh/</link>
      <pubDate>Tue, 18 Jul 2023 10:09:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree.zh/</guid>
      <description>问题描述 834. 树中距离之和 (Hard)&#xA;给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。&#xA;给定整数 n 和数组 edges ， edges[i] = [aᵢ, bᵢ] 表示树中的节点 aᵢ 和 bᵢ 之间有一条边。&#xA;返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。&#xA;示例 1:&#xA;输入: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] 输出: [8,12,6,10,10,10] 解释: 树如图所示。 我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。 示例 2:</description>
    </item>
    <item>
      <title>354. Russian Doll Envelopes (Hard)</title>
      <link>http://localhost:1313/posts/leet/354.russian-doll-envelopes/</link>
      <pubDate>Fri, 23 Jun 2023 23:38:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/354.russian-doll-envelopes/</guid>
      <description>Description 354. Russian Doll Envelopes (Hard)&#xA;Solution The initial reaction to this problem is definitely sorting. The question is, should the second dimension be sorted in ascending or descending order?&#xA;Firstly, let&amp;rsquo;s observe the question. It states that both dimensions must be strictly smaller. When I attempted the problem myself, I didn&amp;rsquo;t notice this point and got stuck for a while. However, once we consider this requirement, it becomes much clearer.</description>
    </item>
    <item>
      <title>354. 俄罗斯套娃信封问题 (Hard)</title>
      <link>http://localhost:1313/posts/leet/354.russian-doll-envelopes.zh/</link>
      <pubDate>Fri, 23 Jun 2023 23:38:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/354.russian-doll-envelopes.zh/</guid>
      <description>问题描述 354. 俄罗斯套娃信封问题 (Hard)&#xA;给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wᵢ, hᵢ] ，表示第 i 个信封的宽度和高度。&#xA;当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。&#xA;请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。&#xA;注意：不允许旋转信封。&#xA;示例 1：&#xA;输入：envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出：3 解释：最多信封的个数为 3, 组合为: [2,3] =&amp;gt; [5,4] =&amp;gt; [6,7]。 示例 2：&#xA;输入：envelopes = [[1,1],[1,1],[1,1]] 输出：1 提示：&#xA;1 &amp;lt;= envelopes.length &amp;lt;= 10⁵ envelopes[i].length == 2 1 &amp;lt;= wᵢ, hᵢ &amp;lt;= 10⁵ 解题思路 本题的第一反应肯定是排序，按照第数组的第一个维度升序排序，问题在于，第二个维度是应该升序还是降序呢？&#xA;首先，观察题目，题目要求是两个维度都必须严格小于才行，我自己做的时候就没观察到这一点，卡了很久，注意到这一点的话，其实就好想很多了。&#xA;我们先假设按照第二个升序排列，当我们选择了 $(w_i, h_i)$ 之后，那么我们就是要找满足 $(w_j, h_j)$ 两个维度都严格小于 $(w_i, h_i)$ 的最大的 $(w_j, h_j)$，这里就可以联系到 LIS 问题了。</description>
    </item>
    <item>
      <title>741. Cherry Pickup (Hard)</title>
      <link>http://localhost:1313/posts/leet/741.cherry-pickup/</link>
      <pubDate>Wed, 21 Jun 2023 12:32:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/741.cherry-pickup/</guid>
      <description>Description 741. Cherry Pickup (Hard)&#xA;Solution This problem can be approached using dynamic programming, and although the concept is straightforward, there are several details to consider.&#xA;The process of picking cherries back and forth is equivalent to two individuals moving from $[0, 0]$ to $[n - 1, n - 1]$.&#xA;Let&amp;rsquo;s use $k$ to represent the number of steps taken, $x_1$ to represent the current $x$ coordinate of the first person, and $x_2$ to represent the current $x$ coordinate of the second person.</description>
    </item>
    <item>
      <title>741. 摘樱桃 (Hard)</title>
      <link>http://localhost:1313/posts/leet/741.cherry-pickup.zh/</link>
      <pubDate>Wed, 21 Jun 2023 12:32:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/741.cherry-pickup.zh/</guid>
      <description>问题描述 741. 摘樱桃 (Hard)&#xA;给你一个 n x n 的网格 grid ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：&#xA;0 表示这个格子是空的，所以你可以穿过它。 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 -1 表示这个格子里有荆棘，挡着你的路。 请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：&#xA;从位置 (0, 0) 出发，最后到达 (n - 1, n - 1) ，只能向下或向右走，并且只能穿越有效的格子（即只可 以穿过值为 0 或者 1 的格子）； 当到达 (n - 1, n - 1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的 格子； 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 0 ）； 如果在 (0, 0) 和 (n - 1, n - 1) 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。 示例 1：&#xA;输入：grid = [[0,1,-1],[1,0,-1],[1,1,1]] 输出：5 解释：玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。 在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。 然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。 总共捡到 5 个樱桃，这是最大可能值。 示例 2：</description>
    </item>
    <item>
      <title>1595. Minimum Cost to Connect Two Groups of Points] (Hard)</title>
      <link>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points/</link>
      <pubDate>Wed, 21 Jun 2023 11:43:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points/</guid>
      <description>Description 1595. Minimum Cost to Connect Two Groups of Points (Hard)&#xA;Solution Dynamic Programming + State Compression&#xA;We use a binary number $j$ to represent the set of chosen elements from the second group. $dp[i][j]$ denotes the minimum cost of connecting the first $i$ elements from the first group and the set of elements $j$ from the second group.&#xA;To establish the recurrence relation, we consider the elements from the first group.</description>
    </item>
    <item>
      <title>1595. 连通两组点的最小成本 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points.zh/</link>
      <pubDate>Wed, 21 Jun 2023 11:43:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points.zh/</guid>
      <description>问题描述 1595. 连通两组点的最小成本 (Hard)&#xA;给你两组点，其中第一组中有 size₁ 个点，第二组中有 size₂ 个点，且 size₁ &amp;gt;= size₂ 。&#xA;任意两点间的连接成本 cost 由大小为 size₁ x size₂ 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。 如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是 连通的。 换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一 组中的一个点连接。&#xA;返回连通两组点所需的最小成本。&#xA;示例 1：&#xA;输入：cost = [[15, 96], [36, 2]] 输出：17 解释：连通两组点的最佳方法是： 1--A 2--B 总成本为 17 。 示例 2：&#xA;输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]] 输出：4 解释：连通两组点的最佳方法是： 1--A 2--B 2--C 3--A 最小成本为 4 。 请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需 要关心最低总成本。 示例 3：</description>
    </item>
    <item>
      <title>1494. Parallel Courses II (Hard)</title>
      <link>http://localhost:1313/posts/leet/1494.parallel-courses-ii/</link>
      <pubDate>Fri, 16 Jun 2023 23:54:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1494.parallel-courses-ii/</guid>
      <description>Description 1494. Parallel Courses II (Hard)&#xA;Solution This problem readily brings to mind the concept of topological sorting, followed by a greedy approach. However, this approach is erroneous! In essence, this problem is NP-Hard and can only be solved through brute force.&#xA;Let&amp;rsquo;s consider the application of state-compressed dynamic programming (DP). The subproblems are relatively straightforward to identify. We start by choosing $1, 2$, followed by selecting $3, 4, 5 $(meeting the prerequisites).</description>
    </item>
    <item>
      <title>1494. 并行课程 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/1494.parallel-courses-ii.zh/</link>
      <pubDate>Fri, 16 Jun 2023 23:54:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1494.parallel-courses-ii.zh/</guid>
      <description>问题描述 1494. 并行课程 II (Hard)&#xA;给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 relations 中， relations[i] = [xᵢ, yᵢ] 表示一个先修课的关系，也就是课程 xᵢ 必须在课程 yᵢ 之前上。同时你还有一个整数 k 。&#xA;在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。&#xA;请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。&#xA;示例 1：&#xA;输入：n = 4, relations = [[2,1],[3,1],[1,4]], k = 2 输出：3 解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ， 第三个学期上课程 4 。 示例 2：&#xA;输入：n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2 输出：4 解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课 程 1 ，第四学期上课程 5 。 示例 3：</description>
    </item>
    <item>
      <title>1483. Kth Ancestor of a Tree Node (Hard)</title>
      <link>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node/</link>
      <pubDate>Mon, 12 Jun 2023 13:07:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node/</guid>
      <description>Description 1483. Kth Ancestor of a Tree Node (Hard) You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.&#xA;The kth ancestor of a tree node is the kth node in the path from that node to the root node.</description>
    </item>
    <item>
      <title>1483. 树节点的第 K 个祖先 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node.zh/</link>
      <pubDate>Mon, 12 Jun 2023 13:06:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node.zh/</guid>
      <description>问题描述 1483. 树节点的第 K 个祖先 (Hard) 给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。&#xA;树节点的第 k个祖先节点是从该节点到根节点路径上的第 k 个节点。&#xA;实现 TreeAncestor 类：&#xA;TreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。 getKthAncestor (int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。 示例 1：&#xA;输入： [&amp;#34;TreeAncestor&amp;#34;,&amp;#34;getKthAncestor&amp;#34;,&amp;#34;getKthAncestor&amp;#34;,&amp;#34;getKthAncestor&amp;#34;] [[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]] 输出： [null,1,0,-1] 解释： TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // 返回 1 ，它是 3 的父节点 treeAncestor.</description>
    </item>
    <item>
      <title>2718. Sum of Matrix After Queries (Medium)</title>
      <link>http://localhost:1313/posts/leet/2718.sum-of-matrix-after-queries/</link>
      <pubDate>Tue, 06 Jun 2023 13:44:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2718.sum-of-matrix-after-queries/</guid>
      <description>Description 2718. Sum of Matrix After Queries (Medium) You are given an integer n and a 0-indexed 2D array queries where queries[i] = [typeᵢ, indexᵢ, valᵢ].&#xA;Initially, there is a 0-indexed n x n matrix filled with 0&amp;rsquo;s. For each query, you must apply one of the following changes:&#xA;if typeᵢ == 0, set the values in the row with indexᵢ to valᵢ, overwriting any previous values. if typeᵢ == 1, set the values in the column with indexᵢ to valᵢ, overwriting any previous values.</description>
    </item>
    <item>
      <title>2718. 查询后矩阵的和 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2718.sum-of-matrix-after-queries.zh/</link>
      <pubDate>Tue, 06 Jun 2023 13:44:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2718.sum-of-matrix-after-queries.zh/</guid>
      <description>问题描述 2718. 查询后矩阵的和 (Medium) 给你一个整数 n 和一个下标从 0 开始的 二维数组 que ries ，其中 queries[i] = [typeᵢ, indexᵢ, valᵢ] 。&#xA;一开始，给你一个下标从 0 开始的 n x n 矩阵，所有元素均 为 0 。每一个查询，你需要执行以下操作之一：&#xA;如果 typeᵢ == 0 ，将第 indexᵢ 行的元素全部修改为 valᵢ ，覆盖任何之前的值。 如果 typeᵢ == 1 ，将第 indexᵢ 列的元素全部修改为 valᵢ ，覆盖任何之前的值。 请你执行完所有查询以后，返回矩阵中所有整数的和。&#xA;示例 1：&#xA;输入：n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]] 输出：23 解释：上图展示了每个查询以后矩阵的值。所有操作执行完以后，矩 阵元素之和为 23 。 示例 2：&#xA;输入：n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2 ,1]] 输出：17 解释：上图展示了每一个查询操作之后的矩阵。所有操作执行完以后 ，矩阵元素之和为 17 。 提示：</description>
    </item>
    <item>
      <title>1156. Swap For Longest Repeated Character Substring (Medium)</title>
      <link>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring/</link>
      <pubDate>Sat, 03 Jun 2023 14:02:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring/</guid>
      <description>Description 1156. Swap For Longest Repeated Character Substring (Medium) You are given a string text. You can swap two of the characters in the text.&#xA;Return the length of the longest substring with repeated characters.&#xA;Example 1:&#xA;Input: text = &amp;#34;ababa&amp;#34; Output: 3 Explanation: We can swap the first &amp;#39;b&amp;#39; with the last &amp;#39;a&amp;#39;, or the last &amp;#39;b&amp;#39; with the first &amp;#39;a&amp;#39;. Then, the longest repeated character substring is &amp;#34;aaa&amp;#34; with length 3.</description>
    </item>
    <item>
      <title>1156. 单字符重复子串的最大长度 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring.zh/</link>
      <pubDate>Sat, 03 Jun 2023 14:02:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring.zh/</guid>
      <description>问题描述 1156. 单字符重复子串的最大长度 (Medium) 如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字 符串。&#xA;给你一个字符串 text，你只能交换其中两个字符一次或者什么都 不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度 。&#xA;示例 1：&#xA;输入：text = &amp;#34;ababa&amp;#34; 输出：3 示例 2：&#xA;输入：text = &amp;#34;aaabaaa&amp;#34; 输出：6 示例 3：&#xA;输入：text = &amp;#34;aaabbaaa&amp;#34; 输出：4 示例 4：&#xA;输入：text = &amp;#34;aaaaa&amp;#34; 输出：5 示例 5：&#xA;输入：text = &amp;#34;abcdef&amp;#34; 输出：1 提示：&#xA;1 &amp;lt;= text.length &amp;lt;= 20000 text 仅由小写英文字母组成。 解题思路 可以利用双指针解决，我们先用数组 $cnt$ 统计 $text$ 中每个字符的出现的次数。&#xA;然后我们定一个三个指针，分别为 $i$，$j$，$k$。初始时都为 $0$，然后我们让 $j$ 右移，直到 $text[j] \neq text[i]$，然后令 $k = j + 1$，再右移 $k$，直到 $text[k] \neq text[i]$，这里可以统计一次结果，$res = \max(res, \min(k - i, cnt[text[i]]))$，然后令 $i = j$，重复以上步骤直到 $i &amp;gt;= text.</description>
    </item>
    <item>
      <title>2517. Maximum Tastiness of Candy Basket (Medium)</title>
      <link>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket/</guid>
      <description>Description 2517. Maximum Tastiness of Candy Basket (Medium) You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.&#xA;The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.&#xA;Return the maximum tastiness of a candy basket.&#xA;Example 1:</description>
    </item>
    <item>
      <title>517. 礼盒的最大甜蜜度 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket.zh/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket.zh/</guid>
      <description>问题描述 2517. 礼盒的最大甜蜜度 (Medium) 给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖 果的价格，另给你一个正整数 k 。&#xA;商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 **甜蜜度 ** 是礼盒中任意两种糖果 价格 绝对差的最小值。&#xA;返回礼盒的 最大 甜蜜度。&#xA;示例 1：&#xA;输入：price = [13,5,1,8,21,2], k = 3 输出：8 解释：选出价格分别为 [13,5,21] 的三类糖果。 礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8 , 16) = 8 。 可以证明能够取得的最大甜蜜度就是 8 。 示例 2：&#xA;输入：price = [1,3,1], k = 2 输出：2 解释：选出价格分别为 [1,3] 的两类糖果。 礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。 可以证明能够取得的最大甜蜜度就是 2 。 示例 3：</description>
    </item>
    <item>
      <title>2646.minimize the Total Price of the Trips</title>
      <link>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips/</link>
      <pubDate>Wed, 31 May 2023 14:05:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips/</guid>
      <description></description>
    </item>
    <item>
      <title>2646. 最小化旅行的价格总和 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips.zh/</link>
      <pubDate>Wed, 31 May 2023 14:05:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips.zh/</guid>
      <description>问题描述 2646. 最小化旅行的价格总和 (Hard) 现有一棵无向、无根的树，树中有 n 个节点，按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数 组 edges ，其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条边。&#xA;每个节点都关联一个价格。给你一个整数数组 price ，其中 pri ce[i] 是第 i 个节点的价格。&#xA;给定路径的 价格总和 是该路径上所有节点的价格之和。&#xA;另给你一个二维整数数组 trips ，其中 trips[i] = [startᵢ, e ndᵢ] 表示您从节点 startᵢ 开始第 i 次旅行，并通过任何你 喜欢的路径前往节点 endᵢ 。&#xA;在执行第一次旅行之前，你可以选择一些 非相邻节点 并将价格 减半。&#xA;返回执行所有旅行的最小价格总和。&#xA;示例 1：&#xA;![](https://assets.leetcode.com/uploads/2023/03/16/diagram2. png)&#xA;输入：n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6] , trips = [[0,3],[2,1],[2,3]] 输出：23 解释： 上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第 二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。 第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。 第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。 第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。 所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实 现的最小答案。 示例 2：</description>
    </item>
    <item>
      <title>421. Maximum XOR of Two Numbers in an Array (Medium)</title>
      <link>http://localhost:1313/posts/leet/421.maximum-xor-of-two-numbers-in-an-array/</link>
      <pubDate>Tue, 30 May 2023 14:22:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/421.maximum-xor-of-two-numbers-in-an-array/</guid>
      <description>Description 421. Maximum XOR of Two Numbers in an Array (Medium) Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &amp;lt;= i &amp;lt;= j &amp;lt; n.&#xA;Example 1:&#xA;Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28. Example 2:&#xA;Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127 Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁵ 0 &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 Solution If we directly use a brute-force approach to find the maximum XOR value, the time complexity would be $O(n^2)$, which would inevitably lead to timeout errors.</description>
    </item>
    <item>
      <title>421. 数组中两个数的最大异或值 (Medium)</title>
      <link>http://localhost:1313/posts/leet/421.maximum-xor-of-two-numbers-in-an-array.zh/</link>
      <pubDate>Tue, 30 May 2023 14:22:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/421.maximum-xor-of-two-numbers-in-an-array.zh/</guid>
      <description>问题描述 421. 数组中两个数的最大异或值 (Medium) 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大 运算结果，其中 0 ≤ i ≤ j &amp;lt; n 。&#xA;示例 1：&#xA;输入：nums = [3,10,5,25,2,8] 输出：28 解释：最大运算结果是 5 XOR 25 = 28. 示例 2：&#xA;输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70] 输出：127 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁵ 0 &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 解题思路 如果直接暴力，求解最大异或值，时间复杂度为 $O(n^2)$，必定会超时。&#xA;实际上，我们可以把每个数字的二进制表示看成字符串，因此可以使用 字典树 这一数据结构来优化求解异或值的过程。暴力情况下，求解 nums[i] 与其他值的异或值，需要遍历整个数组，时间复杂度为 $O(n)$，而利用字典树，我们可以将这个比较的时间复杂度从 $O(n)$ 优化为 $O(\log_2C)$，其中 $C$ 为数字的大小，$\log_2C$ 即为数字的二进制表示的位数。&#xA;如果我们要找到最大异或值，应该从数字的最高位开始比较，字典树也应该从数字的高位开始构建，由于 0 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1，因此我们可以将 nums[i] 右移 j 位的结果插入字典树，j 从 $31$ 递减到 $0$。</description>
    </item>
    <item>
      <title>2681.power of Heroes</title>
      <link>http://localhost:1313/posts/leet/2681.power-of-heroes/</link>
      <pubDate>Mon, 29 May 2023 13:23:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2681.power-of-heroes/</guid>
      <description>Description 2681. Power of Heroes (Hard) You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows:&#xA;Let i₀, i₁, &amp;hellip; , iₖ be the indices of the heroes in a group. Then, the power of this group is max(nums[i₀], nums[i₁], ... ,nums[iₖ])² * min(nums[i₀], nums[i₁], ... ,nums[iₖ]). Return the sum of the power of all non-empty groups of heroes possible.</description>
    </item>
    <item>
      <title>2681. 英雄的力量 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2681.power-of-heroes.zh/</link>
      <pubDate>Mon, 29 May 2023 13:23:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2681.power-of-heroes.zh/</guid>
      <description>问题描述 2681. 英雄的力量 (Hard) 给你一个下标从 0 开始的整数数组 nums ，它表示英雄的能 力值。如果我们选出一部分英雄，这组英雄的 力量 定义为：&#xA;i₀ ， i₁ ，&amp;hellip; iₖ 表示这组英雄在数组中的下标。那么这组英雄的力量为 max(nums[i₀],nums[i₁] ... nums[iₖ])² * min(nums[i₀],nums[i₁] ... nums[iₖ]) 。 请你返回所有可能的 非空 英雄组的 力量 之和。由于答案 可能非常大，请你将结果对 10⁹ + 7 取余。&#xA;示例 1：&#xA;输入：nums = [2,1,4] 输出：141 解释： 第 1 组：[2] 的力量为 2² * 2 = 8 。 第 2 组：[1] 的力量为 1² * 1 = 1 。 第 3 组：[4] 的力量为 4² * 4 = 64 。 第 4 组：[2,1] 的力量为 2² * 1 = 4 。 第 5 组：[2,4] 的力量为 4² * 2 = 32 。 第 6 组：[1,4] 的力量为 4² * 1 = 16 。 第 7 组：[2,1,4] 的力量为 4² * 1 = 16 。 所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。 示例 2：</description>
    </item>
    <item>
      <title>2712. 使所有字符相等的最小成本 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal.zh/</link>
      <pubDate>Mon, 29 May 2023 11:57:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal.zh/</guid>
      <description>问题描述 2712. 使所有字符相等的最小成本 (Medium) 给你一个下标从 0 开始、长度为 n 的二进制字符串 s ， 你可以对其执行两种操作：&#xA;选中一个下标 i 并且反转从下标 0 到下标 i（包括下标 0 和下标 i ）的所有字符，成本为 i + 1 。 选中一个下标 i 并且反转从下标 i 到下标 n - 1（包括下 标 i 和下标 n - 1 ）的所有字符，成本为 n - i 。 返回使字符串内所有字符 相等 需要的 最小成本 。&#xA;反转 字符意味着：如果原来的值是 &amp;lsquo;0&amp;rsquo; ，则反转后值变为 &amp;lsquo;1&amp;rsquo; ，反之亦然。&#xA;示例 1：&#xA;输入：s = &amp;#34;0011&amp;#34; 输出：2 解释：执行第二种操作，选中下标 i = 2 ，可以得到 s = &amp;#34;0000&amp;#34; ，成本为 2 。可以证明 2 是使所有字符相等的最小成本。 示例 2：</description>
    </item>
    <item>
      <title>2712. Minimum Cost to Make All Characters Equal (Medium)</title>
      <link>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal/</link>
      <pubDate>Mon, 29 May 2023 11:57:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal/</guid>
      <description>Description 2712. Minimum Cost to Make All Characters Equal (Medium) You are given a 0-indexed binary string s of length n on which you can apply two types of operations:&#xA;Choose an index i and invert all characters from index 0 to index i (both inclusive), with a cost of i + 1 Choose an index i and invert all characters from index i to index n - 1 (both inclusive), with a cost of n - i Return the minimum cost to make all characters of the string equal.</description>
    </item>
    <item>
      <title>85. Maximal Rectangle (Hard)</title>
      <link>http://localhost:1313/posts/leet/85.maximal-rectangle/</link>
      <pubDate>Tue, 23 May 2023 15:24:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/85.maximal-rectangle/</guid>
      <description>Description Maximal Rectangle (Hard) Given a rows x cols binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest rectangle containing only 1&amp;rsquo;s and return its area. Example 1:&#xA;Input: matrix = [[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Example 2:&#xA;Input: matrix = [[&amp;#34;0&amp;#34;]] Output: 0 Example 3:&#xA;Input: matrix = [[&amp;#34;1&amp;#34;]] Output: 1 Constraints:&#xA;rows == matrix.length cols == matrix[i].length 1 &amp;lt;= row, cols &amp;lt;= 200 matrix[i][j] is &#39;0&#39; or &#39;1&#39;.</description>
    </item>
    <item>
      <title>85. 最大矩形 (Hard)</title>
      <link>http://localhost:1313/posts/leet/85.maximal-rectangle.zh/</link>
      <pubDate>Tue, 23 May 2023 15:24:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/85.maximal-rectangle.zh/</guid>
      <description>问题描述 85. 最大矩形 (Hard) 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进 制矩阵，找出只包含 1 的最大矩形，并返回其面积。&#xA;示例 1：&#xA;![](https://assets.leetcode.com/uploads/2020/09/14/maximal.j pg)&#xA;输入：matrix = [[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;]] 输出：6 解释：最大矩形如上图所示。 示例 2：&#xA;输入：matrix = [] 输出：0 示例 3：&#xA;输入：matrix = [[&amp;#34;0&amp;#34;]] 输出：0 示例 4：&#xA;输入：matrix = [[&amp;#34;1&amp;#34;]] 输出：1 示例 5：&#xA;输入：matrix = [[&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;]] 输出：0 提示：&#xA;rows == matrix.length cols == matrix[0].length 1 &amp;lt;= row, cols &amp;lt;= 200 matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39; 解题思路 其实本题就相当于是 84.</description>
    </item>
    <item>
      <title>84. Largest Rectangle in Histogram (Hard)</title>
      <link>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram/</link>
      <pubDate>Tue, 23 May 2023 15:08:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram/</guid>
      <description>Description 84. Largest Rectangle in Histogram (Hard) Given an array of integers heights representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.&#xA;Example 1:&#xA;Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.</description>
    </item>
    <item>
      <title>84. 柱状图中最大的矩形 (Hard)</title>
      <link>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram.zh/</link>
      <pubDate>Tue, 23 May 2023 15:08:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram.zh/</guid>
      <description>问题描述 84. 柱状图中最大的矩形 (Hard) 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子 彼此相邻，且宽度为 1 。&#xA;求在该柱状图中，能够勾勒出来的矩形的最大面积。&#xA;示例 1:&#xA;![](https://assets.leetcode.com/uploads/2021/01/04/histogram .jpg)&#xA;输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2：&#xA;![](https://assets.leetcode.com/uploads/2021/01/04/histogram -1.jpg)&#xA;输入： heights = [2,4] 输出： 4 提示：&#xA;1 &amp;lt;= heights.length &amp;lt;=10⁵ 0 &amp;lt;= heights[i] &amp;lt;= 10⁴ 解题思路 本题其实还是求一个连续变长区间的最小值，以及该区间的长度，可以考虑到使用单调栈来解决，至于使用单调递增还是单调递减栈，代入题目中的示例模拟一下就知道了，本题应该使用单调递增栈（栈底到栈顶单调递增）。&#xA;在本题中，我们遍历数组，对 nums[i]，找到满足 nums[r] &amp;lt; nums[i] 且 r &amp;gt; i 的最小的 r，记为 ridx，找到满足 nums[l] &amp;lt; nums[i] 且 l &amp;lt; i 的最大的 l，记为 lidx，则 res = max(res, nums[i] * (ridx - lidx - 1))，我们可以利用单调栈在 $O(n)$ 时间内完成求解。</description>
    </item>
    <item>
      <title>2104. Sum of Subarray Ranges (Medium)</title>
      <link>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges/</link>
      <pubDate>Sun, 21 May 2023 19:00:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges/</guid>
      <description>Description 2104. Sum of Subarray Ranges (Medium) You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.&#xA;Return the sum of all subarray ranges of nums.&#xA;A subarray is a contiguous non-empty sequence of elements within an array.&#xA;Example 1:&#xA;Input: nums = [1,2,3] Output: 4 Explanation: The 6 subarrays of nums are the following: [1], range = largest - smallest = 1 - 1 = 0 [2], range = 2 - 2 = 0 [3], range = 3 - 3 = 0 [1,2], range = 2 - 1 = 1 [2,3], range = 3 - 2 = 1 [1,2,3], range = 3 - 1 = 2 So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.</description>
    </item>
    <item>
      <title>2104. 子数组范围和 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges.zh/</link>
      <pubDate>Sun, 21 May 2023 19:00:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges.zh/</guid>
      <description>问题描述 2104. 子数组范围和 (Medium) 给你一个整数数组 nums 。 nums 中，子数组的 范围 是子 数组中最大元素和最小元素的差值。&#xA;返回 nums 中 所有 子数组范围的 和。&#xA;子数组是数组中一个连续 非空 的元素序列。&#xA;示例 1：&#xA;输入：nums = [1,2,3] 输出：4 解释：nums 的 6 个子数组如下所示： [1]，范围 = 最大 - 最小 = 1 - 1 = 0 [2]，范围 = 2 - 2 = 0 [3]，范围 = 3 - 3 = 0 [1,2]，范围 = 2 - 1 = 1 [2,3]，范围 = 3 - 2 = 1 [1,2,3]，范围 = 3 - 1 = 2 所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4 示例 2：</description>
    </item>
    <item>
      <title>795.区间子数组个数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum.zh/</link>
      <pubDate>Sun, 21 May 2023 18:30:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum.zh/</guid>
      <description>问题描述 795. 区间子数组个数 (Medium) 给你一个整数数组 nums 和两个整数： left 及 right 。找 出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。&#xA;生成的测试用例保证结果符合 32-bit 整数范围。&#xA;示例 1：&#xA;输入：nums = [2,1,4,3], left = 2, right = 3 输出：3 解释：满足条件的三个子数组：[2], [2, 1], [3] 示例 2：&#xA;输入：nums = [2,9,2,5,6], left = 2, right = 8 输出：7 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 10⁵ 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ 0 &amp;lt;= left &amp;lt;= right &amp;lt;= 10⁹ 解题思路 单调栈 当我们看到这种连续区间中的最大值的题目时，就可以考虑使用单调栈。&#xA;对 nums[idx]，我们需要找到以 nums[idx] 为最大值的子数组的数量，设 lidx 为满足 nums[l] &amp;gt;= nums[idx] 且 l &amp;lt; idx 的最大的 l；设 ridx 为满足 nums[r] &amp;gt; nums[idx] 且 r &amp;gt; idx 中的最小的 r。我们要做的就是枚举满足 0 &amp;lt;= idx &amp;lt; n 的所有的 idx，找到对应的 lidx 和 ridx，从而计算出子数组的数量。</description>
    </item>
    <item>
      <title>795.number of Subarrays With Bounded Maximum</title>
      <link>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum/</link>
      <pubDate>Sun, 21 May 2023 18:30:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum/</guid>
      <description>Description 795. Number of Subarrays with Bounded Maximum (Medium) Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right].&#xA;The test cases are generated so that the answer will fit in a 32-bit integer.&#xA;Example 1:&#xA;Input: nums = [2,1,4,3], left = 2, right = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].</description>
    </item>
    <item>
      <title>373. 查找和最小的 K 对数字 (Medium)</title>
      <link>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums.zh/</link>
      <pubDate>Sat, 06 May 2023 16:28:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums.zh/</guid>
      <description>问题描述 373. 查找和最小的 K 对数字 (Medium) 给定两个以 升序排列 的整数数组 nums1 和 nums2, 以及 一个整数 k。&#xA;定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来 自 nums2。&#xA;请找到和最小的 k 个数对 (u₁,v₁), (u₂,v₂) &amp;hellip; (uₖ,v ₖ) 。&#xA;示例 1:&#xA;输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 输出: [1,2],[1,4],[1,6] 解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6 ] 示例 2:&#xA;输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 输出: [1,1],[1,1] 解释: 返回序列中的前 2 对数： [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] 示例 3:</description>
    </item>
    <item>
      <title>373. Find K Pairs with Smallest Sums (Medium)</title>
      <link>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums/</link>
      <pubDate>Sat, 06 May 2023 16:28:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums/</guid>
      <description>Description 373. Find K Pairs with Smallest Sums (Medium) You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.&#xA;Define a pair (u, v) which consists of one element from the first array and one element from the second array.&#xA;Return the kpairs (u₁, v₁), (u₂, v₂), ..., (uₖ, vₖ)with the smallest sums.&#xA;Example 1:&#xA;Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2:</description>
    </item>
    <item>
      <title>1020.Number of Enclaves (Medium)</title>
      <link>http://localhost:1313/posts/leet/1020.number-of-enclaves/</link>
      <pubDate>Thu, 13 Apr 2023 10:17:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1020.number-of-enclaves/</guid>
      <description>Description 1020. Number of Enclaves (Medium)&#xA;You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.&#xA;A move consists of walking from one land cell to another adjacent ( 4-directionally) land cell or walking off the boundary of the grid.&#xA;Return the number of land cells in gridfor which we cannot walk off the boundary of the grid in any number of moves.</description>
    </item>
    <item>
      <title>1020.飞地的数量 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1020.number-of-enclaves.zh/</link>
      <pubDate>Thu, 13 Apr 2023 10:16:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1020.number-of-enclaves.zh/</guid>
      <description>问题描述 1020. 飞地的数量 (Medium)&#xA;给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、 1 表示一个陆地单元格。&#xA;一次 移动 是指从一个陆地单元格走到另一个相邻（ 上、下、左、右）的陆地单元格或跨过 grid 的边界。&#xA;返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。&#xA;示例 1：&#xA;输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] 输出：3 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。 示例 2：&#xA;输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] 输出：0 解释：所有 1 都在边界上或可以到达边界。 提示：&#xA;m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 500 grid[i][j] 的值为 0 或 1 解题思路 使用并查集，令cnt1为包含索引为m * n的节点树的节点数，cnt2为海水的节点数，res = m * n - (cnt1 - 1) - cnt2;。</description>
    </item>
    <item>
      <title>851.喧闹和富有 (Medium)</title>
      <link>http://localhost:1313/posts/leet/851.loud-and-rich/</link>
      <pubDate>Mon, 10 Apr 2023 15:07:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/851.loud-and-rich/</guid>
      <description>Description 851. Loud and Rich (Medium)&#xA;There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.&#xA;You are given an array richer where richer[i] = [aᵢ, bᵢ] indicates that aᵢ has more money than bᵢ and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.</description>
    </item>
    <item>
      <title>851.喧闹和富有 (Medium)</title>
      <link>http://localhost:1313/posts/leet/851.loud-and-rich.zh/</link>
      <pubDate>Mon, 10 Apr 2023 15:06:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/851.loud-and-rich.zh/</guid>
      <description>问题描述 851. 喧闹和富有 (Medium)&#xA;有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 &amp;ldquo;person x &amp;ldquo;。&#xA;给你一个数组 richer ，其中 richer[i] = [aᵢ, bᵢ] 表示 person aᵢ 比 person bᵢ 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。 richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。&#xA;现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。&#xA;示例 1：</description>
    </item>
    <item>
      <title>802.Find Eventual Safe States (Medium)</title>
      <link>http://localhost:1313/posts/leet/802.find-eventual-safe-states/</link>
      <pubDate>Mon, 10 Apr 2023 14:49:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/802.find-eventual-safe-states/</guid>
      <description>Description 802. Find Eventual Safe States (Medium)&#xA;There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].&#xA;A node is a terminal node if there are no outgoing edges.</description>
    </item>
    <item>
      <title>802.找到最终的安全状态 (Medium)</title>
      <link>http://localhost:1313/posts/leet/802.find-eventual-safe-states.zh/</link>
      <pubDate>Mon, 10 Apr 2023 14:46:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/802.find-eventual-safe-states.zh/</guid>
      <description>问题描述 802. 找到最终的安全状态 (Medium)&#xA;有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph 表示， graph[i] 是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i] 中的每个节点都有一条边。&#xA;如果一个节点没有连出的有向边，则它是 终端节点 。如果没有出边，则节点为终端节点。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。&#xA;返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。&#xA;示例 1：&#xA;输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]] 输出：[2,4,5,6] 解释：示意图如上。 节点 5 和节点 6 是终端节点，因为它们都没有出边。 从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。 示例 2：&#xA;输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] 输出：[4] 解释: 只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。 提示：</description>
    </item>
    <item>
      <title>442.Find All Duplicates in an Array (Medium)</title>
      <link>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array/</link>
      <pubDate>Tue, 28 Mar 2023 14:45:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array/</guid>
      <description>Description 442. Find All Duplicates in an Array (Medium)&#xA;Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.&#xA;You must write an algorithm that runs in O(n) time and uses only constant extra space.&#xA;Example 1:&#xA;Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Example 2:</description>
    </item>
    <item>
      <title>442.数组中重复的数据 (Medium)</title>
      <link>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array.zh/</link>
      <pubDate>Tue, 28 Mar 2023 14:45:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array.zh/</guid>
      <description>问题描述 442. 数组中重复的数据 (Medium)&#xA;给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。&#xA;你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。&#xA;示例 1：&#xA;输入：nums = [4,3,2,7,8,2,3,1] 输出：[2,3] 示例 2：&#xA;输入：nums = [1,1,2] 输出：[1] 示例 3：&#xA;输入：nums = [1] 输出：[] 提示：&#xA;n == nums.length 1 &amp;lt;= n &amp;lt;= 10⁵ 1 &amp;lt;= nums[i] &amp;lt;= n nums 中的每个元素出现 一次 或 两次 解题思路 参照41.缺失的第一个正数 (Hard)，将数置反，如果已经是负数了，再减去nums.size()。&#xA;这里要注意nums.size()是无符号整数，直接加上负号结果也不是负数。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>41.First Missing Positive (Hard)</title>
      <link>http://localhost:1313/posts/leet/41.first-missing-positive/</link>
      <pubDate>Tue, 28 Mar 2023 11:44:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/41.first-missing-positive/</guid>
      <description>Description 41. First Missing Positive (Hard)&#xA;Given an unsorted integer array nums, return the smallest missing positive integer.&#xA;You must implement an algorithm that runs in O(n) time and uses constant extra space.&#xA;Example 1:&#xA;Input: nums = [1,2,0] Output: 3 Explanation: The numbers in the range [1,2] are all in the array. Example 2:&#xA;Input: nums = [3,4,-1,1] Output: 2 Explanation: 1 is in the array but 2 is missing.</description>
    </item>
    <item>
      <title>41.缺失的第一个正数 (Hard)</title>
      <link>http://localhost:1313/posts/leet/41.first-missing-positive.zh/</link>
      <pubDate>Tue, 28 Mar 2023 11:44:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/41.first-missing-positive.zh/</guid>
      <description>问题描述 41. 缺失的第一个正数 (Hard)&#xA;给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。&#xA;请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。&#xA;示例 1：&#xA;输入：nums = [1,2,0] 输出：3 示例 2：&#xA;输入：nums = [3,4,-1,1] 输出：2 示例 3：&#xA;输入：nums = [7,8,9,11,12] 输出：1 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 5 * 10⁵ -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 解题思路 标记 在nums[i]数组上做标记，我们可以将nums数组中的负数都设为n + 1，令num = abs(nums[i])，然后将nums[num - 1]取反，最后遍历修改后的nums[i]，如果都是负数，返回n + 1，否则返回碰到的第一个非负数的索引加一；&#xA;置换 如果nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp; nums[i] &amp;gt; 0，那么就将它与nums[num[i] - 1]置换，为了防止死循环，还要判断nums[i] != nums[nums[i] - 1]&#xA;代码 标记 class Solution { public: int firstMissingPositive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description>
    </item>
    <item>
      <title>686 Repeated String Match</title>
      <link>http://localhost:1313/posts/leet/686-repeated-string-match/</link>
      <pubDate>Mon, 27 Mar 2023 21:22:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/686-repeated-string-match/</guid>
      <description>Description 686. Repeated String Match (Medium)&#xA;Given two strings a and b, return the minimum number of times you should repeat string a so that string bis a substring of it. If it is impossible for b to be a substring of a after repeating it, return -1.&#xA;Notice: string &amp;quot;abc&amp;quot; repeated 0 times is &amp;quot;&amp;quot;, repeated 1 time is &amp;quot;abc&amp;quot; and repeated 2 times is &amp;quot;abcabc&amp;quot;.&#xA;Example 1:&#xA;Input: a = &amp;#34;abcd&amp;#34;, b = &amp;#34;cdabcdab&amp;#34; Output: 3 Explanation: We return 3 because by repeating a three times &amp;#34;abcdabcdabcd&amp;#34;, b is a substring of it.</description>
    </item>
    <item>
      <title>686.重复叠加字符串匹配 (Medium)</title>
      <link>http://localhost:1313/posts/leet/686-repeated-string-match.zh/</link>
      <pubDate>Mon, 27 Mar 2023 21:22:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/686-repeated-string-match.zh/</guid>
      <description>问题描述 686. 重复叠加字符串匹配 (Medium)&#xA;给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。&#xA;注意： 字符串 &amp;quot;abc&amp;quot; 重复叠加 0 次是 &amp;quot;&amp;quot;，重复叠加 1 次是 &amp;quot;abc&amp;quot;，重复叠加 2 次是 &amp;quot;abcabc&amp;quot;。&#xA;示例 1：&#xA;输入：a = &amp;#34;abcd&amp;#34;, b = &amp;#34;cdabcdab&amp;#34; 输出：3 解释：a 重复叠加三遍后为 &amp;#34;abcdabcdabcd&amp;#34;, 此时 b 是其子串。 示例 2：&#xA;输入：a = &amp;#34;a&amp;#34;, b = &amp;#34;aa&amp;#34; 输出：2 示例 3：&#xA;输入：a = &amp;#34;a&amp;#34;, b = &amp;#34;a&amp;#34; 输出：1 示例 4：&#xA;输入：a = &amp;#34;abc&amp;#34;, b = &amp;#34;wxyz&amp;#34; 输出：-1 提示：</description>
    </item>
    <item>
      <title>28.Find the Index of the First Occurrence in a String (Easy)</title>
      <link>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string/</link>
      <pubDate>Mon, 27 Mar 2023 21:15:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string/</guid>
      <description>Description 28. Find the Index of the First Occurrence in a String (Easy)&#xA;Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&#xA;Example 1:&#xA;Input: haystack = &amp;#34;sadbutsad&amp;#34;, needle = &amp;#34;sad&amp;#34; Output: 0 Explanation: &amp;#34;sad&amp;#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2:</description>
    </item>
    <item>
      <title>28.找出字符串中第一个匹配项的下标 (Medium)</title>
      <link>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string.zh/</link>
      <pubDate>Mon, 27 Mar 2023 21:15:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string.zh/</guid>
      <description>问题描述 28. 找出字符串中第一个匹配项的下标 (Medium)&#xA;给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1。&#xA;示例 1：&#xA;输入：haystack = &amp;#34;sadbutsad&amp;#34;, needle = &amp;#34;sad&amp;#34; 输出：0 解释：&amp;#34;sad&amp;#34; 在下标 0 和 6 处匹配。 第一个匹配项的下标是 0 ，所以返回 0 。 示例 2：&#xA;输入：haystack = &amp;#34;leetcode&amp;#34;, needle = &amp;#34;leeto&amp;#34; 输出：-1 解释：&amp;#34;leeto&amp;#34; 没有在 &amp;#34;leetcode&amp;#34; 中出现，所以返回 -1 。 提示：&#xA;1 &amp;lt;= haystack.length, needle.length &amp;lt;= 10⁴ haystack 和 needle 仅由小写英文字符组成 解题思路 标准的kmp算法模板题。&#xA;代码 class Solution { public: void SetNext(vector&amp;lt;int&amp;gt; &amp;amp;next, string needle) { int x = 1, now = 0; while (x &amp;lt; needle.</description>
    </item>
    <item>
      <title>297.serialize and Deserialize Binary Tree</title>
      <link>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree/</link>
      <pubDate>Thu, 23 Mar 2023 10:41:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree/</guid>
      <description></description>
    </item>
    <item>
      <title>297.二叉树的序列化与反序列化 (Hard)</title>
      <link>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree.zh/</link>
      <pubDate>Thu, 23 Mar 2023 10:40:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree.zh/</guid>
      <description>问题描述 297. 二叉树的序列化与反序列化 (Hard)&#xA;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。&#xA;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。&#xA;提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。&#xA;示例 1：&#xA;输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2：&#xA;输入：root = [] 输出：[] 示例 3：&#xA;输入：root = [1] 输出：[1] 示例 4：&#xA;输入：root = [1,2] 输出：[1,2] 提示：&#xA;树中结点数在范围 [0, 10⁴] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 解题思路 首先利用前序遍历的dfs，将节点的值存放到字符串中，如果遇到空节点，则str += &amp;quot;null_&amp;quot;，然后return。&#xA;反序列化时，首先将字符串转化为字符串链表，然后递归地进行反序列化，如果链表首元素为null，则为当前子树的root节点，然后先反序列化左子树，然后反序列化又子树，如果首元素为null，则直接返回。&#xA;可以注意到与前序遍历是相对应的的。&#xA;代码 class Codec { public: void rserialize(TreeNode* root, string&amp;amp; str) { if (root == nullptr) { str += &amp;#34;None,&amp;#34;; } else { str += to_string(root-&amp;gt;val) + &amp;#34;,&amp;#34;; rserialize(root-&amp;gt;left, str); rserialize(root-&amp;gt;right, str); } } string serialize(TreeNode* root) { string ret; rserialize(root, ret); return ret; } TreeNode* rdeserialize(list&amp;lt;string&amp;gt;&amp;amp; dataArray) { if (dataArray.</description>
    </item>
    <item>
      <title>2071.Maximum Number of Tasks You Can Assign (Hard)</title>
      <link>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign/</link>
      <pubDate>Wed, 22 Mar 2023 19:49:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign/</guid>
      <description>Description Maximum Number of Tasks You Can Assign (Hard) You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task&amp;rsquo;s strength requirement (i.</description>
    </item>
    <item>
      <title>2071.你可以安排的最多任务数目 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign.zh/</link>
      <pubDate>Wed, 22 Mar 2023 19:49:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign.zh/</guid>
      <description>问题描述 2071. 你可以安排的最多任务数目 (Hard)&#xA;给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] &amp;gt;= tasks[i] ）。&#xA;除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。&#xA;给你下标从 0 开始的整数数组 tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。&#xA;示例 1：&#xA;输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1 输出：3 解释： 我们可以按照如下方案安排药丸： - 给 0 号工人药丸。 - 0 号工人完成任务 2（0 + 1 &amp;gt;= 1） - 1 号工人完成任务 1（3 &amp;gt;= 2） - 2 号工人完成任务 0（3 &amp;gt;= 3） 示例 2：</description>
    </item>
    <item>
      <title>952.Largest Component Size by Common Factor (Hard)</title>
      <link>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor/</link>
      <pubDate>Wed, 22 Mar 2023 19:45:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor/</guid>
      <description>Description 952. Largest Component Size by Common Factor (Hard)&#xA;You are given an integer array of unique positive integers nums. Consider the following graph:&#xA;There are nums.length nodes, labeled nums[0] to nums[nums.length - 1], There is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph.&#xA;Example 1:&#xA;Input: nums = [4,6,15,35] Output: 4 Example 2:</description>
    </item>
    <item>
      <title>952.按公因数计算最大组件大小 (Hard)</title>
      <link>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor.zh/</link>
      <pubDate>Wed, 22 Mar 2023 19:29:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor.zh/</guid>
      <description>问题描述 952. 按公因数计算最大组件大小 (Hard)&#xA;给定一个由不同正整数的组成的非空数组 nums ，考虑下面的图：&#xA;有 nums.length 个节点，按从 nums[0] 到 nums[nums.length - 1] 标记； 只有当 nums[i] 和 nums[j] 共用一个大于 1 的公因数时， nums[i] 和 nums[j] 之间才有一条边。 返回 图中最大连通组件的大小 。&#xA;示例 1：&#xA;输入：nums = [4,6,15,35] 输出：4 示例 2：&#xA;输入：nums = [20,50,9,63] 输出：2 示例 3：&#xA;输入：nums = [2,3,6,7,4,12,21,39] 输出：8 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁴ 1 &amp;lt;= nums[i] &amp;lt;= 10⁵ nums 中所有值都 不同 解题思路 使用并查集，并注意质因数分解的求法。&#xA;由于nums[i] &amp;lt;= 100000，因此我们设置初始的并查集的节点为$100001$个，遍历数组中的每个元素，将每个元素和他的质因数连接起来，我们只将size_[nums[i]]初始化为1，其余均为0，这样不属于nums[i]的质因数的个数就不会被统计到树的数量中，遍历数组的元素时，更新ans即可。&#xA;注意，由于时间复杂度的要求，我们需要压缩路径并且使用启发式合并。</description>
    </item>
    <item>
      <title>654.Maximum Binary Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/654.maximum-binary-tree/</link>
      <pubDate>Sun, 19 Mar 2023 17:25:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/654.maximum-binary-tree/</guid>
      <description>Description 654. Maximum Binary Tree (Medium)&#xA;You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:&#xA;Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value.</description>
    </item>
    <item>
      <title>654.最大二叉树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/654.maximum-binary-tree.zh/</link>
      <pubDate>Sun, 19 Mar 2023 17:25:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/654.maximum-binary-tree.zh/</guid>
      <description>问题描述 654. 最大二叉树 (Medium)&#xA;给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:&#xA;创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树。&#xA;示例 1：&#xA;输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2：</description>
    </item>
    <item>
      <title>2389.Longest Subsequence With Limited Sum (Easy)</title>
      <link>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum/</link>
      <pubDate>Fri, 17 Mar 2023 15:44:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum/</guid>
      <description>Description 2389. Longest Subsequence With Limited Sum (Easy)&#xA;You are given an integer array nums of length n, and an integer array queries of length m.&#xA;Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].&#xA;A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</description>
    </item>
    <item>
      <title>2389.和有限的最长子序列 (Easy)</title>
      <link>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum.zh/</link>
      <pubDate>Fri, 17 Mar 2023 15:44:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum.zh/</guid>
      <description>问题描述 和有限的最长子序列 (Easy) 给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。&#xA;返回一个长度为 m 的数组 answer，其中 answer[i] 是 nums 中元素之和小于等于 queries[i] 的 子序列 的 最大 长度。&#xA;子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。&#xA;示例 1：&#xA;输入：nums = [4,5,2,1], queries = [3,10,21] 输出：[2,3,4] 解释：queries 对应的 answer 如下： - 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。 - 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。 - 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。 示例 2：</description>
    </item>
    <item>
      <title>778.Swim in Rising Water (Hard)</title>
      <link>http://localhost:1313/posts/leet/778.swim-in-rising-water/</link>
      <pubDate>Fri, 17 Mar 2023 15:29:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/778.swim-in-rising-water/</guid>
      <description>Description 778. Swim in Rising Water (Hard)&#xA;You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).&#xA;The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time.</description>
    </item>
    <item>
      <title>778.水位上升的泳池中游泳 (Hard)</title>
      <link>http://localhost:1313/posts/leet/778.swim-in-rising-water.zh/</link>
      <pubDate>Fri, 17 Mar 2023 15:29:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/778.swim-in-rising-water.zh/</guid>
      <description>问题描述 778. 水位上升的泳池中游泳 (Hard)&#xA;在一个 n x n 的整数矩阵 grid 中，每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。&#xA;当开始下雨时，在时间为 t 时，水池中的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。&#xA;你从坐标方格的左上平台 (0，0) 出发。返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间 。&#xA;示例 1:&#xA;输入: grid = [[0,2],[1,3]] 输出: 3 解释: 时间为0时，你位于坐标方格的位置为 (0, 0)。 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。 等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置 示例 2:&#xA;输入: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] 输出: 16 解释: 最终的路线用加粗进行了标记。 我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的 提示:</description>
    </item>
    <item>
      <title>1631.Path With Minimum Effort (Medium)</title>
      <link>http://localhost:1313/posts/leet/1631.path-with-minimum-effort/</link>
      <pubDate>Thu, 16 Mar 2023 13:53:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1631.path-with-minimum-effort/</guid>
      <description>Solution 1631. Path With Minimum Effort (Medium)&#xA;You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.</description>
    </item>
    <item>
      <title>1631.最小体力消耗路径 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1631.path-with-minimum-effort.zh/</link>
      <pubDate>Thu, 16 Mar 2023 13:49:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1631.path-with-minimum-effort.zh/</guid>
      <description>问题描述 1631. 最小体力消耗路径 (Medium)&#xA;你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上， 下， 左， 右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。&#xA;一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。&#xA;请你返回从左上角走到右下角的最小 体力消耗值 。&#xA;示例 1：&#xA;输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。 示例 2：&#xA;输入：heights = [[1,2,3],[3,8,4],[5,3,5]] 输出：1 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3：</description>
    </item>
    <item>
      <title>407.Trapping Rain Water II (Hard)</title>
      <link>http://localhost:1313/posts/leet/407.trapping-rain-water-ii/</link>
      <pubDate>Wed, 15 Mar 2023 15:01:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/407.trapping-rain-water-ii/</guid>
      <description>Description 407. Trapping Rain Water II (Hard)&#xA;Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.&#xA;Example 1:&#xA;Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] Output: 4 Explanation: After the rain, water is trapped between the blocks. We have two small ponds 1 and 3 units trapped. The total volume of water trapped is 4.</description>
    </item>
    <item>
      <title>407.接雨水 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/407.trapping-rain-water-ii.zh/</link>
      <pubDate>Wed, 15 Mar 2023 15:01:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/407.trapping-rain-water-ii.zh/</guid>
      <description>问题描述 407. 接雨水 II (Hard)&#xA;给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。&#xA;示例 1:&#xA;输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] 输出: 4 解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。 示例 2:&#xA;输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] 输出: 10 提示:&#xA;m == heightMap.length n == heightMap[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= heightMap[i][j] &amp;lt;= 2 * 10⁴ 解题思路 设方格$(i, j)$到边界上的点$(x, y)$的路径的最大高度为$h_{x,y}$，那么方格$(i, j)$所能存放的雨水就是$h_xy$的最小值减去height[i][j]；&#xA;$h_{x,y}$也可以转化成边界上的点$(x, y)$到方格$(i, j)$的路径的上的方格的最大高度，那么就可以使用Dijkstra算法来解决，初始时将边界上所有的点都加入优先队列中，即可求边界上所有方格到$(i, j)$的最大高度的最小值，还是使用小顶堆。&#xA;代码 class Solution { public: int trapRainWater(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;heightMap) { // 找边界上所有点，到x,y的路径上的最大高度的最小值（不包括x,y） // (x,y)处的存放的雨水即这个高度h-heightMap[x][y]; int m = heightMap.</description>
    </item>
    <item>
      <title>1615.Maximal Network Rank (Medium)</title>
      <link>http://localhost:1313/posts/leet/1615.maximal-network-rank/</link>
      <pubDate>Wed, 15 Mar 2023 09:46:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1615.maximal-network-rank/</guid>
      <description>Description 1615. Maximal Network Rank (Medium)&#xA;There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [aᵢ, bᵢ] indicates that there is a bidirectional road between cities aᵢ and bᵢ.&#xA;The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.</description>
    </item>
    <item>
      <title>1615.最大网络秩 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1615.maximal-network-rank.zh/</link>
      <pubDate>Wed, 15 Mar 2023 09:46:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1615.maximal-network-rank.zh/</guid>
      <description>问题描述 1615. 最大网络秩 (Medium)&#xA;n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [aᵢ, bᵢ] 都表示在城市 aᵢ 和 bᵢ 之间有一条双向道路。&#xA;两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。&#xA;整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。&#xA;给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。&#xA;示例 1：&#xA;输入：n = 4, roads = [[0,1],[0,3],[1,2],[1,3]] 输出：4 解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。 示例 2：&#xA;输入：n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] 输出：5 解释：共有 5 条道路与城市 1 或 2 相连。 示例 3：</description>
    </item>
    <item>
      <title>ssh简单教程</title>
      <link>http://localhost:1313/posts/leet/ssh_tips.zh/</link>
      <pubDate>Tue, 14 Mar 2023 16:23:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/ssh_tips.zh/</guid>
      <description>ssh配置免密码登录服务器 生成密钥对 执行ssh-keygen -t ed25519 -C &amp;quot;zwyyy456@hotmail.com&amp;quot;以生成密钥对，存放在~/.ssh文件夹下，id_ed25519.pub为公钥，id_ed25519为私钥。&#xA;上传公钥到服务器 这里以我的N1为例，执行ssh-copy-id -i ~/.ssh/id_ed25519.pub root@192.168.6.217和ssh-copy-id -i ~/.ssh/id_ed25519.pub zwyyy@192.168.6.217，将公钥上传到服务器，root和zwyyy分别是两个用户。&#xA;配置局域网ssh连接到wsl hyper-v创建虚拟交换机 打开hyper-v管理器，选择虚拟交换机管理器，选择创建外部类型的虚拟交换机，这里命名为wsl_ssh。&#xA;win11上新建wsl配置文件 cd ~ New-Item .wslconfig nvim .wslconfig 修改配置文件内容为&#xA;[wsl2] networkingMode=bridged vmSwitch=wsl_ssh # 这里为你创建的虚拟交换机名称 ipv6=true 之后执行wsl --shutdown再启动wsl，就会发现ip地址为电脑本身的ip了。&#xA;openwrt上固定电脑的ip 进入openwrt的管理界面，点击网络-&amp;gt;DHCP/DNS，选择静态地址分配，固定windows笔记本的ip&#xA;启用wsl上的ssh 执行sudo nvim /etc/ssh/sshd_config，将#port 22修改为port 2222，取消注释#PasswordAuthentication yes和#PubekyAuthentcation yes，重启ssh服务，执行sudo service ssh restart。&#xA;win11设置端口转发 参照该链接&#xA;之后同一局域网的mac执行ssh -p 2222 zwyyy456@192.168.6.209，即可连接到wsl。</description>
    </item>
    <item>
      <title>1976.Number of Ways to Arrive at Destination (Medium)</title>
      <link>http://localhost:1313/posts/leet/1976.number-of-ways-to-arrive-at-destination/</link>
      <pubDate>Tue, 14 Mar 2023 14:39:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1976.number-of-ways-to-arrive-at-destination/</guid>
      <description>Description 1976. Number of Ways to Arrive at Destination (Medium)&#xA;You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.&#xA;You are given an integer n and a 2D integer array roads where roads[i] = [uᵢ, vᵢ, timeᵢ] means that there is a road between intersections uᵢ and vᵢ that takes timeᵢ minutes to travel.</description>
    </item>
    <item>
      <title>1976.到达目的地的方案数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1976.number-of-ways-to-arrive-at-destination.zh/</link>
      <pubDate>Tue, 14 Mar 2023 14:39:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1976.number-of-ways-to-arrive-at-destination.zh/</guid>
      <description>问题描述 1976. 到达目的地的方案数 (Medium)&#xA;你在一个城市里，城市由 n 个路口组成，路口编号为 0 到 n - 1 ，某些路口之间有 双向 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。&#xA;给你一个整数 n 和二维整数数组 roads ，其中 roads[i] = [uᵢ, vᵢ, timeᵢ] 表示在路口 uᵢ 和 vᵢ 之间有一条需要花费 timeᵢ 时间才能通过的道路。你想知道花费 最少时间 从路口 0 出发到达路口 n - 1 的方案数。&#xA;请返回花费 最少时间 到达目的地的 路径数目 。由于答案可能很大，将结果对 10⁹ + 7 取余 后返回。&#xA;示例 1：&#xA;输入：n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]] 输出：4 解释：从路口 0 出发到路口 6 花费的最少时间是 7 分钟。 四条花费 7 分钟的路径分别为： - 0 ➝ 6 - 0 ➝ 4 ➝ 6 - 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6 - 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6 示例 2：</description>
    </item>
    <item>
      <title>787.Cheapest Flights Within K Stops (Medium)</title>
      <link>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops/</link>
      <pubDate>Mon, 13 Mar 2023 14:16:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops/</guid>
      <description>Description 787. Cheapest Flights Within K Stops (Medium)&#xA;There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromᵢ, toᵢ, priceᵢ] indicates that there is a flight from city fromᵢ to city toᵢ with cost priceᵢ.&#xA;You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.</description>
    </item>
    <item>
      <title>787.K 站中转内最便宜的航班 (Medium)</title>
      <link>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops.zh/</link>
      <pubDate>Mon, 13 Mar 2023 14:14:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops.zh/</guid>
      <description>问题描述 787. K 站中转内最便宜的航班 (Medium)&#xA;有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromᵢ, toᵢ, priceᵢ] ，表示该航班都从城市 fromᵢ 开始，以价格 priceᵢ 抵达 toᵢ。&#xA;现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。&#xA;示例 1：&#xA;输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 输出: 200 解释: 城市航班图如下 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 示例 2：&#xA;输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 输出: 500 解释: 城市航班图如下 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。 提示：</description>
    </item>
    <item>
      <title>1786.Number of Restricted Paths From First to Last Node (Medium)</title>
      <link>http://localhost:1313/posts/leet/1786.number-of-restricted-paths-from-first-to-last-node/</link>
      <pubDate>Mon, 13 Mar 2023 13:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1786.number-of-restricted-paths-from-first-to-last-node/</guid>
      <description>Description Number of Restricted Paths From First to Last Node (Medium) There is an undirected weighted connected graph. You are given a positive integer n which denotes that the graph has n nodes labeled from 1 to n, and an array edges where each edges[i] = [uᵢ, vᵢ, weightᵢ] denotes that there is an edge between nodes uᵢ and vᵢ with weight equal to weightᵢ.&#xA;A path from node start to node end is a sequence of nodes [z₀, z₁,z₂, .</description>
    </item>
    <item>
      <title>1786. 从第一个节点出发到最后一个节点的受限路径数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1786.number-of-restricted-paths-from-first-to-last-node.zh/</link>
      <pubDate>Mon, 13 Mar 2023 13:27:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1786.number-of-restricted-paths-from-first-to-last-node.zh/</guid>
      <description>问题描述 1786. 从第一个节点出发到最后一个节点的受限路径数 (Medium)&#xA;现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [uᵢ, vᵢ, weightᵢ] 表示存在一条位于节点 uᵢ 和 vᵢ 之间的边，这条边的权重为 weightᵢ 。&#xA;从节点 start 出发到节点 end 的路径是一个形如 [z₀, z₁,z₂, ..., zₖ] 的节点序列，满足 z₀ = start 、 zₖ = end 且在所有符合 0 &amp;lt;= i &amp;lt;= k-1 的节点 zᵢ 和 zᵢ+₁ 之间存在一条边。&#xA;路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。 受限路径 为满足 distanceToLastNode(zᵢ) &amp;gt; distanceToLastNode(zᵢ+₁) 的一条路径，其中 0 &amp;lt;= i &amp;lt;= k-1 。</description>
    </item>
    <item>
      <title>2383. Minimum Hours of Training to Win a Competition (Easy)</title>
      <link>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition/</link>
      <pubDate>Mon, 13 Mar 2023 09:34:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition/</guid>
      <description>Description Minimum Hours of Training to Win a Competition (Easy) You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively.&#xA;You are also given two 0-indexed integer arrays energy and experience, both of length n.&#xA;You will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available.</description>
    </item>
    <item>
      <title>2383.赢得比赛需要的最少训练时长 (Easy)</title>
      <link>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition.zh/</link>
      <pubDate>Mon, 13 Mar 2023 09:34:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition.zh/</guid>
      <description>问题描述 2383. 赢得比赛需要的最少训练时长 (Easy)&#xA;你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。&#xA;另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。&#xA;你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。&#xA;击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少 energy[i] 。&#xA;在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。&#xA;返回击败全部 n 个对手需要训练的 最少 小时数目。&#xA;示例 1：&#xA;输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1] 输出：8 解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。 按以下顺序与对手比赛： - 你的精力与经验都超过第 0 个对手，所以获胜。 精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。 - 你的精力与经验都超过第 1 个对手，所以获胜。 精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。 - 你的精力与经验都超过第 2 个对手，所以获胜。 精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。 - 你的精力与经验都超过第 3 个对手，所以获胜。 精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。 在比赛前进行了 8 小时训练，所以返回 8 。 可以证明不存在更小的答案。 示例 2：</description>
    </item>
    <item>
      <title>743. Network Delay Time (Medium)</title>
      <link>http://localhost:1313/posts/leet/743.network-delay-time/</link>
      <pubDate>Sun, 12 Mar 2023 14:23:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/743.network-delay-time/</guid>
      <description>743. Network Delay Time (Medium)&#xA;You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (uᵢ, vᵢ, wᵢ), where uᵢ is the source node, vᵢ is the target node, and wᵢ is the time it takes for a signal to travel from source to target.&#xA;We will send a signal from a given node k.</description>
    </item>
    <item>
      <title>743. 网络延迟时间 (Medium)</title>
      <link>http://localhost:1313/posts/leet/743.network-delay-time.zh/</link>
      <pubDate>Sun, 12 Mar 2023 14:23:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/743.network-delay-time.zh/</guid>
      <description>问题描述 743. 网络延迟时间 (Medium)&#xA;有 n 个网络节点，标记为 1 到 n。&#xA;给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (uᵢ, vᵢ, wᵢ)，其中 uᵢ 是源节点， vᵢ 是目标节点， wᵢ 是一个信号从源节点传递到目标节点的时间。&#xA;现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。&#xA;示例 1：&#xA;输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 输出：2 示例 2：&#xA;输入：times = [[1,2,1]], n = 2, k = 1 输出：1 示例 3：&#xA;输入：times = [[1,2,1]], n = 2, k = 2 输出：-1 提示：&#xA;1 &amp;lt;= k &amp;lt;= n &amp;lt;= 100 1 &amp;lt;= times.</description>
    </item>
    <item>
      <title>面试题 17.05.  字母与数字 (Medium)</title>
      <link>http://localhost:1313/posts/leet/interview-17.05.zh/</link>
      <pubDate>Sat, 11 Mar 2023 15:31:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/interview-17.05.zh/</guid>
      <description>问题描述 面试题 17.05. 字母与数字 (Medium)&#xA;给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。&#xA;返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。&#xA;示例 1:&#xA;输入: [&amp;#34;A&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;2&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;4&amp;#34;,&amp;#34;E&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;F&amp;#34;,&amp;#34;G&amp;#34;,&amp;#34;6&amp;#34;,&amp;#34;7&amp;#34;,&amp;#34;H&amp;#34;,&amp;#34;I&amp;#34;,&amp;#34;J&amp;#34;,&amp;#34;K&amp;#34;,&amp;#34;L&amp;#34;,&amp;#34;M&amp;#34;] 输出: [&amp;#34;A&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;2&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;4&amp;#34;,&amp;#34;E&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;F&amp;#34;,&amp;#34;G&amp;#34;,&amp;#34;6&amp;#34;,&amp;#34;7&amp;#34;] 示例 2:&#xA;输入: [&amp;#34;A&amp;#34;,&amp;#34;A&amp;#34;] 输出: [] 提示：&#xA;array.length &amp;lt;= 100000 解题思路 首先使用一个前缀和数组prefix，prefix[i]表示前i个数里，数字的数量减去字母的数量，遍历array，更新prefix，同时在哈希表中查找key-&amp;gt;prefix[i]是否存在：&#xA;如果存在，比较记录的最长长度len，如果大于len，则更新idx = ump[prefix[i]]，并更新len = i - ump[prefix[i]]； 否则，更新哈希表，即ump[prefix[i]] = i； 代码 class Solution { public: vector&amp;lt;string&amp;gt; findLongestSubarray(vector&amp;lt;string&amp;gt; &amp;amp;array) { int n = array.size(); vector&amp;lt;string&amp;gt; res; if (n &amp;lt; 2) { return res; } unordered_set&amp;lt;string&amp;gt; ust; for (char c = &amp;#39;a&amp;#39;; c &amp;lt;= &amp;#39;z&amp;#39;; c++) { // 统计所有的字母 string s(1, c); ust.</description>
    </item>
    <item>
      <title>1590. Make Sum Divisible by P (Medium)</title>
      <link>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p/</link>
      <pubDate>Fri, 10 Mar 2023 09:31:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p/</guid>
      <description>Description 1590. Make Sum Divisible by P (Medium)&#xA;Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.&#xA;Return the length of the smallest subarray that you need to remove, or -1 if it&amp;rsquo;s impossible.&#xA;A subarray is defined as a contiguous block of elements in the array.</description>
    </item>
    <item>
      <title>1590.使数组和能被 P 整除 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p.zh/</link>
      <pubDate>Fri, 10 Mar 2023 09:31:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p.zh/</guid>
      <description>问题描述 1590. 使数组和能被 P 整除 (Medium)&#xA;给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。&#xA;请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。&#xA;子数组 定义为原数组中连续的一组元素。&#xA;示例 1：&#xA;输入：nums = [3,1,4,2], p = 6 输出：1 解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。 示例 2：&#xA;输入：nums = [6,3,5,2], p = 9 输出：2 解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。 示例 3：&#xA;输入：nums = [1,2,3], p = 3 输出：0 解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。 示例 4：</description>
    </item>
    <item>
      <title>1310.XOR Queries of a Subarray (Medium)</title>
      <link>http://localhost:1313/posts/leet/1310.xor-queries-of-a-subarray/</link>
      <pubDate>Thu, 09 Mar 2023 09:16:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1310.xor-queries-of-a-subarray/</guid>
      <description>Description 1310. XOR Queries of a Subarray (Medium)&#xA;You are given an array arr of positive integers. You are also given the array queries where queries[i] = [leftᵢ, rightᵢ].&#xA;For each query i compute the XOR of elements from leftᵢ to rightᵢ (that is, arr[leftᵢ] XOR arr[leftᵢ + 1] XOR ... XOR arr[rightᵢ] ).&#xA;Return an array answer where answer[i] is the answer to the ith query.&#xA;Example 1:&#xA;Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] Output: [2,7,14,8] Explanation: The binary representation of the elements in the array are: 1 = 0001 3 = 0011 4 = 0100 8 = 1000 The XOR values for queries are: [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 Example 2:</description>
    </item>
    <item>
      <title>1310. 子数组异或查询 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1310.xor-queries-of-a-subarray.zh/</link>
      <pubDate>Thu, 09 Mar 2023 09:16:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1310.xor-queries-of-a-subarray.zh/</guid>
      <description>问题描述 1310. 子数组异或查询 (Medium)&#xA;有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Lᵢ, Rᵢ]。&#xA;对于每个查询 i，请你计算从 Lᵢ 到 Rᵢ 的 XOR 值（即 arr[Lᵢ] xor arr[Lᵢ+1] xor ... xor arr[Rᵢ]）作为本次查询的结果。&#xA;并返回一个包含给定查询 queries 所有结果的数组。&#xA;示例 1：&#xA;输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] 输出：[2,7,14,8] 解释： 数组中元素的二进制表示形式是： 1 = 0001 3 = 0011 4 = 0100 8 = 1000 查询的 XOR 值为： [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 示例 2：</description>
    </item>
    <item>
      <title>629. K Inverse Pairs Array (Hard)</title>
      <link>http://localhost:1313/posts/leet/629.k-inverse-pairs-array/</link>
      <pubDate>Wed, 08 Mar 2023 13:09:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/629.k-inverse-pairs-array/</guid>
      <description>Description K Inverse Pairs Array (Hard) For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length and nums[i] &amp;gt; nums[j].&#xA;Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 10⁹ + 7.</description>
    </item>
    <item>
      <title>629.K个逆序对数组 (Hard)</title>
      <link>http://localhost:1313/posts/leet/629.k-inverse-pairs-array.zh/</link>
      <pubDate>Wed, 08 Mar 2023 13:09:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/629.k-inverse-pairs-array.zh/</guid>
      <description>问题描述 629. K个逆序对数组 (Hard)&#xA;给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。&#xA;逆序对的定义如下：对于数组的第 i 个和第 j 个元素，如果满 i &amp;lt; j 且 a[i] &amp;gt; a[j]，则其为一个逆序对；否则不是。&#xA;由于答案可能很大，只需要返回 答案 mod 10 + 7 的值。&#xA;示例 1:&#xA;输入: n = 3, k = 0 输出: 1 解释: 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。 示例 2:&#xA;输入: n = 3, k = 1 输出: 2 解释: 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。 说明:</description>
    </item>
    <item>
      <title>560. Subarray Sum Equals K (Medium)</title>
      <link>http://localhost:1313/posts/leet/560.subarray-sum-equals-k/</link>
      <pubDate>Tue, 07 Mar 2023 15:28:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/560.subarray-sum-equals-k/</guid>
      <description>Description 560. Subarray Sum Equals K (Medium)&#xA;Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.&#xA;A subarray is a contiguous non-empty sequence of elements within an array.&#xA;Example 1:&#xA;Input: nums = [1,1,1], k = 2 Output: 2 Example 2:&#xA;Input: nums = [1,2,3], k = 3 Output: 2 Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁴ -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -10⁷ &amp;lt;= k &amp;lt;= 10⁷ Solution We only need traverse once.</description>
    </item>
    <item>
      <title>560. 和为 K 的子数组 (Medium)</title>
      <link>http://localhost:1313/posts/leet/560.subarray-sum-equals-k.zh/</link>
      <pubDate>Tue, 07 Mar 2023 15:28:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/560.subarray-sum-equals-k.zh/</guid>
      <description>问题描述 560. 和为 K 的子数组 (Medium)&#xA;给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。&#xA;示例 1：&#xA;输入：nums = [1,1,1], k = 2 输出：2 示例 2：&#xA;输入：nums = [1,2,3], k = 3 输出：2 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁴ -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -10⁷ &amp;lt;= k &amp;lt;= 10⁷ 解题思路 一次遍历，记录数组的前缀和prefix[i]，然后在ump中查找key为prefix[i] - target的元素是否存在，如果存在res += ump[prefix[i] - k]，++ump[prefix[i]]。&#xA;代码 class Solution { public: int subarraySum(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { vector&amp;lt;int&amp;gt; prefix(nums.</description>
    </item>
    <item>
      <title>497.Random Point in Non-overlapping Rectangles (Medium)</title>
      <link>http://localhost:1313/posts/leet/497.random-point-in-non-overlapping-rectangles/</link>
      <pubDate>Tue, 07 Mar 2023 14:45:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/497.random-point-in-non-overlapping-rectangles/</guid>
      <description>Description 497. Random Point in Non-overlapping Rectangles (Medium)&#xA;You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [aᵢ, bᵢ, xᵢ, yᵢ] indicates that (aᵢ, bᵢ) is the bottom-left corner point of the ith rectangle and (xᵢ, yᵢ) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.</description>
    </item>
    <item>
      <title>497.非重叠矩形中的随机点 (Medium)</title>
      <link>http://localhost:1313/posts/leet/497.random-point-in-non-overlapping-rectangles.zh/</link>
      <pubDate>Tue, 07 Mar 2023 14:45:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/497.random-point-in-non-overlapping-rectangles.zh/</guid>
      <description>问题描述 497. 非重叠矩形中的随机点 (Medium)&#xA;给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点， (xi, yi) 是第 i 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。&#xA;在给定的矩形覆盖的空间内的任何整数点都有可能被返回。&#xA;请注意，整数点是具有整数坐标的点。&#xA;实现 Solution 类:&#xA;Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。 int[] pick() 返回一个随机的整数点 [u, v] 在给定的矩形所覆盖的空间内。 示例 1：&#xA;输入: [&amp;#34;Solution&amp;#34;, &amp;#34;pick&amp;#34;, &amp;#34;pick&amp;#34;, &amp;#34;pick&amp;#34;, &amp;#34;pick&amp;#34;, &amp;#34;pick&amp;#34;] [[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []] 输出: [null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]] 解释： Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]); solution.</description>
    </item>
    <item>
      <title>162.Find Peak Element (Medium)</title>
      <link>http://localhost:1313/posts/leet/162.find-peak-element/</link>
      <pubDate>Mon, 06 Mar 2023 19:43:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/162.find-peak-element/</guid>
      <description>Description 162. Find Peak Element (Medium)&#xA;A peak element is an element that is strictly greater than its neighbors.&#xA;Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.&#xA;You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</description>
    </item>
    <item>
      <title>162.寻找峰值 (Medium)</title>
      <link>http://localhost:1313/posts/leet/162.find-peak-element.zh/</link>
      <pubDate>Mon, 06 Mar 2023 19:39:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/162.find-peak-element.zh/</guid>
      <description>问题描述 162. 寻找峰值 (Medium)&#xA;峰值元素是指其值严格大于左右相邻值的元素。&#xA;给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。&#xA;你可以假设 nums[-1] = nums[n] = -∞ 。&#xA;你必须实现时间复杂度为 O(log n) 的算法来解决此问题。&#xA;示例 1：&#xA;输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2：&#xA;输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 1000 -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1] 解题思路 本题要求实现时间复杂度为$O(\log n)$的算法来解决问题，因此我们很容易想到二分，二分本质上并不要求单调性，而是要求二段性。&#xA;代码 class Solution { public: int findPeakElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.</description>
    </item>
    <item>
      <title>1599.Maximum Profit of Operating a Centennial Wheel (Medium)</title>
      <link>http://localhost:1313/posts/leet/1599.maximum-profit-of-operating-a-centennial-wheel/</link>
      <pubDate>Mon, 06 Mar 2023 19:35:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1599.maximum-profit-of-operating-a-centennial-wheel/</guid>
      <description>Description 1599. Maximum Profit of Operating a Centennial Wheel (Medium)&#xA;You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.&#xA;You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive.</description>
    </item>
    <item>
      <title>1599.经营摩天轮的最大利润 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1599.maximum-profit-of-operating-a-centennial-wheel.zh/</link>
      <pubDate>Mon, 06 Mar 2023 19:33:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1599.maximum-profit-of-operating-a-centennial-wheel.zh/</guid>
      <description>问题描述 1599. 经营摩天轮的最大利润 (Medium)&#xA;你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。&#xA;给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。&#xA;你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆， 将免费进行 所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。&#xA;返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。&#xA;示例 1：&#xA;输入：customers = [8,3], boardingCost = 5, runningCost = 6 输出：3 解释：座舱上标注的数字是该座舱的当前游客数。 1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。 2.</description>
    </item>
    <item>
      <title>209.Minimum Size Subarray Sum (Medium)</title>
      <link>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum/</link>
      <pubDate>Mon, 06 Mar 2023 19:11:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum/</guid>
      <description>Description 209. Minimum Size Subarray Sum (Medium)&#xA;Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.&#xA;Example 1:&#xA;Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. Example 2:&#xA;Input: target = 4, nums = [1,4,4] Output: 1 Example 3:</description>
    </item>
    <item>
      <title>209.长度最小的子数组 (Medium)</title>
      <link>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum.zh/</link>
      <pubDate>Mon, 06 Mar 2023 19:11:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum.zh/</guid>
      <description>问题描述 209. 长度最小的子数组 (Medium)&#xA;给定一个含有 n 个正整数的数组和一个正整数 target 。&#xA;找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsₗ, numsₗ+₁, ..., numsr-₁, numsr] ，并返回其长度 。 如果不存在符合条件的子数组，返回 0 。&#xA;示例 1：&#xA;输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：&#xA;输入：target = 4, nums = [1,4,4] 输出：1 示例 3：&#xA;输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示：&#xA;1 &amp;lt;= target &amp;lt;= 10⁹ 1 &amp;lt;= nums.length &amp;lt;= 10⁵ 1 &amp;lt;= nums[i] &amp;lt;= 10⁵ 进阶：</description>
    </item>
    <item>
      <title>2584.split the Array to Make Coprime Products</title>
      <link>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products/</link>
      <pubDate>Mon, 06 Mar 2023 18:56:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products/</guid>
      <description>Description 2584. Split the Array to Make Coprime Products (Hard)&#xA;You are given a 0-indexed integer array nums of length n.&#xA;A split at an index i where 0 &amp;lt;= i &amp;lt;= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.&#xA;For example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime.</description>
    </item>
    <item>
      <title>2584.分割数组使乘积互质 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products.zh/</link>
      <pubDate>Mon, 06 Mar 2023 18:56:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products.zh/</guid>
      <description>问题描述 2584. 分割数组使乘积互质 (Medium)&#xA;给你一个长度为 n 的整数数组 nums ，下标从 0 开始。&#xA;如果在下标 i 处 分割 数组，其中 0 &amp;lt;= i &amp;lt;= n - 2 ，使前 i + 1 个元素的乘积和剩余元素的乘积互质，则认为该分割 有效 。&#xA;例如，如果 nums = [2, 3, 3] ，那么在下标 i = 0 处的分割有效，因为 2 和 9 互质，而在下标 i = 1 处的分割无效，因为 6 和 3 不互质。在下标 i = 2 处的分割也无效，因为 i == n - 1 。 返回可以有效分割数组的最小下标 i ，如果不存在有效分割，则返回 -1 。&#xA;当且仅当 gcd(val1, val2) == 1 成立时， val1 和 val2 这两个值才是互质的，其中 gcd(val1, val2) 表示 val1 和 val2 的最大公约数。</description>
    </item>
    <item>
      <title>1744.can You Eat Your Favorite Candy on Your Favorite Day</title>
      <link>http://localhost:1313/posts/leet/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/</link>
      <pubDate>Mon, 06 Mar 2023 14:10:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/</guid>
      <description>Description 1744. Can You Eat Your Favorite Candy on Your Favorite Day? (Medium)&#xA;You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. You are also given a 2D array queries where queries[i] = [favoriteTypeᵢ, favoriteDayᵢ, dailyCapᵢ].&#xA;You play a game with the following rules:&#xA;You start eating candies on day 0. You cannot eat any candy of type i unless you have eaten all candies of type i - 1.</description>
    </item>
    <item>
      <title>1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？ (Medium)</title>
      <link>http://localhost:1313/posts/leet/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/</link>
      <pubDate>Mon, 06 Mar 2023 14:10:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/</guid>
      <description>问题描述 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ (Medium)&#xA;给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypeᵢ, favoriteDayᵢ, dailyCapᵢ] 。&#xA;你按照如下规则进行一场游戏：&#xA;你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前， 不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。 请你构建一个布尔型数组 answer ，用以给出 queries 中每一项的对应答案。此数组满足：&#xA;answer.length == queries.length 。 answer[i] 是 queries[i] 的答案。 answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapᵢ 颗糖果的前提下，你可以在第 favoriteDayᵢ 天吃到第 favoriteTypeᵢ 类糖果；否则 answer[i] 为 false 。 注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</description>
    </item>
    <item>
      <title>1653.minimum deletions to make string balanced</title>
      <link>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced/</link>
      <pubDate>Mon, 06 Mar 2023 10:36:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced/</guid>
      <description>Description 1653. Minimum Deletions to Make String Balanced (Medium)&#xA;You are given a string s consisting only of characters &#39;a&#39; and &#39;b&#39; .&#xA;You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i &amp;lt; j and s[i] = &#39;b&#39; and s[j]= &#39;a&#39;.&#xA;Return the minimum number of deletions needed to make sbalanced.&#xA;Example 1:</description>
    </item>
    <item>
      <title>1653.使字符串平衡的最少删除次数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced.zh/</link>
      <pubDate>Mon, 06 Mar 2023 10:36:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced.zh/</guid>
      <description>问题描述 1653. 使字符串平衡的最少删除次数 (Medium)&#xA;给你一个字符串 s ，它仅包含字符 &#39;a&#39; 和 &#39;b&#39; 。&#xA;你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i &amp;lt; j ，且 s[i] = &#39;b&#39; 的同时 s[j]= &#39;a&#39; ，此时认为 s 是 平衡 的。&#xA;请你返回使 s 平衡 的 最少 删除次数。&#xA;示例 1：&#xA;输入：s = &amp;#34;aababbab&amp;#34; 输出：2 解释：你可以选择以下任意一种方案： 下标从 0 开始，删除第 2 和第 6 个字符（&amp;#34;aababbab&amp;#34; -&amp;gt; &amp;#34;aaabbb&amp;#34;）， 下标从 0 开始，删除第 3 和第 6 个字符（&amp;#34;aababbab&amp;#34; -&amp;gt; &amp;#34;aabbbb&amp;#34;）。 示例 2：&#xA;输入：s = &amp;#34;bbaaaaabb&amp;#34; 输出：2 解释：唯一的最优解是删除最前面两个字符。 提示：</description>
    </item>
    <item>
      <title>154.find Minimum in Rotated Sorted Array Ii</title>
      <link>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii/</link>
      <pubDate>Sat, 04 Mar 2023 15:57:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii/</guid>
      <description></description>
    </item>
    <item>
      <title>154.寻找旋转排序数组中的最小值 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii.zh/</link>
      <pubDate>Sat, 04 Mar 2023 15:57:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii.zh/</guid>
      <description>问题描述 154. 寻找旋转排序数组中的最小值 II (Hard)&#xA;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：&#xA;若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。&#xA;给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。&#xA;你必须尽可能减少整个过程的操作步骤。&#xA;示例 1：&#xA;输入：nums = [1,3,5] 输出：1 示例 2：&#xA;输入：nums = [2,2,2,0,1] 输出：0 提示：&#xA;n == nums.length 1 &amp;lt;= n &amp;lt;= 5000 -5000 &amp;lt;= nums[i] &amp;lt;= 5000 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶： 这道题与 寻找旋转排序数组中的最小值 类似，但 nums 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</description>
    </item>
    <item>
      <title>153.Find Minimum in Rotated Sorted Array (Medium)</title>
      <link>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array/</link>
      <pubDate>Sat, 04 Mar 2023 15:26:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array/</guid>
      <description>Description 153. Find Minimum in Rotated Sorted Array (Medium)&#xA;Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].</description>
    </item>
    <item>
      <title>153.寻找旋转排序数组中的最小值 (Medium)</title>
      <link>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array.zh/</link>
      <pubDate>Sat, 04 Mar 2023 15:26:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array.zh/</guid>
      <description>问题描述 153. 寻找旋转排序数组中的最小值 (Medium)&#xA;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：&#xA;若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。&#xA;给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。&#xA;你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。&#xA;示例 1：&#xA;输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2：&#xA;输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3：</description>
    </item>
    <item>
      <title>982.Triples with Bitwise AND Equal To Zero (Hard)</title>
      <link>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero/</link>
      <pubDate>Sat, 04 Mar 2023 14:43:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero/</guid>
      <description>Description 982. Triples with Bitwise AND Equal To Zero (Hard)&#xA;Given an integer array nums, return the number of AND triples.&#xA;An AND triple is a triple of indices (i, j, k) such that:&#xA;0 &amp;lt;= i &amp;lt; nums.length 0 &amp;lt;= j &amp;lt; nums.length 0 &amp;lt;= k &amp;lt; nums.length nums[i] &amp;amp; nums[j] &amp;amp; nums[k] == 0, where &amp;amp; represents the bitwise-AND operator. Example 1:&#xA;Input: nums = [2,1,3] Output: 12 Explanation: We could choose the following i, j, k triples: (i=0, j=0, k=1) : 2 &amp;amp; 2 &amp;amp; 1 (i=0, j=1, k=0) : 2 &amp;amp; 1 &amp;amp; 2 (i=0, j=1, k=1) : 2 &amp;amp; 1 &amp;amp; 1 (i=0, j=1, k=2) : 2 &amp;amp; 1 &amp;amp; 3 (i=0, j=2, k=1) : 2 &amp;amp; 3 &amp;amp; 1 (i=1, j=0, k=0) : 1 &amp;amp; 2 &amp;amp; 2 (i=1, j=0, k=1) : 1 &amp;amp; 2 &amp;amp; 1 (i=1, j=0, k=2) : 1 &amp;amp; 2 &amp;amp; 3 (i=1, j=1, k=0) : 1 &amp;amp; 1 &amp;amp; 2 (i=1, j=2, k=0) : 1 &amp;amp; 3 &amp;amp; 2 (i=2, j=0, k=1) : 3 &amp;amp; 2 &amp;amp; 1 (i=2, j=1, k=0) : 3 &amp;amp; 1 &amp;amp; 2 Example 2:</description>
    </item>
    <item>
      <title>982.按位与为零的三元组 (Hard)</title>
      <link>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero.zh/</link>
      <pubDate>Sat, 04 Mar 2023 14:41:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero.zh/</guid>
      <description>问题描述 982. 按位与为零的三元组 (Hard)&#xA;给你一个整数数组 nums ，返回其中 按位与三元组 的数目。&#xA;按位与三元组 是由下标 (i, j, k) 组成的三元组，并满足下述全部条件：&#xA;0 &amp;lt;= i &amp;lt; nums.length 0 &amp;lt;= j &amp;lt; nums.length 0 &amp;lt;= k &amp;lt; nums.length nums[i] &amp;amp; nums[j] &amp;amp; nums[k] == 0 ，其中 &amp;amp; 表示按位与运算符。 示例 1：&#xA;输入：nums = [2,1,3] 输出：12 解释：可以选出如下 i, j, k 三元组： (i=0, j=0, k=1) : 2 &amp;amp; 2 &amp;amp; 1 (i=0, j=1, k=0) : 2 &amp;amp; 1 &amp;amp; 2 (i=0, j=1, k=1) : 2 &amp;amp; 1 &amp;amp; 1 (i=0, j=1, k=2) : 2 &amp;amp; 1 &amp;amp; 3 (i=0, j=2, k=1) : 2 &amp;amp; 3 &amp;amp; 1 (i=1, j=0, k=0) : 1 &amp;amp; 2 &amp;amp; 2 (i=1, j=0, k=1) : 1 &amp;amp; 2 &amp;amp; 1 (i=1, j=0, k=2) : 1 &amp;amp; 2 &amp;amp; 3 (i=1, j=1, k=0) : 1 &amp;amp; 1 &amp;amp; 2 (i=1, j=2, k=0) : 1 &amp;amp; 3 &amp;amp; 2 (i=2, j=0, k=1) : 3 &amp;amp; 2 &amp;amp; 1 (i=2, j=1, k=0) : 3 &amp;amp; 1 &amp;amp; 2 示例 2：</description>
    </item>
    <item>
      <title>1223.Dice Roll Simulation (Hard)</title>
      <link>http://localhost:1313/posts/leet/1223.dice-roll-simulation/</link>
      <pubDate>Fri, 03 Mar 2023 16:46:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1223.dice-roll-simulation/</guid>
      <description>Description 1223. Dice Roll Simulation (Hard)&#xA;A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] ( 1-indexed) consecutive times.&#xA;Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 10⁹ + 7.</description>
    </item>
    <item>
      <title>1223.掷骰子模拟 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1223.dice-roll-simulation.zh/</link>
      <pubDate>Fri, 03 Mar 2023 16:46:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1223.dice-roll-simulation.zh/</guid>
      <description>问题描述 1223. 掷骰子模拟 (Hard)&#xA;有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。&#xA;不过我们在使用它时有个约束，就是使得投掷骰子时， 连续 掷出数字 i 的次数不能超过 rollMax[i]（ i 从 1 开始编号）。&#xA;现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。&#xA;假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。&#xA;示例 1：&#xA;输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。 示例 2：&#xA;输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30 示例 3：</description>
    </item>
    <item>
      <title>552.Student Attendance Record II (Hard)</title>
      <link>http://localhost:1313/posts/leet/552.student-attendance-record-ii/</link>
      <pubDate>Fri, 03 Mar 2023 14:58:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/552.student-attendance-record-ii/</guid>
      <description>Description 552. Student Attendance Record II (Hard)&#xA;An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:&#xA;&#39;A&#39;: Absent. &#39;L&#39;: Late. &#39;P&#39;: Present. Any student is eligible for an attendance award if they meet both of the following criteria:&#xA;The student was absent ( &#39;A&#39;) for strictly fewer than 2 days total.</description>
    </item>
    <item>
      <title>552.学生出勤记录 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/552.student-attendance-record-ii.zh/</link>
      <pubDate>Fri, 03 Mar 2023 14:58:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/552.student-attendance-record-ii.zh/</guid>
      <description>问题描述 552. 学生出勤记录 II (Hard)&#xA;可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：&#xA;&#39;A&#39;：Absent，缺勤 &#39;L&#39;：Late，迟到 &#39;P&#39;：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：&#xA;按 总出勤 计，学生缺勤（ &#39;A&#39;） 严格 少于两天。 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（ &#39;L&#39;）记录。 给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 10⁹ + 7 取余 的结果。&#xA;示例 1：&#xA;输入：n = 2 输出：8 解释： 有 8 种长度为 2 的记录将被视为可奖励： &amp;#34;PP&amp;#34; , &amp;#34;AP&amp;#34;, &amp;#34;PA&amp;#34;, &amp;#34;LP&amp;#34;, &amp;#34;PL&amp;#34;, &amp;#34;AL&amp;#34;, &amp;#34;LA&amp;#34;, &amp;#34;LL&amp;#34; 只有&amp;#34;AA&amp;#34;不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。 示例 2：&#xA;输入：n = 1 输出：3 示例 3：</description>
    </item>
    <item>
      <title>N Th Tribonacci Number</title>
      <link>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number/</link>
      <pubDate>Fri, 03 Mar 2023 10:03:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number/</guid>
      <description>Description 1137. N-th Tribonacci Number (Easy)&#xA;The Tribonacci sequence T is defined as follows:&#xA;T = 0, T = 1, T = 1, and T = T + T + T for n &amp;gt;= 0.&#xA;Given n, return the value of T.&#xA;Example 1:&#xA;Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2:</description>
    </item>
    <item>
      <title>第 N 个泰波那契数 (Easy)</title>
      <link>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number.zh/</link>
      <pubDate>Fri, 03 Mar 2023 10:03:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number.zh/</guid>
      <description>问题描述 1137. 第 N 个泰波那契数 (Easy)&#xA;泰波那契序列 T 定义如下：&#xA;T = 0, T = 1, T = 1, 且在 n &amp;gt;= 0 的条件下 T = T + T + T&#xA;给你整数 n，请返回第 n 个泰波那契数 T的值。&#xA;示例 1：&#xA;输入：n = 4 输出：4 解释： T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 示例 2：&#xA;输入：n = 25 输出：1389537 提示：&#xA;0 &amp;lt;= n &amp;lt;= 37 答案保证是一个 32 位整数，即 answer &amp;lt;= 2^31 - 1。 解题思路 非常简单的动态规划</description>
    </item>
    <item>
      <title>1487.Making File Names Unique (Medium)</title>
      <link>http://localhost:1313/posts/leet/1487.making-file-names-unique/</link>
      <pubDate>Fri, 03 Mar 2023 09:40:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1487.making-file-names-unique/</guid>
      <description>Description 1487. Making File Names Unique (Medium)&#xA;Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].&#xA;Since two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.</description>
    </item>
    <item>
      <title>1487.保证文件名唯一 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1487.making-file-names-unique.zh/</link>
      <pubDate>Fri, 03 Mar 2023 09:40:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1487.making-file-names-unique.zh/</guid>
      <description>问题描述 1487. 保证文件名唯一 (Medium)&#xA;给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。&#xA;由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。&#xA;返回长度为n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。&#xA;示例 1：&#xA;输入：names = [&amp;#34;pes&amp;#34;,&amp;#34;fifa&amp;#34;,&amp;#34;gta&amp;#34;,&amp;#34;pes(2019)&amp;#34;] 输出：[&amp;#34;pes&amp;#34;,&amp;#34;fifa&amp;#34;,&amp;#34;gta&amp;#34;,&amp;#34;pes(2019)&amp;#34;] 解释：文件系统将会这样创建文件名： &amp;#34;pes&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;pes&amp;#34; &amp;#34;fifa&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;fifa&amp;#34; &amp;#34;gta&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;gta&amp;#34; &amp;#34;pes(2019)&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;pes(2019)&amp;#34; 示例 2：&#xA;输入：names = [&amp;#34;gta&amp;#34;,&amp;#34;gta(1)&amp;#34;,&amp;#34;gta&amp;#34;,&amp;#34;avalon&amp;#34;] 输出：[&amp;#34;gta&amp;#34;,&amp;#34;gta(1)&amp;#34;,&amp;#34;gta(2)&amp;#34;,&amp;#34;avalon&amp;#34;] 解释：文件系统将会这样创建文件名： &amp;#34;gta&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;gta&amp;#34; &amp;#34;gta(1)&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;gta(1)&amp;#34; &amp;#34;gta&amp;#34; --&amp;gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &amp;#34;gta(1)&amp;#34; 也被占用，所以 k = 2 。实际创建的文件名为 &amp;#34;gta(2)&amp;#34; 。 &amp;#34;avalon&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;avalon&amp;#34; 示例 3：</description>
    </item>
    <item>
      <title>464.Can I Win (Medium)</title>
      <link>http://localhost:1313/posts/leet/464.can-i-win/</link>
      <pubDate>Thu, 02 Mar 2023 17:55:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/464.can-i-win/</guid>
      <description>Description 464. Can I Win (Medium)&#xA;In the &amp;ldquo;100 game&amp;rdquo; two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.&#xA;What if we change the game so that players cannot re-use integers?&#xA;For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &amp;gt;= 100.</description>
    </item>
    <item>
      <title>464.我能赢吗 (Medium)</title>
      <link>http://localhost:1313/posts/leet/464.can-i-win.zh/</link>
      <pubDate>Thu, 02 Mar 2023 16:56:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/464.can-i-win.zh/</guid>
      <description>问题描述 464. 我能赢吗 (Medium)&#xA;在 &amp;ldquo;100 game&amp;rdquo; 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过 100 的玩家，即为胜者。&#xA;如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？&#xA;例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &amp;gt;= 100。&#xA;给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。&#xA;示例 1：&#xA;输入：maxChoosableInteger = 10, desiredTotal = 11 输出：false 解释： 无论第一个玩家选择哪个整数，他都会失败。 第一个玩家可以选择从 1 到 10 的整数。 如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。 第二个玩家可以通过选择整数 10（那么累积和为 11 &amp;gt;= desiredTotal），从而取得胜利. 同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。 示例 2:&#xA;输入：maxChoosableInteger = 10, desiredTotal = 0 输出：true 示例 3:</description>
    </item>
    <item>
      <title>2373.largest local values in a matrix</title>
      <link>http://localhost:1313/posts/leet/2373.largest-local-values-in-a-matrix/</link>
      <pubDate>Wed, 01 Mar 2023 19:44:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2373.largest-local-values-in-a-matrix/</guid>
      <description>Description Largest Local Values in a Matrix (Easy) You are given an n x n integer matrix grid.&#xA;Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:&#xA;maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1. In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.</description>
    </item>
    <item>
      <title>2373.矩阵中的局部最大值</title>
      <link>http://localhost:1313/posts/leet/2373.largest-local-values-in-a-matrix.zh/</link>
      <pubDate>Wed, 01 Mar 2023 19:44:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2373.largest-local-values-in-a-matrix.zh/</guid>
      <description>问题描述 2373. 矩阵中的局部最大值 (Easy)&#xA;给你一个大小为 n x n 的整数矩阵 grid 。&#xA;生成一个大小为 (n - 2) x (n - 2) 的整数矩阵 maxLocal ，并满足：&#xA;maxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。 换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。&#xA;返回生成的矩阵。&#xA;示例 1：&#xA;输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] 输出：[[9,9],[8,6]] 解释：原矩阵和生成的矩阵如上图所示。 注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。 示例 2：&#xA;输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] 输出：[[2,2,2],[2,2,2],[2,2,2]] 解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。 提示：</description>
    </item>
    <item>
      <title>1405.longest happy string</title>
      <link>http://localhost:1313/posts/leet/1405.longest-happy-string/</link>
      <pubDate>Wed, 01 Mar 2023 19:29:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1405.longest-happy-string/</guid>
      <description>Description 1405. Longest Happy String (Medium)&#xA;A string s is called happy if it satisfies the following conditions:&#xA;s only contains the letters &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;. s does not contain any of &amp;quot;aaa&amp;quot;, &amp;quot;bbb&amp;quot;, or &amp;quot;ccc&amp;quot; as a substring. s contains at most a occurrences of the letter &#39;a&#39;. s contains at most b occurrences of the letter &#39;b&#39;. s contains at most c occurrences of the letter &#39;c&#39;. Given three integers a, b, and c, return the longest possible happy string.</description>
    </item>
    <item>
      <title>1405.最长快乐字符串</title>
      <link>http://localhost:1313/posts/leet/1405.longest-happy-string.zh/</link>
      <pubDate>Wed, 01 Mar 2023 19:29:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1405.longest-happy-string.zh/</guid>
      <description>问题描述 1405. 最长快乐字符串 (Medium)&#xA;如果字符串中不含有任何 &#39;aaa&#39;， &#39;bbb&#39; 或 &#39;ccc&#39; 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。&#xA;给你三个整数 a， b ， c，请你返回 任意一个 满足下列全部条件的字符串 s：&#xA;s 是一个尽可能长的快乐字符串。 s 中 最多 有 a 个字母 &#39;a&#39;、 b 个字母 &#39;b&#39;、 c 个字母 &#39;c&#39; 。 s 中只含有 &#39;a&#39;、 &#39;b&#39; 、 &#39;c&#39; 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串 &amp;quot;&amp;quot;。&#xA;示例 1：&#xA;输入：a = 1, b = 1, c = 7 输出：&amp;#34;ccaccbcc&amp;#34; 解释：&amp;#34;ccbccacc&amp;#34; 也是一种正确答案。 示例 2：&#xA;输入：a = 2, b = 2, c = 1 输出：&amp;#34;aabbc&amp;#34; 示例 3：</description>
    </item>
    <item>
      <title>403.frog jump</title>
      <link>http://localhost:1313/posts/leet/403.frog-jump/</link>
      <pubDate>Wed, 01 Mar 2023 15:08:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/403.frog-jump/</guid>
      <description>Description 403. Frog Jump (Hard)&#xA;A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.&#xA;Given a list of stones&amp;rsquo; positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone.</description>
    </item>
    <item>
      <title>403.青蛙过河</title>
      <link>http://localhost:1313/posts/leet/403.frog-jump.zh/</link>
      <pubDate>Wed, 01 Mar 2023 15:08:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/403.frog-jump.zh/</guid>
      <description>问题描述 403. 青蛙过河 (Hard)&#xA;一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。&#xA;给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。&#xA;如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、 k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。&#xA;示例 1：&#xA;输入：stones = [0,1,3,5,6,8,12,17] 输出：true 解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。 示例 2：</description>
    </item>
    <item>
      <title>524.longest word in dictionary through deleting</title>
      <link>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting/</link>
      <pubDate>Tue, 28 Feb 2023 16:26:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting/</guid>
      <description>Description 524. Longest Word in Dictionary through Deleting (Medium)&#xA;Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.&#xA;Example 1:&#xA;Input: s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] Output: &amp;#34;apple&amp;#34; Example 2:</description>
    </item>
    <item>
      <title>524.通过删除字母匹配到字典里最长单词</title>
      <link>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting.zh/</link>
      <pubDate>Tue, 28 Feb 2023 16:26:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting.zh/</guid>
      <description>问题描述 524. 通过删除字母匹配到字典里最长单词 (Medium)&#xA;给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。&#xA;如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。&#xA;示例 1：&#xA;输入：s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] 输出：&amp;#34;apple&amp;#34; 示例 2：&#xA;输入：s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 输出：&amp;#34;a&amp;#34; 提示：&#xA;1 &amp;lt;= s.length &amp;lt;= 1000 1 &amp;lt;= dictionary.length &amp;lt;= 1000 1 &amp;lt;= dictionary[i].length &amp;lt;= 1000 s 和 dictionary[i] 仅由小写英文字母组成 解题思路 首先将dictionary按长度从大到小排序，相同长度的字符串，字典序小的在前面；&#xA;判断dictionary中的字符串是否能通过删除s中的某些字符得到可以利用双指针优化时间复杂度为$O(n)$，n为s的长度。&#xA;代码 class Solution { public: bool IsSub(string &amp;amp;s, string &amp;amp;word) { for (int i = 0, j = 0; j &amp;lt; word.</description>
    </item>
    <item>
      <title>179.largest number</title>
      <link>http://localhost:1313/posts/leet/179.largest-number/</link>
      <pubDate>Tue, 28 Feb 2023 10:14:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/179.largest-number/</guid>
      <description>Description 179. Largest Number (Medium)&#xA;Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.&#xA;Since the result may be very large, so you need to return a string instead of an integer.&#xA;Example 1:&#xA;Input: nums = [10,2] Output: &amp;#34;210&amp;#34; Example 2:&#xA;Input: nums = [3,30,34,5,9] Output: &amp;#34;9534330&amp;#34; Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ Solution First, we change the vector&amp;lt;int&amp;gt; to vector&amp;lt;string&amp;gt;.</description>
    </item>
    <item>
      <title>179.最大数</title>
      <link>http://localhost:1313/posts/leet/179.largest-number.zh/</link>
      <pubDate>Tue, 28 Feb 2023 10:13:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/179.largest-number.zh/</guid>
      <description>问题描述 179. 最大数 (Medium)&#xA;给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。&#xA;注意： 输出结果可能非常大，所以你需要返回一个字符串而不是整数。&#xA;示例 1：&#xA;输入：nums = [10,2] 输出：&amp;#34;210&amp;#34; 示例 2：&#xA;输入：nums = [3,30,34,5,9] 输出：&amp;#34;9534330&amp;#34; 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ 解题思路 贪心，将数组转化为字符串数组，然后如果s1 + s2 &amp;gt;= s2 + s1，那么就保证s1一定在s2的前面，利用该规则自定义排序，同时要注意对数组中元素全为0的特殊条件的判断。&#xA;代码 class Solution { public: string largestNumber(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { if (nums[i] != 0) { sum += nums[i]; break; } } // 对数组元素全为0的特殊情况的判断 if (sum == 0) { return &amp;#34;0&amp;#34;; } vector&amp;lt;string&amp;gt; tmp; for (int &amp;amp;num : nums) { tmp.</description>
    </item>
    <item>
      <title>2363.merge similar items</title>
      <link>http://localhost:1313/posts/leet/2363.merge-similar-items/</link>
      <pubDate>Tue, 28 Feb 2023 09:22:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2363.merge-similar-items/</guid>
      <description>Description 2363. Merge Similar Items (Easy)&#xA;You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:&#xA;items[i] = [valueᵢ, weightᵢ] where valueᵢ represents the value and weightᵢ represents the weight of the ith item. The value of each item in items is unique. Return a 2D integer array retwhere ret[i] = [valueᵢ, weightᵢ],with weightᵢbeing the sum of weights of all items with value valueᵢ.</description>
    </item>
    <item>
      <title>2363.合并相似的物品</title>
      <link>http://localhost:1313/posts/leet/2363.merge-similar-items.zh/</link>
      <pubDate>Tue, 28 Feb 2023 09:22:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2363.merge-similar-items.zh/</guid>
      <description>问题描述 2363. 合并相似的物品 (Easy)&#xA;给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质：&#xA;items[i] = [valueᵢ, weightᵢ] 其中 valueᵢ 表示第 i 件物品的 价值 ， weightᵢ 表示第 i 件物品的 重量 。 items 中每件物品的价值都是 唯一的 。 请你返回一个二维数组 ret，其中 ret[i] = [valueᵢ, weightᵢ]， weightᵢ 是所有价值为 valueᵢ 物品的 重量之和 。&#xA;注意： ret 应该按价值 升序 排序后返回。&#xA;示例 1：&#xA;输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] 输出：[[1,6],[3,9],[4,5]] 解释： value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。 value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。 value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。 所以，我们返回 [[1,6],[3,9],[4,5]] 。 示例 2：</description>
    </item>
    <item>
      <title>765.couples holding hands</title>
      <link>http://localhost:1313/posts/leet/765.couples-holding-hands/</link>
      <pubDate>Mon, 27 Feb 2023 16:39:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/765.couples-holding-hands/</guid>
      <description>Description 765. Couples Holding Hands (Hard)&#xA;There are n couples sitting in 2n seats arranged in a row and want to hold hands.&#xA;The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).</description>
    </item>
    <item>
      <title>765.情侣牵手</title>
      <link>http://localhost:1313/posts/leet/765.couples-holding-hands.zh/</link>
      <pubDate>Mon, 27 Feb 2023 16:39:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/765.couples-holding-hands.zh/</guid>
      <description>问题描述 765. 情侣牵手 (Hard)&#xA;n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。&#xA;人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。&#xA;返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次 交换可选择任意两人，让他们站起来交换座位。&#xA;示例 1:&#xA;输入: row = [0,2,1,3] 输出: 1 解释: 只需要交换row[1]和row[2]的位置即可。 示例 2:&#xA;输入: row = [3,2,0,1] 输出: 0 解释: 无需交换座位，所有的情侣都已经可以手牵手了。 提示:&#xA;2n == row.length 2 &amp;lt;= n &amp;lt;= 30 n 是偶数 0 &amp;lt;= row[i] &amp;lt; 2n row 中所有元素均 无重复 解题思路 我们只需要遍历i = 0, 2, 4, 6, .</description>
    </item>
    <item>
      <title>1140.stone game ii</title>
      <link>http://localhost:1313/posts/leet/1140.stone-game-ii/</link>
      <pubDate>Mon, 27 Feb 2023 16:02:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1140.stone-game-ii/</guid>
      <description>Description 1140. Stone Game II (Medium)&#xA;Alice and Bob continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.&#xA;Alice and Bob take turns, with Alice starting first. Initially, M = 1.&#xA;On each player&amp;rsquo;s turn, that player can take all the stones in the first X remaining piles, where 1 &amp;lt;= X &amp;lt;= 2M.</description>
    </item>
    <item>
      <title>1140.石子游戏 II</title>
      <link>http://localhost:1313/posts/leet/1140.stone-game-ii.zh/</link>
      <pubDate>Mon, 27 Feb 2023 16:01:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1140.stone-game-ii.zh/</guid>
      <description>问题描述 1140. 石子游戏 II (Medium)&#xA;爱丽丝和鲍勃继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。&#xA;爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初， M = 1。&#xA;在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 &amp;lt;= X &amp;lt;= 2M。然后，令 M = max(M, X)。&#xA;游戏一直持续到所有石子都被拿走。&#xA;假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。&#xA;示例 1：&#xA;输入：piles = [2,7,9,4,4] 输出：10 解释：如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。 示例 2:&#xA;输入：piles = [1,2,3,4,5,100] 输出：104 提示：&#xA;1 &amp;lt;= piles.length &amp;lt;= 100 1 &amp;lt;= piles[i] &amp;lt;= 10⁴ 解题思路 首先这里要明确发挥最佳水平的含义： 如果自己拿了前x块石子之后，对方所能拿到的石子最少，这就是博弈中的发挥最佳水平，对应到dfs，明白了这一点就能写出递归和记忆化搜索，注意这里还需要用到后缀数组。&#xA;写出记忆化搜索之后可以改写成动态规划。&#xA;代码 记忆化搜索 class Solution { public: int dfs(int idx_start, int M, vector&amp;lt;int&amp;gt; &amp;amp;postfix, int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;cach) { if (idx_start &amp;gt;= n) return 0; int minnum = 100001; if (cach[idx_start][M] &amp;gt;= 0) { return cach[idx_start][M]; } for (int i = idx_start + 1; i &amp;lt;= idx_start + 2 * M &amp;amp;&amp;amp; i &amp;lt;= n; i++) { // i表示下一个人拿石子的开始位置，所以i至少为idx_start+1 int tmp = dfs(i, std::max(i - idx_start, M), postfix, n, cach); if (minnum &amp;gt; tmp) { minnum = tmp; } } cach[idx_start][M] = postfix[idx_start] - minnum; return cach[idx_start][M]; } int stoneGameII(vector&amp;lt;int&amp;gt;&amp;amp; piles) { int n = piles.</description>
    </item>
    <item>
      <title>1255.maximum score words formed by letters</title>
      <link>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters/</link>
      <pubDate>Mon, 27 Feb 2023 15:53:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters/</guid>
      <description>Description 1255. Maximum Score Words Formed by Letters (Hard)&#xA;Given a list of words, list of single letters (might be repeating) and score of every character.&#xA;Return the maximum score of any valid set of words formed by using the given letters ( words[i] cannot be used two or more times).&#xA;It is not necessary to use all characters in letters and each letter can only be used once. Score of letters &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &amp;hellip; , &#39;z&#39; is given by score[0], score[1], &amp;hellip; , score[25] respectively.</description>
    </item>
    <item>
      <title>1255.得分最高的单词集合</title>
      <link>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters.zh/</link>
      <pubDate>Mon, 27 Feb 2023 15:53:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters.zh/</guid>
      <description>问题描述 1255. 得分最高的单词集合 (Hard)&#xA;你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。&#xA;请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。&#xA;单词拼写游戏的规则概述如下：&#xA;玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。 可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。 单词表 words 中每个单词只能计分（使用）一次。 根据字母得分情况表 score，字母 &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &amp;hellip; , &#39;z&#39; 对应的得分分别为 score[0], score[1], &amp;hellip;, score[25]。 本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。 示例 1：&#xA;输入：words = [&amp;#34;dog&amp;#34;,&amp;#34;cat&amp;#34;,&amp;#34;dad&amp;#34;,&amp;#34;good&amp;#34;], letters = [&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;c&amp;#34;,&amp;#34;d&amp;#34;,&amp;#34;d&amp;#34;,&amp;#34;d&amp;#34;,&amp;#34;g&amp;#34;,&amp;#34;o&amp;#34;,&amp;#34;o&amp;#34;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] 输出：23 解释： 字母得分为 a=1, c=9, d=5, g=3, o=2 使用给定的字母表 letters，我们可以拼写单词 &amp;#34;dad&amp;#34; (5+1+5)和 &amp;#34;good&amp;#34; (3+2+2+5)，得分为 23 。 而单词 &amp;#34;dad&amp;#34; 和 &amp;#34;dog&amp;#34; 只能得到 21 分。 示例 2：</description>
    </item>
    <item>
      <title>2170.minimum operations to make the array alternating</title>
      <link>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating/</link>
      <pubDate>Mon, 27 Feb 2023 15:38:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating/</guid>
      <description>Description 2170. Minimum Operations to Make the Array Alternating (Medium)&#xA;You are given a 0-indexed array nums consisting of n positive integers.&#xA;The array nums is called alternating if:&#xA;nums[i - 2] == nums[i], where 2 &amp;lt;= i &amp;lt;= n - 1. nums[i - 1] != nums[i], where 1 &amp;lt;= i &amp;lt;= n - 1. In one operation, you can choose an index i and change nums[i] into any positive integer.</description>
    </item>
    <item>
      <title>2170.使数组变成交替数组的最少操作数</title>
      <link>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating.zh/</link>
      <pubDate>Mon, 27 Feb 2023 15:38:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating.zh/</guid>
      <description>问题描述 2170. 使数组变成交替数组的最少操作数 (Medium)&#xA;给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。&#xA;如果满足下述条件，则数组 nums 是一个 交替数组 ：&#xA;nums[i - 2] == nums[i] ，其中 2 &amp;lt;= i &amp;lt;= n - 1 。 nums[i - 1] != nums[i] ，其中 1 &amp;lt;= i &amp;lt;= n - 1 。 在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。&#xA;返回使数组变成交替数组的 最少操作数 。&#xA;示例 1：&#xA;输入：nums = [3,1,3,2,4,3] 输出：3 解释： 使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。 在这种情况下，操作数为 3 。 可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。 示例 2：</description>
    </item>
    <item>
      <title>1144.decrease elements to make array zigzag</title>
      <link>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag/</link>
      <pubDate>Mon, 27 Feb 2023 15:28:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag/</guid>
      <description>Description 1144. Decrease Elements To Make Array Zigzag (Medium)&#xA;Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.&#xA;An array A is a zigzag array if either:&#xA;Every even-indexed element is greater than adjacent elements, ie. A[0] &amp;gt; A[1] &amp;lt; A[2] &amp;gt; A[3] &amp;lt; A[4] &amp;gt; ... OR, every odd-indexed element is greater than adjacent elements, ie. A[0] &amp;lt; A[1] &amp;gt; A[2] &amp;lt; A[3] &amp;gt; A[4] &amp;lt; .</description>
    </item>
    <item>
      <title>1144.递减元素使数组呈锯齿状</title>
      <link>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag.zh/</link>
      <pubDate>Mon, 27 Feb 2023 15:28:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag.zh/</guid>
      <description>问题描述 1144. 递减元素使数组呈锯齿状 (Medium)&#xA;给你一个整数数组 nums，每次 操作 会从中选择一个元素并 将该元素的值减少 1。&#xA;如果符合下列情况之一，则数组 A 就是 锯齿数组：&#xA;每个偶数索引对应的元素都大于相邻的元素，即 A[0] &amp;gt; A[1] &amp;lt; A[2] &amp;gt; A[3] &amp;lt; A[4] &amp;gt; ... 或者，每个奇数索引对应的元素都大于相邻的元素，即 A[0] &amp;lt; A[1] &amp;gt; A[2] &amp;lt; A[3] &amp;gt; A[4] &amp;lt; ... 返回将数组 nums 转换为锯齿数组所需的最小操作次数。&#xA;示例 1：&#xA;输入：nums = [1,2,3] 输出：2 解释：我们可以把 2 递减到 0，或把 3 递减到 1。 示例 2：&#xA;输入：nums = [9,6,1,6,2] 输出：4 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 1000 1 &amp;lt;= nums[i] &amp;lt;= 1000 解题思路 首先要注意本题只允许递减数字，只需要考虑分别考虑偶数索引满足情况和奇数索引满足情况的情况，模拟即可。</description>
    </item>
    <item>
      <title>881.boats to save people</title>
      <link>http://localhost:1313/posts/leet/881.boats-to-save-people/</link>
      <pubDate>Sat, 25 Feb 2023 10:24:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/881.boats-to-save-people/</guid>
      <description>Description 881. Boats to Save People (Medium)&#xA;You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.&#xA;Return the minimum number of boats to carry every given person.</description>
    </item>
    <item>
      <title>881.救生艇</title>
      <link>http://localhost:1313/posts/leet/881.boats-to-save-people.zh/</link>
      <pubDate>Sat, 25 Feb 2023 10:23:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/881.boats-to-save-people.zh/</guid>
      <description>问题描述 881. 救生艇 (Medium)&#xA;给定数组 people 。 people[i] 表示第 i 个人的体重 ， 船的数量不限，每艘船可以承载的最大重量为 limit。&#xA;每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。&#xA;返回 承载所有人所需的最小船数 。&#xA;示例 1：&#xA;输入：people = [1,2], limit = 3 输出：1 解释：1 艘船载 (1, 2) 示例 2：&#xA;输入：people = [3,2,2,1], limit = 3 输出：3 解释：3 艘船分别载 (1, 2), (2) 和 (3) 示例 3：&#xA;输入：people = [3,5,3,4], limit = 5 输出：4 解释：4 艘船分别载 (3), (3), (4), (5) 提示：&#xA;1 &amp;lt;= people.length &amp;lt;= 5 * 10⁴ 1 &amp;lt;= people[i] &amp;lt;= limit &amp;lt;= 3 * 10⁴ 解题思路 每次必定选择最轻的的和二者重量和不超过limit的最重的人上船，因此可以将数组排序，然后一左一右双指针向中间遍历。</description>
    </item>
    <item>
      <title>1247.minimum swaps to make strings.equal</title>
      <link>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal/</link>
      <pubDate>Sat, 25 Feb 2023 10:11:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal/</guid>
      <description>Description 1247. Minimum Swaps to Make Strings Equal (Medium)&#xA;You are given two strings s1 and s2 of equal length consisting of letters &amp;quot;x&amp;quot; and &amp;quot;y&amp;quot; only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].&#xA;Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.</description>
    </item>
    <item>
      <title>1247.交换字符使得字符串相同</title>
      <link>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal.zh/</link>
      <pubDate>Sat, 25 Feb 2023 10:01:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal.zh/</guid>
      <description>问题描述 1247. 交换字符使得字符串相同 (Medium)&#xA;有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 &amp;quot;x&amp;quot; 和 &amp;quot;y&amp;quot;，你需要通过「交换字符」的方式使这两个字符串相同。&#xA;每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。&#xA;交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。&#xA;最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。&#xA;示例 1：&#xA;输入：s1 = &amp;#34;xx&amp;#34;, s2 = &amp;#34;yy&amp;#34; 输出：1 解释： 交换 s1[0] 和 s2[1]，得到 s1 = &amp;#34;yx&amp;#34;，s2 = &amp;#34;yx&amp;#34;。 示例 2：&#xA;输入：s1 = &amp;#34;xy&amp;#34;, s2 = &amp;#34;yx&amp;#34; 输出：2 解释： 交换 s1[0] 和 s2[0]，得到 s1 = &amp;#34;yy&amp;#34;，s2 = &amp;#34;xx&amp;#34; 。 交换 s1[0] 和 s2[1]，得到 s1 = &amp;#34;xy&amp;#34;，s2 = &amp;#34;xy&amp;#34; 。 注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 &amp;#34;yx&amp;#34;，因为我们只能交换属于两个不同字符串的字符。 示例 3：</description>
    </item>
    <item>
      <title>312.burst Balloons</title>
      <link>http://localhost:1313/posts/leet/312.burst-balloons/</link>
      <pubDate>Fri, 24 Feb 2023 09:26:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/312.burst-balloons/</guid>
      <description></description>
    </item>
    <item>
      <title>312.戳气球</title>
      <link>http://localhost:1313/posts/leet/312.burst-balloons.zh/</link>
      <pubDate>Fri, 24 Feb 2023 09:26:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/312.burst-balloons.zh/</guid>
      <description>问题描述 312. 戳气球 (Hard)&#xA;有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&#xA;现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1 或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。&#xA;求所能获得硬币的最大数量。&#xA;示例 1：&#xA;输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8] --&amp;gt; [3,5,8] --&amp;gt; [3,8] --&amp;gt; [8] --&amp;gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 示例 2：</description>
    </item>
    <item>
      <title>2357.make array zero by subtracting equal amounts</title>
      <link>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts/</link>
      <pubDate>Fri, 24 Feb 2023 09:18:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts/</guid>
      <description>Description 2357. Make Array Zero by Subtracting Equal Amounts (Easy)&#xA;You are given a non-negative integer array nums. In one operation, you must:&#xA;Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums. Subtract x from every positive element in nums. Return the minimum number of operations to make every element in nums equal to 0.&#xA;Example 1:&#xA;Input: nums = [1,5,0,3,5] Output: 3 Explanation: In the first operation, choose x = 1.</description>
    </item>
    <item>
      <title>2357.使数组中所有元素都等于零</title>
      <link>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts.zh/</link>
      <pubDate>Fri, 24 Feb 2023 09:17:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts.zh/</guid>
      <description>问题描述 2357. 使数组中所有元素都等于零 (Easy)&#xA;给你一个非负整数数组 nums 。在一步操作中，你必须：&#xA;选出一个正整数 x ， x 需要小于或等于 nums 中 最小 的 非零 元素。 nums 中的每个正整数都减去 x。 返回使 nums 中所有元素都等于 0 需要的 最少 操作数。&#xA;示例 1：&#xA;输入：nums = [1,5,0,3,5] 输出：3 解释： 第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。 第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。 第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。 示例 2：&#xA;输入：nums = [0] 输出：0 解释：nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。 提示：</description>
    </item>
    <item>
      <title>397.integer replacement</title>
      <link>http://localhost:1313/posts/leet/397.integer-replacement/</link>
      <pubDate>Thu, 23 Feb 2023 16:08:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/397.integer-replacement/</guid>
      <description>Description 397. Integer Replacement (Medium)&#xA;Given a positive integer n, you can apply one of the following operations:&#xA;If n is even, replace n with n / 2. If n is odd, replace n with either n + 1 or n - 1. Return the minimum number of operations needed for nto become 1.&#xA;Example 1:&#xA;Input: n = 8 Output: 3 Explanation: 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 Example 2:</description>
    </item>
    <item>
      <title>397.整数替换</title>
      <link>http://localhost:1313/posts/leet/397.integer-replacement.zh/</link>
      <pubDate>Thu, 23 Feb 2023 16:08:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/397.integer-replacement.zh/</guid>
      <description>问题描述 397. 整数替换 (Medium)&#xA;给定一个正整数 n ，你可以做如下操作：&#xA;如果 n 是偶数，则用 n / 2 替换 n。 如果 n 是奇数，则可以用 n + 1 或 n - 1 替换 n 。 返回 n 变为 1 所需的 最小替换次数 。&#xA;示例 1：&#xA;输入：n = 8 输出：3 解释：8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 示例 2：&#xA;输入：n = 7 输出：4 解释：7 -&amp;gt; 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 或 7 -&amp;gt; 6 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1 示例 3：</description>
    </item>
    <item>
      <title>1238.circular permutation in binary representation</title>
      <link>http://localhost:1313/posts/leet/1238.circular-permutation-in-binary-representation/</link>
      <pubDate>Thu, 23 Feb 2023 15:56:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1238.circular-permutation-in-binary-representation/</guid>
      <description>Description 1238. Circular Permutation in Binary Representation (Medium)&#xA;Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that :&#xA;p[0] = start p[i] and p[i+1] differ by only one bit in their binary representation. p[0] and p[2^n -1] must also differ by only one bit in their binary representation. Example 1:&#xA;Input: n = 2, start = 3 Output: [3,2,0,1] Explanation: The binary representation of the permutation is (11,10,00,01).</description>
    </item>
    <item>
      <title>1238.循环码排列</title>
      <link>http://localhost:1313/posts/leet/1238.circular-permutation-in-binary-representation.zh/</link>
      <pubDate>Thu, 23 Feb 2023 15:56:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1238.circular-permutation-in-binary-representation.zh/</guid>
      <description>问题描述 1238. 循环码排列 (Medium)&#xA;给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,...,2^n-1) 的排列 p，并且满足：&#xA;p[0] = start p[i] 和 p[i+1] 的二进制表示形式只有一位不同 p[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同 示例 1：&#xA;输入：n = 2, start = 3 输出：[3,2,0,1] 解释：这个排列的二进制表示是 (11,10,00,01) 所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2] 示例 2：&#xA;输出：n = 3, start = 2 输出：[2,6,7,5,4,0,1,3] 解释：这个排列的二进制表示是 (010,110,111,101,100,000,001,011) 提示：&#xA;1 &amp;lt;= n &amp;lt;= 16 0 &amp;lt;= start &amp;lt; 2^n 解题思路 参照89.格雷编码，只需要将得到的结果再与start按位异或就好了，因为x ^ 0 = x对任意x恒成立。&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; circularPermutation(int n, int start) { vector&amp;lt;int&amp;gt; res(1 &amp;lt;&amp;lt; n, 0); for (int i = 0; i &amp;lt; res.</description>
    </item>
    <item>
      <title>89.gray code</title>
      <link>http://localhost:1313/posts/leet/89.gray-code/</link>
      <pubDate>Thu, 23 Feb 2023 15:53:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/89.gray-code/</guid>
      <description>Description 89. Gray Code (Medium)&#xA;An n-bit gray code sequence is a sequence of 2ⁿ integers where:&#xA;Every integer is in the inclusive range [0, 2ⁿ - 1], The first integer is 0, An integer appears no more than once in the sequence, The binary representation of every pair of adjacent integers differs by exactly one bit, and The binary representation of the first and last integers differs by exactly one bit.</description>
    </item>
    <item>
      <title>89.格雷编码</title>
      <link>http://localhost:1313/posts/leet/89.gray-code.zh/</link>
      <pubDate>Thu, 23 Feb 2023 15:51:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/89.gray-code.zh/</guid>
      <description>问题描述 89. 格雷编码 (Medium)&#xA;n 位格雷码序列 是一个由 2ⁿ 个整数组成的序列，其中：&#xA;每个整数都在范围 [0, 2ⁿ - 1] 内（含 0 和 2ⁿ - 1） 第一个整数是 0 一个整数在序列中出现 不超过一次 每对 相邻 整数的二进制表示 恰好一位不同 ，且 第一个 和 最后一个 整数的二进制表示 恰好一位不同 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。&#xA;示例 1：&#xA;输入：n = 2 输出：[0,1,3,2] 解释： [0,1,3,2] 的二进制表示是 [00,01,11,10] 。 - 00 和 01 有一位不同 - 01 和 11 有一位不同 - 11 和 10 有一位不同 - 10 和 00 有一位不同 [0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。 - 00 和 10 有一位不同 - 10 和 11 有一位不同 - 11 和 01 有一位不同 - 01 和 00 有一位不同 示例 2：</description>
    </item>
    <item>
      <title>1326.minimum number of taps to open to water a garden</title>
      <link>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden/</link>
      <pubDate>Tue, 21 Feb 2023 15:35:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden/</guid>
      <description>Description 1326. Minimum Number of Taps to Open to Water a Garden (Hard)&#xA;There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).&#xA;There are n + 1 taps located at points [0, 1, ..., n] in the garden.&#xA;Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.</description>
    </item>
    <item>
      <title>1326.浇灌花园的最少水龙头数目</title>
      <link>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/</link>
      <pubDate>Tue, 21 Feb 2023 15:35:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/</guid>
      <description>问题描述 1326. 灌溉花园的最少水龙头数目 (Hard)&#xA;在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。&#xA;花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。&#xA;给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i - ranges[i], i + ranges[i]] 。&#xA;请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。&#xA;示例 1：&#xA;输入：n = 5, ranges = [3,4,1,1,0,0] 输出：1 解释： 点 0 处的水龙头可以灌溉区间 [-3,3] 点 1 处的水龙头可以灌溉区间 [-3,5] 点 2 处的水龙头可以灌溉区间 [1,3] 点 3 处的水龙头可以灌溉区间 [2,4] 点 4 处的水龙头可以灌溉区间 [4,4] 点 5 处的水龙头可以灌溉区间 [5,5] 只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。 示例 2：</description>
    </item>
    <item>
      <title>1792.maximum average pass ratio</title>
      <link>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio/</link>
      <pubDate>Mon, 20 Feb 2023 14:14:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio/</guid>
      <description>Description 1792. Maximum Average Pass Ratio (Medium)&#xA;There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passᵢ, totalᵢ]. You know beforehand that in the ith class, there are totalᵢ total students, but only passᵢ number of students will pass the exam.&#xA;You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to.</description>
    </item>
    <item>
      <title>1792.最大平均通过率</title>
      <link>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio.zh/</link>
      <pubDate>Mon, 20 Feb 2023 14:14:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio.zh/</guid>
      <description>问题描述 1792. 最大平均通过率 (Medium)&#xA;一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passᵢ, totalᵢ] ，表示你提前知道了第 i 个班级总共有 totalᵢ 个学生，其中只有 passᵢ 个学生可以通过考试。&#xA;给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。&#xA;一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。 平均通过率 是所有班级的通过率之和除以班级数目。&#xA;请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-⁵ 以内的结果都会视为正确结果。&#xA;示例 1：&#xA;输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2 输出：0.78333 解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。 示例 2：&#xA;输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4 输出：0.</description>
    </item>
    <item>
      <title>1833.maximum Ice Cream Bars</title>
      <link>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars/</link>
      <pubDate>Mon, 20 Feb 2023 10:14:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars/</guid>
      <description>Description 1833. Maximum Ice Cream Bars (Medium)&#xA;It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.</description>
    </item>
    <item>
      <title>1833.雪糕的最大数量</title>
      <link>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars.zh/</link>
      <pubDate>Mon, 20 Feb 2023 10:14:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars.zh/</guid>
      <description>问题描述 1833. 雪糕的最大数量 (Medium)&#xA;夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。&#xA;商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。&#xA;注意： Tony 可以按任意顺序购买雪糕。&#xA;给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。&#xA;示例 1：&#xA;输入：costs = [1,3,2,4,1], coins = 7 输出：4 解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7 示例 2：&#xA;输入：costs = [10,6,8,7,7,8], coins = 5 输出：0 解释：Tony 没有足够的钱买任何一支雪糕。 示例 3：</description>
    </item>
    <item>
      <title>2347.best poker hand</title>
      <link>http://localhost:1313/posts/leet/2347.best-poker-hand/</link>
      <pubDate>Mon, 20 Feb 2023 09:38:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2347.best-poker-hand/</guid>
      <description>Description 2347. Best Poker Hand (Easy)&#xA;You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i]. The following are the types of poker hands you can make from best to worst:&#xA;&amp;quot;Flush&amp;quot;: Five cards of the same suit. &amp;quot;Three of a Kind&amp;quot;: Three cards of the same rank. &amp;quot;Pair&amp;quot;: Two cards of the same rank.</description>
    </item>
    <item>
      <title>2347.最好的扑克手牌</title>
      <link>http://localhost:1313/posts/leet/2347.best-poker-hand.zh/</link>
      <pubDate>Mon, 20 Feb 2023 09:38:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2347.best-poker-hand.zh/</guid>
      <description>问题描述 2347. 最好的扑克手牌 (Easy)&#xA;给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。 下述是从好到坏你可能持有的 手牌类型：&#xA;&amp;quot;Flush&amp;quot;：同花，五张相同花色的扑克牌。 &amp;quot;Three of a Kind&amp;quot;：三条，有 3 张大小相同的扑克牌。 &amp;quot;Pair&amp;quot;：对子，两张大小一样的扑克牌。 &amp;quot;High Card&amp;quot;：高牌，五张大小互不相同的扑克牌。 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。 注意： 返回的字符串 大小写 需与题目描述相同。 示例 1： 输入：ranks = [13,2,3,1,9], suits = [&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;] 输出：&amp;#34;Flush&amp;#34; 解释：5 张扑克牌的花色相同，所以返回 &amp;#34;Flush&amp;#34; 。 示例 2：&#xA;输入：ranks = [4,4,2,4,4], suits = [&amp;#34;d&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 输出：&amp;#34;Three of a Kind&amp;#34; 解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 &amp;#34;Three of a Kind&amp;#34; 。 注意我们也可以得到 &amp;#34;Pair&amp;#34; ，但是 &amp;#34;Three of a Kind&amp;#34; 是更好的手牌类型。 有其他的 3 张牌也可以组成 &amp;#34;Three of a Kind&amp;#34; 手牌类型。 示例 3：</description>
    </item>
    <item>
      <title>781.rabbits in forest</title>
      <link>http://localhost:1313/posts/leet/781.rabbits-in-forest/</link>
      <pubDate>Sat, 18 Feb 2023 18:14:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/781.rabbits-in-forest/</guid>
      <description>Solution 781. Rabbits in Forest (Medium)&#xA;There is a forest with an unknown number of rabbits. We asked n rabbits &amp;ldquo;How many rabbits have the same color as you?&amp;rdquo; and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit. Given the array answers, return the minimum number of rabbits that could be in the forest. Example 1:&#xA;Input: answers = [1,1,2] Output: 5 Explanation: The two rabbits that answered &amp;#34;1&amp;#34; could both be the same color, say red.</description>
    </item>
    <item>
      <title>781.森林中的兔子</title>
      <link>http://localhost:1313/posts/leet/781.rabbits-in-forest.zh/</link>
      <pubDate>Sat, 18 Feb 2023 18:14:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/781.rabbits-in-forest.zh/</guid>
      <description>问题描述 781. 森林中的兔子 (Medium)&#xA;森林中有未知数量的兔子。提问其中若干只兔子 &amp;ldquo;还有多少只兔子与你（指被提问的兔子）颜色相同?&amp;rdquo; ，将答案收集到一个整数数组 answers 中，其中 answers[i] 是第 i 只兔子的回答。 给你数组 answers ，返回森林中兔子的最少数量。 示例 1：&#xA;输入：answers = [1,1,2] 输出：5 解释： 两只回答了 &amp;#34;1&amp;#34; 的兔子可能有相同的颜色，设为红色。 之后回答了 &amp;#34;2&amp;#34; 的兔子不会是红色，否则他们的回答会相互矛盾。 设回答了 &amp;#34;2&amp;#34; 的兔子为蓝色。 此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。 因此森林中兔子的最少数量是 5 只：3 只回答的和 2 只没有回答的。 示例 2：&#xA;输入：answers = [10,10,10] 输出：11 提示：&#xA;1 &amp;lt;= answers.length &amp;lt;= 1000 0 &amp;lt;= answers[i] &amp;lt; 1000 解题思路 从题目中给出的例子我们可以发现，要想让兔子数量最小，那么要尽量让回答结果相同的兔子是同一个颜色的；&#xA;我们用一个哈希表unordered_map&amp;lt;int, int&amp;gt; ump来记录每种结果有多少只兔子回答了，key为回答结果，value是回答该结果的兔子的数量；&#xA;如果ump[i] &amp;gt; i + 1，说明这批兔子至少有不止一种颜色，颜色数为(ump[i] - 1) / (i + 1) + 1，每种颜色有i + 1个兔子。</description>
    </item>
    <item>
      <title>1996.the number of weak characters in the game</title>
      <link>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game/</link>
      <pubDate>Sat, 18 Feb 2023 17:23:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game/</guid>
      <description>Description 1223. Dice Roll Simulation (Hard)&#xA;A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] ( 1-indexed) consecutive times. Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 10⁹ + 7.</description>
    </item>
    <item>
      <title>1996.游戏中弱角色的数量</title>
      <link>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game.zh/</link>
      <pubDate>Sat, 18 Feb 2023 17:23:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game.zh/</guid>
      <description>问题描述 1996. 游戏中弱角色的数量 (Medium)&#xA;你正在参加一个多角色游戏，每个角色都有两个主要属性： 攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attackᵢ, defenseᵢ] 表示游戏中第 i 个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackⱼ &amp;gt; attackᵢ 且 defenseⱼ &amp;gt; defenseᵢ 。 返回 弱角色 的数量。 示例 1：&#xA;输入：properties = [[5,5],[6,3],[3,6]] 输出：0 解释：不存在攻击和防御都严格高于其他角色的角色。 示例 2：&#xA;输入：properties = [[2,2],[3,3]] 输出：1 解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 示例 3：&#xA;输入：properties = [[1,5],[10,4],[4,3]] 输出：1 解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 提示：&#xA;2 &amp;lt;= properties.length &amp;lt;= 10⁵ properties[i].length == 2 1 &amp;lt;= attackᵢ, defenseᵢ &amp;lt;= 10⁵ 解题思路 首先将角色按照攻击值从大到小排序，至于相同攻击值之间的角色的排序，有两种思路</description>
    </item>
    <item>
      <title>1797.design authentication manager</title>
      <link>http://localhost:1313/posts/leet/1797.design-authentication-manager/</link>
      <pubDate>Sat, 18 Feb 2023 16:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1797.design-authentication-manager/</guid>
      <description>Description 1797. Design Authentication Manager (Medium)&#xA;There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime. Implement the AuthenticationManager class:&#xA;AuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive. generate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.</description>
    </item>
    <item>
      <title>1797.设计一个验证系统</title>
      <link>http://localhost:1313/posts/leet/1797.design-authentication-manager.zh/</link>
      <pubDate>Sat, 18 Feb 2023 16:43:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1797.design-authentication-manager.zh/</guid>
      <description>问题描述 1797. 设计一个验证系统 (Medium)&#xA;你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。 请你实现 AuthenticationManager 类：&#xA;AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。 generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。 renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。 countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻， 未过期 的验证码数目。 如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（ renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。 示例 1： 输入： [&amp;#34;AuthenticationManager&amp;#34;, &amp;#34;renew&amp;#34;, &amp;#34;generate&amp;#34;, &amp;#34;countUnexpiredTokens&amp;#34;, &amp;#34;generate&amp;#34;, &amp;#34;renew&amp;#34;, &amp;#34;renew&amp;#34;, &amp;#34;countUnexpiredTokens&amp;#34;] [[5], [&amp;#34;aaa&amp;#34;, 1], [&amp;#34;aaa&amp;#34;, 2], [6], [&amp;#34;bbb&amp;#34;, 7], [&amp;#34;aaa&amp;#34;, 8], [&amp;#34;bbb&amp;#34;, 10], [15]] 输出： [null, null, null, 1, null, null, null, 0] 解释： AuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 timeToLive = 5 秒。 authenticationManager.</description>
    </item>
    <item>
      <title>1233.remove sub folders from the filesystem</title>
      <link>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem/</link>
      <pubDate>Sat, 18 Feb 2023 16:37:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem/</guid>
      <description>Description 1233. Remove Sub-Folders from the Filesystem (Medium)&#xA;Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order. If a folder[i] is located within another folder[j], it is called a sub-folder of it. The format of a path is one or more concatenated strings of the form: &#39;/&#39; followed by one or more lowercase English letters.</description>
    </item>
    <item>
      <title>1233.删除子文件夹</title>
      <link>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem.zh/</link>
      <pubDate>Sat, 18 Feb 2023 16:37:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem.zh/</guid>
      <description>问题描述 [1233. 删除子文件夹 (Medium)]&#xA;你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：&amp;rsquo;/&amp;rsquo; 后跟一个或者多个小写英文字母。&#xA;例如， &amp;quot;/leetcode&amp;quot; 和 &amp;quot;/leetcode/problems&amp;quot; 都是有效的路径，而空字符串和 &amp;quot;/&amp;quot; 不是。 示例 1： 输入：folder = [&amp;#34;/a&amp;#34;,&amp;#34;/a/b&amp;#34;,&amp;#34;/c/d&amp;#34;,&amp;#34;/c/d/e&amp;#34;,&amp;#34;/c/f&amp;#34;] 输出：[&amp;#34;/a&amp;#34;,&amp;#34;/c/d&amp;#34;,&amp;#34;/c/f&amp;#34;] 解释：&amp;#34;/a/b&amp;#34; 是 &amp;#34;/a&amp;#34; 的子文件夹，而 &amp;#34;/c/d/e&amp;#34; 是 &amp;#34;/c/d&amp;#34; 的子文件夹。 示例 2：&#xA;输入：folder = [&amp;#34;/a&amp;#34;,&amp;#34;/a/b/c&amp;#34;,&amp;#34;/a/b/d&amp;#34;] 输出：[&amp;#34;/a&amp;#34;] 解释：文件夹 &amp;#34;/a/b/c&amp;#34; 和 &amp;#34;/a/b/d&amp;#34; 都会被删除，因为它们都是 &amp;#34;/a&amp;#34; 的子文件夹。 示例 3：&#xA;输入: folder = [&amp;#34;/a/b/c&amp;#34;,&amp;#34;/a/b/ca&amp;#34;,&amp;#34;/a/b/d&amp;#34;] 输出: [&amp;#34;/a/b/c&amp;#34;,&amp;#34;/a/b/ca&amp;#34;,&amp;#34;/a/b/d&amp;#34;] 提示：&#xA;1 &amp;lt;= folder.length &amp;lt;= 4 * 10⁴ 2 &amp;lt;= folder[i].</description>
    </item>
    <item>
      <title>646.maximum length of pair chain</title>
      <link>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain/</link>
      <pubDate>Sat, 18 Feb 2023 15:00:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain/</guid>
      <description>Description 646. Maximum Length of Pair Chain (Medium)&#xA;You are given an array of n pairs pairs where pairs[i] = [leftᵢ, rightᵢ] and leftᵢ &amp;lt; rightᵢ. A pair p2 = [c, d] follows a pair p1 = [a, b] if b &amp;lt; c. A chain of pairs can be formed in this fashion. Return the length longest chain which can be formed. You do not need to use up all the given intervals.</description>
    </item>
    <item>
      <title>646.最长数对链</title>
      <link>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain.zh/</link>
      <pubDate>Sat, 18 Feb 2023 15:00:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain.zh/</guid>
      <description>问题描述 646. 最长数对链 (Medium)&#xA;给你一个由 n 个数对组成的数对数组 pairs ，其中 pairs[i] = [leftᵢ, rightᵢ] 且 leftᵢ &amp;lt; rightᵢ 现在，我们定义一种 跟随 关系，当且仅当 b &amp;lt; c 时，数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面。我们用这种形式来构造 数对链 。 找出并返回能够形成的 最长数对链的长度 。 你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例 1：&#xA;输入：pairs = [[1,2], [2,3], [3,4]] 输出：2 解释：最长的数对链是 [1,2] -&amp;gt; [3,4] 。 示例 2：&#xA;输入：pairs = [[1,2],[7,8],[4,5]] 输出：3 解释：最长的数对链是 [1,2] -&amp;gt; [4,5] -&amp;gt; [7,8] 。 提示：&#xA;n == pairs.length 1 &amp;lt;= n &amp;lt;= 1000 -1000 &amp;lt;= leftᵢ &amp;lt; rightᵢ &amp;lt;= 1000 解题思路 贪心 在选择第一个数对时，必定选择使pairs[i][1]最小的那个i，第二个数对则必定选择pairs[j][0] &amp;gt; pairs[i][1]且使pairs[j][0]最小的j，因此类推，因此我们将pairs按照其第二个元素升序排列。</description>
    </item>
    <item>
      <title>1124.longest well performing interval</title>
      <link>http://localhost:1313/posts/leet/1124.longest-well-performing-interval/</link>
      <pubDate>Fri, 17 Feb 2023 16:13:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1124.longest-well-performing-interval/</guid>
      <description>Description 1124. Longest Well-Performing Interval (Medium)&#xA;We are given hours, a list of the number of hours worked per day for a given employee. A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8. A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</description>
    </item>
    <item>
      <title>1124.表现良好的最长时间段</title>
      <link>http://localhost:1313/posts/leet/1124.longest-well-performing-interval.zh/</link>
      <pubDate>Fri, 17 Feb 2023 16:13:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1124.longest-well-performing-interval.zh/</guid>
      <description>问题描述 1124. 表现良好的最长时间段 (Medium)&#xA;给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「 劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。 示例 1：&#xA;输入：hours = [9,9,6,0,6,6,9] 输出：3 解释：最长的表现良好时间段是 [9,9,6]。 示例 2：&#xA;输入：hours = [6,6,6] 输出：0 提示：&#xA;1 &amp;lt;= hours.length &amp;lt;= 10⁴ 0 &amp;lt;= hours[i] &amp;lt;= 16 解题思路 单调栈 首先，将原数组中大于8的值设为1，小于或等于8的值设为-1，分别表示劳累的一天和不劳累的一天，然后求这个新数组的前缀和，得到一个前缀和数组prefix；&#xA;那么我们就是要求满足prefix[j] &amp;gt; prefix[i]条件下的最大的j - i，首先，我们考虑左端点，如果prefix[i1] &amp;lt; prefix[i2]且i1 &amp;lt;= i2，那么我们完全不需要考虑使用i2作为左端点，因为选择i1作为左端点的res一定更大，所以我们可以正向遍历prefix，并将索引idx压入单调栈，满足栈底到栈顶单调递减；&#xA;然后，我们从从右往左遍历prefix找右端点，如果prefix[j1] &amp;gt; prefix[stk.top()]，那就弹出栈顶元素并更新res = std::max(res, r - stk.top())，如果选择从左往右遍历的话，prefix[j2] &amp;lt; prefix[stk.top()]的时候，最终结果可能是j2 - i，其中i是一个被弹出的元素，从左往右遍历右端点，这种情况无法考虑到。&#xA;哈希表 如果prefix[i] &amp;gt; 0，说明这i天内都是表现良好的时间段，那么res = max(i, res)； 如果prefix[i] &amp;lt;= 0，如果key prefix[i]之前未在哈希表ump中出现过，那么ump[prefix[i]] = i, 否则不更新ump[prefix[i]]，因为哈希表中key对应的value一定更小，对应的差值即时间长度会更大， 以第i天结尾表现良好的时间段的最大长度即为ump[prefix[i]] - ump[prefix[i] - 1]（要求key prefix[i] - 1在哈希表中，否则为0，即不存在这样的时间段），这是因为由于新数组中只有1和-1两种元素，那么值prefix[i] - 1一定比prefix[i] - 2先出现在前缀和数组中。 代码 单调栈 class Solution { public: int longestWPI(vector&amp;lt;int&amp;gt; &amp;amp;hours) { int n = hours.</description>
    </item>
    <item>
      <title>926.flip string to monotone increasing</title>
      <link>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing/</link>
      <pubDate>Fri, 17 Feb 2023 16:00:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing/</guid>
      <description>Description 926. Flip String to Monotone Increasing (Medium)&#xA;A binary string is monotone increasing if it consists of some number of 0&amp;rsquo;s (possibly none), followed by some number of 1&amp;rsquo;s (also possibly none). You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0. Return the minimum number of flips to make s monotone increasing. Example 1:&#xA;Input: s = &amp;#34;00110&amp;#34; Output: 1 Explanation: We flip the last digit to get 00111.</description>
    </item>
    <item>
      <title>926.将字符串翻转到单调递增</title>
      <link>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing.zh/</link>
      <pubDate>Fri, 17 Feb 2023 16:00:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing.zh/</guid>
      <description>问题描述 926. 将字符串翻转到单调递增 (Medium)&#xA;如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。 给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。 返回使 s 单调递增的最小翻转次数。 示例 1：&#xA;输入：s = &amp;#34;00110&amp;#34; 输出：1 解释：翻转最后一位得到 00111. 示例 2：&#xA;输入：s = &amp;#34;010110&amp;#34; 输出：2 解释：翻转得到 011111，或者是 000111。 示例 3：&#xA;输入：s = &amp;#34;00011000&amp;#34; 输出：2 解释：翻转得到 00000000。 提示：&#xA;1 &amp;lt;= s.length &amp;lt;= 10⁵ s[i] 为 &#39;0&#39; 或 &#39;1&#39; 解题思路 令dp[i]为将前i个字符翻转成单调递增的字符串所需要的最少翻转次数，cnt表示前i个字符中&#39;1&#39;的个数，其递推关系很容易分析:&#xA;s[i - 1] == &#39;1&#39;，dp[i] = dp[i - 1]; s[i - 1] == &#39;0&#39;，dp[i] = min(dp[i - 1] + 1, cnt); 代码 class Solution { public: int minFlipsMonoIncr(string s) { int cnt = 0, res = 0; // cnt为遍历中1的个数 vector&amp;lt;int&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>1139.largest 1 bordered square</title>
      <link>http://localhost:1313/posts/leet/1139.largest-1-bordered-square/</link>
      <pubDate>Fri, 17 Feb 2023 15:52:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1139.largest-1-bordered-square/</guid>
      <description>Description 1139. Largest 1-Bordered Square (Medium)&#xA;Given a 2D grid of 0 s and 1 s, return the number of elements in the largest square subgrid that has all 1 s on its border, or 0 if such a subgrid doesn&amp;rsquo;t exist in the grid. Example 1:&#xA;Input: grid = [[1,1,1],[1,0,1],[1,1,1]] Output: 9 Example 2:&#xA;Input: grid = [[1,1,0,0]] Output: 1 Constraints:&#xA;1 &amp;lt;= grid.length &amp;lt;= 100 1 &amp;lt;= grid[0].length &amp;lt;= 100 grid[i][j] is 0 or 1 Solution We can use prefix sum to reduce coumputaional comlexity.</description>
    </item>
    <item>
      <title>1139.最大的以1为边界的正方形</title>
      <link>http://localhost:1313/posts/leet/1139.largest-1-bordered-square.zh/</link>
      <pubDate>Fri, 17 Feb 2023 15:52:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1139.largest-1-bordered-square.zh/</guid>
      <description>问题描述 1139. 最大的以 1 为边界的正方形 (Medium)&#xA;给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。 示例 1：&#xA;输入：grid = [[1,1,1],[1,0,1],[1,1,1]] 输出：9 示例 2：&#xA;输入：grid = [[1,1,0,0]] 输出：1 提示：&#xA;1 &amp;lt;= grid.length &amp;lt;= 100 1 &amp;lt;= grid[0].length &amp;lt;= 100 grid[i][j] 为 0 或 1 解题思路 利用前缀和来简化满足正方形条件的计算，枚举正方形边长，找到最大的l，再和已经得出的结果进行比较。&#xA;代码 class Solution { public: int largest1BorderedSquare(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { // 前缀和 int m = grid.size(), n = grid[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; sum_row(m, vector&amp;lt;int&amp;gt;(n + 1, 0)); // 每行前缀和 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; sum_col(m + 1, vector&amp;lt;int&amp;gt;(n, 0)); // 每列前缀和 for (int i = 0; i &amp;lt; grid.</description>
    </item>
    <item>
      <title>456.132 pattern</title>
      <link>http://localhost:1313/posts/leet/456.132-pattern/</link>
      <pubDate>Fri, 17 Feb 2023 14:46:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/456.132-pattern/</guid>
      <description>Description 456. 132 Pattern (Medium)&#xA;Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false. Example 1:&#xA;Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Example 2:</description>
    </item>
    <item>
      <title>456.132模式</title>
      <link>http://localhost:1313/posts/leet/456.132-pattern.zh/</link>
      <pubDate>Fri, 17 Feb 2023 14:46:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/456.132-pattern.zh/</guid>
      <description>问题描述 456. 132 模式 (Medium)&#xA;给你一个整数数组 nums ，数组中共有 n 个整数。 132 模式的子序列 由三个整数 nums[i]、 nums[j] 和 nums[k] 组成，并同时满足： i &amp;lt; j &amp;lt; k 和 nums[i] &amp;lt; nums[k] &amp;lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 示例 1：&#xA;输入：nums = [1,2,3,4] 输出：false 解释：序列中不存在 132 模式的子序列。 示例 2：&#xA;输入：nums = [3,1,4,2] 输出：true 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3：&#xA;输入：nums = [-1,3,2,0] 输出：true 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示：</description>
    </item>
    <item>
      <title>334.increasing triplet subsequence</title>
      <link>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence/</link>
      <pubDate>Fri, 17 Feb 2023 14:07:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence/</guid>
      <description>Description 334. Increasing Triplet Subsequence (Medium)&#xA;Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[j] &amp;lt; nums[k]. If no such indices exists, return false. Example 1:&#xA;Input: nums = [1,2,3,4,5] Output: true Explanation: Any triplet where i &amp;lt; j &amp;lt; k is valid. Example 2:&#xA;Input: nums = [5,4,3,2,1] Output: false Explanation: No triplet exists.</description>
    </item>
    <item>
      <title>334.递增的三元子序列</title>
      <link>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence.zh/</link>
      <pubDate>Fri, 17 Feb 2023 14:07:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence.zh/</guid>
      <description>问题描述 334. 递增的三元子序列 (Medium)&#xA;给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标 (i, j, k) 且满足 i &amp;lt; j &amp;lt; k ，使得 nums[i] &amp;lt; nums[j] &amp;lt; nums[k] ，返回 true ；否则，返回 false 。 示例 1：&#xA;输入：nums = [1,2,3,4,5] 输出：true 解释：任何 i &amp;lt; j &amp;lt; k 的三元组都满足题意 示例 2：&#xA;输入：nums = [5,4,3,2,1] 输出：false 解释：不存在满足题意的三元组 示例 3：&#xA;输入：nums = [2,1,5,0,4,6] 输出：true 解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &amp;lt; nums[4] == 4 &amp;lt; nums[5] == 6 提示：</description>
    </item>
    <item>
      <title>1218.longest arithmetic subsequence of given difference</title>
      <link>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference/</link>
      <pubDate>Thu, 16 Feb 2023 20:01:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference/</guid>
      <description>Description 1218. Longest Arithmetic Subsequence of Given Difference (Medium)&#xA;Longest Arithmetic Subsequence of Given Difference (Medium) Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference. A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.</description>
    </item>
    <item>
      <title>1218.最长定差子序列</title>
      <link>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference.zh/</link>
      <pubDate>Thu, 16 Feb 2023 20:01:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference.zh/</guid>
      <description>问题描述 1218. 最长定差子序列 (Medium)&#xA;给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。 子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。 示例 1：&#xA;输入：arr = [1,2,3,4], difference = 1 输出：4 解释：最长的等差子序列是 [1,2,3,4]。 示例 2：&#xA;输入：arr = [1,3,5,7], difference = 1 输出：1 解释：最长的等差子序列是任意单个元素。 示例 3：&#xA;输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2 输出：4 解释：最长的等差子序列是 [7,5,3,1]。 提示：&#xA;1 &amp;lt;= arr.length &amp;lt;= 10⁵ -10⁴ &amp;lt;= arr[i], difference &amp;lt;= 10⁴ 解题思路 利用哈希表，记录数组中每个元素，作为子序列末尾元素时，该元素对应的最长子序列的长度，有&#xA;if (ump.find(num - difference) != ump.end()) { ump[num] = ump[num - difference] + 1; } else { ump[num] = 1; } 代码 class Solution { public: int longestSubsequence(vector&amp;lt;int&amp;gt; &amp;amp;arr, int difference) { unordered_map&amp;lt;int, int&amp;gt; ump; for (auto &amp;amp;num : arr) { if (ump.</description>
    </item>
    <item>
      <title>2341.maximum Number of Pairs in Array</title>
      <link>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array/</link>
      <pubDate>Thu, 16 Feb 2023 19:19:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array/</guid>
      <description>Description 2341. Maximum Number of Pairs in Array (Easy)&#xA;You are given a 0-indexed integer array nums. In one operation, you may do the following:&#xA;Choose two integers in nums that are equal. Remove both integers from nums, forming a pair. The operation is done on nums as many times as possible. Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.</description>
    </item>
    <item>
      <title>2341.maximum Number of Pairs in Array</title>
      <link>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array.zh/</link>
      <pubDate>Thu, 16 Feb 2023 19:18:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array.zh/</guid>
      <description>问题描述 2341. 数组能形成多少数对 (Easy)&#xA;给你一个下标从 0 开始的整数数组 nums 。在一步操作中，你可以执行以下步骤：&#xA;从 nums 选出 两个 相等的 整数 从 nums 中移除这两个整数，形成一个 数对 请你在 nums 上多次执行此操作直到无法继续执行。 返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目， answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。 示例 1： 输入：nums = [1,3,2,1,3,2,2] 输出：[3,1] 解释： nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。 nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。 nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。 无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。 示例 2：</description>
    </item>
    <item>
      <title>2335.minimum amount of time to fill cups</title>
      <link>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups/</link>
      <pubDate>Wed, 15 Feb 2023 16:51:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups/</guid>
      <description>Description [2335. Minimum Amount of Time to Fill Cups (Easy)]&#xA;You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water. You are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively.</description>
    </item>
    <item>
      <title>2335.装满杯子所需要的最短时长</title>
      <link>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups.zh/</link>
      <pubDate>Wed, 15 Feb 2023 16:51:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups.zh/</guid>
      <description>问题描述 2335. 装满杯子需要的最短总时长 (Easy)&#xA;现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。 给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、 amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。 示例 1：&#xA;输入：amount = [1,4,2] 输出：4 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯温水。 第 2 秒：装满一杯温水和一杯热水。 第 3 秒：装满一杯温水和一杯热水。 第 4 秒：装满一杯温水。 可以证明最少需要 4 秒才能装满所有杯子。 示例 2：&#xA;输入：amount = [5,4,4] 输出：7 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯热水。 第 2 秒：装满一杯冷水和一杯温水。 第 3 秒：装满一杯冷水和一杯温水。 第 4 秒：装满一杯温水和一杯热水。 第 5 秒：装满一杯冷水和一杯热水。 第 6 秒：装满一杯冷水和一杯温水。 第 7 秒：装满一杯热水。 示例 3：</description>
    </item>
    <item>
      <title>1705.maximum number of eaten apples</title>
      <link>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples/</link>
      <pubDate>Wed, 15 Feb 2023 15:59:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples/</guid>
      <description>Description 1705.maximum-number-of-eaten-apples&#xA;Solution The optimal strategy is to eat the apple that rots first, we can use the priority queue to simulate the process.&#xA;app_decay[i][0] indicates the expected decay time of the apples born on day i, and app_decay[i][1] indicates how many apples were born on day i.&#xA;The top() of the priority queue pq must be a vector with the minimum vec[0].&#xA;We traverse the array by time, if there are apples born on this day, we push app_decay[i] to pq, and pop the elements of the top() of pq until the heap is empty or pq.</description>
    </item>
    <item>
      <title>1705.吃苹果的最大数目</title>
      <link>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples.zh/</link>
      <pubDate>Wed, 15 Feb 2023 15:59:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples.zh/</guid>
      <description>问题描述 1705.吃苹果的最大数目 中等&#xA;There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0.</description>
    </item>
    <item>
      <title>871.minimum number of refueling stops</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</guid>
      <description>Description 871.minimum-number-of-refueling-stops&#xA;Solution Dynamic programming In this problem, the number is finite, and there is a recurrence relation, so we can use dynamic programming to solve this problem.&#xA;Let dp[i][j] means the furthest distance we can reach after passing throught i stations and adding fuel for j times. Obviously, i &amp;gt;= j.&#xA;So we can discuss dp[i][j] in two cases:&#xA;We don&amp;rsquo;t add fuel at the ith station: dp[i][j] = dp[i - 1][j] We add fuel in the ith station(We have to arrive at the ith station in the case we have just added fuel for j - 1 times before, that is: dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]): dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1].</description>
    </item>
    <item>
      <title>871.最低加油次数</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</guid>
      <description>问题描述 871.最低加油次数&#xA;解题思路 动态规划 对于这种有限次数，能看出来有递推关系的，可以考虑动态规划。&#xA;这里状态记为dp[i][j]，表示经过前i个加油站，加j次油之后，能够到达的最远距离，这里显然有i &amp;gt;= j。&#xA;那么考虑dp[i][j]的递推关系，可以分在第i个加油站加油和不加油两种情况来讨论：&#xA;在第i个加油站不加油：dp[i][j] = dp[i - 1][j] 在第i个加油站加油（要求第i个加油站可以在之前只加了j - 1次油的情况下到达），即dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]，此时dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1] dp[i][j]取两者中的最大值&#xA;贪心 首先，很容易想到，最佳策略每次加油，都是在油最多的加油站去加油，这里实际上可以认为能直接从经过的加油站中取油，即每次发现到达不了下一个加油站或者终点了，就从已经经过但是没加过油的加油站里加油，直到可以到达下一个加油站或者终点，可以利用优先队列来模拟这个过程，每次需要更新剩余的燃油cur_fuel。&#xA;代码 动态规划 class Solution { public: int minRefuelStops(int target, int startFuel, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;stations) { int n = stations.size(); if (n == 0) { if (startFuel &amp;gt;= target) return 0; return -1; } vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; dp(n + 1, vector&amp;lt;long long&amp;gt;(n + 1, 0)); dp[0][0] = startFuel; for (int i = 1; i &amp;lt;= n; i++) { dp[i][0] = stations[i - 1][0] &amp;lt;= startFuel ?</description>
    </item>
    <item>
      <title>1250.check if it is a good array</title>
      <link>http://localhost:1313/posts/leet/1250.check-if-it-is-a-good-array/</link>
      <pubDate>Wed, 15 Feb 2023 14:46:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1250.check-if-it-is-a-good-array/</guid>
      <description>Description 1250.check-if-it-is-a-good-array&#xA;Solution Actually, what we need to determine is whether the maximum common divisor of all elements in the array is 1.&#xA;We can use rolling division to get the maximum common divisor gcd of nums[0] and nums[1], then get the new maximum common divisor gcd of gcd and nums[2]&amp;hellip;&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int gcd(int a, int b) { // b^=a,a^=b,b^=a the same as swap(a, b) while (b ^= (a ^= (b ^= (a %= b)))) ; return a; } bool isGoodArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.</description>
    </item>
    <item>
      <title>1250.检查“好数组”</title>
      <link>http://localhost:1313/posts/leet/1250.check-if-it-is-a-good-array.zh/</link>
      <pubDate>Wed, 15 Feb 2023 14:46:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1250.check-if-it-is-a-good-array.zh/</guid>
      <description>问题描述 1250.检查“好数组”&#xA;解题思路 首先，要注意到，本题的要求，其实可以转化为数组中所有元素的最大公因数为1；&#xA;利用辗转相除法，将nums[0]和nums[1]求得的最大公因数num再与nums[2]求最大公因数作为新的num，如果到最后num == 1，返回true，否则返回false。&#xA;代码 class Solution { public: bool isGoodArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { std::sort(nums.begin(), nums.end()); // 利用哈希表储存不为1的因子，然后遍历，如果最后哈希表为空，return true if (nums[0] == 1) return true; std::unordered_set&amp;lt;int&amp;gt; factor; int root = sqrt(nums[0]); for (int i = 2; i &amp;lt;= root; i++) { if (nums[0] % i == 0) { if (factor.empty()) { factor.insert(i); factor.insert(nums[0] / i); } else { int flag = 0; // 为0说明factor里面没有它的因子 for (auto &amp;amp;num : factor) { if (i % num == 0) { flag = 1; break; } } if (flag == 0) { factor.</description>
    </item>
    <item>
      <title>1234.replace the substring for balanced string</title>
      <link>http://localhost:1313/posts/leet/1234.replace-the-substring-for-balanced-string/</link>
      <pubDate>Mon, 13 Feb 2023 16:21:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1234.replace-the-substring-for-balanced-string/</guid>
      <description>Description 1234.replace-the-substring-for-balanced-string&#xA;Solution We use two pointers left and right. Let&amp;rsquo;s traverse the string throughright from right = 0. If the amount of each character in the string other than [left, right] is less than or equal to n / 4, it means that we can form a balanced string by replacing [left, right], then increment left until [left, right] can&amp;rsquo;t form a balanced string.&#xA;Code class Solution { public: bool check(unordered_map&amp;lt;char, int&amp;gt; &amp;amp;mp, int m) { if (mp[&amp;#39;Q&amp;#39;] &amp;gt; m || mp[&amp;#39;W&amp;#39;] &amp;gt; m || mp[&amp;#39;E&amp;#39;] &amp;gt; m || mp[&amp;#39;R&amp;#39;] &amp;gt; m) return true; else return false; } int balancedString(string s) { int n = s.</description>
    </item>
    <item>
      <title>1234.替换子串得到平衡字符串</title>
      <link>http://localhost:1313/posts/leet/1234.replace-the-substring-for-balanced-string.zh/</link>
      <pubDate>Mon, 13 Feb 2023 16:21:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1234.replace-the-substring-for-balanced-string.zh/</guid>
      <description>问题描述 1234.替换子串得到平衡字符串&#xA;解题思路 利用两个指针left，right，right从0开始遍历，如果[left, right]之外的字符串中，每个字符出现次数都小于或等于n / 4，说明替换[left, right]可以构成平衡字符串，此时递增left，直到移除[left, right]不能构成平衡字符串。&#xA;代码 class Solution { public: bool check(unordered_map&amp;lt;char, int&amp;gt; &amp;amp;mp, int m) { if (mp[&amp;#39;Q&amp;#39;] &amp;gt; m || mp[&amp;#39;W&amp;#39;] &amp;gt; m || mp[&amp;#39;E&amp;#39;] &amp;gt; m || mp[&amp;#39;R&amp;#39;] &amp;gt; m) return true; else return false; } int balancedString(string s) { int n = s.size(), partial = n / 4; int res = n; unordered_map&amp;lt;char, int&amp;gt; chars; for (auto &amp;amp;c : s) chars[c]++; int flag = 1; for (auto &amp;amp;pa : chars) { // 检查字符串本身是否平衡 if (pa.</description>
    </item>
    <item>
      <title>517.super Washing Machines</title>
      <link>http://localhost:1313/posts/leet/517.super-washing-machines/</link>
      <pubDate>Mon, 13 Feb 2023 16:15:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/517.super-washing-machines/</guid>
      <description></description>
    </item>
    <item>
      <title>517.超级洗衣机</title>
      <link>http://localhost:1313/posts/leet/517.super-washing-machines.zh/</link>
      <pubDate>Mon, 13 Feb 2023 16:15:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/517.super-washing-machines.zh/</guid>
      <description>问题描述 517.超级洗衣机&#xA;解题思路 参照直观清晰：理解官方题解——超级洗衣机和贪心,再动一点点脑子。&#xA;这个题我也还没搞懂，先搁置&#xA;代码 class Solution { public: int findMinMoves(vector&amp;lt;int&amp;gt; &amp;amp;machines) { int tot = accumulate(machines.begin(), machines.end(), 0); int n = machines.size(); if (tot % n) { return -1; } int avg = tot / n; int ans = 0, sum = 0; for (int num: machines) { num -= avg; sum += num; ans = max(ans, max(abs(sum), num)); } return ans; } }; </description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo/</guid>
      <description>Description 502.IPO&#xA;Solution Greedy algorithm: if we want to maximize the final capital, we choose the project whose profit is maximum and whose minimum captial required is less than or equal to our current capital.&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;Let key be the profits, value be a map, of which key is the minimum capital required while value is the amount of the corresponding project.&#xA;Code class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.</description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo.zh/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo.zh/</guid>
      <description>问题描述 502.IPO&#xA;解题思路 贪心：要最大化最终资本，因此必然选择满足当前资本需要的纯利润最大的项目。&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;key为纯利润，value也是map，该map的key为启动所需最小资本、value为项目数量。&#xA;代码 class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.size(); i++) { projs[profits[i]][capital[i]]++; } for (int i = 0; i &amp;lt; k; i++) { int find_flag = 0; for (auto &amp;amp;prj : projs) { if (w &amp;gt;= ((prj.second).begin())-&amp;gt;first) { w += prj.first; prj.</description>
    </item>
    <item>
      <title>1138.alphabet board path</title>
      <link>http://localhost:1313/posts/leet/1138.alphabet-board-path/</link>
      <pubDate>Sun, 12 Feb 2023 19:14:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1138.alphabet-board-path/</guid>
      <description>Description 1138.alphabet-board-path&#xA;Solution Hash table.&#xA;Notice that we shouldn&amp;rsquo;t go left then go down or go right then go up.&#xA;Code class Solution { public: string alphabetBoardPath(string target) { string res; vector&amp;lt;int&amp;gt; cur_loc{0, 0}; vector&amp;lt;int&amp;gt; target_loc{0, 0}; // 要注意边缘的存在 for (auto &amp;amp;c : target) { target_loc[0] = (c - &amp;#39;a&amp;#39;) / 5; target_loc[1] = (c - &amp;#39;a&amp;#39;) % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col &amp;lt; 0) { res.</description>
    </item>
    <item>
      <title>1138.字母板上的路径</title>
      <link>http://localhost:1313/posts/leet/1138.alphabet-board-path.zh/</link>
      <pubDate>Sun, 12 Feb 2023 19:14:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1138.alphabet-board-path.zh/</guid>
      <description>问题描述 1138.字母板上的路径&#xA;解题思路 考虑到&amp;rsquo;z&amp;rsquo;单独在一个地方，因此移动顺序中，左下、右上不能反过来，即不能先往下再往左或者先往右再往上。&#xA;代码 class Solution { public: string alphabetBoardPath(string target) { string res; vector&amp;lt;int&amp;gt; cur_loc{0, 0}; vector&amp;lt;int&amp;gt; target_loc{0, 0}; // 要注意边缘的存在 for (auto &amp;amp;c : target) { target_loc[0] = (c - &amp;#39;a&amp;#39;) / 5; target_loc[1] = (c - &amp;#39;a&amp;#39;) % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col &amp;lt; 0) { res.insert(res.end(), -move_col, &amp;#39;L&amp;#39;); if (move_row &amp;gt;= 0) res.</description>
    </item>
    <item>
      <title>1604.alert using same key card three or more times in a one hour period</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</guid>
      <description>Description 1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period&#xA;Solution Analog, hash table + sort.&#xA;Code class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>1604.警告一小时内使用相同员工卡大于等于三次的人</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</guid>
      <description>问题描述 1604.警告一小时内使用相同员工卡大于等于三次的人&#xA;解题思路 模拟，哈希表+排序&#xA;代码 class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>575.分糖果</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies.zh/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies.zh/</guid>
      <description>问题描述 575.分糖果&#xA;解题思路 最优思路为一种糖果只吃一颗。&#xA;代码 class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>575.distribute candies</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies/</guid>
      <description>Description 575.distribute-candies&#xA;Solution The optimal way is to eat only one candy for each kind of candy.&#xA;Code class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>2331.evaluate boolean binary tree</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</guid>
      <description>Description 2331.evaluate-boolean-binary-tree&#xA;Solution dfs(recursion)&#xA;Code class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
    <item>
      <title>2331.计算布尔二叉树的值</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</guid>
      <description>问题描述 2331.计算布尔二叉树的值&#xA;解题思路 递归&#xA;代码 class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
    <item>
      <title>553.optimal division</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division/</guid>
      <description>Description 553.optimal division&#xA;Solution Greedy algorithm&#xA;The optimal method is actually to bracket the penultimate elements.&#xA;Code class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.</description>
    </item>
    <item>
      <title>553.最优除法</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division.zh/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division.zh/</guid>
      <description>问题描述 553.最优除法&#xA;解题思路 贪心，最优的除法实际上就是把第二个到最后一个元素括起来。&#xA;代码 class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.pop_back(); res.push_back(&amp;#39;)&amp;#39;); return res; } }; </description>
    </item>
    <item>
      <title>1710.maximum units on a truck</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</guid>
      <description>Description 1710.maximum-units-on-a-truck&#xA;Solution Sort boxTypes by the units that the box can load, then put the box of which the units are maximum on the truck one by one.&#xA;The time complexity can be decreased to $O(n)$ by using quick select.&#xA;Code class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.</description>
    </item>
    <item>
      <title>1710.卡车上的最大单元数</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</guid>
      <description>问题描述 1710.卡车上的最大单元数&#xA;解题思路 根据每个箱子可以装载的单元数量从大到小对boxTypes排序，然后每次将单元数量最大的箱子填入卡车。&#xA;使用快速选择算法可以将时间复杂度降低到$O(n)$。&#xA;代码 class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.size(); i++) { if (cnt + boxTypes[i][0] &amp;lt;= truckSize) { sum += boxTypes[i][0] * boxTypes[i][1]; cnt += boxTypes[i][0]; } else { sum += (truckSize - cnt) * boxTypes[i][1]; break; } } return sum; } }; </description>
    </item>
    <item>
      <title>1736.latest time by replacing hidden digits</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</guid>
      <description>Description 1736.latest-time-by-replacing-hidden-digits&#xA;Solution Analog + greedy algorithm&#xA;Code class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.</description>
    </item>
    <item>
      <title>1736.替换隐藏数字得到的最晚时间</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</guid>
      <description>问题描述 1736.替换隐藏数字得到的最晚时间&#xA;解题思路 模拟+贪心&#xA;代码 class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.push_back(time[0]); res.</description>
    </item>
    <item>
      <title>1210.minimum moves to reach target with rotations</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</guid>
      <description>Description 1210.minimum-moves-to-reach-target-with-rotations&#xA;Solution BFS.&#xA;We can use (x, y state) to denote the position of the snake, x as the abscissa of the tail of the snake, y as the ordinate of the tail of the snake. state indicates whether the snake is vertical or horizontal.&#xA;Code class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.</description>
    </item>
    <item>
      <title>1210.穿过迷宫的最少移动次数</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</guid>
      <description>问题描述 1210.穿过迷宫的最少移动次数&#xA;解题思路 广度优先搜索&#xA;可以用(x, y, state)来表示贪吃蛇当前所处的位置，x为蛇尾的横坐标，y为蛇尾的纵坐标，state表示蛇当前处于水平还是竖直状态。&#xA;代码 class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0) return true; else return false; } } else if (i == 1) { vec_tmp[0] += 1; vec_tmp[2] += 1; if (vec_tmp[2] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0 &amp;amp;&amp;amp; vec_tmp[2] &amp;lt; grid.</description>
    </item>
    <item>
      <title>1798.maximum number of consecutive values you can make</title>
      <link>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make/</link>
      <pubDate>Sat, 04 Feb 2023 18:26:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make/</guid>
      <description>Description 1798.maximum-number-of-consecutive-values-you-can-make&#xA;Solution Greedy algorithm + dynamic programming&#xA;First, we sort the array in ascending orders. Let res[n] be the maximum value of consecutive integer that we can make by using the first n numbers.&#xA;if (coins[i - 1] &amp;gt; res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; Code class Solution { public: int getMaximumConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; coins) { std::sort(coins.begin(), coins.</description>
    </item>
    <item>
      <title>1798.你能构造出连续值的最大数目</title>
      <link>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make.zh/</link>
      <pubDate>Sat, 04 Feb 2023 18:26:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make.zh/</guid>
      <description>问题描述 1798.你能构造出连续值的最大数目&#xA;解题思路 贪心+动态规划&#xA;首先将数组按升序排序，令res[n]为前n个数所能构造出的连续整数的最大值:&#xA;if (coins[i - 1] &amp;gt; res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; 代码 class Solution { public: int getMaximumConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; coins) { std::sort(coins.begin(), coins.end()); vector&amp;lt;int&amp;gt; res(coins.size() + 1, 0); // 表示前n个数能表示出来的最大值 for (int i = 1; i &amp;lt;= coins.size(); i++) { if (coins[i - 1] &amp;gt; res[i - 1] + 1) res[i] = res[i - 1]; else res[i] = res[i - 1] + coins[i - 1]; } return res[coins.</description>
    </item>
    <item>
      <title>768.max chunks to make sorted ii</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</guid>
      <description>Description 768.max-chunks-to-make-sorted-ii&#xA;Solution A sufficient condition for an array to be divisible into blocks that satisfy the condition is that all elements in the block are less than or equal to any of the undivided elements in the right-hand array.&#xA;Code class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.</description>
    </item>
    <item>
      <title>768.最多能完成排序的块 II</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</guid>
      <description>问题描述 768.最多能完成排序的块II&#xA;解题思路 可以划分成满足条件的块的充分必要条件是，块内所有元素都小于等于右侧数组中未划分的任一元素。&#xA;本题中使用了map来进行处理，实际上使用单调栈就可以了。&#xA;代码 class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.size(); i++) r_map[arr[i]]++; while (idx &amp;lt; arr.size()) { for (int i = idx; i &amp;lt; arr.size(); i++) { l_map[arr[i]]++; r_map[arr[i]]--; if (r_map[arr[i]] == 0) r_map.erase(arr[i]); if (r_map.empty()) break; if (l_map.begin()-&amp;gt;first &amp;lt;= r_map.begin()-&amp;gt;first) { idx = i + 1; ans++; break; } } if (r_map.</description>
    </item>
    <item>
      <title>1145.binary tree coloring game</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</guid>
      <description>Description 1145.binary-tree-coloring-game&#xA;Solution Greedy algorithm: for second player, if he wants to win, there are three ways to color the node.&#xA;color the parent node of x, then we use dfs to get the number of red nodes, the number of blue nodes is $n$ minus the nubmer of red nodes; color the left child node of x, then we use dfs to get the number of blue nodes, the number of red nodes is $n$ minus the number of blue nodes; color the right child node of x Code class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root !</description>
    </item>
    <item>
      <title>1145.二叉树着色游戏</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</guid>
      <description>问题描述 1145.二叉树着色游戏&#xA;解题思路 贪心策略：对二号玩家来说，想要取胜，选择染色节点只有三种可能：&#xA;选择x的父节点，则通过深度优先搜索可以求得红色节点数，蓝色节点数为$n$减去红色节点数 选择x的左子节点，则通过dfs可以求得蓝色节点数，红色节点数为$n$减去蓝色节点数 选择x的右子节点 代码 class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root != nullptr) return get_num(root-&amp;gt;left) + get_num(root-&amp;gt;right) + 1; else return 0; } TreeNode *get_pos(int x, int n, TreeNode *root) { // 获取当前x对应的指针 if (root == nullptr) return nullptr; else { if (root-&amp;gt;val == x) return root; else { TreeNode *l = get_pos(x, n, root-&amp;gt;left); TreeNode *r = get_pos(x, n, root-&amp;gt;right); if (l !</description>
    </item>
    <item>
      <title>1877.minimize maximum pair sum in array</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</guid>
      <description>Description 1877.minimize-maximum-pair-sum-in-array&#xA;Solution Sort the array from smallest to largest, the smallest and largest pair, the next smallest and next largest pair, in that order. The result we need the maximum value of the sum of those pairs.&#xA;Code class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1877.数组中最大数对和的最小值</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</guid>
      <description>问题描述 1877.数组中最大数对和的最小值&#xA;解题思路 贪心&#xA;将数组从小到大排序，最小最大配对，次小次大配对，依次配对，结果就是这些配对和的最大值。&#xA;代码 class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1129.shortest path with alternating colors</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</guid>
      <description>Description 1129.shortest-path-with-alternating-colors&#xA;Solution First, we need represent the graph as an edge matrix, and we use bfs to find the shortest path.&#xA;In this problem, since the edge color of the shortest path must change along the path, when we judge whether the current node is visited, we should distinguish the cases that the current node is visited by red edges and the cases that the current node is visited by blue edges.</description>
    </item>
    <item>
      <title>1129.颜色交替的最短路径</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</guid>
      <description>问题描述 1129.颜色交替的最短路径&#xA;解题思路 首先，将本题的图结构以边表的形式表现出来，然后采取广度优先搜索的方式寻找最短路径，一般来说广度优先搜索能够保证找到的是最短路径。&#xA;在本题中，由于要求最短路径是交替出现的，那么在判断节点是否已经访问过时，要分红色路径访问节点和蓝色路径访问节点两种情况讨论。&#xA;队列中的元素为三元组tie(point, len, c_flag)，分别表示当前节点的索引、到达当前节点的路径长度（不一定是最短的，本题中存在环）、到达当前节点的路径颜色（0表示蓝色，1表示红色）&#xA;提示bfs(q, red_connect, blue_connect, answer, n)（其中q包含tie(0, 0, 0)和tie(0, 0, 1)）与bfs(q, red_connect, blue_connect, answer, n)执行两次（q分别为tie(0, 0, 0)和tie(0, 0, 1)）的结果是一样的。&#xA;代码 class Solution { public: void bfs(queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;red_connect, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;blue_connect, vector&amp;lt;int&amp;gt; &amp;amp;answer, int n, int i) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; visited(n, vector&amp;lt;int&amp;gt;(2, 0)); // visited[k][1]表示由红到point，visited[k][0]为1表示由蓝到point int tmp_point = 0; while (!q.empty()) { auto [point, len, c_flag] = q.front(); visited[point][c_flag] = 1; q.pop(); if (answer[point] == -1) answer[point] = len; else answer[point] = min(answer[point], len); if (c_flag == 0) { for (int k = 0; k &amp;lt; red_connect[point].</description>
    </item>
    <item>
      <title>2325.decode the message</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message/</guid>
      <description>Description 2325.decode-the-message&#xA;Solution We use arrya as a hash table, to keep track of the order in which the letter appear.&#xA;Code class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // -1 means the letter never appears, other value means the order in which the letter appears for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c !</description>
    </item>
    <item>
      <title>2325.解密消息</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</guid>
      <description>问题描述 2325.解密消息&#xA;解题思路 利用数组作为哈希表，记录每个字母是第几个出现的&#xA;代码 class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // 为-1表示这个字母从未出现过，0，1，2等表示这个字母对应的解密字母 for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c != &amp;#39; &amp;#39;) res.push_back(&amp;#39;a&amp;#39; + arr[c - &amp;#39;a&amp;#39;]); else res.</description>
    </item>
    <item>
      <title>1846.maximum element after decreasing and rearranging</title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</guid>
      <description>Description 1846.maximum-element-after-decreasing-and-rearranging&#xA;Solution Since we can reorder the element in the array as many times as we like, so we should sort the array first. If we want to find the possible maximum number of array whose the first element must be 1 and the absolute difference of any 2 adjacent differences must be less or equal to 1， so we can get arr[i] = min(i + 1, arr[i - 1] + 1).</description>
    </item>
    <item>
      <title>1846.减小和重新排列数组后的最大元素</title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</guid>
      <description>问题描述 1846.减小和重新排列数组后的最大元素&#xA;解题思路 由于题目允许我们重新排列数组中的元素任意次，因此首先将数组排序，根据arr中第一个元素必须为1，以及相邻两元素的差的绝对值小于等于1，可得arr[i] = min(i + 1, arr[i - 1] + 1)（因为我们要找arr可能的最大值），又因为不允许增大arr中的元素，所以arr[i] = min(arr[i], i + 1, arr[i - 1] + 1)。&#xA;代码 class Solution { public: int maximumElementAfterDecrementingAndRearranging(vector&amp;lt;int&amp;gt;&amp;amp; arr) { sort(arr.begin(), arr.end()); arr[0] = 1; for (int i = 1; i &amp;lt; arr.size(); i++) { arr[i] = min(arr[i - 1] + 1, min(arr[i], i + 1)); } return arr[arr.size() - 1]; } }; </description>
    </item>
    <item>
      <title>2319.check if matrix is X matrix</title>
      <link>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix/</link>
      <pubDate>Tue, 31 Jan 2023 09:50:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix/</guid>
      <description>Description 2319.check-if-matrix-is-X-matrix&#xA;Solution Analog&#xA;Code class Solution { public: bool checkXMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { bool res = true; for (int i = 0; i &amp;lt; grid.size(); i++) { for (int j = 0; j &amp;lt; grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>2319.判断矩阵是否是一个X矩阵</title>
      <link>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix.zh/</link>
      <pubDate>Tue, 31 Jan 2023 09:50:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix.zh/</guid>
      <description>问题描述 2319.判断矩阵是否是一个X矩阵&#xA;解题思路 模拟&#xA;代码 class Solution { public: bool checkXMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { bool res = true; for (int i = 0; i &amp;lt; grid.size(); i++) { for (int j = 0; j &amp;lt; grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>1669.merge in between linked list</title>
      <link>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list/</link>
      <pubDate>Mon, 30 Jan 2023 12:22:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list/</guid>
      <description>Description 1669.merge-in-between-linked-list&#xA;Solution Analog&#xA;Code class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i &amp;lt; a - 1; i++) { head = head-&amp;gt;next; } for (int i = 0; i &amp;lt; b; i++) { head2 = head2-&amp;gt;next; } while (tail2-&amp;gt;next != nullptr) tail2 = tail2-&amp;gt;next; tail2-&amp;gt;next = head2-&amp;gt;next; head2-&amp;gt;next = nullptr; head-&amp;gt;next = list2; return list1; } }; </description>
    </item>
    <item>
      <title>1669.合并两个链表</title>
      <link>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list.zh/</link>
      <pubDate>Mon, 30 Jan 2023 12:22:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list.zh/</guid>
      <description>问题描述 1669.合并两个链表&#xA;解题思路 模拟&#xA;代码 class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i &amp;lt; a - 1; i++) { head = head-&amp;gt;next; } for (int i = 0; i &amp;lt; b; i++) { head2 = head2-&amp;gt;next; } while (tail2-&amp;gt;next != nullptr) tail2 = tail2-&amp;gt;next; tail2-&amp;gt;next = head2-&amp;gt;next; head2-&amp;gt;next = nullptr; head-&amp;gt;next = list2; return list1; } }; </description>
    </item>
    <item>
      <title>1817.finding the users active minutes</title>
      <link>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes/</link>
      <pubDate>Fri, 20 Jan 2023 13:01:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes/</guid>
      <description>Description 1817.finding-the-users-active-minutes&#xA;Solution We can use unordered_map&amp;lt;int, unordered_set&amp;lt;int&amp;gt;&amp;gt; mp to record the id and time_i that they operate.&#xA;We can use unordered_map&amp;lt;int, int&amp;gt; mins to record the minutes and their number of users.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; findingUsersActiveMinutes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; logs, int k) { unordered_map&amp;lt;int, unordered_set&amp;lt;int&amp;gt;&amp;gt; mp; for (auto &amp;amp;vec : logs) { mp[vec[0]].insert(vec[1]); } unordered_map&amp;lt;int, int&amp;gt; mins; int num = mp.size(); vector&amp;lt;int&amp;gt; ans(k, 0); for (auto iter = mp.begin(); iter !</description>
    </item>
    <item>
      <title>1817.查找用户活跃分钟数</title>
      <link>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes.zh/</link>
      <pubDate>Fri, 20 Jan 2023 12:32:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes.zh/</guid>
      <description>问题描述 1817. 查找用户活跃分钟数 (Medium)&#xA;给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDᵢ, timeᵢ] 表示 ID 为 IDᵢ 的用户在 timeᵢ 分钟时执行了某个操作。&#xA;多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。&#xA;指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。&#xA;请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（ 1 &amp;lt;= j &amp;lt;= k）， answer[j] 表示 用户活跃分钟数 等于 j 的用户数。&#xA;返回上面描述的答案数组 answer。&#xA;示例 1：&#xA;输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5 输出：[0,2,0,0,0] 解释： ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次） ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2 2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0 示例 2：</description>
    </item>
    <item>
      <title>1814.count nice pairs in an array</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</link>
      <pubDate>Tue, 17 Jan 2023 17:19:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</guid>
      <description>Description 1814.count-nice-pairs-in-an-array&#xA;Solution We can change the requirements to nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]).&#xA;Then we use hash tables to record the times of occurrence of the value.&#xA;Code class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>1814.统计一个数组中好对子的数目</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</link>
      <pubDate>Tue, 17 Jan 2023 17:12:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</guid>
      <description>问题描述 1814.统计一个数组中好对子的数目&#xA;解题思路 首先，变换一下题目的需求，nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])，然后利用哈希表记录每个值出现了多少次就可以了。&#xA;代码 class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>2042.check if numbers are ascending in a sentence</title>
      <link>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence/</link>
      <pubDate>Tue, 03 Jan 2023 16:34:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence/</guid>
      <description>Description 2042.check-if-numbers-are-ascending-in-a-sentence&#xA;Solution analog1 I change string s to &amp;quot; &amp;quot; + s + &amp;quot; &amp;quot;, then traverse the new string, check whether substr between two blanks is numbers;&#xA;analog2 We just check whether current char is a number, if that, num = num * 10 + s[i] - &#39;0&#39;, loop until current char is not a number.&#xA;Code code1 class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string &amp;amp;s) { int ans = 0; for (int i = l + 1; i &amp;lt; r; i++) { if (s[i] - &amp;#39;0&amp;#39; &amp;lt;= 9 &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt;= 0) { ans += mpow(s[i] - &amp;#39;0&amp;#39;, r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector&amp;lt;int&amp;gt; numbers; s = &amp;#34; &amp;#34; + s + &amp;#34; &amp;#34;; for (int i = 0; i &amp;lt; s.</description>
    </item>
    <item>
      <title>2042.检查句子中的数字是否递增</title>
      <link>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence.zh/</link>
      <pubDate>Tue, 03 Jan 2023 16:34:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence.zh/</guid>
      <description>问题描述 2042.检查句子中的数字是否递增&#xA;解题思路 模拟一 首先将字符串的首尾都加上空格，然后遍历即可，检查两次空格之间的字符串是否是数字，如果是就转化为数字;&#xA;模拟二 直接判断字符是否是数字，如果是数字，num = num * 10 + s[i] - &#39;0&#39;，循环直到碰到空格&#xA;代码 代码一 class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string &amp;amp;s) { int ans = 0; for (int i = l + 1; i &amp;lt; r; i++) { if (s[i] - &amp;#39;0&amp;#39; &amp;lt;= 9 &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt;= 0) { ans += mpow(s[i] - &amp;#39;0&amp;#39;, r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector&amp;lt;int&amp;gt; numbers; s = &amp;#34; &amp;#34; + s + &amp;#34; &amp;#34;; for (int i = 0; i &amp;lt; s.</description>
    </item>
    <item>
      <title>847.shortest path visiting all nodes</title>
      <link>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes/</link>
      <pubDate>Mon, 02 Jan 2023 20:38:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes/</guid>
      <description>Description 847.shortest-path-visiting-all-nodes&#xA;Solution solution 1: bitmask + bfs For example, $(0101)_2$ means the nodes numbered 0 and 2 have been accessed, while nodes nubmered 1 and 3 have not been accessed.&#xA;bfs;&#xA;Array seen[x][mask_x] means whether node x and path mask_x have been accessed.&#xA;Code class Solution { public: int shortestPathLength(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) { int n = graph.size(); queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; seen(n, vector&amp;lt;int&amp;gt;(1 &amp;lt;&amp;lt; n)); for (int i = 0; i &amp;lt; n; i++) { q.</description>
    </item>
    <item>
      <title>847.访问所有节点的最短路径</title>
      <link>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes.zh/</link>
      <pubDate>Mon, 02 Jan 2023 20:38:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes.zh/</guid>
      <description>问题描述 847.访问所有节点的最短路径&#xA;解题思路 方法一:状态压缩+bfs 状态压缩 由于本题中，n只有12，且状态只有访问和未访问两种，因此可以使用二进制表示法，利用int的低12位来代指点是否被访问过;&#xA;例如$(000&amp;hellip;0101)_2$表示编号为0和编号为2的节点已经被访问过，而编号为1和3的节点还没有被访问过;&#xA;假设mask存放了当前一系列点的访问状态，假如要检查编号为x的点是否被访问过，可以使用位运算a = (mask &amp;gt;&amp;gt; x) &amp;amp; 1来检查，如果a为1，那么访问过，为0表示未访问;&#xA;假设如果表示在x未被访问的情况下，要去访问x，那么mask_v = mask | (1 &amp;lt;&amp;lt; x)，其中mask_v表示更新后的状态二进制数。&#xA;代码 class Solution { public: int shortestPathLength(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) { int n = graph.size(); queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; seen(n, vector&amp;lt;int&amp;gt;(1 &amp;lt;&amp;lt; n)); for (int i = 0; i &amp;lt; n; i++) { q.emplace(i, 1 &amp;lt;&amp;lt; i, 0); // 索引、二进制掩码、距离 seen[i][1 &amp;lt;&amp;lt; i] = 1; } int ans = 0; while (!</description>
    </item>
    <item>
      <title>1751.maximum Number of Events That Can Be Attended Ii</title>
      <link>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii/</link>
      <pubDate>Thu, 15 Dec 2022 18:10:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii/</guid>
      <description></description>
    </item>
    <item>
      <title>1751.最多可以参加的会议数目II</title>
      <link>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:09:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</guid>
      <description>问题描述 1751.最多可以参加的会议数目II&#xA;解题思路 动态规划+二分法 令dp[i][j]表示在前i个会议，最多参加j个会议，收获的最大价值:&#xA;考虑选择不参加events[i - 1]，dp[i][j] = dp[i - 1][j]; 选择参加events[i - 1]，dp[i][j] = dp[idx][j - 1] + events[i - 1][2]; 其中idx表示结束日期小于events[i - 1][0]且最接近events[i - 1][0]的会议的索引号，因此这里需要按照结束日期从小到大对events排序; 寻找idx可以使用二分查找; 二分查找要注意其中的不变量，即l左侧的值都小于target，r右侧的值都大于或等于target(这里是否等于取决于具体实现&amp;gt;=或者&amp;gt;)&#xA;代码 class Solution { public: int maxValue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;events, int k) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(events.size() + 1, vector&amp;lt;int&amp;gt;(k + 1, 0)); // 按照会议结束顺序排序 std::sort(events.begin(), events.end(), [](auto &amp;amp;a, auto &amp;amp;b) { return a[1] &amp;lt; b[1]; }); // for (int i = 1; i &amp;lt;= events.</description>
    </item>
    <item>
      <title>1945.sum of digits of string after convert</title>
      <link>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert/</link>
      <pubDate>Thu, 15 Dec 2022 18:06:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert/</guid>
      <description>Solution 1945.sum-of-digits-of-string-after-convert&#xA;Solution Code class Solution { public: int getLucky(string s, int k) { vector&amp;lt;int&amp;gt; num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - &amp;#39;a&amp;#39; + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i &amp;lt; k; i++) { while (sum !</description>
    </item>
    <item>
      <title>1945.字符串转化之后的各位数字之和</title>
      <link>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:06:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert.zh/</guid>
      <description>问题描述 1945.字符串转化后的各位数字之和&#xA;解题思路 正常思路就好。&#xA;代码 class Solution { public: int getLucky(string s, int k) { vector&amp;lt;int&amp;gt; num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - &amp;#39;a&amp;#39; + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i &amp;lt; k; i++) { while (sum !</description>
    </item>
    <item>
      <title>443.压缩字符串</title>
      <link>http://localhost:1313/posts/leet/443.string-compression.zh/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression.zh/</guid>
      <description>问题描述 443.压缩字符串&#xA;解题思路 双指针、滑动窗口，注意for循环中不需要fast++。&#xA;代码 class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.push_back(chars[slow]); res.push_back(cnt + &amp;#39;0&amp;#39;); } else if (cnt &amp;gt;= 10 &amp;amp;&amp;amp; cnt &amp;lt;= 99) { res.</description>
    </item>
    <item>
      <title>443.string compression</title>
      <link>http://localhost:1313/posts/leet/443.string-compression/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression/</guid>
      <description>Description 443.string-compression&#xA;Solution Sliding window, please pay attention to that fast++ is not needed in for loop.&#xA;Code class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.</description>
    </item>
    <item>
      <title>1812.determine color of a chessboard square</title>
      <link>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square/</link>
      <pubDate>Thu, 08 Dec 2022 16:00:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square/</guid>
      <description>Description 1812.determine color of a chessboard square&#xA;Solution Easy&#xA;Code class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - &amp;#39;a&amp;#39; + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>1812.判断国际象棋棋盘中一个格子的颜色</title>
      <link>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square.zh/</link>
      <pubDate>Thu, 08 Dec 2022 16:00:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square.zh/</guid>
      <description>问题描述 1812.判断国际象棋棋盘中一个格子的颜色&#xA;解题思路 太简单了，不写&#xA;代码 class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - &amp;#39;a&amp;#39; + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>698.partition to k equal sum subsets</title>
      <link>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets/</link>
      <pubDate>Thu, 08 Dec 2022 15:47:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets/</guid>
      <description>Description 698.partition-to-k-equal-sum-subsets&#xA;Solution Sort array from large to small, so that we can avoid making mistake of judging arrays like [1, 1, 2, 2].&#xA;We use used[i] to avoid using the same element more than once, if sum == target, sum = 0, if cnt == k, than it can be devided.&#xA;Code class Solution { public: bool dfs(vector&amp;lt;int&amp;gt; &amp;amp;nums, int index, int sum, int target, int cnt, int k, vector&amp;lt;int&amp;gt; &amp;amp;used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); // pay attention to the `idx - 1` rather than `index - 1` } for (int i = index; i &amp;gt;= 0; i--) { if (used[i] || sum + nums[i] &amp;gt; target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k !</description>
    </item>
    <item>
      <title>698.划为k个相等的子集</title>
      <link>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets.zh/</link>
      <pubDate>Thu, 08 Dec 2022 15:47:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets.zh/</guid>
      <description>问题描述 698.划为k个相等的子集&#xA;解题思路 首先，对数组按照从大到小排序，相比从小到大排序，能避免[1, 1, 2, 2]这样的数组的误判;&#xA;利用used[i]数组避免重复使用同一个元素，如果sum == target，就将sum置零，如果cnt == k，说明满足条件。&#xA;代码 class Solution { public: bool dfs(vector&amp;lt;int&amp;gt; &amp;amp;nums, int index, int sum, int target, int cnt, int k, vector&amp;lt;int&amp;gt; &amp;amp;used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); //注意这里是idex - 1而不是index - 1 } for (int i = index; i &amp;gt;= 0; i--) { if (used[i] || sum + nums[i] &amp;gt; target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k !</description>
    </item>
    <item>
      <title>438.find all anagrams in a string</title>
      <link>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string/</link>
      <pubDate>Wed, 07 Dec 2022 19:23:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string/</guid>
      <description>Description 438.find-all-anagrams-in-a-string&#xA;Solution Similar to 30.substring-with-concatenation-of-all-words, easier.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { unordered_map&amp;lt;char, int&amp;gt; mp; for (char &amp;amp;c : p) mp[c]++; vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;char, int&amp;gt; tmp = mp; for (int l = 0, r = 0; r &amp;lt; s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.</description>
    </item>
    <item>
      <title>438.找到字符串中所有字母异位词</title>
      <link>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string.zh/</link>
      <pubDate>Wed, 07 Dec 2022 19:23:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string.zh/</guid>
      <description>问题描述 438.找到字符串中所有字母异位词&#xA;解题思路 参照30.串联所有单词串，思路完全一致。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { unordered_map&amp;lt;char, int&amp;gt; mp; for (char &amp;amp;c : p) mp[c]++; vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;char, int&amp;gt; tmp = mp; for (int l = 0, r = 0; r &amp;lt; s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.find(s[r]) != mp.end()) { while (s[l] !</description>
    </item>
    <item>
      <title>93.restore ip addresses</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses/</guid>
      <description>Description 93.restore-ip-addresses&#xA;Solution Backtracking is actually changing a problem to one like a tree, and doing DFS(depth first search).&#xA;Code class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.</description>
    </item>
    <item>
      <title>93.复原ip地址</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</guid>
      <description>问题描述 93.复原ip地址&#xA;解题思路 回溯实际上就是转化为树形问题，做深度优先遍历。&#xA;代码 class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.size()) { if (cnt == 4) { ip.</description>
    </item>
    <item>
      <title>1775.equal sum arrays with minimum number of operations</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</guid>
      <description>Description 1775.equal-sum-arrays-with-minmum-number-of-operations&#xA;Solution hash table + greedy algorithm The general idea of this problem is hash + greedy algorithm.&#xA;Assuming that the sum1 minus sum2 to be diff and diff &amp;gt; 0, to reduce the difference of the sum of two arrays, we should make diff be value minus the maximum value of changing a number in one of the two array, and make the count of number changed minus 1, until diff &amp;lt; 0.</description>
    </item>
    <item>
      <title>1775.通过最少操作次数使数组的和相等</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</guid>
      <description>问题描述 1775.通过最少操作次数使数组的和相等&#xA;解题思路 哈希+贪心 本题总体思路为哈希+贪心，用两个数组mp1，mp2记录nums1，nums2中每个数各出现了多少次;&#xA;假设nums1的和sum1减去nums2的和sum2的结果为diff，这里假设diff &amp;gt; 0，为了抹平两个数组的和的差距，应该每次减去两个数组中，变化数字引起的数值变化的最大值，并且将变化的数字的计数值减一;&#xA;nums1的和小于nums2的和的情况类似。&#xA;优化 首先假设sum1 &amp;lt; sum2，否则我们交换nums1和nums2并交换sum1和sum2即可，接下来，必定是nums1缩小，nums2增大，对应diff = sum2 - sum1缩小，diff可以减少1,2,3,4,5各若干次，取决于nums1和nums2中原先各个数的数量，用一个哈希表来记录，最后我们从大到小遍历i = 5, 4, 3, 2, 1.&#xA;代码 hash + greedy algorithm class Solution { public: int find_min(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = 1; i &amp;lt; v.size(); i++) { if (v[i] != 0) return i; } return 6; } int find_max(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = v.size() - 1; i &amp;gt;= 1; i--) { if (v[i] !</description>
    </item>
    <item>
      <title>219.contains duplicate ii</title>
      <link>http://localhost:1313/posts/leet/219.contains-duplicate-ii/</link>
      <pubDate>Tue, 06 Dec 2022 20:00:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/219.contains-duplicate-ii/</guid>
      <description>Description 219.contains-duplicate-ii&#xA;Solution We can use unordered_map to record the number of ocurrence of each integer and slide window accrording the unordered_map.&#xA;Code class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] &amp;lt;= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; </description>
    </item>
    <item>
      <title>219.存在重复元素II</title>
      <link>http://localhost:1313/posts/leet/219.contains-duplicate-ii.zh/</link>
      <pubDate>Tue, 06 Dec 2022 20:00:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/219.contains-duplicate-ii.zh/</guid>
      <description>问题描述 219.存在重复元素II&#xA;解题思路 利用unordered_map记录元素出现的次数，使用滑动窗口法。&#xA;代码 class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] &amp;lt;= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; </description>
    </item>
    <item>
      <title>396.rotate function</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function/</guid>
      <description>Description 396. rotate-function&#xA;Solution The key is to find the mathematical laws&#xA;Code class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>396.旋转函数</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function.zh/</guid>
      <description>问题描述 396.旋转函数&#xA;解题思路 关键在于找到数学规律&#xA;代码 class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.size(); i++) { res[i] = res[i - 1] + sum - (nums.</description>
    </item>
    <item>
      <title>1796.second largest digit in a string</title>
      <link>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string/</link>
      <pubDate>Tue, 06 Dec 2022 19:47:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string/</guid>
      <description>Description 1796.second-largest-digit-in-a-string&#xA;Solution Just traversing.&#xA;Code class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] &amp;lt;= &amp;#39;9&amp;#39;) { if (s[i] - &amp;#39;0&amp;#39; &amp;gt; first) { second = first; first = s[i] - &amp;#39;0&amp;#39;; } else if (s[i] - &amp;#39;0&amp;#39; &amp;lt; first &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt; second) second = s[i] - &amp;#39;0&amp;#39;; } } return second; } }; </description>
    </item>
    <item>
      <title>1796.字符串中第二大的数字</title>
      <link>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:47:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string.zh/</guid>
      <description>问题描述 1796.字符串中第二大的数字&#xA;解题思路 遍历就好了&#xA;代码 class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] &amp;lt;= &amp;#39;9&amp;#39;) { if (s[i] - &amp;#39;0&amp;#39; &amp;gt; first) { second = first; first = s[i] - &amp;#39;0&amp;#39;; } else if (s[i] - &amp;#39;0&amp;#39; &amp;lt; first &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt; second) second = s[i] - &amp;#39;0&amp;#39;; } } return second; } }; </description>
    </item>
    <item>
      <title>1774.closest Dessert Cost</title>
      <link>http://localhost:1313/posts/leet/1774.closest-dessert-cost/</link>
      <pubDate>Tue, 06 Dec 2022 19:37:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1774.closest-dessert-cost/</guid>
      <description></description>
    </item>
    <item>
      <title>1774.最接近目标价格的甜点成本</title>
      <link>http://localhost:1313/posts/leet/1774.closest-dessert-cost.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:37:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1774.closest-dessert-cost.zh/</guid>
      <description>问题描述 1774.最接近目标价格的甜点成本&#xA;解题思路 回溯法 动态规划法 代码 回溯法 class Solution { public: // res表示存储的最接近target的成本，sum表示和 int traverse(vector&amp;lt;int&amp;gt; &amp;amp;toppingCosts, int target, int index, int sum, int res, vector&amp;lt;int&amp;gt; &amp;amp;cnt) { if (cnt[index] &amp;gt; 2) return res; if (sum &amp;gt;= target) { // 返回最接近的成本 if (abs(sum - target) &amp;lt; abs(target - res)) return sum; else if (abs(sum - target) == abs(target - res)) return min(res, sum); else return res; } for (int i = index; i &amp;lt; toppingCosts.</description>
    </item>
    <item>
      <title>1805.number of different integers in a string</title>
      <link>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string/</link>
      <pubDate>Tue, 06 Dec 2022 19:14:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string/</guid>
      <description>Descripiton 1805.number-of-different-integers-in-a-string&#xA;Solution Treating numbers as strings, save them in unordered_set, we need pay attention to pilot zero and the condition which last character is a number.&#xA;Code class Solution { public: int numDifferentIntegers(string word) { unordered_set&amp;lt;string&amp;gt; words; string str; for (int i = 0; i &amp;lt; word.size(); i++) { if (str.empty()) { if (word[i] - &amp;#39;0&amp;#39; &amp;lt;= 9) str.push_back(word[i]); } else { if (word[i] - &amp;#39;0&amp;#39; &amp;gt; 9) { if (words.</description>
    </item>
    <item>
      <title>1805.字符串中不同整数的数目</title>
      <link>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:14:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string.zh/</guid>
      <description>问题描述 1805.字符串中不同整数的数目&#xA;解题思路 把数字当作字符串处理，存入unordered_set(哈希表)中，注意最后一个字符是数字的情况。&#xA;代码 class Solution { public: int numDifferentIntegers(string word) { unordered_set&amp;lt;string&amp;gt; words; string str; for (int i = 0; i &amp;lt; word.size(); i++) { if (str.empty()) { if (word[i] - &amp;#39;0&amp;#39; &amp;lt;= 9) str.push_back(word[i]); } else { if (word[i] - &amp;#39;0&amp;#39; &amp;gt; 9) { if (words.find(str) == words.end()) words.insert(str); str.clear(); } else { if (str.size() == 1 &amp;amp;&amp;amp; str[0] == &amp;#39;0&amp;#39;) { // 去除先导0 str.clear(); } str.push_back(word[i]); } } } if (!</description>
    </item>
    <item>
      <title>131.palindrome patitioning</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning/</guid>
      <description>Description 131.palindrome-partitioning&#xA;Solution We can whether it is palindrome by dynamic programming: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;When traversing, pay attention to the order of traversing i;&#xA;Last, we use backtracking to update res.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.</description>
    </item>
    <item>
      <title>131.分割回文串</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</guid>
      <description>问题描述 131.分割回文串&#xA;解题思路 利用动态规划来判断字符串是否是回文串: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;这里遍历的时候要注意i的遍历顺序;&#xA;最后考虑利用回溯法，更新答案。&#xA;代码 class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.size(); i++) { if (dp[index][i]) { res_tmp.push_back(s.substr(index, i - index + 1)); track_back(s, i + 1, dp); res_tmp.pop_back(); } } return; } vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) { vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>3.longest substring without repeating characters</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</guid>
      <description>Description 3.longest-substring-withou-repeating-characters&#xA;Solution We use arr[96] to record the number of occurence of each character. If the number is larger than 1, than there is repeating character between l and r; else, update res, if current length of substr is larger than res.&#xA;Code class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.</description>
    </item>
    <item>
      <title>3.无重复字符的最长子串</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</guid>
      <description>问题描述 3.无重复字符的最长子串&#xA;解题思路 用arr[96]记录每个字符出现的次数，如果字符次数大于1，说明已经包含了重复字符，则要更新l，否则递增r，并记录最大的子串长度。&#xA;代码 class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.size(); r++) { arr[s[r] - &amp;#39; &amp;#39;]++; if (arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) { while (l &amp;lt; r &amp;amp;&amp;amp; arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) arr[s[l++] - &amp;#39; &amp;#39;]--; } else { res = max(r - l + 1, res); } } return res; } }; </description>
    </item>
    <item>
      <title>30.substring with concatenation of all words</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</guid>
      <description>Description 30.substring-with-concatenation-of-all-words&#xA;Solution For each word sequence {s.substr(i, word_len), s.substr(i + word_len, word_len)...} of i($[0, word_len - 1]$), we use sliding window to judge;&#xA;We should pay attention to the detail when judging. We can use mp to determine whether substr is in words, and mp_tmp to determine whether it is concatenated substring, if mp is empty, then it is;&#xA;For key-value in mp_tmp, if value becomes 0, then erase(key);</description>
    </item>
    <item>
      <title>30.串联所有单词串</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</guid>
      <description>问题描述 30.串联所有单词串&#xA;解题思路 首先，由于words中所有字符串长度相同，要比较words与s: - s从i = 0开始，可以划分为一系列的长为word_len = words[0].size()的单词; - s从i = 1开始，可以划分为一系列的长为word_len = words[0].size()的单词; - &amp;hellip;&amp;hellip; - s从i = word_len - 1开始&amp;hellip;&amp;hellip;&#xA;然后要注意利用unordered_map&amp;lt;string, int&amp;gt;判断是否满足条件的细节，mp用于判断word是否在words中;&#xA;mp_tmp的键值对中，如果值为0，就删掉该键;&#xA;还要注意l的处理，分为在mp_tmp为空，和mp_tmp不为空，但是word已经出现了超过words中的次数.&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findSubstring(string s, vector&amp;lt;string&amp;gt; &amp;amp;words) { unordered_map&amp;lt;string, int&amp;gt; mp; int word_len = words[0].size(); int cnt = 0; vector&amp;lt;int&amp;gt; res; for (int i = 0; i &amp;lt; words.size(); i++) { mp[words[i]]++; cnt++; } if (cnt * word_len &amp;gt; s.</description>
    </item>
    <item>
      <title>1610.maximum Number of Visible Points</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</guid>
      <description>Descripiton 1610.maximum-number-of-visible-points&#xA;Soluiton We can use function atan2 to change slope to angle in $-\pi ~ \pi$.&#xA;We need also expand arrays, let angle[n + i] = angle[i] + 360, and the length of array to be 2 * n, so we can avoid omission.&#xA;Code class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>1610.可见点的最大数目</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</guid>
      <description>问题描述 1610.可见点的最大数目&#xA;解题思路 利用atan2函数，即可将斜率转化为$-\pi ~ \pi$的角度;&#xA;扩充数组，令angle[n + i] = angle[i] + 360，使角度数组长度为2 * n，这样就能避免遗漏一四象限。&#xA;代码 class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>303.range sum query-immutable</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</guid>
      <description>Description 303.range-sum-query-immutable&#xA;Solution We can use prefix sum array, so we can get sum without traversing.&#xA;Code class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>303.区域和检索-数组不可变</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</guid>
      <description>问题描述 303.区域和检索-数组不可变&#xA;解题思路 利用前缀和数组，使得求区间和时无需再遍历数组求和。&#xA;代码 class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>1769.minimum number of operation to ove ll balls to each box</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</guid>
      <description>Description 1769.minimum-number-of-operations-to-move-all-balls-to-each-box&#xA;Solution Violent solution: $\Theta(n^2)$&#xA;We could use prefix sum to reduce the time complexity.&#xA;nums[i] denotes the number of ball in first i + 1 boxes, res[i] is the minimum number of operation to ove ll balls to the i + 1th box, sum is the total number of balls. Compared to moving all balls to i th box, if we want to move all ball to the i + 1th box, the balls in 0 =&amp;gt; i - 1 all need move an additional step, while the balls in i =&amp;gt; n - 1 will move one step less.</description>
    </item>
    <item>
      <title>1769.移动所有球到每个盒子所需的最小操作数</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</guid>
      <description>问题描述 1769.移动所有球到每个盒子所需的最小操作数&#xA;解题思路 暴力求解，时间复杂度为$\Theta(n^2)$;&#xA;可以考虑利用前缀和来降低时间复杂度: 设nums[i]是前i + 1个盒子里的球的总个数，res[i]为将所有球移到第i + 1个盒子里所需要的操作数，sum为球总个数，移到第i + 1个盒子相比移到第i个盒子，左边的球各要多移一步，右边的球各少移一步，因此有那么有:res[i] = res[i - 1] + nums[i - 1] - (sum - nums[i - 1])，&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; minOperations(string boxes) { vector&amp;lt;int&amp;gt; nums(boxes.size(), 0); int sum = boxes[0] - &amp;#39;0&amp;#39;; nums[0] = boxes[0] - &amp;#39;0&amp;#39;; for (int i = 1; i &amp;lt; boxes.size(); i++) { if (boxes[i] == &amp;#39;1&amp;#39;) { nums[i] = nums[i - 1] + 1; sum++; } else nums[i] = nums[i - 1]; } vector&amp;lt;int&amp;gt; res(boxes.</description>
    </item>
    <item>
      <title>424.longest repeating character replacement</title>
      <link>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement/</link>
      <pubDate>Tue, 29 Nov 2022 13:47:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement/</guid>
      <description>Description 424.longest-repeating-character-replacement&#xA;Solution First, note that if the substring can be turned into a substring containing only the same letters by substituing for k times, then there must be max_cnt + k &amp;gt;= subarray.size(); then the substring that does not satisfy the condition must have max_cnt + k &amp;lt; subarray.size(), and according to this, we can use the sliding window method;&#xA;If it satifies the condition, just right++, else right++, left++, so right - left must be incremental.</description>
    </item>
    <item>
      <title>424.替换后的最长重复字符</title>
      <link>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:47:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</guid>
      <description>问题描述 424.替换后的最长重复字符&#xA;解题思路 首先，注意一点，子串如果能通过k次替换变成只包含相同字母的子串，那么一定有max_cnt + k &amp;gt;= subarray.size();那么不满足条件的子串一定有max_cnt + k &amp;lt; subarray.size()，根据这一点，我们可以采用滑动窗口法;&#xA;如果满足条件，那么只增加right，如果不满足条件，right++、left++，这样right - left一定是递增的，并且会遍历搜寻到所有的不同字符。&#xA;代码 class Solution { public: int characterReplacement(string s, int k) { vector&amp;lt;int&amp;gt; num(26); int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right &amp;lt; n) { num[s[right] - &amp;#39;A&amp;#39;]++; maxn = max(maxn, num[s[right] - &amp;#39;A&amp;#39;]); if (right - left + 1 - maxn &amp;gt; k) { num[s[left] - &amp;#39;A&amp;#39;]--; left++; } right++; } return right - left; } }; </description>
    </item>
    <item>
      <title>413.arithmetic slices</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices/</guid>
      <description>Descritpion 413.arithmetic slices&#xA;Solution We should notice that the number of subarray $cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$(len) is the length of arithmetic array.&#xA;Code class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>413.等差数列划分</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</guid>
      <description>问题描述 413.等差数列划分&#xA;解题思路 注意到子数组个数$cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$，其中len是等差数组的长度，则cnt = (n - 1) * (n - 2) / 2，每次遍历找出连续的等差数组的长度即可。 测试test&#xA;代码 class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.size(); i++) { if (nums[i] - nums[i - 1] == dif) len++; else { if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; len = 2; dif = nums[i] - nums[i - 1]; } } if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; return cnt; } }; </description>
    </item>
    <item>
      <title>88.merge sorted array</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array/</guid>
      <description>Description 88.merge-sorted-array&#xA;Solution We use pointers, assign values of nums1 from end to front, so we use only $\Theta(1)$ extra space.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>88.合并两个有序数组</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</guid>
      <description>问题描述 88.合并两个有序数组&#xA;解题思路 双指针，由于num1的长度是m + n，因此遍历时，可以考虑针对nums1，从后往前赋值，从而只需要$\Theta(1)$的额外空间。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>142.linked list cycle ii</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</guid>
      <description>Description 142.linked-list-cycle-ii&#xA;Solution Like 141.linked-list-cycle, when fast and slow meet each other, we make a pointer p start from virtual head node, traverse one by one, the same as slow. slow and p will meet at the entrance of the cycle.&#xA;Code class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead !</description>
    </item>
    <item>
      <title>142.环形链表II</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</guid>
      <description>问题描述 142.环形链表II&#xA;解题思路 判断是否链表是否存在环的方式与141.环形链表一致，当两个指针相遇时，再让一个指针从虚拟头节点开始一个节点一个节点的遍历，slow指针也是，两个指针会在环的入口处相遇。&#xA;代码 class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead != slow) { vhead = vhead-&amp;gt;next; slow = slow-&amp;gt;next; } delete vhead; return slow; } } return nullptr; } }; </description>
    </item>
    <item>
      <title>141.linked list cycle</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle/</guid>
      <description>Description 141.linked-list-cycle&#xA;Solution We can use two pointers, one fast, one slow. For each time, fast move to next next node, slow move to next node. If there is cycle, fast will be equal to slow, or fast will be nullptr.&#xA;Code class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>141.环形链表</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</guid>
      <description>问题描述 141.环形链表&#xA;解题思路 使用快慢两个指针，fast一次移动两个节点，slow一次移动一个节点，如果链表存在环，那么fast和slow一定会有相等的时候，否则fast会运动到链表末尾。&#xA;代码 class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>345.reverse vowels of a string</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</guid>
      <description>Description 345.reverse-vowels-of-a-string&#xA;Solution We use unordered_set to determine whether it is vowel, two pointers.&#xA;Code class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.</description>
    </item>
    <item>
      <title>345.反转字符串中的元音字母</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</guid>
      <description>问题描述 345.反转字符串中的元音字母&#xA;解题思路 双指针法，使用unordered_set(底层实现为哈希表)来判断是否是元音字母。&#xA;代码 class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) == mset.end()) r--; else if (mset.</description>
    </item>
    <item>
      <title>75.sort colors</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors/</link>
      <pubDate>Fri, 25 Nov 2022 15:27:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors/</guid>
      <description>Description 75.sort-colors&#xA;Solution Here, we need three pointers l, r, idx, l for 0, r for 2, idx for traversing.&#xA;When traversing:&#xA;if nums[idx] == 0,swap(nums[idx], nums[l]);, and idx++; l++ if nums[idx] == 1, idx++; if nums[idx] == 2, swap(nums[idx], nums[r]);, and only r--, because new nums[idx] may be 0 or 1 or 2, so we need determine the value of nums[idx] again. if swap(nums[idx], nums[l]);, new nums[idx] will be 0 only when idx == l, or nums[idx] == 1, so we can increase idx.</description>
    </item>
    <item>
      <title>75.颜色分类</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors.zh/</link>
      <pubDate>Fri, 25 Nov 2022 15:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors.zh/</guid>
      <description>问题描述 75.颜色分类&#xA;解题思路 这里，我们需要三个指针l, r, idx, l用来存放0,r用来存放2，idx用来进行遍历数组。&#xA;要注意的是，在遍历数组时:&#xA;if nums[idx] == 0，需要交换nums[idx]和nums[l]的值，同时idx++; l++; if nums[idx] == 1，idx++即可 if nums[idx] == 2，需要交换nums[idx]和nums[l]的值，但此时只是r--，不会idx++，这是因为新的交换后的nums[idx]的值可能是0、1、2中的任意一个，因此还需要重新判断nums[idx] 如果idx == l，那么[0, idx]区间范围内的数都是0，如果idx != l，那么[0, l - 1]区间范围内都是0，[l, idx)区间范围内都是1，因此可以进行idx++; 代码 class Solution { public: void sortColors(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int tmp = 0, index = 0; int l = 0, r = nums.size() - 1; while (index &amp;lt;= r) { if (nums[index] == 0) { tmp = nums[l]; nums[l++] = 0; nums[index++] = tmp; } else if (nums[index] == 2) { tmp = nums[r]; nums[r--] = 2; nums[index] = tmp; } else index++; } } }; </description>
    </item>
    <item>
      <title>26.remove duplicates from sorted array</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</guid>
      <description>Description 26.remove-duplicates-from-sorted-array&#xA;Solution We use two pointers fast and slow, fast used to check if duplicated, slow use for assignment.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>26.删除有序数组中的重复项</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</guid>
      <description>问题描述 26.删除有序数组中的重复项&#xA;解题思路 采用双指针法，一快一慢，fast用于检测是否重复，slow用来被赋值。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>18.4sum</title>
      <link>http://localhost:1313/posts/leet/18.4sum/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum/</guid>
      <description>Description 18.4sum&#xA;Solution Two pointers, i, j = i + 1, l = j + 1, r = nums.size() - 1;&#xA;Pay attention to overflow exception and deduplication.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    <item>
      <title>18.4四数之和</title>
      <link>http://localhost:1313/posts/leet/18.4sum.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum.zh/</guid>
      <description>问题描述 18.四数之和&#xA;解题思路 双指针法，i, j = i + 1, l, r;&#xA;注意去重和溢出。&#xA;代码 class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.size() - 2; j++) { if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) continue; int l = j + 1, r = nums.</description>
    </item>
    <item>
      <title>19.remove nth node from end of list</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</guid>
      <description>Description 19.remove-nth-node-from-end-of-list&#xA;Solution For convenience, we create a virtual head node pre, pre-&amp;gt;next = head.&#xA;We will use two pointers fast and slow. First, fast go head for n times, then fast and slow go ahead together. When fast arrives at last node, slow points to the last node of the node we need delete.&#xA;Code class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next !</description>
    </item>
    <item>
      <title>19.删除链表的倒数第N个节点</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</guid>
      <description>问题描述 19.删除链表的倒数第N个节点&#xA;解题思路 首先设置一个虚拟头节点pre，pre-&amp;gt;next = head;&#xA;双指针法，考虑使用两个指针fast，slow，一快一慢，fast指针先前进n个位置，然后fast和slow一起遍历，当fast到达最后一个节点的时候，slow刚好位于要删除的节点的前一个节点。&#xA;代码 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next; slow = slow-&amp;gt;next; } slow-&amp;gt;next = slow-&amp;gt;next-&amp;gt;next; return pre-&amp;gt;next; } }; </description>
    </item>
    <item>
      <title>16.3sum closest</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest/</guid>
      <description>Description 16.3sum-closest&#xA;Solution The violent solution: triple cycle, $\Theta(n^3)$&#xA;We should notice that we don&amp;rsquo;t care the original index of array, so we can use two pointers to reduce the time complexity.&#xA;First, we need sort the array, in outer loop, i iterates from 0 to nums.size() - 3, in inner loop, l and r come together from end to the middle.&#xA;Code class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.</description>
    </item>
    <item>
      <title>16.最接近的三数之和</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest.zh/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest.zh/</guid>
      <description>问题描述 16.最接近的三数之和&#xA;解题思路 暴力解法，三重循环，时间复杂度为$\Theta(n^3)$;&#xA;注意到本题不关注数组中元素的初始索引，因此可以考虑利用双指针来降低时间复杂度: 首先将数组排序，最外层i从0遍历到nums.size() - 3，内层循环采用相向双指针l，r从两端向中间靠拢，并且要注意如何去重，(当然，此题可以不关注)。&#xA;代码 class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.begin(), nums.end()); int sum = nums[0] + nums[1] + nums[2]; // 记录三数之和 for (int i = 0; i &amp;lt; nums.size() - 2; i++) { // 跳过重复的 if (i !</description>
    </item>
    <item>
      <title>11.container with most water</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water/</link>
      <pubDate>Sat, 19 Nov 2022 09:46:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water/</guid>
      <description>Description 11.container-with-most-water&#xA;Solution The violent solution of this problem has a time complexity of $O(n^2)$, to reduce the time complexity, we consider two-pointers.&#xA;So, we need determine how left pointer l and right pointer r will meet each other:&#xA;if (height[l] &amp;gt;= height[r]), the capacity depends on height[r]. If l++, the capacity will become smaller, so we should r--. if (height[l] &amp;lt; height[r]), the capacity depends on height[l]. If r--, the capacity will become smaller, so we should l++.</description>
    </item>
    <item>
      <title>11.盛最多水的容器</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</link>
      <pubDate>Sat, 19 Nov 2022 09:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</guid>
      <description>问题描述 11.盛最多水的容器&#xA;解题思路 本题暴力解法，时间复杂度为$O(n^2)$(会超时，没试过)，为了降低时间复杂度，考虑使用双指针。&#xA;那么，本题需要考虑的就是左指针l和右指针r如何向中间靠拢：&#xA;if (height[l] &amp;gt;= height[r])，说明容器容积是由height[r]来决定的，这时候，l向中间考虑，只可能会缩小容积，因此应该r--; if (height[l] &amp;lt; height[r])，说明容器容积由height[l]来决定，这时候，r向中间靠拢，只会缩小容积，因此应该l++; 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int l = 0, r = height.size() - 1; int res = 0; while (l &amp;lt; r) { if (height[l] &amp;gt;= height[r]) { res = max(res, (r - l) * height[r]); r--; // 因为此时，增加l只可能缩小res，所以减少r } else { res = max(res, (r - l) * height[l]); l++; // height[l] &amp;lt; height[r], 此时减少r也只会缩小res，所以增加l } } return res; } }; </description>
    </item>
    <item>
      <title>42.trapping rain water</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water/</guid>
      <description>Description 42.trapping-rain-water&#xA;Solution We can use monotone stack&#xA;The capacity of unit cosist of height[stk.top()] is (min(height[r], height[l]) - height[stk.top()]) * (l - r - 1), l is next element below the top of the stack, since height[l] &amp;gt;= height[stk.top()] r is the index of first column which height[r] &amp;gt;= height[stk.top()].&#xA;The result is the sum.&#xA;Code ```cpp #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.</description>
    </item>
    <item>
      <title>42.接雨水</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</guid>
      <description>问题描述 42.接雨水&#xA;解题思路 本题考虑使用单调栈(monotone stack)，栈顶到栈底依次递增。&#xA;由height[stk.top()]存放雨水的单元，其计算方式为(min(height[r], height[l]) - height[stk.top()]) * (l - r - 1)，其中l即栈顶的下一个元素，r则是第一个高度大于height[stk.top()]的柱子的索引。&#xA;结果为所有柱子能存放的雨水的累加。&#xA;代码 #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.push(0); int res = 0; for (int i = 1; i &amp;lt; height.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; height[i] &amp;gt; height[stk.top()]) { int mid = stk.top(); stk.pop(); if (!stk.empty()) { int h = min(height[i], height[stk.top()]) - height[mid]; int w = i - stk.</description>
    </item>
    <item>
      <title>503.next Greater Element Ii</title>
      <link>http://localhost:1313/posts/leet/503.next-greater-element-ii/</link>
      <pubDate>Fri, 11 Nov 2022 16:59:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/503.next-greater-element-ii/</guid>
      <description></description>
    </item>
    <item>
      <title>503.下一个更大元素II</title>
      <link>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:59:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</guid>
      <description>问题描述 503.下一个更大元素II&#xA;解题思路 相比496.下一个更大元素I，在遍历数组上有所区别，如果i &amp;gt;= nums.size()，用j = i - nums.size();来代替i，因此i的取值范围是[0, 2 * nums.size())。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElements(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; res(nums.size(), -1); stack&amp;lt;int&amp;gt; stk; stk.push(0); int j = 0; for (int i = 1; i &amp;lt; 2 * nums.size(); i++) { if (i &amp;gt;= nums.size()) { j = i - nums.size(); while (!stk.empty() &amp;amp;&amp;amp; nums[j] &amp;gt; nums[stk.top()]) { res[stk.top()] = nums[j]; stk.pop(); } stk.push(j); } else { while (!</description>
    </item>
    <item>
      <title>496.next greater element i</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i/</guid>
      <description>Description 496.next-greater-element-i&#xA;Solution We can use monotone stack to traverse nums2, and use unordered_map to store the element in nums1 and corresponding result.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.</description>
    </item>
    <item>
      <title>496.下一个更大元素I</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</guid>
      <description>问题描述 496.下一个更大元素I&#xA;解题思路 本题利用单调栈(monotone stack)来遍历nums2，并且利用unordered_map来存储nums1中元素和对应的结果。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.find(nums2[stk.top()]) != umap.end()) { umap[nums2[stk.top()]] = nums2[i]; } stk.pop(); } stk.push(i); } vector&amp;lt;int&amp;gt; res(nums1.size(), -1); for (int i = 0; i &amp;lt; nums1.</description>
    </item>
    <item>
      <title>739.daily temperatures</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures/</guid>
      <description>Description 739.dail-temperatures&#xA;Solution We can consider monotone stack. If the stack is empty or the element to deal with is smaller than the element in the top of the stack, we can push the element to the stack, else we should pop the element in the top of the stack until the stack is empty or the element is smaller than the element in the top of the stack.&#xA;It&amp;rsquo;s convenient to push the index i into the stack.</description>
    </item>
    <item>
      <title>739.每日温度</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</guid>
      <description>问题描述 739.每日温度&#xA;解题思路 考虑利用单调栈(monotone stack)来进行处理，如果栈为空或者要入栈的元素小于栈顶元素，那么该元素入栈，否则弹出栈顶元素直到栈为空，或者要入栈的元素小于栈顶元素，再将该元素入栈。&#xA;这里应该将数组索引i入栈会比较方便。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt; &amp;amp;temperatures) { vector&amp;lt;int&amp;gt; res(temperatures.size(), 0); stack&amp;lt;int&amp;gt; st; st.push(0); for (int i = 1; i &amp;lt; temperatures.size(); i++) { int j = i; // if (!st.empty()) { while (!st.empty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[st.top()]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); // } } return res; } }; </description>
    </item>
    <item>
      <title>738.monotone increasing digits</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</guid>
      <description>Description 738.monotone-increasing-digits&#xA;Solution First, we need change the number to a vector&amp;lt;int&amp;gt; dec, for example:1234 to {1, 2, 3, 4}. Then we can traverse the vector, until dec[i] &amp;gt; dec[i + 1], then set dec[i + n] = 9(n &amp;gt;= 1). If dec[i] == dec[i - 1] == ... == dec[j], then dec[j]--, set others as 9, else dec[i]--;&#xA;Code class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n !</description>
    </item>
    <item>
      <title>738.单调递增的数字</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</guid>
      <description>问题描述 738.单调递增的数字&#xA;解题思路 将该数字的每一位数字变成数组dec&amp;lt;int&amp;gt;的一部分，然后依次遍历，直到dec[i] &amp;gt; dec[i + 1]，然后将dec[i + 1]及以后的数字都变成9，如果dec[i] == dec[i - 1] == ··· == dec[j]，就将dec[j]--，其余全设置为9。&#xA;代码 class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n != 0) { res.push_back(n % 10); n = n / 10; } } int ten(int i) { int res = 1; while (i != 0) { i--; res *= 10; } return res; } public: int monotoneIncreasingDigits(int n) { vector&amp;lt;int&amp;gt; dec; vec_dec(n, dec); std::reverse(dec.</description>
    </item>
    <item>
      <title>56.merge intervals</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals/</guid>
      <description>Description 56.merge-intervals&#xA;Solution The solution is similar to 452.minimum-number-of-arrows-to-burst-balloons, if there is common space, change the res.back()[1] to intervals[i][1], while intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); if there is not common space, res.push_back().&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>56.合并区间</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals.zh/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals.zh/</guid>
      <description>问题描述 56.合并区间&#xA;解题思路 思路与452.用最少的箭引爆气球，只不过这里intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])，如果存在重叠，修改res最后一个元素的右端点值；如果不存在重叠，就往res里添加一个新的区间。&#xA;代码 class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i - 1][1] &amp;lt; intervals[i][0]) res.push_back(intervals[i]); else { intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); res[res.size() - 1][1] = intervals[i][1]; } } return res; } }; </description>
    </item>
    <item>
      <title>763.partition labels</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels/</guid>
      <description>Description 763.partition-label&#xA;Solution solution 1 First, we need traverse the string, record the maximum index of each letter in the string.&#xA;Then we need declare a variable right to record the maximum index of letter traversed. When the maximum index is the same as current index, we can partition the string.&#xA;solution 2 First, we need traverse the string, record the number of occurrence of each letter, and record whether the letter occur.</description>
    </item>
    <item>
      <title>763.划分字母区间</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels.zh/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels.zh/</guid>
      <description>问题描述 763.划分字母区间&#xA;解题思路 思路一 首先遍历一遍数组，记录每个字母在字符串中出现的最远位置。&#xA;声明一个变量right，用来记录已经遍历的字符中，最远的位置，当遍历到的位置与记录的最远位置重叠时，就说明可以划分数组了。&#xA;思路二 首先遍历一遍数组，记录每个字母出现的次数，并记录是否出现；&#xA;再遍历一次数组，当第一次碰到该字符时，该字符入栈，最后一次碰到该字符时，弹出栈顶的字符，栈空时，说明可以分割了。&#xA;代码 代码一 class Solution { public: vector&amp;lt;int&amp;gt; partitionLabels(string S) { int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置 for (int i = 0; i &amp;lt; S.size(); i++) { // 统计每一个字符最后出现的位置 hash[S[i] - &amp;#39;a&amp;#39;] = i; } vector&amp;lt;int&amp;gt; result; int left = 0; int right = 0; for (int i = 0; i &amp;lt; S.size(); i++) { right = max(right, hash[S[i] - &amp;#39;a&amp;#39;]); // 找到字符出现的最远边界 if (i == right) { result.</description>
    </item>
    <item>
      <title>435.non overlapping intervals</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</guid>
      <description>Description 435.non-overlapping-intervals&#xA;Solution This problem is almost the same with 452.minimum-number-of-arrows-to-burst-balloons, the number intervals minus the result of 452.minimum-number-of-arrows-to-burst-balloons is the result of this problem.&#xA;Attention, [1, 3], [3, 5] is not overlapping intervals in this problem.&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>435.无重叠区间</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</guid>
      <description>问题描述 435.无重叠区间&#xA;解题思路 本题和452.用最少数量的箭引爆气球可以说解题思路一模一样，区间数减去452.用最少数量的箭引爆气球就可以说是本题要求的答案，但是要注意的是，在本题中，区间端点相同是不认为重叠的。&#xA;代码 class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i][0] &amp;gt;= intervals[i - 1][1]) cnt++; else { intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); } } return intervals.size() - cnt; } }; </description>
    </item>
    <item>
      <title>452.minimum number of arrows to burst balloons</title>
      <link>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons/</link>
      <pubDate>Thu, 03 Nov 2022 13:56:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons/</guid>
      <description>Description [452.minimum-number-of-arrows-to-burst-balloons]&#xA;Solution First, sort points array by x_start from smallest to largest, then we need analyze how many arrows we need.&#xA;if (points[i][0] &amp;gt; points[i - 1]), there is no common space between two balloons, we need to arrow, result++; else, then there is common space between two balloons, we need a new arrow. How about the next balloon? if (points[i + 1][0] &amp;gt; min(points[i - 1][1], points[i][1])), then we need new arrow; if not , we don&amp;rsquo;t need.</description>
    </item>
    <item>
      <title>452.用最少数量的箭引爆气球</title>
      <link>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</link>
      <pubDate>Thu, 03 Nov 2022 13:55:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</guid>
      <description>问题描述 452.用最少数量的箭引爆气球&#xA;解题思路 首先，按照$x_start$从小到大的顺序排序，然后开始分析需要的弓箭数。&#xA;if (points[i][0] &amp;gt; points[i - 1])，说明两个气球不存在重叠，需要两支箭，箭数result++; else，说明两个气球存在重叠，只需要一支箭，但此时，如何判断下一个气球是否需要新的箭呢: if (points[i + 1][0] &amp;gt; min(points[i - 1][1], points[i][1]))，那么就需要新的箭，反之就不需要，因此，令points[i][1] = min(points[i - 1][1], points[i][1])。 代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::sort; using std::vector; class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { return a[0] &amp;lt; b[0]; } public: int findMinArrowShots(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points) { int result = 1; sort(points.begin(), points.end(), cmp); for (int i = 1; i &amp;lt; points.size(); i++) { if (points[i - 1][1] &amp;lt; points[i][0]) result++; else { points[i][1] = min(points[i][1], points[i - 1][1]); } } return result; } }; </description>
    </item>
    <item>
      <title>406.queue reconstruction by height</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</guid>
      <description>Description 406.queue-reconstruction-by-height&#xA;Solution First, we need sort the vector by height, then do insertion according to ki.&#xA;When sorting, we need rewrite the comparing method, in reference to the use of sort() method in C++&#xA;Since there may be performance problem when doing insertion frequently in vector, we should use list based on linked list.&#xA;Code class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.</description>
    </item>
    <item>
      <title>406.根据身高重建队列</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</guid>
      <description>问题描述 406.根据身高重建队列&#xA;解题思路 首先根据身高对数组重新排序，再根据ki进行插入操作。&#xA;排序时，需要对排序的比较方法重写，参见C++ sort排序函数用法。&#xA;同时，考虑到基于使用vector来进行频繁的插入操作可能会存在性能问题，应该使用基于链表的list。&#xA;代码 class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.begin(), people.end(), cmp); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; queue; for (int i = 0; i &amp;lt; people.size(); i++) { int tmp = people[i][1]; queue.insert(tmp + queue.begin(), people[i]); } return queue; } }; class Solution { public: // 身高从大到小排（身高相同k小的站前面） static bool cmp(const vector&amp;lt;int&amp;gt;&amp;amp; a, const vector&amp;lt;int&amp;gt;&amp;amp; b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; people) { sort (people.</description>
    </item>
    <item>
      <title>860.lemonade change</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change/</guid>
      <description>Description 860.lemonade-change&#xA;Solution We can create an array to show the number of $5, $10, $20. When the number of $5 is less than 0, return false. When we receive $20, we should provide change with $10 preferentially.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>860.柠檬水找零</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change.zh/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change.zh/</guid>
      <description>问题描述 860.柠檬水找零&#xA;解题思路 创建一个数组，表示手中的5元纸币、10元纸币、20元纸币的数目，当其中5元纸币数目小于0，说明无法找零，遇到20元纸币时，优先使用10元纸币找零。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>135.candy</title>
      <link>http://localhost:1313/posts/leet/135.candy/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy/</guid>
      <description>Description 135.candy&#xA;Solution The key point of this problem is that we need traverse two times, one from front to back, the other from back to front.&#xA;Code class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // front to back for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // back to front for (int i = ratings.</description>
    </item>
    <item>
      <title>135.分发糖果</title>
      <link>http://localhost:1313/posts/leet/135.candy.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy.zh/</guid>
      <description>问题描述 135.分发糖果&#xA;解题思路 本题的关键在于，需要一次从前往后的遍历，第一次确定最少糖果数，同时还需要从后往前遍历，再一次确定最少糖果数。&#xA;代码 class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // 从前向后 for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // 从后向前 for (int i = ratings.size() - 2; i &amp;gt;= 0; i--) { if (ratings[i] &amp;gt; ratings[i + 1] ) { candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1); } } // 统计结果 int result = 0; for (int i = 0; i &amp;lt; candyVec.</description>
    </item>
    <item>
      <title>1005.maximize sum of array after k negations</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</guid>
      <description>Description 1005.maximize-sum-of-array-after-k-negations&#xA;Solution Greedy algorithm.&#xA;Code class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // first step for (int i = 0; i &amp;lt; A.size(); i++) { // second step if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // third step int result = 0; for (int a : A) result += a; // forth step return result; } }; </description>
    </item>
    <item>
      <title>1005.K次取反后的最大化的数组和</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</guid>
      <description>问题描述 1005.K次取反后最大化的数组和&#xA;解题思路 贪心算法&#xA;代码 class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // 第一步 for (int i = 0; i &amp;lt; A.size(); i++) { // 第二步 if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步 int result = 0; for (int a : A) result += a; // 第四步 return result; } }; </description>
    </item>
    <item>
      <title>45.jump game ii</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii/</guid>
      <description>Description 45.jump-game-ii&#xA;Solution In outer loop, we traverse from back to front, while in inner loop, we traverse from front to back, to find the station with minimum index that can arrive at destination. Make the station the new destination, and cnt++.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>45.跳跃游戏II</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</guid>
      <description>问题描述 45.跳跃游戏II&#xA;解题思路 外循环还是从末尾向前遍历，内循环从前往后遍历，每次找能到达终点的索引最小的位置，该位置作为新的终点，同时步数cnt++。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.size(); i++) { if (nums[i] + i &amp;gt;= cur_end) { cur_end = i; cnt++; break; } } } return cnt; } }; </description>
    </item>
    <item>
      <title>55.jump game</title>
      <link>http://localhost:1313/posts/leet/55.jump-game/</link>
      <pubDate>Sun, 30 Oct 2022 16:04:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game/</guid>
      <description>Description 55.jump-game&#xA;Solution Traversing from back to front, if nums[j] can be achieved from nums[j - 1] or nums in the front, then destination change from nums[j] to nums[j - 1] or num in the front.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r !</description>
    </item>
    <item>
      <title>55.跳跃游戏</title>
      <link>http://localhost:1313/posts/leet/55.jump-game.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:03:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game.zh/</guid>
      <description>问题描述 55.跳跃游戏&#xA;解题思路 从后向前遍历，只要nums[j]能由nums[j - 1]或者更前面的点跳到，那么终点就从nums[j]变成nums[j - 1]或更前面的点。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r != 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>72.edit distance</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance/</guid>
      <description>Description 72.edit-distance&#xA;Solution It&amp;rsquo;s easy to consider what dp[i][j] should denotes.&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else, we can consider in three cases: replace the word1[i - 1]: dp[i][j] = dp[i - 1][j - 1] + 1; remove word1[i - 1]: dp[i][j] = dp[i - 1][j] + 1; insert word2[j - 1] between word[i - 1] and word[i], it&amp;rsquo;s the same as remove word2[j - 1]: dp[i][j] = dp[i][j - 1] + 1; We should also pay attention to the initialzation of dp[i][j].</description>
    </item>
    <item>
      <title>72.编辑距离</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance.zh/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance.zh/</guid>
      <description>问题描述 72.编辑距离&#xA;解题思路 dp[i][j]的含义不再赘述:&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else,分为三种操作情况: 替换末尾字符: dp[i][j] = dp[i - 1][j - 1] + 1; 删除word1的第i个字符: dp[i][j] = dp[i - 1][j] + 1; 删除word2的第j个字符，即相当于在第i个字符后插入word2[j - 1]: dp[i][j] = dp[i][j - 1] 代码 class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 1; i &amp;lt;= word1.</description>
    </item>
    <item>
      <title>583.delete operations for two strings</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</guid>
      <description>Description 583.delete-operation-for-two-strings&#xA;Solution dp[i][j] denotes minimum number of options to make strings the same when considering the first i characters of word1 and the first j characters of word2.&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; Code class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.</description>
    </item>
    <item>
      <title>583.两个字符串的删除操作</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</guid>
      <description>问题描述 583.两个字符串的删除操作&#xA;解题思路 dp[i][j]表示对word1的前i个字符，word2的前j个字符，使得它们相同的最小步数:&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; 代码 class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 0; i &amp;lt;= word1.size(); i++) { dp[i][0] = i; } for (int j = 0; j &amp;lt;= word2.</description>
    </item>
    <item>
      <title>115.distinct subsequences</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences/</guid>
      <description>Description 115.distinct-subsequence&#xA;Solution dp[i][j] denotes the occurrences of the first j characters of t in the first i characters of s:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(uses[i - 1] and not use s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; Code class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>115.不同的子序列</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</guid>
      <description>问题描述 115.不同的子序列&#xA;解题思路 dp[i][j]表示考虑考虑t的前j个字符在s的前i个字符中的出现个数:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(表示使用s[i - 1]匹配和不使用s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; 代码 class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;uint32_t&amp;gt;(t.size() + 1, 0)); // dp[0][0] = 1; for (int i = 0; i &amp;lt;= s.size(); i++) { dp[i][0] = 1; } for (int i = 1; i &amp;lt;= s.</description>
    </item>
    <item>
      <title>392.is subsequence</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence/</guid>
      <description>Description 392.is-subsequence&#xA;Solution It&amp;rsquo;s similar to 1143.longest-common-subsequence. We just need to judge whether the result is equal to s.size().&#xA;Code class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>392.判断子序列</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence.zh/</guid>
      <description>问题描述 392.判断子序列&#xA;解题思路 与1143.最长公共子序列基本一样，只需要再判断结果是否和s.size()相等就好了。&#xA;代码 class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>53.maximum subarray</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray/</link>
      <pubDate>Sun, 30 Oct 2022 14:30:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray/</guid>
      <description>Description 53.maximum-subarray&#xA;Solution dp[i] denotes maximum sum of subarray ending with nums[i - 1], then: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;Code class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>53.最大子数组和</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</guid>
      <description>问题描述 53.最大子数组和&#xA;解题思路 动态规划 令dp[i]表示以nums[i - 1]结尾的连续子数组的最大和，则: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;贪心算法 以第一个正数为起点，开始记录和sum_temp，同时记录最大和sum，当sum_temp小于0时，起点变为新的正数。&#xA;代码 class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>1035.uncrossed lines</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines/</link>
      <pubDate>Sat, 29 Oct 2022 20:45:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines/</guid>
      <description>Description 1035.uncrossed-lines&#xA;Solution The same as 1143.longest-common-subsequence&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1035.不相交的线</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:44:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</guid>
      <description>问题描述 1035.不相交的线&#xA;解题思路 只是1143.最长公共子序列的另一种描述&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1143.longest common subsequence</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</guid>
      <description>Description 1143.longest-common-subsequence&#xA;Solution dp[i][j] denotes the length of longest common subsequence of first i characters of text1 and first j characters of text2:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.</description>
    </item>
    <item>
      <title>1143.最长公共子序列</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</guid>
      <description>问题描述 1143.最长公共子序列&#xA;解题思路 dp[i][j]表示text1的前i个字符和text2的前j个字符里最长公共子序列长度:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); 代码 #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.size() + 1, vector&amp;lt;int&amp;gt;(text2.size() + 1, 0)); int m = 0; int res = 0; for (int i = 1; i &amp;lt;= text1.</description>
    </item>
    <item>
      <title>134.gas station</title>
      <link>http://localhost:1313/posts/leet/134.gas-station/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station/</guid>
      <description>Description 134.gas-station&#xA;Solution We should consider total oil consumption total_oil, and remaining oil from new start station cur_oil(not replenish oil in new station):&#xA;total_oil &amp;lt; 0, can&amp;rsquo;t complete; cur_oil &amp;lt; 0, start at the new station; Code class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //total_oil need &amp;gt; 0, or can&amp;#39;t complete total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // start from i + 1 starting_station = i + 1; // restore to first state cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
    <item>
      <title>134.加油站</title>
      <link>http://localhost:1313/posts/leet/134.gas-station.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station.zh/</guid>
      <description>问题描述 134.加油站&#xA;解题思路 考虑两个变量，一个是总油耗total_oil，一个是从起点到下一个站点后汽车内部剩余的汽油cur_oil(没有在目标站点补充油耗)。 总油耗total_oil &amp;lt; 0，说明不可能到; cur_oil &amp;lt; 0，则以到达的站点作为新的起点再出发;&#xA;代码 class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //总和必须大于等于0，否则不能完成绕行 total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // 一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。 starting_station = i + 1; // 还原到初始状态 cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
    <item>
      <title>718.maximum length of repeated subarray</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</guid>
      <description>Description 718.maximum-length-of-repeated-subarray&#xA;Solution dp[i][j] denotes the length of longest public subarray of two subarray ending with nums1[i - 1], nums2[j - 1];&#xA;Recurrence formula&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; Code class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.</description>
    </item>
    <item>
      <title>718.最长重复子数组</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</guid>
      <description>问题描述 718.最长重复子数组&#xA;解题思路 dp[i][j]表示分别以nums1[i - 1], nums2[j - 1]结尾的两个子数组的最长公共子数组的长度；&#xA;递推关系:&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; 代码 class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) // dp[i][j] = max(dp[i - 1][j - 1] + 1, dp[i][j]); dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] &amp;gt; m) m = dp[i][j]; } } return m; } }; </description>
    </item>
    <item>
      <title>674.longest continuous increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</guid>
      <description>Description 674.longest-continuous-increasing-subsequence&#xA;Solution dp[i] denotes the length of longest continuous increasing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; Code class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>674.最长连续递增序列</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</guid>
      <description>问题描述 674.最长连续递增序列&#xA;解题思路 dp[i]表示以nums[i - 1]结尾的最长连续递增子序列长度;&#xA;递推关系为:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; 代码 class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>300.longest increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</guid>
      <description>Description 300.longest-increasing-subsequence&#xA;Solution The key point is: what dp[i] means is conducive to solving this problem. Since subsequence may be not continuous, dp[i] should denotes maximum length increaing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; i dp[i] = max(dp[j] + 1, dp[i]) Code class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // initialize dp[i] as 1 since there is one element at least // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>300.最长递增子序列</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</guid>
      <description>问题描述 300.最长递增子序列 本题简写为LIS问题，与LCS问题（最长公共子序列）相对。&#xA;解题思路 动态规划 关键在于，dp[i]表示什么含义便于解这道题，子序列不一定连续，所以为了便于求解，dp[i]应该表示为以nums[i - 1]结尾的最长严格递增子序列的长度；&#xA;递推关系为:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; i，表示nums[i - 1]前的任意一个元素 dp[i] = max(dp[j] + 1, dp[i]) 贪心 动态规划的时间复杂度为$O(n^2)$，这里存在一个时间复杂度更低的贪心解法：&#xA;动态规划的时间$O(n^2)$的时间复杂度中，$O(n)$的时间复杂度在与遍历整个数组，这是无法避免的；剩下的$O(n)$的时间复杂度，实际上在找一个满足j &amp;lt; i以及nums[j] &amp;lt; nums[i]的并且使dp[j]最大的j；&#xA;那么，可以转化为找dp[j]固定的情况下，最小的一个nums[j]，这样必然能够优先满足，nums[i] &amp;gt; nums[j]；因此我们构造一个贪心数组：min_len，min_len[i] = x表示长度为i的上升子序列的最小结尾元素为x。考虑到min_len一定是个单调递增的数组（易证），那么我们可以基于这个单调递增的特性，利用二分查找，找到满足min_len[j] &amp;lt; nums[i]的最大的j，即利用$O(\log n)$找到最佳转移位置。&#xA;代码 动态规划 class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // dp[0]不考虑，至少有一个元素，所以初始化为1 // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>714.买卖股票的最佳时机含手续费</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</guid>
      <description>问题描述 714.买卖股票的最佳时机含手续费&#xA;解题思路 分为手中有股票和无股票两种情况讨论，设定在卖出股票时支出手续费:&#xA;手中有股票:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); 手中无股票:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); 初始化:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; 代码 class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); dp[0][0] = -prices[0]; dp[0][1] = -fee; for (int i = 1; i &amp;lt;= prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); } return dp[prices.</description>
    </item>
    <item>
      <title>714.best time to buy and sell stock with transaction fee</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</guid>
      <description>Description 714.best-time-to-buy-and-sell-stock-with-transaction-fee&#xA;解题思路 We can consider this problem in two cases: owning stock and not owning stock, assuming that you need to pay transaction fee when selling stock.&#xA;owning stock:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); not owning stock:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); Initializing dp:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; Code class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>309.best time to buy and sell stock with cooldown</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>Description 309.best-time-to-buy-and-sell-stock-with-cooldown&#xA;Solution The key point is find what dp should denote and its recurrence formula.&#xA;dp[i] indicates only considering first i days, and is devided into five cases: no operation, bought but not sold (stock in hand), exactly sold, cooling off period, and idle, which are noted as dp[i][0], dp[i][1], dp[i][2], dp[i][3], and dp[i][4] correspondingly.&#xA;Recurrence formula:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // last day can be on operation, bought but not sold, cooling off period, idle dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // last day can be cooling off period adn idle.</description>
    </item>
    <item>
      <title>309.最佳买卖股票时机含冷冻期</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</guid>
      <description>问题描述 309.最佳买卖股票时机含冷冻期&#xA;解题思路 本题的关键在于找到dp的实际含义，以及它的递推关系; dp[i]表示只考虑前i天的情况，分为无操作、买入未卖出(手中有股票)、正好卖出、冷静期、空闲五种情况，分别记为dp[i][0], dp[i][1], dp[i][2], dp[i][3], dp[i][4].&#xA;递推关系如下:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // 上一天的可能情况有无操作、买入未卖出、冷静期、空闲四种情况 dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // 上一天可能有冷静期和空闲两种情况 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max3(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ?</description>
    </item>
    <item>
      <title>solve the problem of downloading assets from github</title>
      <link>http://localhost:1313/posts/leet/webots_assets_dl/</link>
      <pubDate>Thu, 13 Oct 2022 21:38:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/webots_assets_dl/</guid>
      <description>Description After version 2021a, in order to reduce the file size, Webots set resource files such as textures and sounds up for network download by github. However, for well-known reasons, github is very inaccessible in China, so there will be errors like:&#xA;ERROR: Error downloading EXTERNPROTO &amp;#39;StraightStairs&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/objects/stairs/protos/StraightStairs.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;Spot&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/robots/boston_dynamics/spot/protos/Spot.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;Roughcast&amp;#39;: Cannot download &amp;#39;https://raw.</description>
    </item>
    <item>
      <title>解决webots无法从github下载外部资源的问题</title>
      <link>http://localhost:1313/posts/leet/webots_assets_dl.zh/</link>
      <pubDate>Thu, 13 Oct 2022 10:25:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/webots_assets_dl.zh/</guid>
      <description>问题描述 Webots在2021a版本后，为了缩小文件大小，将纹理、声音等资源文件设置成网络下载，即需要通过github进行下载，然而由于众所周知的原因，github在国内的可访问性非常差，因此会出现&#xA;ERROR: Error downloading EXTERNPROTO &amp;#39;StraightStairs&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/objects/stairs/protos/StraightStairs.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;Spot&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/robots/boston_dynamics/spot/protos/Spot.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;Roughcast&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/appearances/protos/Roughcast.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;ThreadMetalPlate&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/appearances/protos/ThreadMetalPlate.proto&amp;#39;, error code: 1: Connection refused 即无法从github上把资源文件下载下来。&#xA;解决方案 webots的preferences中有关于代理的设置(这也就是为什么系统代理没有生效)，点击preferences-&amp;gt;network，在proxy那一栏，勾选SOCKS v5, Hostname填入127.0.0.1，Port填入7890。 注:首先你自己的电脑要有代理，端口(Port)与你自己的设置有关系。</description>
    </item>
    <item>
      <title>123.买卖股票的最佳时机III</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</link>
      <pubDate>Wed, 12 Oct 2022 20:04:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</guid>
      <description>问题描述 123.买卖股票的最佳时机III&#xA;解题思路 本题的关键在于找到dp的实际含义，以及它的递推关系;&#xA;dp[i]表示只考虑前i天的情况，那么到了第i天，有五种可能的情况:&#xA;没有做任何操作，记为dp[i][0]; 前i天发生了一次买入，记为dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) 前i天发生了一次卖出，记为dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) 前i天发生了两次买入，记为dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) 前i天发生了两次卖出，记为dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) 初始化:&#xA;dp[0][0] = 0; dp[0][1] = -prices[0]; // 发生了一次买入 dp[0][2] = 0; // 买入又卖出 dp[0][3] = -prices[0]; // 买入-&amp;gt;卖出-&amp;gt;买入 dp[0][4] = 0; // 买入-&amp;gt;卖出-&amp;gt;买入-&amp;gt;卖出 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>122.best time to buy and sell stock ii</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sat, 08 Oct 2022 08:14:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Description 122.best-time-to-buy-and-sell-stock-ii&#xA;Solution The key point of this problem is to find the recurrence formula of dp[i]. Let&amp;rsquo;s discuss this problem in two cases.&#xA;if prices[i - 1] is not selected, then dp[i] = dp[i - 1]. It shows that: prices[i - 1] &amp;lt; prices[i - 2]; if prices[i - 1] is selected, then prices[i - 1] &amp;gt;= prices[i - 2], dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2].</description>
    </item>
    <item>
      <title>122.买卖股票的最佳时机II</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</guid>
      <description>问题描述 122.买卖股票的最佳时机II&#xA;解题思路 本题的关键是要找dp的递推关系，分两种情况讨论:&#xA;prices[i - 1]不会被选择，那么dp[i] = dp[i - 1]，其实也说明，prices[i - 1] &amp;lt; prices[i - 2]； prices[i - 1]被选择，那么prices[i - 1] &amp;gt;= prices[i - 2]，dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]。 代码 class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.size() == 1) return 0; vector&amp;lt;int&amp;gt; dp(prices.size() + 1, 0); for (int i = 2; i &amp;lt;= prices.size(); i++) { if (prices[i - 1] &amp;gt;= prices[i - 2]) dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]; else dp[i] = dp[i - 1]; } return dp[prices.</description>
    </item>
    <item>
      <title>123.best time to buy and sell stock iii</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</guid>
      <description>Description 123.best-time-to-buy-and-sell-stock-iii&#xA;Solution The key point is to find what dp should denotes and the recursion formula:&#xA;dp[i] denotes only considering first i days, then by day i, there are five possible cases:&#xA;no operation, written as dp[i][0]; buy stock once in first i days, written as dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) sell stock once in first i days, written as dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) by stock twice in first i days, written as dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) sell stock twice in first i days, written as dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) Initializaiton:</description>
    </item>
    <item>
      <title>121.best time to buy and sell stock</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 07 Oct 2022 16:34:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</guid>
      <description>Description 121.best-time-to-buy-and-sell-stock&#xA;Solution dynamic programming dp[i] denotes maximum profit in first i days, so the recurrence relation of dp[i] is: dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0).&#xA;greedy algorithm Let&amp;rsquo;s use cur to record the minimum element and replace the value of cur if the element is smaller, if the element is larger than cur, calculate the profit, save the maximum profit.&#xA;Code class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>121.买卖股票的最佳时机</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</link>
      <pubDate>Fri, 07 Oct 2022 16:33:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</guid>
      <description>问题描述 121.买卖股票的最佳时机&#xA;解题思路 动态规划 dp[i]表示前i天的最大收益，那么dp[i]的递推公式为:dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0)。&#xA;贪心算法 利用cur记录最小元素，碰到更小的就替换cur的值，遇到比它大的就进行一次利润计算，保存最大的利润。&#xA;代码 class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } int max(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ? a : c; else return b &amp;gt; c ? b : c; } public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.</description>
    </item>
    <item>
      <title>337.打家劫舍III</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</guid>
      <description>问题描述 337.打家劫舍III&#xA;解题思路 严格来说，这一题和198.打家劫舍，213.打家劫舍II的思路并不一致。&#xA;首先，这一道题遍历的是树，而不是一个数组。要比较的是选择目前节点和目前节点左子节点+右子节点，因此在遍历方式上需要采取后序遍历。&#xA;同时，作为二叉树的问题，一般是考虑递归进行处理：&#xA;递归的终止条件： 当前节点为空； 递归函数的返回值： 返回一个长度为2的数组dp，dp[0]表示不偷当前节点的最大金钱，dp[1]表示偷当前节点的最大金钱； 本级递归做什么： 计算偷当前节点的收益val1，不偷当前节点的收益val2，返回{val2, val1}。 代码 class Solution { public: int rob(TreeNode* root) { vector&amp;lt;int&amp;gt; result = robTree(root); return max(result[0], result[1]); } // 长度为2的数组，0：不偷，1：偷 vector&amp;lt;int&amp;gt; robTree(TreeNode* cur) { if (cur == NULL) return vector&amp;lt;int&amp;gt;{0, 0}; vector&amp;lt;int&amp;gt; left = robTree(cur-&amp;gt;left); vector&amp;lt;int&amp;gt; right = robTree(cur-&amp;gt;right); // 偷cur，那么就不能偷左右节点。 int val1 = cur-&amp;gt;val + left[0] + right[0]; // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况 int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; } }; </description>
    </item>
    <item>
      <title>337.house robber iii</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii/</guid>
      <description>Description 337.house-robber-iii&#xA;Solution Strictly speaking, the idea of this problem is different from 198.house-robber，213.house-robber-ii.&#xA;At first, what this problem need to traverse is tree, rather than an array. We need to compare selecting curent node with selecting left-child node and right-child node rather than current node. So, we should select postorder traversal.&#xA;And as a problem of binary tree, we consider recursion.&#xA;termination conditions of recursion current node is null; return value of recursion function return an array dp of length 2, dp[0] denotes maximum amount when not stealing current node, dp[1] denotes maximum amount when stealing current node; what this level of recursion does calculate the amount val1 when stealing current node, val2 for not stealing current node, return {val2, val1}.</description>
    </item>
    <item>
      <title>213.house robber ii</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii/</guid>
      <description>Description 213.house-robber-ii&#xA;Solution Referring to 198.house-robber, there be another constraint that first and last can&amp;rsquo;t be selected at the same time. So we can split the array into two part: one for [0, n - 1), another for [1, n), corresponding to dp0 and dp1 respectively, just return max(dp0, dp1).&#xA;Code class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.</description>
    </item>
    <item>
      <title>213.打家劫舍II</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</guid>
      <description>问题描述 213.打家劫舍II&#xA;解题思路 参照198.打家劫舍，但是这里多了一个首尾不能同时选择的选项，因此可以考虑将数组分成两部分，一个包含[0, n - 1)，一个包含[1, n)，分别对应dp0和dp1，取最后两者的最大值即可。&#xA;代码 class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.size() - 2); int result2 = robRange(nums, 1, nums.size() - 1); return max(result1, result2); } int robRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int end) { if (end == start) return nums[start]; vector&amp;lt;int&amp;gt; dp(nums.size()); dp[start] = nums[start]; dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i &amp;lt;= end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; } }; </description>
    </item>
    <item>
      <title>198.house robber</title>
      <link>http://localhost:1313/posts/leet/198.house-robber/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber/</guid>
      <description>Description 198.house-robber&#xA;Solution dp[i] denotes the maximum amount when the first i houses are considered.&#xA;Let&amp;rsquo;s consider the recursive relationship:&#xA;If the i-th house was stolen, it means that the i - 1th house was not stolen, so dp[i] = dp[i - 2] + a[i - 1]. If the i-th house was not stolen, then dp[i] = dp[i - 1]. So, dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]).</description>
    </item>
    <item>
      <title>198.打家劫舍</title>
      <link>http://localhost:1313/posts/leet/198.house-robber.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber.zh/</guid>
      <description>问题描述 198.打家劫舍&#xA;解题思路 dp[i]表示考虑前i个房间，能窃取到的最大金额。&#xA;考虑递推关系:&#xA;假设第要窃取第i个房间，那么说明第i - 1个房间，肯定没有被窃取，dp[i] = dp[i - 2] + nums[i - 1]。 假设不窃取第i个房间，则dp[i] = dp[i - 1]。 综上，dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1])。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int rob(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); if (nums.size() == 1) return nums[0]; if (nums.</description>
    </item>
    <item>
      <title>139.word Break</title>
      <link>http://localhost:1313/posts/leet/139.word-break/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break/</guid>
      <description>Description 139.word-break&#xA;Solution First, we should determine what dp array means. In this problem, dp[i] = 1 denotes that a string of length i can be split into words that appear in the dictionary.&#xA;So, we can get the recursive relationship:dp[j] = dp[i] &amp;amp;&amp;amp; substr in [i, j) can be split.&#xA;To initialize dp array: dp[0] = 1.&#xA;Attention: we should traverse volume first, then traverse items; if in the reverse order, it&amp;rsquo;s not convenient to judge whether string can be split.</description>
    </item>
    <item>
      <title>139.单词拆分</title>
      <link>http://localhost:1313/posts/leet/139.word-break.zh/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break.zh/</guid>
      <description>问题描述 139.单词拆分&#xA;解题思路 首先确定dp数组的含义，dp[i] = 1应该表示长度为i的字符串，可以拆分成字典中出现的单词;&#xA;则，dp的递推公式为:dp[j] = dp[i] &amp;amp;&amp;amp; [i, j]区间的字串可以拆分成字典中的单词&#xA;初始化dp数组:dp[0] = 1。&#xA;这里要注意，先遍历体积，再遍历物品；如果倒过来，是不方便判断字串是否可以拆分的。&#xA;代码 #include &amp;lt;string&amp;gt; #include &amp;lt;unordered_set&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::unordered_set; using std::vector; class Solution { public: bool wordBreak(string s, vector&amp;lt;string&amp;gt; &amp;amp;wordDict) { unordered_set&amp;lt;string&amp;gt; wordSet(wordDict.begin(), wordDict.end()); vector&amp;lt;int&amp;gt; dp(s.length() + 1, 0); // 0 为false dp[0] = 1; // 先遍历体积，再遍历物品 for (int j = 0; j &amp;lt;= s.length(); j++) { for (int i = 0; i &amp;lt;= j; i++) { string word = s.</description>
    </item>
    <item>
      <title>279.perfect Squares</title>
      <link>http://localhost:1313/posts/leet/279.perfect-squares/</link>
      <pubDate>Wed, 05 Oct 2022 17:07:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/279.perfect-squares/</guid>
      <description></description>
    </item>
    <item>
      <title>279.完全平方数</title>
      <link>http://localhost:1313/posts/leet/279.perfect-squares.zh/</link>
      <pubDate>Wed, 05 Oct 2022 17:07:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/279.perfect-squares.zh/</guid>
      <description>问题描述 279.完全平方数&#xA;解题思路 本题可以转化成一个完全背包问题，“物品”即{1, 4, 9, 16,...}等完全平方数，体积限制即所给的整数$n$。&#xA;代码 class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } public: int numSquares(int n) { int num = 1; for (int i = 1; i * i &amp;lt;= n; i++) num = i; vector&amp;lt;int&amp;gt; nums(num, 0); for (int i = 0; i &amp;lt; num; i++) // nums[i] &amp;lt;= n nums[i] = (i + 1) * (i + 1); vector&amp;lt;int&amp;gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; num; i++) { for (int j = nums[i]; j &amp;lt;= n; j++) { if (dp[j - nums[i]] &amp;lt; INT_MAX) dp[j] = min(dp[j], dp[j - nums[i]] + 1); } } return dp[n]; } }; </description>
    </item>
    <item>
      <title>322.coin change</title>
      <link>http://localhost:1313/posts/leet/322.coin-change/</link>
      <pubDate>Wed, 05 Oct 2022 03:53:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change/</guid>
      <description>Description 322.coin-change&#xA;Solution The recursive relationship change from max to min: dp[j] = min(dp[j], dp[j - coins[i]] + 1).&#xA;We need pay attention to issue about initializing dp array. To ensure that if j - coins[i] can&amp;rsquo;t be come up with, dp[j] is still dp[j] in last loop, we should initialize dp as INT_MAX, and dp[0] = 0.&#xA;Attention: INT_MAX + 1 &amp;lt; INT_MAX(in C++)&#xA;Code #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>322.零钱兑换</title>
      <link>http://localhost:1313/posts/leet/322.coin-change.zh/</link>
      <pubDate>Wed, 05 Oct 2022 03:52:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change.zh/</guid>
      <description>问题描述 322.零钱兑换&#xA;解题思路 首先，递推关系从最大变成了最小，即dp[j] = min(dp[j], dp[j - coins[i]] + 1)。&#xA;同时，要注意对dp数组的初始化问题，为了保证j - coins[i]无法组成时，dp[j]选择的仍是上一次i循环的dp[j]，因此要将dp数组初始化为INT_MAX，同时dp[0] = 0。&#xA;要注意INT_MAX + 1 &amp;lt; INT_MAX(在C++中)&#xA;代码 #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } public: int coinChange(vector&amp;lt;int&amp;gt; &amp;amp;coins, int amount) { if (amount == 0) return 0; vector&amp;lt;int&amp;gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; coins.</description>
    </item>
    <item>
      <title>377.combination sum iv</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv/</guid>
      <description>Description 377.combination-sum-iv&#xA;Solution This problem is still a unbounded-knapsack-problem, however, what this problem want to get is permutations rather than combinations.&#xA;With reference to 518.coin-change-ii, traverse volume first, than traverse items.&#xA;代码 class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // prevent overflow, not dp[j] + dp[j - nums[i]] &amp;lt; INT_MAX if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>377.组合总和IV</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</guid>
      <description>问题描述 377.组合总和IV&#xA;解题思路 本题依旧是一个完全背包问题，但是本题求的是排列而非组合。&#xA;参考518.零钱兑换II，先遍历体积，再遍历物品。&#xA;代码 class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // 防止溢出 if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>518.coin change ii</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii/</guid>
      <description>Description 518.coin-change-ii&#xA;Solution This problem is still a unbounded-knapsack-problem. What this problem need to solve is combination rather than combination.&#xA;If we want to get the number of combination, we should traverse items first, than traverse volume. But if you want to get the number of permutation, you should traverse volume first, than traverse items.&#xA;For example, assume that nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2, combnations: {1, 1, 1}, {1, 2}.</description>
    </item>
    <item>
      <title>518.零钱兑换II</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</guid>
      <description>问题描述 518.零钱兑换II&#xA;解题思路 本题依旧是一个完全背包问题，但是本题求的是组合而非排列。&#xA;求组合时，先遍历物品，再遍历体积；求排列时，则是先遍历体积，再遍历物品。&#xA;例如：假设nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2，选择组合方式为{1, 1, 1}, {1, 2}。&#xA;dp[0] = 1; for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; 2; i++) { if (j &amp;gt;= nums[i]) dp[j] = dp[j] + dp[j - nums[i]]; } } dp[3] = 3，选择的排列方式为{1, 1, 1}, {1, 2}, {2, 1}。</description>
    </item>
    <item>
      <title>474.ones and zeroes</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes/</link>
      <pubDate>Wed, 05 Oct 2022 00:34:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes/</guid>
      <description>Description 474.ones-and-zeroes&#xA;Solution This problem can be viewed as a two-dimensional 01-knapsack-problem. There are two-dimensional limits about &amp;ldquo;volume&amp;rdquo;: numbers of $0$ can not exceed $m$ and numbers of $1$ can not exceed $n$.&#xA;Recursive relation: dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ?</description>
    </item>
    <item>
      <title>474.一和零</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:37:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</guid>
      <description>问题描述 474.一和零&#xA;解题思路 本题可以看成一个二维的01背包问题，体积存在两个维度的限制，即$0$的个数不能超过$m$，$1$的个数不超过$n$。&#xA;递推关系:dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;代码 #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: int findMaxForm(vector&amp;lt;string&amp;gt; &amp;amp;strs, int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; str_num(strs.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); for (int i = 0; i &amp;lt; strs.size(); i++) { for (int j = 0; j &amp;lt; strs[i].</description>
    </item>
    <item>
      <title>494.target sum</title>
      <link>http://localhost:1313/posts/leet/494.target-sum/</link>
      <pubDate>Tue, 04 Oct 2022 04:22:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum/</guid>
      <description>Description 494.target-sum&#xA;Solution Actually, what we need to do is choose some numbers whose sum is $\max((sum + target) / 2, (sum - target) / 2)$ in this array. So we can change this problem to a 01-knapsack-problem, and dynamic programming can be used to solve this problem. Also, backtracking can be used to solve this problem.&#xA;In this problem, dp[i][j] should denotes the number of methods to make the sum of number selected to be j when considering the first i numbers.</description>
    </item>
    <item>
      <title>494.目标和</title>
      <link>http://localhost:1313/posts/leet/494.target-sum.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:09:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum.zh/</guid>
      <description>问题描述 494.目标和&#xA;解题思路 本题表面上说添加&amp;rsquo;+&amp;lsquo;或者&amp;rsquo;-&amp;rsquo;，实际上就是在这个数组中选择一些数，使这些数的总和为$\max((sum + target) / 2, (sum - target) / 2)$。从而转换成01背包问题，利用动态规划求解，当然也可以利用回溯法求解。&#xA;在本题中，dp[i][j]应该表示为考虑前i个数时，使选择的数总和为j的方法数。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int findTargetSumWays(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int sum = 0; vector&amp;lt;int&amp;gt; my_num(nums.size() + 1, 0); for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; my_num[i + 1] = nums[i]; } if ((sum + target) % 2 == 1) return 0; vector&amp;lt;int&amp;gt; res(1001, 0); res[0] = 1; target = max((sum + target) / 2, (sum - target) / 2); // int cnt = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>1049.last stone weight ii</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</link>
      <pubDate>Sat, 01 Oct 2022 19:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</guid>
      <description>Description 1049.last-stone-weight-ii&#xA;Solution In reality, it&amp;rsquo;s still a 01-pack-problem.&#xA;What it want to get is when you divide the array into two part with least difference of their sum, what the difference is. If you are aware of this, just write code similar to 416.partition-equal-subset-sum.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.</description>
    </item>
    <item>
      <title>1049.最后一块石头的重量II</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:22:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</guid>
      <description>问题描述 1049.最后一块石头的重量II&#xA;解题思路 实际上还是一个01背包问题。本质上是在求将数组分成差值最小的两部分之后，这两部分的差值，理解了这一点之后，参照416.分割等和子集写代码就好了。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.size(); i++) { sum += stones[i]; } vector&amp;lt;int&amp;gt; dp(sum / 2 + 1, 0); for (int i = 0; i &amp;lt; stones.size(); i++) { for (int j = sum / 2; j &amp;gt;= stones[i]; j--) dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); } return sum - 2 * dp[sum / 2]; } }; </description>
    </item>
    <item>
      <title>416.分割等和子集</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</guid>
      <description>问题描述 416.分割等和子集&#xA;解题思路 本题实际上是一个01背包问题，在这个问题中，背包的体积$V$是数组中所有数的的和的一半(向下取整)，物品的价值就是数组中数的取值：&#xA;代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; } if (sum % 2 == 1) return false; sum_half = sum / 2; vector&amp;lt;int&amp;gt; dp(sum_half + 1, 0); for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>416.partition equal subset sum</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</guid>
      <description>Description 416.partition-equal-subset-sum&#xA;Solution This problem can be viewed as one case of 01-pack-problem&#xA;In this problem, the volume of pack $V$ is half of sum of all integers in the array(rounded down), the value of item is just value of integer in the array.&#xA;Code #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>01背包问题</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem.zh/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem.zh/</guid>
      <description>问题描述 01背包问题 有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。&#xA;第$i$件物品的体积是$v_i$，价值是$w_i$，求解将哪些物品装入背包，可使这些物品总体积不超过背包容量，并且总价值最大。&#xA;解题思路 动态规划的经典例题，首先考虑dp[i][j]的含义，这里i表示只考虑前i个物品(i从$1\sim N$)，dp[i][j]表示总体积为j的情况下，考虑前i个物品时，背包里的物品的最大价值。&#xA;可以分成两种情况考虑dp[i][j]的递推关系：&#xA;第i个物品不在背包中时，dp[i][j] = dp[i - 1][j] 此时只有前i - 1个物品，背包中物品体积仍为j。 第i个物品在背包中时，dp[i][j] = dp[i - 1][j - v[i]] + w[i] 前i - 1个物品的体积为j - v[i]。 初始化，显然dp[0][0] = 0。&#xA;根据递推关系和初始化条件写for循环遍历即可。&#xA;代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; const int N = 1010; // 体积不超过1000， 物品件数也不超过1000 int main() { int n, m; // n为物品数量，m为背包体积 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int dp[N][N] = {0}; int v[N] = {0}; // 体积 int w[N] = {0}; // 价值 for (int i = 1; i &amp;lt;=n; i++) cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i]; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { dp[i][j] = dp[i - 1][j]; if (j &amp;gt;= v[i]) // 当前总体积肯定不能小于v[i]，如果小于的话，第i个物品不能放 dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } // int res = 0; // for (int j = 1; j &amp;lt;=m; j++) { // res = max(res, dp[n][j]); // 不需要遍历，直接输出dp[n][m]即可 // } cout &amp;lt;&amp;lt; dp[n][m] &amp;lt;&amp;lt; endl; return 0; } 优化 分析上面的代码，实际上dp[i][j]递推时只会用到dp[i - 1][j]，而不会用到dp[i - 2][j], dp[i - 3][j]等，因此dp数组实际上只需要一维即可，索引为当前总体积。</description>
    </item>
    <item>
      <title>01 kanpsack problem</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem/</guid>
      <description>Description 01-pack-problem&#xA;There are $N$ items and a pack with capacity of $V$, and each item can only be used once.&#xA;The volume of the $i$-th item is $v_i$, and vaule is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen&amp;rsquo;t exceed the capacity of the pack.&#xA;Solution It&amp;rsquo;s a classic problem of dynamic programming.</description>
    </item>
    <item>
      <title>746.min cost climbing stairs</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 16:13:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</guid>
      <description>Description 746.min-cost-climbing-stairs&#xA;Solution It&amp;rsquo;s like 70.climbing-stairs plus, the recursive relationship becomes more complicated, but the essence is the same.&#xA;$$dp_n = \min[dp_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2]]$$&#xA;After get the recursive relationship, we can write traversal code to get the answer using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ?</description>
    </item>
    <item>
      <title>509.fibonacci number</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number/</link>
      <pubDate>Thu, 29 Sep 2022 16:10:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number/</guid>
      <description>Description 509.fibonacci number&#xA;Solution $a_n = a_{n - 1} + a_{n - 2}$.&#xA;Based on the recursive relationship, we can easily write traversal code using for loop.&#xA;Code class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>343.integer break</title>
      <link>http://localhost:1313/posts/leet/343.integer-break/</link>
      <pubDate>Thu, 29 Sep 2022 16:05:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break/</guid>
      <description>Description 343.integer-break&#xA;Solution The key point is still find the recursive relationship.&#xA;Notice that when $n &amp;gt; 4$, $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$.&#xA;So we can easily write traversal code using for loop.&#xA;Code class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>70.climbing stairs</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 15:55:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs/</guid>
      <description>Description 70.climbing-stairs&#xA;Solution Actually, it&amp;rsquo;s the same with 509.fibonacci-number. Let $dp_n$ be the number of ways to get to the top, then we have: $$dp_n = dp_{n - 1} + dp_{n - 2}$$ So we can write the traversal code of for loop.&#xA;Code class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>63.unique paths ii</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii/</link>
      <pubDate>Thu, 29 Sep 2022 15:39:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii/</guid>
      <description>Description 63.unique-paths-ii&#xA;Solution Compared with 62.unique-paths, the main difference is that you need to change $dp_{mn}$ when hitting an obstacle(obstacleGrid[i][j] = 0). Just set dp[i][j] = 0.&#xA;And you need pay attention to judging the conditionality in for loop.&#xA;When i = 0 or j = 0, dp[i][j] = dp[i][j - 1] or dp[i][j] = dp[i - 1][j]. dp[0][0] = 0.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.</description>
    </item>
    <item>
      <title>62.unique paths</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths/</link>
      <pubDate>Thu, 29 Sep 2022 15:28:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths/</guid>
      <description>Description 62.unique-paths&#xA;Solution $dp_{mn}$ means the number of paths from (1, 1) to (m, n). Just find the connection among $dp_{mn}, dp_{(m-1)n}, dp_{m(n-1)}$.&#xA;We have: $$dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$$ Based on the relationship, we can write the traversal code using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>343.整数拆分</title>
      <link>http://localhost:1313/posts/leet/343.integer-break.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:59:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break.zh/</guid>
      <description>题目描述 343.整数拆分&#xA;解题思路 还是寻找递推关系,设$dp_n$为正整数$n$所求的最大乘积。 这里可以注意到:$n &amp;gt; 4$时， $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$。 根据递推关系写出for循环递推求解。&#xA;代码 class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>63.不同路径II</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:55:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</guid>
      <description>题目描述 63.不同路径II&#xA;解题思路 相比62.不同路径II， 主要是多了障碍物地判断，设$obstacleGrid[i][j] = 0$，则$dp_{{i}{j}} = 0$，其余递推关系相同。 注意for循环遍历地过程中的条件判断。当i = 0或j = 0，dp[i][j] = dp[i][j - 1]或dp[i][j] = dp[i - 1][j]。 dp[0][0] = 0。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m, vector&amp;lt;int&amp;gt;(n, 0)); dp[0][0] = 1; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (i == 0 &amp;amp;&amp;amp; j == 0) { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = 1; } else { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else { if (i == 0) dp[i][j] = dp[i][j - 1]; else if (j == 0) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } } return dp[m - 1][n - 1]; } }; </description>
    </item>
    <item>
      <title>62.不同路径</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:51:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths.zh/</guid>
      <description>问题描述 62.不同路径&#xA;解题思路 还是找递推关系： $dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>746.使用最小花费爬楼梯</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:36:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</guid>
      <description>题目描述 746.使用最小花费爬楼梯&#xA;解题思路 相当于爬楼梯的进阶版，递推关系变复杂了一些，但本质没有变。 $a_n = min(a_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2])$ 写出递推关系后就能很方便地写出for循环来遍历求解。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ? cost[0] : cost[1]; for (int i = 2; i &amp;lt;= sz; i++) { // 原始版本 // dp[i] = (dp[i - 2] + cost[i - 2]) &amp;lt; (dp[i - 1] + cost[i - 1]) ?</description>
    </item>
    <item>
      <title>70.爬楼梯</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:56:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</guid>
      <description>题目描述 70.爬楼梯&#xA;解题思路 本质上与斐波那契数是一样的：$a_n = a_{n - 1} + a_{n - 2}$ 构建for循环来遍历。&#xA;代码 class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>509.斐波那契数</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:52:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</guid>
      <description>题目描述 509.斐波那契数&#xA;解题思路 $a_n = a_{n-1} + a_{n-2}$，利用这一递推关系构建for循环即可，实际上只需要容量为2的数组。&#xA;代码 class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>37.sudoku Solver 解数独</title>
      <link>http://localhost:1313/posts/leet/37.sudoku-solver.zh/</link>
      <pubDate>Mon, 26 Sep 2022 15:03:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/37.sudoku-solver.zh/</guid>
      <description>题目描述 链接：37.Sodoku Solver&#xA;解题思路 相比一般的回溯，需要两层for循环，一个处理行，一个处理列，递归的过程来决定，空格处到底填哪个数字； 本递归函数用bool作为返回值类型，要注意返回值在递归中的作用； 另外还有一个判断board是否合规的函数。&#xA;代码 class Solution { private: bool isValid(int row, int col, char val, vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // 判断行里是否重复 if (board[row][i] == val) { return false; } } for (int j = 0; j &amp;lt; 9; j++) { // 判断列里是否重复 if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i &amp;lt; startRow + 3; i++) { // 判断9方格里是否重复 for (int j = startCol; j &amp;lt; startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // 逐行 for (int j = 0; j &amp;lt; 9; j++) { // 逐列 if (board[i][j] !</description>
    </item>
    <item>
      <title>37.解数独</title>
      <link>http://localhost:1313/posts/leet/37.sudoku-solver/</link>
      <pubDate>Mon, 26 Sep 2022 15:03:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/37.sudoku-solver/</guid>
      <description>Description 链接：37.Sodoku Solver&#xA;Solution Compared with usual backtracking, we need for loop of two layers, one for row and another for column. A recursive process is used to determine exactly which number to fill in the space.&#xA;This return type of this function is bool, please pay attention to the role of return value in recursion.&#xA;Also a function to determine whether board is legal is required.&#xA;Code class Solution { private: bool isValid(int row, int col, char val, vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // judge whether there are duplicates in a row if (board[row][i] == val) { return false; } } for (int j = 0; j &amp;lt; 9; j++) { // judge whether there are duplicates in a column if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; // judge whether there are duplicates in ninepin for (int i = startRow; i &amp;lt; startRow + 3; i++) { for (int j = startCol; j &amp;lt; startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // traverse in row for (int j = 0; j &amp;lt; 9; j++) { // traverse in column if (board[i][j] !</description>
    </item>
    <item>
      <title>47.permutations-ii</title>
      <link>http://localhost:1313/posts/leet/47.permutations-ii/</link>
      <pubDate>Sun, 25 Sep 2022 22:05:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/47.permutations-ii/</guid>
      <description>Description 47.permutations-ii&#xA;Solution Compared with 47.permutations, there is interference from duplicate numbers. So we should de-duplicate such as combination-sum-ii&#xA;Judge whether nums[i] is in path by if (used[i] == 1), de-duplicate by if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0).&#xA;Attention: we should sort the array first.&#xA;Code #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; using std::vector; class Solution { private: vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int used[8] = {0}; void track_back(vector&amp;lt;int&amp;gt; nums, int index) { if (path.</description>
    </item>
    <item>
      <title>47.permutations-ii 全排列II</title>
      <link>http://localhost:1313/posts/leet/47.permutations-ii.zh/</link>
      <pubDate>Sun, 25 Sep 2022 22:05:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/47.permutations-ii.zh/</guid>
      <description>问题描述 47.全排列II&#xA;解题思路 相比全排列，多了重复数字的干扰，可以参照带重复数字的组合问题来进行去重:&#xA;if (used[i] == 1)判断nums[i]是否已经在path中，if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0)来进行去重。&#xA;注意，要先对目标数组排序。&#xA;代码 #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; using std::vector; class Solution { private: vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int used[8] = {0}; void track_back(vector&amp;lt;int&amp;gt; nums, int index) { if (path.size() &amp;gt;= nums.size()) { res.push_back(path); return; } for (int i = 0; i &amp;lt; nums.size(); i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0) continue; if (used[i] == 1) continue; path.</description>
    </item>
    <item>
      <title>51.n Queens</title>
      <link>http://localhost:1313/posts/leet/51.n-queens/</link>
      <pubDate>Sun, 25 Sep 2022 21:42:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/51.n-queens/</guid>
      <description>Description 51.n-queens&#xA;Solution Backtracking, please pay attention to how to judge whether chess is in the same diagonal.&#xA;Code class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = &amp;#34;.........&amp;#34;; vector&amp;lt;string&amp;gt; row_str; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; void track_back(int n, int index) { if (index &amp;gt;= n) { res.</description>
    </item>
    <item>
      <title>51.n皇后</title>
      <link>http://localhost:1313/posts/leet/51.n-queens.zh/</link>
      <pubDate>Sun, 25 Sep 2022 21:42:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/51.n-queens.zh/</guid>
      <description>问题描述 51.n皇后&#xA;解题思路 典型的回溯，注意如何判断棋子在同一斜线上。&#xA;代码 class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = &amp;#34;.........&amp;#34;; vector&amp;lt;string&amp;gt; row_str; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; void track_back(int n, int index) { if (index &amp;gt;= n) { res.push_back(row_str); return; } for (int i = 0; i &amp;lt; n; i++) { // i表示在第几列，index表示在第几行 if (col_arr[i] !</description>
    </item>
    <item>
      <title>Leetcode</title>
      <link>http://localhost:1313/posts/leet/_index.zh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leet/_index.zh/</guid>
      <description></description>
    </item>
  </channel>
</rss>
