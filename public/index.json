[{"categories":["tutorial","linux"],"content":" 1 前言入职了某公司，福利待遇不错，就是这开发环境属实一言难尽，开发机部署在内网，没有网络，只能通过内外网交换软件传文件，没有 root 权限（暂无，后面拿到 root 权限我也不敢用来安装什么软件），开发机的系统版本还特别旧，是 2014 年发布的 RHEL 7，上面的软件版本也是老掉牙了（除了没人用的 cmake），令人无语。故这里记录一下我克服困难，在这个 RHEL 7 上配置开发环境的步骤。 注，考虑到安全问题，以及权限受限，软件都安装在 $HOME/.local 目录下，然后设置对应的环境变量，其中 bash 不会去设置环境变量。 整体部署思路如下，利用自己的 VPS 开了一个 CentOS 7 的 docker 镜像，并创建一个与开发机上本人用户一致的用户，并使其 $HOME 目录与开发机的一致，在 CentOS 7 上，通过源码编译安装到 $HOME/.local 目录下，然后将 $HOME/.local 目录拷贝到开发机上，再配置好对应的环境变量，如果再不行，再考虑把源码以及依赖的源码拷贝到开发机上，再进行编译安装。 可以通过执行 ldd ${binary_name} 来查看运行该程序需要哪些动态链接库。 ","date":"2024-08-21","objectID":"/rhel7-dev-env-deploy.zh/:1:0","series":null,"tags":["linux","geek"],"title":"RHEL 7 个人开发环境部署","uri":"/rhel7-dev-env-deploy.zh/#前言"},{"categories":["tutorial","linux"],"content":" 2 软件安装","date":"2024-08-21","objectID":"/rhel7-dev-env-deploy.zh/:2:0","series":null,"tags":["linux","geek"],"title":"RHEL 7 个人开发环境部署","uri":"/rhel7-dev-env-deploy.zh/#软件安装"},{"categories":["tutorial","linux"],"content":" 2.1 GCC执行以下命令即可安装 GCC： sh mkdir src # 安装依赖库 GMP cd $HOME/src wget https://gmplib.org/download/gmp/gmp-6.2.1.tar.xz tar -xvf gmp-6.2.1.tar.xz cd gmp-6.2.1 ./configure --prefix=$HOME/.local make -j$(nproc) make install # 安装依赖库 MPFR cd $HOME/src wget https://www.mpfr.org/mpfr-current/mpfr-4.1.0.tar.xz tar -xvf mpfr-4.1.0.tar.xz cd mpfr-4.1.0 ./configure --prefix=$HOME/.local --with-gmp=$HOME/.local make -j$(nproc) make install # 安装依赖库 MPC cd $HOME/src wget https://ftp.gnu.org/gnu/mpc/mpc-1.2.1.tar.gz tar -xvf mpc-1.2.1.tar.gz cd mpc-1.2.1 ./configure --prefix=$HOME/.local --with-gmp=$HOME/.local --with-mpfr=$HOME/.local make -j$(nproc) make install # 编译安装 GCC cd $HOME/src wget https://ftp.gnu.org/gnu/gcc/gcc-11.2.0/gcc-11.2.0.tar.xz tar -xvf gcc-11.2.0.tar.xz cd gcc-11.2.0 # 下载 GCC 依赖，由于前面已经安装好了依赖，这一步应该是不需要了 ./contrib/download_prerequisites mkdir build cd build ## 配置 GCC 编译 ../configure --prefix=$HOME/.local/gcc-11.2 --disable-multilib --enable-languages=c,c++ --with-gmp=$HOME/.local --with-mpfr=$HOME/.local --with-mpc=$HOME/.local ## 编译并安装 make -j$(nproc) make install ## 设置环境变量，.bashrc 不设置 echo 'export PATH=$HOME/.local/gcc-11.2/bin:$PATH' \u003e\u003e ~/.zshrc echo 'export LD_LIBRARY_PATH=$HOME/.local/lib:$LD_LIBRARY_PATH' \u003e\u003e ~/.zshrc echo 'export LIBRARY_PATH=$HOME/.local/lib:$LIBRARY_PATH' \u003e\u003e ~/.zshrc source ~/.bashrc ","date":"2024-08-21","objectID":"/rhel7-dev-env-deploy.zh/:2:1","series":null,"tags":["linux","geek"],"title":"RHEL 7 个人开发环境部署","uri":"/rhel7-dev-env-deploy.zh/#gcc"},{"categories":["tutorial","linux"],"content":" 2.2 OpenSSL安装 Python 3.10 需要高于 1.11.1 的 OpenSSL，机器上的 OpenSSL 版本太旧了，故重新编译安装。 sh ## 安装 perl-devel wget https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz tar -xzf perl-5.34.0.tar.gz cd perl-5.34.0 ./Configure -des -Dprefix=$HOME/.local/perl5 make make install export PATH=$HOME/.local/perl5/bin:$PATH export PERL5LIB=$HOME/.local/perl5/lib/perl5:$HOME/.local/perl5/lib64/perl5:$PERL5LIB export PERL5LIB=$HOME/.local/perl5/share/perl5:$PERL5LIB cd $HOME/src wget https://github.com/openssl/openssl/releases/download/openssl-3.3.1/openssl-3.3.1.tar.gz tar -zxvf openssl-3.3.1.tar.gz cd openssl-3.3.1 ./config --prefix=$HOME/.local/openssl --openssldir=$HOME/.local/openssl shared zlib make -j$(nproc) make install ## 安装模块，实际上由于前面安装了 perl-devel，故不需要了 cd $HOME/src wget https://cpan.metacpan.org/authors/id/E/EX/EXODIST/Test-Simple-1.302201.tar.gz tar -xvf Test-Simple-1.302201.tar.gz cd Test-Simple-1.302201 ### 安装 ExtUtils::MakeMaker 模块， cd $HOME/src wget https://cpan.metacpan.org/authors/id/B/BI/BINGOS/ExtUtils-MakeMaker-7.70.tar.gz tar -xvf ExtUtils-MakeMaker-7.70.tar.gz cd ExtUtils-MakeMaker-7.70 perl Makefile.PL PREFIX=$HOME/.local/perl5 make make test make install ## 设置环境变量 echo 'export PERL5LIB=$HOME/.local/perl5/share/perl5:$PERL5LIB' \u003e\u003e ~/.bashrc wget https://cpan.metacpan.org/authors/id/E/EX/EXODIST/Test-Simple-1.302201.tar.gz wget https://cpan.metacpan.org/authors/id/B/BI/BINGOS/IPC-Cmd-1.04.tar.gz wget https://cpan.metacpan.org/authors/id/B/BI/BINGOS/Params-Check-0.38.tar.gz wget https://cpan.metacpan.org/authors/id/J/JE/JESSE/Locale-Maketext-Simple-0.21.tar.gz wget https://cpan.metacpan.org/authors/id/B/BI/BINGOS/Module-Load-Conditional-0.74.tar.gz wget https://cpan.metacpan.org/authors/id/B/BI/BINGOS/Module-Load-0.36.tar.gz wget https://cpan.metacpan.org/authors/id/L/LE/LEONT/ExtUtils-ParseXS-3.51.tar.gz wget https://cpan.metacpan.org/authors/id/L/LE/LEONT/version-0.9932.tar.gz ","date":"2024-08-21","objectID":"/rhel7-dev-env-deploy.zh/:2:2","series":null,"tags":["linux","geek"],"title":"RHEL 7 个人开发环境部署","uri":"/rhel7-dev-env-deploy.zh/#openssl"},{"categories":["tutorial","linux"],"content":" 2.3 CMake执行以下命令以编译安装 CMake。 sh wget https://github.com/Kitware/CMake/releases/download/v3.30.2/cmake-3.30.2.tar.gz mv cmake-3.30.2.tar.gz $HOME/src cd $HOME/src tar -xvf cmake-3.30.2.tar.gz cd cmake-3.30.2 ./bootstrap --prefix=$HOME/.local/cmake make -j2 make install ","date":"2024-08-21","objectID":"/rhel7-dev-env-deploy.zh/:2:3","series":null,"tags":["linux","geek"],"title":"RHEL 7 个人开发环境部署","uri":"/rhel7-dev-env-deploy.zh/#cmake"},{"categories":["tutorial","linux"],"content":" 2.4 Python编译安装 Python 3.10 需要用到我们编译安装的 OpenSSL。 ","date":"2024-08-21","objectID":"/rhel7-dev-env-deploy.zh/:2:4","series":null,"tags":["linux","geek"],"title":"RHEL 7 个人开发环境部署","uri":"/rhel7-dev-env-deploy.zh/#python"},{"categories":["tutorial"],"content":" 1 简介与安装Hugo 是一个用 Go 编写的静态网站生成器，可以轻松生成个人博客。 Hugo 安装起来也非常方便，以下是 Hugo 的安装命令： sh brew install hugo # mac sudo apt install hugo # Debian scoop install hugo # windows Windows 推荐使用 scoop 包管理器，非常好用 安装好 Hugo 后，执行 hugo new site blog 就会在当前目录下创建名为 blog 的目录，Hugo 后续将基于该目录中的内容来创建网站。 ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:1:0","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#简介与安装"},{"categories":["tutorial"],"content":" 2 主题配置这里介绍了三个个人比较喜欢的 Hugo 主题的配置方案。读者可以自选其一，我是部署了三个博客网站，当然只有一个能被搜索引擎检索到。 ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:0","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#主题配置"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#papermod"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#安装主题"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#配置文件"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#基础配置"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#杂项配置"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#menu-配置"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#params-配置"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#友链设置"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#添加-latex-支持"},{"categories":["tutorial"],"content":" 2.1 PaperMod 2.1.1 安装主题在 blog 目录下，执行以下命令： sh git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。 如果要更新主题，在 blog 目录下执行 git submodule update --remote --merge 即可。 在 blog/themes/PaperMod 目录下执行 git pull origin master 也可以更新。 2.1.2 配置文件Hugo 读取配置文件非常灵活，既可以把所有配置都写在 blog 目录下的 hugo.toml 或者 config.toml 中，也可以在 blog/config/_default 目录下，将 hugo.toml 配置分成几个配置文件来编写，如下所示： sh blog/config/_default on  main [✘!?] ❯ ls hugo.toml markup.toml menu.zh.toml outputs.toml params.en.toml params.zh.toml privacy.toml hugo.en.toml hugo.zh.toml menu.en.toml minify.toml papermod.yml.bak params.toml permalinks.toml services.toml 2.1.2.1 基础配置在 hugo.toml 中，我们可以写入单配置文件下的 config.toml（后简称 config.toml）中的不属于任何 table 的键值对信息，config.toml 中除 languages 外的 table，都可以单独作为一个配置文件。 toml # blog/config.toml or blog/config/_default/hugo.toml baseURL = \"https://blog.example.com\" # 默认语言为中文，则 xxx.md 与 xxx.zh.md 都会被认为是中文 defaultContentLanguage = \"zh\" # 为 true，则路径为 xxx/zh/posts/；为 false，则为 xxx/posts/ defaultContentLanguageInSubdir = true enableInlineShortcodes = true # 允许使用内联短码 enableEmoji = true # 允许使用 Emoji enableRobotsTXT = false # 允许爬虫抓取到搜索引擎，此处设置不允许 enableGitInfo = true buildDrafts = false buildFuture = false buildExpired = false paginate = 12 # 每页显示的文章数 theme = \"PaperMod\" 而 config.toml 中的 langauges table 中的内容，可以写到对应语言的 hugo.${lang}.toml 中，如 hugo.zh.toml，hugo.en.toml 中。如下所示： toml # config.toml [languages] ## 中文 [languages.zh] languageName = \"简体中文\" title = \"翼仔的博客\" weight = 1 hasCJKLanguage = true toml # hugo.zh.toml weight = 1 # hugo.toml 中 defaultContentLanguage 必须是这些 langaugeCode 中的一项 languageCode = \"zh\" languageName = \"简体中文\" # 在浏览器标签页显示的网站标题 title = \"翼仔\" # whether to include Chinese/Japanese/Korean hasCJKLanguage = true # copyright description used only for seo schema # 版权信息，会显示在页脚，如果不指定 copyright，默认会显示网站标题、hugo、PaperMod # 如果指定了 copyright，则网站标题不会再在页脚显示 # copyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\" 可以看到 config.toml 中的 languages table 与 hugo.zh.toml 的对应关系，[languages.xx] 即对应 langaugeCode = \"xx\"，其他键值对复制过来即可。hugo.en.toml 的处理方法类似。 2.1.3 杂项配置config.toml 中的 markup、outputs、minify、privacy、services、permalinks 这几个 table 类似： toml # config.toml [markup.goldmark.renderer] unsafe = true [minify] disableXML = true [permalinks] # 浏览器链接显示方式 post = \"/:title/\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true toml # makrup.toml [goldmark.renderer] unsafe = true [highlight] noClasses = false codeFences = true guessSyntax = true lineNos = true style = \"monokai\" # minify.toml disableXML = true # outputs.toml home = [\"HTML\", \"RSS\", \"JSON\"] # permalinks.toml post = \"/:title/\" # privacy.toml [vimeo] disabled = false simple = true [twitter] disabled = false enableDNT = true simple = true [instagram] disabled = false simple = true [youtube] disabled = false privacyEnhanced = true # services.toml [instagram] disableInlineCSS = true [twitter] disableInlineCSS = true 2.1.4 menu 配置再然后是 menu table，由于不同语言需要分别设置，故分成 menu.zh.toml 和 menu.en.toml： toml [[languages.zh.menu.main]] identifier = \"search\" name = \"搜索\" url = \"/search/\" weight = 1 [[languages.zh.menu.main]] identifier = \"home\" name = \"主页\" url = \"/\" weight = 2 [[languages.zh.menu.main]] identifier = \"posts\" name = \"文章\" url = \"posts\" weight = 3 [[languages.zh.menu.main]] identifier = \"tags\" name = \"标签\" url = \"tags\" weight = 20 [[languages.zh.menu.main]] identifier = \"archives\" name = \"时间线\" url = \"archives/\" weight = 40 [[languages.zh.menu.main]] identifier = \"about\" name = \"关于\" ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:2:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#设置侧边显示目录"},{"categories":["tutorial"],"content":" 3 部署博客Hugo 博客可以很容易的部署到 Vercel 或者 Netlify 上，二者均免费。 ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:3:0","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#部署博客"},{"categories":["tutorial"],"content":" 3.1 部署至 Vercel首先在 blog/ 目录下创建 vercel.json 文件，添加以下内容： json { \"github\": { \"silent\": true } } 将这个博客项目 push 到 GitHub，然后 Vercel 添加新项目，选择从 Import Git Repository，注意 GitHub App 权限问题，添加该项目，然后 Framework Preset 选择 Hugo，Environment Variables 设置 Key 为 HUGO_VERSION，Value 设置为当前最新 hugo 的版本号。 如下图所示，点击 Deploy 即可： ","date":"2024-08-11","objectID":"/build-site-with-papermod.zh/:3:1","series":null,"tags":["hugo","tips","geek"],"title":"基于 Hugo 搭建个人博客","uri":"/build-site-with-papermod.zh/#部署至-vercel"},{"categories":["notes"],"content":" 1 版本控制系统介绍版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS 通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。 版本控制系统的事实标准是 Git。 Git 的许多操作或者说命令看起来非常奇怪，但 Git 的底层设计与思想非常优雅，因此，从 Git 的数据模型开始学习 Git，自底向上，最后再学习 Git 的接口或者说命令，会比较容易让人理解 Git 的命令以及 Git 是如何操作数据模型的。 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:1:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#版本控制系统介绍"},{"categories":["notes"],"content":" 2 Git 的数据模型Git 将项目的根目录（顶层目录）中的文件夹与文件作为集合，通过这一系列集合的快照来管理项目历史记录。在 Git 的术语中，文件被称为 Blob（数据对象），即一组数据，目录则是被称为 tree。tree 的名称与另一个 tree 又或者文件相对应。 把目录视为 tree，那么子目录就是 subtree，目录下的文件就是 tree 的子节点。 一棵 tree 看起来可能是这样的： txt \u003croot\u003e (tree) | +- foo (tree) | | | + bar.txt (blob, contents = \"hello world\") | +- baz.txt (blob, contents = \"git is wonderful\") ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:2:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#git-的数据模型"},{"categories":["notes"],"content":" 3 Git 历史记录建模：关联快照Git 中的 object 可以分为 blob、tree、commit 三类，每次我们执行 git commit 时，都会创建一个 commit 对象，又或者说对当前的 work directory 的 snapshot。 此后，在本文中不再区分作为名词的 commit 与 snapshot。 在 Git 中，历史记录是一个由 snapshot（commit）组成的有向无环图。Git 中每次 commit 都有一系列的 parent，即当前 commit 之前的一系列 commit，commit 可能有多个 parent，例如当两条分支合并为一条分支时。 以可视化的方式查看这些 commit histories 时，看起来差不多是这样的： txt o \u003c-- o \u003c-- o \u003c-- o ^ \\ --- o \u003c-- o 其中 o 表示一次 commit。箭头指向了当前 commit 的 parent，在第三次 commit 之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的 commit，这个新的 commit 会同时包含这些特性。新的 commit 会创建一个新的历史记录，看上去像这样（最新的合并提交用大写 O 标记）： txt o \u003c-- o \u003c-- o \u003c-- o \u003c---- O ^ / \\ v --- o \u003c-- o Git 中 commit 发生后，该 commit 是不可变的，修改内容会导致新的 commit 产生，而之前的 commit 仍然不变。 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:3:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#git-历史记录建模关联快照"},{"categories":["notes"],"content":" 4 数据模型与伪代码表示以下这段“伪代码”可以更好的理解 Git 的数据模型： txt // 文件就是一组数据 type blob = array\u003cbyte\u003e // 目录可以包含目录，也可以同时包含文件 type tree = map\u003cstring, tree | blob\u003e // 每个 commit 包含该 commit 的 parents，一些元数据，以及顶层目录对应的 tree type commit = struct { parrents: array\u003ccommit\u003e author: string message: string snapshot: tree } ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:4:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#数据模型与伪代码表示"},{"categories":["notes"],"content":" 5 对象与内存寻址Git 中的对象可以是 blob、tree 或 commit： text type object = blob | tree | commit Git 在储存数据时，所有的对象都会基于它们的 SHA-1 哈希 进行寻址。 text objects = map\u003cstring, object\u003e def store(object): id = sha1(object) objects[id] = object def load(id): return objects[id] Blobs、tree 和 commit 都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。 可以执行 git cat-file -p \u003csha-1\u003e 来查看底层数据的表示： 我们首先查看了 commit 的底层数据，可以看到 commit 中存储了 author、commiter、commit-message 等元数据，还存储了顶层目录对应的 tree 的哈希值。 而通过 git cat-file -p aec8d2 则可以查看该 tree 的内容，包含了两个 blob 的哈希值，一个是 animal.py 的，一个是 hello.txt 的。以同样的方案可以查看 blob 的内容： ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:5:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#对象与内存寻址"},{"categories":["notes"],"content":" 6 引用所有的 commit 都可以通过其 SHA-1 哈希值来标记，但使用哈希值非常不方便，针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的 commit），例如 master 引用通常指向主分支的最新一次 commit。 txt references = map\u003cstring, string\u003e def update_reference(name, id): references[name] = id def read_reference(name): return references[name] def load_reference(name_or_id): if name_or_id in references: return load(references[name_or_id]) else: return load(name_or_id) 有一个细节需要我们注意，通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的 snapshot 的时候，我们就可以知道它的相对位置（如何设置它的“parent”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:6:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#引用"},{"categories":["notes"],"content":" 7 仓库 (repository)最后，我们可以粗略地给出 Git 仓库的定义了：对象 和 引用。 也许可以再加上对象的哈希值 在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 git 命令都对应着对 commit-tree 的操作，例如增加对象，增加或删除引用。 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:7:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#仓库-repository"},{"categories":["notes"],"content":" 8 暂存区Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。 就上面介绍的 snapshot 系统来说，您也许会期望它的实现里包括一个“创建 snapshot”的命令，该命令能够基于当前工作目录的当前状态创建一个全新的 snapshot。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的 snapshot，而且每次从当前状态创建 snapshot 可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的 commit，其中第一个 commit 仅包含第一个特性，而第二个提交仅包含第二个 commit。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。 Git 处理这些场景的方法是使用一种叫做“暂存区（staging area）”的机制，它允许您指定下次 snapshot 中要包括那些改动。 git add xxx 就表示将 xxx 文件添加到暂存区，下次执行 git commit 时就会为暂存区的内容创建 snapshot。 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:8:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#暂存区"},{"categories":["notes"],"content":" 9 Git 的命令行接口","date":"2024-06-16","objectID":"/missing-semester-git.zh/:9:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#git-的命令行接口"},{"categories":["notes"],"content":" 9.1 基础 git log --all --graph --decorate --oneline 可以以简洁的有向无环图的方式可视化 Git 历史记录。 git help \u003ccommand\u003e: 获取 git 命令的帮助信息 git init: 创建一个新的 git 仓库，其数据会存放在一个名为 .git 的目录下 git status: 显示当前的仓库状态 git add \u003cfilename\u003e: 添加文件到暂存区 git commit: 创建一个新的提交 如何编写 良好的提交信息! 为何要 编写良好的提交信息 git log: 显示历史日志 git log --all --graph --decorate: 可视化历史记录（有向无环图） git diff \u003cfilename\u003e: 显示与暂存区文件的差异 git diff \u003crevision\u003e \u003cfilename\u003e: 显示某个文件两个版本之间的差异 git checkout \u003crevision\u003e: 更新 HEAD 和目前的分支 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:9:1","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#基础"},{"categories":["notes"],"content":" 9.2 分支和合并 git branch: 显示分支 git branch \u003cname\u003e: 创建分支 git checkout -b \u003cname\u003e: 创建分支并切换到该分支 相当于 git branch \u003cname\u003e; git checkout \u003cname\u003e git merge \u003crevision\u003e: 合并到当前分支 git mergetool: 使用工具来处理合并冲突 git rebase: 将一系列补丁变基（rebase）为新的基线 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:9:2","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#分支和合并"},{"categories":["notes"],"content":" 9.3 远端操作 git remote: 列出远端 git remote add \u003cname\u003e \u003curl\u003e: 添加一个远端 git push \u003cremote\u003e \u003clocal branch\u003e:\u003cremote branch\u003e: 将对象传送至远端并更新远端引用 git branch --set-upstream-to=\u003cremote\u003e/\u003cremote branch\u003e: 创建本地和远端分支的关联关系 git fetch: 从远端获取对象/索引 git pull: 相当于 git fetch; git merge git clone: 从远端下载仓库 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:9:3","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#远端操作"},{"categories":["notes"],"content":" 9.4 撤销 git commit --amend: 编辑提交的内容或信息 git reset HEAD \u003cfile\u003e: 恢复暂存的文件 git checkout -- \u003cfile\u003e: 丢弃修改 git restore: git2.32 版本后取代 git reset 进行许多撤销操作 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:9:4","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#撤销"},{"categories":["notes"],"content":" 10 Git 高级操作 git config: Git 是一个 高度可定制的 工具 git clone --depth=1: 浅克隆（shallow clone），不包括完整的版本历史信息 git add -p: 交互式暂存 git rebase -i: 交互式变基 git blame: 查看最后修改某行的人 git stash: 暂时移除工作目录下的修改内容 git bisect: 通过二分查找搜索历史记录 .gitignore: 指定 故意不追踪的文件 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:10:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#git-高级操作"},{"categories":["notes"],"content":" 11 杂项 图形用户界面: Git 的 图形用户界面客户端 有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口 Shell 集成: 将 Git 状态集成到您的 shell 中会非常方便。(zsh, bash)。Oh My Zsh这样的框架中一般以及集成了这一功能 编辑器集成: 和上面一条类似，将 Git 集成到编辑器中好处多多。fugitive.vim 是 Vim 中集成 GIt 的常用插件 工作流: 我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例 ( 有很多 不同的 处理方法) GitHub: Git 并不等同于 GitHub。在 GitHub 中您需要使用一个被称作拉取请求（pull request）的方法来向其他项目贡献代码 其他 Git 提供商: GitHub 并不是唯一的。还有像 GitLab 和 BitBucket 这样的平台。 ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:11:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#杂项"},{"categories":["notes"],"content":" 12 资源 Pro Git ，强烈推荐！学习前五章的内容可以教会您流畅使用 Git 的绝大多数技巧，因为您已经理解了 Git 的数据模型。后面的章节提供了很多有趣的高级主题。（Pro Git 中文版）； Oh Shit, Git!?! ，简短的介绍了如何从 Git 错误中恢复； Git for Computer Scientists ，简短的介绍了 Git 的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片； Git from the Bottom Up详细的介绍了 Git 的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看； How to explain git in simple words； Learn Git Branching 通过基于浏览器的游戏来学习 Git； ","date":"2024-06-16","objectID":"/missing-semester-git.zh/:12:0","series":null,"tags":["mit","git"],"title":"计算机教育缺失的一课：Git","uri":"/missing-semester-git.zh/#资源"},{"categories":["notes"],"content":" 1 前言在计算机科学中，很多专业术语或者名词的初始版本都是英文的，之后会被翻译成中文而引入国内。然而，个人看来，许多专业名词的中文翻译，看起来都非常奇怪，反而不如其原始的英文表述好理解，故本文列出笔者常见的一些计算机专业术语以及它的英文版本，以供查阅 ","date":"2024-06-15","objectID":"/cs-zh-en-translation.zh/:1:0","series":null,"tags":["cs"],"title":"计算机常用术语中英文对比","uri":"/cs-zh-en-translation.zh/#前言"},{"categories":["notes"],"content":" 2 术语列表 中文版本 英文版本 个人理解 快照 snapshot 在某个特定时刻，对系统、数据或者文件的状态进行捕捉与记录从而生成的副本，功能上类似备份 会话 session 一段时间内，用户与系统之间的交互或者连接状态 接口 interface 也许可以理解为暴露出来供用户（开发者）调用的函数？ ","date":"2024-06-15","objectID":"/cs-zh-en-translation.zh/:2:0","series":null,"tags":["cs"],"title":"计算机常用术语中英文对比","uri":"/cs-zh-en-translation.zh/#术语列表"},{"categories":["notes"],"content":" 1 任务控制","date":"2024-06-15","objectID":"/missing-semester-command-line.zh/:1:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：命令行环境","uri":"/missing-semester-command-line.zh/#任务控制"},{"categories":["notes"],"content":" 1.1 信号与终止进程shell 会使用 unix 提供的信号机制来进行进程之间的通信，当一个进程接收到信号时，它会停止执行原来的任务、处理该信号、并基于该信号传递的信息来改变任务的执行，可以认为信号是一种 软件中断。 下面这个 python 程序演示了捕获 SIGINT 信号并忽略该信号，即这个程序在收到 SIGINT 信号时，不会终止程序，我们需要使用 SIGQUIT 信号来停止这个程序，可以通过 \u003cC-\\\u003e 来发送该信号。 py #!/usr/bin/env python import signal, time def handler(signum, time): print(\"\\nI got a SIGINT, but I am not stopping\") signal.signal(signal.SIGINT, handler) i = 0 while True: time.sleep(.1) print(\"\\r{}\".format(i), end=\"\") i += 1 运行该程序，向该程序发送两次 SIGINT，然后发送一次 SIGQUIT，程序反应如下： txt zwyyy in 🌐 d3855u in ~/missing-semester 13s ❯ python3 sig.py 28^C I got a SIGINT, but I am not stopping 53^C I got a SIGINT, but I am not stopping 63^\\zsh: quit python3 sig.py 注意 ^ 是我们在终端输入 Ctrl 时的表现形式。 ","date":"2024-06-15","objectID":"/missing-semester-command-line.zh/:1:1","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：命令行环境","uri":"/missing-semester-command-line.zh/#信号与终止进程"},{"categories":["notes"],"content":" 1.2 暂停与后台执行进程信号除了终止进程之外，也可以让进程做其他事情，例如 SIGSTOP 会让进程暂停，在终端中，键入 \u003cC-z\u003e 会让 shell 发送 SIGTSTP 信号（terminal 版本的 SIGSTOP）。 我们可以使用 fg 或者 bg 来恢复暂停的工作，它们分别表示在前台继续或者在后台继续。 jobs 命令会列出当前终端会话中尚未完成的全部任务，可以使用 pid 来引用这些任务（也可以使用 pgrep 来找出 pid）。一种更符合直觉的操作是使用百分号+任务编号（jobs 会打印出任务编号）来选取该任务，可以用 $! 来选择最近一个任务。 在命令中添加 \u0026 后缀可以让命令直接在后台运行，这样就能在 shell 中继续执行其他操作，但是该命令仍会使用 shell 的标准输出，例如 sleep 1000 \u0026。 对于正在运行的前台进程，我们输入 \u003cC-z\u003e，该进程就会被暂停，再输入 bg %\u003c任务编号\u003e 就能让该进程在后台运行。要注意的是，后台运行的进程仍然是当前 shell 的子进程，一旦关闭当前终端（会发送 SIGHUP 信号），这些后台的进程也会被终止，可以使用 nohup 运行进程来防止这种情况（忽略 SIGHUP）。 以下这个简单的会话中展示了上面这些概念的应用： txt $ sleep 1000 ^Z [1] + 18653 suspended sleep 1000 $ nohup sleep 2000 \u0026 [2] 18745 appending output to nohup.out $ jobs [1] + suspended sleep 1000 [2] - running nohup sleep 2000 $ bg %1 [1] - 18653 continued sleep 1000 $ jobs [1] - running sleep 1000 [2] + running nohup sleep 2000 $ kill -STOP %1 [1] + 18653 suspended (signal) sleep 1000 $ jobs [1] + suspended (signal) sleep 1000 [2] - running nohup sleep 2000 $ kill -SIGHUP %1 [1] + 18653 hangup sleep 1000 $ jobs [2] + running nohup sleep 2000 $ kill -SIGHUP %2 $ jobs [2] + running nohup sleep 2000 $ kill %2 [2] + 18745 terminated nohup sleep 2000 $ jobs SIGKILL 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程 ","date":"2024-06-15","objectID":"/missing-semester-command-line.zh/:1:2","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：命令行环境","uri":"/missing-semester-command-line.zh/#暂停与后台执行进程"},{"categories":["notes"],"content":" 2 终端复用器：tmuxtmux 这类的终端多路复用器可以允许我们基于 panes 和 tabs 分割出多个终端窗口（即打开一个 terminal 窗口相当于打开了多个），这样您便可以同时与多个 shell 会话进行交互。 tmux 也允许我们分离当前 session 并在将来重新连接，被分离的 session 内的 shell 不会收到 SIGHUP 信号。 tmux 有三个核心概念： sessions windows panes 这三个概念的层级如上所示。windows 可以理解为浏览器中的 tabs。 tmux 的快捷键需要我们掌握，它们都是类似 \u003cC-b\u003e x 这样的组合，即需要先按下Ctrl+b，松开后再按下 x。tmux 中对象的继承结构如下： 会话 - 每个会话都是一个独立的工作区，其中包含一个或多个窗口 tmux 开始一个新的会话 tmux new -s NAME 以指定名称开始一个新的会话 tmux ls 列出当前所有会话 在 tmux 中输入 \u003cC-b\u003e d ，将当前会话分离 tmux a 重新连接最后一个会话。您也可以通过 -t 来指定具体的会话 窗口 - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分 \u003cC-b\u003e c 创建一个新的窗口，使用 \u003cC-d\u003e关闭 \u003cC-b\u003e N 跳转到第 N 个窗口，注意每个窗口都是有编号的 \u003cC-b\u003e p 切换到前一个窗口 \u003cC-b\u003e n 切换到下一个窗口 \u003cC-b\u003e , 重命名当前窗口 \u003cC-b\u003e w 列出当前所有窗口 面板 - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell \u003cC-b\u003e \" 水平分割 \u003cC-b\u003e % 垂直分割 \u003cC-b\u003e \u003c方向\u003e 切换到指定方向的面板，\u003c方向\u003e 指的是键盘上的方向键 \u003cC-b\u003e z 切换当前面板的缩放 \u003cC-b\u003e [ 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分 \u003cC-b\u003e \u003c空格\u003e 在不同的面板排布间切换 扩展阅读： 这里 是一份 tmux 快速入门教程。 ","date":"2024-06-15","objectID":"/missing-semester-command-line.zh/:2:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：命令行环境","uri":"/missing-semester-command-line.zh/#终端复用器tmux"},{"categories":["notes"],"content":" 3 别名与配置文件","date":"2024-06-15","objectID":"/missing-semester-command-line.zh/:3:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：命令行环境","uri":"/missing-semester-command-line.zh/#别名与配置文件"},{"categories":["notes"],"content":" 3.1 别名当我们在 shell 中执行 alias ll=\"ls -lh\" 后，执行 ll 命令就相当于执行 ls -lh。 txt zwyyy in 🌐 d3855u in ~/missing-semester ❯ ls nohup.out sig.py words.txt zwyyy in 🌐 d3855u in ~/missing-semester ❯ ls -lh total 968K -rw------- 1 zwyyy zwyyy 0 Jun 15 15:29 nohup.out -rw-r--r-- 1 zwyyy zwyyy 246 Jun 15 15:39 sig.py -rw-r--r-- 1 zwyyy zwyyy 962K Jun 15 14:55 words.txt zwyyy in 🌐 d3855u in ~/missing-semester ❯ alias ll=\"ls -lh\" zwyyy in 🌐 d3855u in ~/missing-semester ❯ ll total 968K -rw------- 1 zwyyy zwyyy 0 Jun 15 15:29 nohup.out -rw-r--r-- 1 zwyyy zwyyy 246 Jun 15 15:39 sig.py -rw-r--r-- 1 zwyyy zwyyy 962K Jun 15 14:55 words.txt 当我们关闭这个 shell 或者切换到另一个 shell 后，别名就不再生效，为了让别名对所有 shell 生效，需要将它写入 shell 的配置文件中，以我这里使用的 zsh 为例，在 ~/.zshrc 中追加 alias ll=\"ls -lh\"，再执行 source ~/.zshrc 后，别名就将一直生效。 ","date":"2024-06-15","objectID":"/missing-semester-command-line.zh/:3:1","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：命令行环境","uri":"/missing-semester-command-line.zh/#别名"},{"categories":["notes"],"content":" 3.2 配置文件很多程序的配置都是通过纯文本格式的被称作 dotfile 的配置文件来完成的（之所以称为 dotfile，是因为它们的文件名以 . 开头，例如 ~/.vimrc。也正因为此，它们默认是隐藏文件，ls并不会显示它们）。 shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，这里 有非常好的资源 对于 bash来说，在大多数系统下，您可以通过编辑 .bashrc 或 .bash_profile 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。 实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 export PATH=\"$PATH:/path/to/program/bin\" 的命令，这样才能确保这些程序能够被 shell 找到。 还有一些其他的工具也可以通过 dotfile 进行配置： bash - ~/.bashrc, ~/.bash_profile git - ~/.gitconfig vim - ~/.vimrc 和 ~/.vim 目录 ssh - ~/.ssh/config tmux - ~/.tmux.conf 此外，也有一些工具，其配置文件位于 ~/.config/xxx/ 目录下： fish - ~/.config/fish/config.fish gdb - ~/.config/gdb/gdbinit lazygit - ~/.config/lazygit/config.yaml 我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下（例如统一放在 ~/.config），并使用版本控制系统进行管理，然后通过脚本将其 符号链接 到需要的地方。这么做有如下好处： 安装简单: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间； 可移植性: 您的工具在任何地方都以相同的配置工作 同步: 在一处更新配置文件，可以同步到其他所有地方 变更追踪: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的 ","date":"2024-06-15","objectID":"/missing-semester-command-line.zh/:3:2","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：命令行环境","uri":"/missing-semester-command-line.zh/#配置文件"},{"categories":["notes"],"content":" 4 连接远程设备参见 ssh 简单教程 ","date":"2024-06-15","objectID":"/missing-semester-command-line.zh/:4:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：命令行环境","uri":"/missing-semester-command-line.zh/#连接远程设备"},{"categories":["notes"],"content":" 1 前言您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！ 这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。 在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。 例如这样一条命令 journalctl | grep -i intel，它会找到所有包含intel(不区分大小写)的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。 让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器： bash ssh myserver journalctl 内容太多了。现在让我们把涉及 sshd 的信息过滤出来： bash ssh myserver journalctl | grep sshd 注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 grep 程序！ ssh 太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论 ssh 的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下： bash ssh myserver 'journalctl | grep sshd | grep \"Disconnected from\"' | less 多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 less 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了： console $ ssh myserver 'journalctl | grep sshd | grep \"Disconnected from\"' \u003e ssh.log $ less ssh.log 过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下 sed 这个非常强大的工具。 sed 是一个基于文本编辑器ed构建的\"流编辑器\" 。在 sed 中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 s，即替换命令，例如我们可以这样写： bash ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed 's/.*Disconnected from //' 上面这段命令中，我们使用了一段简单的正则表达式。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。s 命令的语法如下：s/REGEX/SUBSTITUTION/, 其中 REGEX 部分是我们需要使用的正则表达式，而 SUBSTITUTION 是用于替换匹配结果的文本。 ","date":"2024-06-14","objectID":"/missing-semester-data-organize.zh/:1:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：数据整理","uri":"/missing-semester-data-organize.zh/#前言"},{"categories":["notes"],"content":" 2 正则表达式正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： /.*Disconnected from /。正则表达式通常以（尽管并不总是） /开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有： . 除换行符之外的\"任意单个字符\" * 匹配前面字符零次或多次 + 匹配前面字符一次或多次 [abc] 匹配 a, b 和 c 中的任意一个 (RX1|RX2) 任何能够匹配RX1 或 RX2的结果 ^ 行首 $ 行尾 sed 的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加\\才能使其具有特殊含义。或者，您也可以添加-E选项来支持这些匹配。 回过头我们再看/.*Disconnected from /，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含\"Disconnected from “的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将 “Disconnected from” 作为自己的用户名会怎样呢？ text Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth] 正则表达式会如何匹配？* 和 + 在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下： text 46.97.239.16 port 55920 [preauth] 这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给 * 或 + 增加一个? 后缀使其变成非贪婪模式，但是很可惜 sed 并不支持该后缀。不过，我们可以切换到 perl 的命令行模式，该模式支持编写这样的正则表达式： bash perl -pe 's/.*?Disconnected from //' 让我们回到 sed 命令并使用它完成后续的任务，毕竟对于这一类任务，sed是最常见的工具。sed 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。sed 本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。 好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？ 想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配一整行： bash | sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \\[preauth\\])?$//' 让我们借助正则表达式在线调试工具regex debugger 来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（[^ ]+ 会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀[preauth]，最后再匹配行尾。 注意，这样做的话，即使用户名是“Disconnected from”，对匹配结果也不会有任何影响，您知道这是为什么吗？ 问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名保留下来。对此，我们可以使用“捕获组（capture groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如\\1、 \\2、\\3等等，因此可以使用如下命令： bash | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' 想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章e-mail address，匹配电子邮箱可一点也不简单。网络上还有很多关于如何匹配电子邮箱地址的讨论。人们还为其编写了测试用例及 测试矩阵。您甚至可以编写一个用于判断一个数是否为质数的正则表达式。 正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。 ","date":"2024-06-14","objectID":"/missing-semester-data-organize.zh/:2:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：数据整理","uri":"/missing-semester-data-organize.zh/#正则表达式"},{"categories":["notes"],"content":" 3 回到数据整理OK，现在我们有如下表达式： bash ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' sed 还可以做很多各种各样有趣的事情，例如文本注入：(使用 i 命令)，打印特定的行 (使用 p命令)，基于索引选择特定行等等。详情请见man sed! 现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户： bash ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c sort 会对其输入数据进行排序。uniq -c 会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名： bash ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 sort -n 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序 -k1,1 则表示“仅基于以空格分割的第一列进行排序”。,n 部分表示“仅排序到第n个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！ 如果我们希望得到登录次数最少的用户，我们可以使用 head 来代替tail。或者使用sort -r来进行倒序排序。 相当不错。但我们只想获取用户名，而且不要一行一个地显示。 bash ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 | awk '{print $2}' | paste -sd, 如果您使用的是 MacOS：注意这个命令并不能配合 MacOS 系统默认的 BSD paste使用。参考课程概览与 shell的习题内容获取更多相关信息。 我们可以利用 paste命令来合并行(-s)，并指定一个分隔符进行分割 (-d)，那awk的作用又是什么呢？ ","date":"2024-06-14","objectID":"/missing-semester-data-organize.zh/:3:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：数据整理","uri":"/missing-semester-data-organize.zh/#回到数据整理"},{"categories":["notes"],"content":" 4 awk – 另外一种编辑器awk 其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 awk 可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。 首先， {print $2} 的作用是什么？ awk 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。 在代码块中，$0 表示整行的内容，$1 到 $n 为一行中的 n 个区域，区域的分割基于 awk 的域分隔符（默认是空格，可以通过-F来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。 让我们康康，还有什么炫酷的操作可以做。让我们统计一下所有以c 开头，以 e 结尾，并且仅尝试过一次登录的用户。 bash | awk '$1 == 1 \u0026\u0026 $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l 让我们好好分析一下。首先，注意这次我们为 awk指定了一个匹配模式串（也就是{...}前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是uniq -c得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 wc -l 统计输出结果的行数。 不过，既然 awk 是一种编程语言，那么则可以这样： awk BEGIN { rows = 0 } $1 == 1 \u0026\u0026 $2 ~ /^c[^ ]*e$/ { rows += $1 } END { print rows } BEGIN 也是一种模式，它会匹配输入的开头（ END 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃 grep 和 sed ，因为 awk 就可以解决所有问题。至于怎么做，就留给读者们做课后练习吧。 ","date":"2024-06-14","objectID":"/missing-semester-data-organize.zh/:4:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：数据整理","uri":"/missing-semester-data-organize.zh/#awk----另外一种编辑器"},{"categories":["notes"],"content":" 5 分析数据想做数学计算也是可以的！例如这样，您可以将每行的数字加起来： bash | paste -sd+ | bc -l 下面这种更加复杂的表达式也可以： bash echo \"2*($(data | paste -sd+))\" | bc -l 您可以通过多种方式获取统计数据。如果已经安装了R语言，st是个不错的选择： bash ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | awk '{print $1}' | R --slave -e 'x \u003c- scan(file=\"stdin\", quiet=TRUE); summary(x)' R 也是一种编程语言，它非常适合被用来进行数据分析和绘制图表。这里我们不会讲的特别详细， 您只需要知道summary 可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用R语言就可以得到我们想要的统计数据。 如果您希望绘制一些简单的图表， gnuplot 可以帮助到您： bash ssh myserver journalctl | grep sshd | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c | sort -nk1,1 | tail -n10 | gnuplot -p -e 'set boxwidth 0.5; plot \"-\" using 1:xtic(2) with boxes' ","date":"2024-06-14","objectID":"/missing-semester-data-organize.zh/:5:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：数据整理","uri":"/missing-semester-data-organize.zh/#分析数据"},{"categories":["notes"],"content":" 6 利用数据整理来确定参数有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合 xargs 即可实现： bash rustup toolchain list | grep nightly | grep -vE \"nightly-x86\" | sed 's/-x86.*//' | xargs rustup toolchain uninstall ","date":"2024-06-14","objectID":"/missing-semester-data-organize.zh/:6:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：数据整理","uri":"/missing-semester-data-organize.zh/#利用数据整理来确定参数"},{"categories":["notes"],"content":" 7 整理二进制数据虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过SSH将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。 bash ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 - | convert - -colorspace gray - | gzip | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -' ","date":"2024-06-14","objectID":"/missing-semester-data-organize.zh/:7:0","series":null,"tags":["mit"],"title":"计算机教育缺失的一课：数据整理","uri":"/missing-semester-data-organize.zh/#整理二进制数据"},{"categories":["notes"],"content":" 1 编辑模式Vim 的符号说明，对于 Ctlr+v 的组合键，可能有 ^V、Ctrl-v、\u003cC-v\u003e 三种表达方式。 Vim 的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式： 正常模式：在文件中四处移动光标进行修改 插入模式：插入文本 替换模式：替换文本 可视化模式（一般，行，块）：选中文本块 命令模式：用于执行命令 正常模式即 normal 模式，我更习惯叫 normal 模式。 Vim 的模式： txt normal \u003c-\u003e insert replace visual command-line 在 normal 模式下，按下 v 可以进入可视（一般）模式，按下 V 则可以进入可视（行）模式，而 \u003cC-v\u003e 则会进入可视（方块）模式。 ","date":"2024-06-14","objectID":"/missing-semester-editor-vim.zh/:1:0","series":null,"tags":["vim","mit"],"title":"计算机教育缺失的一课：编辑器（Vim）","uri":"/missing-semester-editor-vim.zh/#编辑模式"},{"categories":["notes"],"content":" 2 buffer，window，tabvim 具有多个 tab（标签），每个 tab 可以包含多个 window，每个 window 对应一个 buffer，而同一个 buffer 可能由多个 window 打开。 :q 实际上只是关闭当前窗口，假设 vim 已经没有打开的窗口了，那么才会退出 vim。 ","date":"2024-06-14","objectID":"/missing-semester-editor-vim.zh/:2:0","series":null,"tags":["vim","mit"],"title":"计算机教育缺失的一课：编辑器（Vim）","uri":"/missing-semester-editor-vim.zh/#bufferwindowtab"},{"categories":["notes"],"content":" 3 命令模式在 normal 模式下按下 : 可以进入命令模式，这个模式下，可以打开、保存、关闭文件，以及退出 Vim。 :q 退出（关闭窗口） :w 保存（写） :wq 保存然后退出 :e {文件名} 打开要编辑的文件 :ls 显示打开的缓存 :help {标题} 打开帮助文档 :help :w 打开 :w 命令的帮助文档 :help w 打开 w 移动的帮助文档 ","date":"2024-06-14","objectID":"/missing-semester-editor-vim.zh/:3:0","series":null,"tags":["vim","mit"],"title":"计算机教育缺失的一课：编辑器（Vim）","uri":"/missing-semester-editor-vim.zh/#命令模式"},{"categories":["notes"],"content":" 4 移动光标在 normal 模式下，可以利用移动命令在 buffer 中移动光标，在 Vim 中，移动也被称为“名词”，与编辑命令（i、o）等相对应。 基本移动: hjkl （左， 下， 上， 右） 词： w （下一个词）， b （词初）， e （词尾） 行： 0 （行初）， ^ （第一个非空格字符）， $ （行尾） 屏幕： H （屏幕首行）， M （屏幕中间）， L （屏幕底部） 翻页： Ctrl-u （上翻）， Ctrl-d （下翻） 文件： gg （文件头）， G （文件尾） 行数： :{行数}\u003cCR\u003e 或者 {行数}G ({行数}为行数) 杂项： % （找到配对，比如括号或者 /* */ 之类的注释对） 查找： f{字符}， t{字符}， F{字符}， T{字符} 查找/到 向前/向后 在本行的{字符} , / ; 用于导航匹配 搜索: /{正则表达式}, 按下 之后，n / N 用于导航匹配 ","date":"2024-06-14","objectID":"/missing-semester-editor-vim.zh/:4:0","series":null,"tags":["vim","mit"],"title":"计算机教育缺失的一课：编辑器（Vim）","uri":"/missing-semester-editor-vim.zh/#移动光标"},{"categories":["notes"],"content":" 5 编辑所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。 i 进入插入模式 但是对于操纵/编辑文本，不单想用退格键完成 I 表示在当前行首插入，a 表示在当前光标后插入，A 表示在当前行末插入 O / o 在之上/之下插入行 d{移动命令} 删除 {移动命令} 例如，dw 删除词, d$ 删除到行尾, d0 删除到行头。 c{移动命令} 改变 {移动命令} 例如，cw 改变词，相当于 dw 再执行 i x 删除字符（等同于 dl） s 替换字符（等同于 xi） 可视化模式 + 操作 选中文字, d 删除 或者 c 改变 u 撤销, \u003cC-r\u003e 重做 y 复制 / “yank” （其他一些命令比如 d 也会复制） p 粘贴 更多值得学习的: 比如 ~ 改变字符的大小写 ","date":"2024-06-14","objectID":"/missing-semester-editor-vim.zh/:5:0","series":null,"tags":["vim","mit"],"title":"计算机教育缺失的一课：编辑器（Vim）","uri":"/missing-semester-editor-vim.zh/#编辑"},{"categories":["notes"],"content":" 6 计数你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。 3w 向后移动三个词 5j 向下移动5行 7dw 删除7个词 ","date":"2024-06-14","objectID":"/missing-semester-editor-vim.zh/:6:0","series":null,"tags":["vim","mit"],"title":"计算机教育缺失的一课：编辑器（Vim）","uri":"/missing-semester-editor-vim.zh/#计数"},{"categories":["notes"],"content":" 7 修饰语你可以用修饰语改变“名词”的意义。修饰语有 i，表示“内部”或者“在内”，和 a， 表示“周围”。 ci( 改变当前括号内的内容 ci[ 改变当前方括号内的内容 da' 删除一个单引号字符串， 包括周围的单引号 ","date":"2024-06-14","objectID":"/missing-semester-editor-vim.zh/:7:0","series":null,"tags":["vim","mit"],"title":"计算机教育缺失的一课：编辑器（Vim）","uri":"/missing-semester-editor-vim.zh/#修饰语"},{"categories":["notes"],"content":" 8 宏 q{字符} 来开始在寄存器{字符}中录制宏 q停止录制 @{字符} 重放宏 宏的执行遇错误会停止 {计数}@{字符}执行一个宏{计数}次 宏可以递归 首先用q{字符}q清除宏 录制该宏，用 @{字符} 来递归调用该宏 （在录制完成之前不会有任何操作） 例子：将 xml 转成 json (file) 一个有 “name” / “email” 键对象的数组 用一个 Python 程序？ 用 sed / 正则表达式 g/people/d %s/\u003cperson\u003e/{/g %s/\u003cname\u003e\\(.*\\)\u003c\\/name\u003e/\"name\": \"\\1\",/g … Vim 命令 / 宏 ggdd, Gdd 删除第一行和最后一行 格式化最后一个元素的宏 （寄存器 e） 跳转到有 \u003cname\u003e 的行 qe^r\"f\u003es\": \"\u003cESC\u003ef\u003cC\"\u003cESC\u003eq 格式化一个的宏 跳转到有 \u003cperson\u003e 的行 qpS{\u003cESC\u003ej@eA,\u003cESC\u003ej@ejS},\u003cESC\u003eq 格式化一个标签然后转到另外一个的宏 跳转到有 \u003cperson\u003e 的行 qq@pjq 执行宏到文件尾 999@q 手动移除最后的 , 然后加上 [ 和 ] 分隔符 ","date":"2024-06-14","objectID":"/missing-semester-editor-vim.zh/:8:0","series":null,"tags":["vim","mit"],"title":"计算机教育缺失的一课：编辑器（Vim）","uri":"/missing-semester-editor-vim.zh/#宏"},{"categories":["tutorial"],"content":" 1 前言论文写完之后，以 840 元的价格购入了投影群里群友的优派 PJD7822HDL，只能说还能凑合用吧，噪音与发热巨大，开节能模式之后勉强可以接受，标称 3200 流明，实际上亮度不超过 50% 的情况下才能有比较好的对比度，亮度拉高了之后泛白严重，白天关灯拉窗帘看，由于我房间的窗帘的遮光性一般，感觉亮度还是低了点，晚上看倒不错，自带的音响效果也很一般（从闲鱼上淘了对音箱解决了）。不过好歹也是 dmd0.65，原生的 1080P 分辨率，清晰度还是让人满意的。 不过，该投影仪并无安卓系统，为了解决影视内容问题，我就开始在闲鱼上淘电视盒子，一共考虑了以下几个设备：移动魔百盒、亚马逊火棒、以及外贸盒子。 ","date":"2024-06-11","objectID":"/android-tv-box.zh/:1:0","series":null,"tags":["atv","fun"],"title":"安卓电视盒子的折腾之旅","uri":"/android-tv-box.zh/#前言"},{"categories":["tutorial"],"content":" 2 移动魔百盒我是在 v2ex 上看到有人 60 出 cm211-1 增强版（2+16g），于是买下了它，事实证明这玩意现在最多值 50（因为我在闲鱼上 50r 又买了一个）。 这个魔百盒的 cpu 为晶晨 S905L3，默认固件是基于老掉牙的安卓 4.4，好在可以刷的固件还是不少的，我选择的是基于 Android TV 9.0 的 slimbox 固件，还是折腾了好一番才刷入的固件。 步骤如下，首先去淘宝购买了晶晨 S905 的免拆短接 HDMI 刷机工具，将它插在盒子的 HDMI 口，打开商家提供的刷机软件 USB Burning Tool ，和以前 N1 刷机的时候用的其实是同一个软件，该软件非绿色版，安装的时候会为你安装晶晨的相关驱动，安装好之后打开该软件，通过 USB 双头线连接电脑和魔百盒，打开 USB_Burning_Tool，会检测到已连接到设备，点击 文件 -\u003e 导入烧录包 来导入 img 格式的固件，烧录配置选择默认的 擦除 flash 和 擦除 bootloader 即可，就可以开始烧录了，耐心等待即可。 由于该盒子已经刷过机了，按理来说不需要短接就能直接刷，也不需要什么免拆工具，强烈怀疑之前一直检测不到设备是因为用的绿色版，没有安装驱动。 刷好机之后，可以通过 Google play store 安装 Plex，理论上就能愉快玩耍了，然而我发现一个严重的问题，那就是用 Plex 播放音轨为 ac3 或者 eac3 格式的视频，会没有声音，经查找资料，应该是因为 S905L3 这个芯片不支持解码杜比全景声，而 Plex 默认对于这两种格式的音轨是在本地客户端直接硬解的，所以播放这样的视频会没有声音，而 Plex 的 tv 端界面无法像手机端那样针对音频格式设置是否硬解，因此，只能放弃这一款魔百盒，安装好 Tvbox 与 Emby，准备拿回去给家里人用了。 ","date":"2024-06-11","objectID":"/android-tv-box.zh/:2:0","series":null,"tags":["atv","fun"],"title":"安卓电视盒子的折腾之旅","uri":"/android-tv-box.zh/#移动魔百盒"},{"categories":["tutorial"],"content":" 3 亚马逊火棒经过查阅资料，发现亚马逊的 Fire tv stick 4k max（后面简称火棒），其对视频与音频格式的支持十分丰富，价格也还算能接受吧，一代 200 左右，二代 400 左右，其对比如下图所示： 可以看到二代相比一代的主要升级在于存储空间增加了 8g 和支持了更多音频格式，至于 cpu 性能提升个人认为不关键，毕竟视频解码能力没区别，也不会用盒子打游戏。 二代是支持 Dolby TrueHD 和 DTS-HD MA 的音频直通的，一代似乎不支持，这样看来，假如后面也搭建家庭影院，在不考虑观看双层杜比的原盘的情况下，二代火棒作为电视盒子也完全够用了。 然而，二代的火棒还是太贵了，一代又感觉比较老了，考虑到自己目前只是接这个垃圾投影仪看 Plex，又没必要上二代，因此将目光转向了外贸盒子。 ","date":"2024-06-11","objectID":"/android-tv-box.zh/:3:0","series":null,"tags":["atv","fun"],"title":"安卓电视盒子的折腾之旅","uri":"/android-tv-box.zh/#亚马逊火棒"},{"categories":["tutorial"],"content":" 4 x98h pro本来是准备在酷安上一个专门卖外贸盒子的贩子那里买的，后面在闲鱼上看到一个卖 x98H pro 的帖子，这个盒子被原主升级 magisk 之后卡开机界面了，于是我 80r 入手了该盒子。 该盒子芯片为全志的 H618，支持解码杜比全景声，支持解码 4K H265 和 VP9，可惜不支持硬解 av1，支持 HDR10+（杜比视界就别想了）。 刷机过程也经历了一番折腾，参照 x98h pro盒子固件 中的教程，教程作者也提供了刷机工具和固件，我刷的是 atv 固件，这里要注意的是，先安装驱动，如下图所示： 驱动位于 x98hpro/PhoenixSuit/Drivers/AW_Driver。 安装好驱动之后，先打开刷机软件，选择 一键刷机，并导入 img 格式的固件，此时左下角会显示“无设备连接”，然后给盒子通电，用牙签抵住 AV 接口孔中的复位键不放，最后用双公头 USB 线连接盒子和电脑（USB 线要插入盒子后面的 USB 接口），此时工具会显示设备已连接，点击 立即升级 即可开始刷机，之后可以松开牙签了。 教程作者提供的 ATV 固件源于俄罗斯的 slimbox 项目，最新固件可从 slimbox x98h-pro 处下载，不过下载要用 mega 盘，我嫌麻烦就用的之前教程作者的，后面也许可以再刷刷玩玩。 由于也是 slimbox，自带 Google play store，可以通过它安装 Plex，安装好之后，Plex 的设置中要将 音频直通 设置为禁用，否则播放音轨为 ac3 或者 eac3 的视频会卡住。 ","date":"2024-06-11","objectID":"/android-tv-box.zh/:4:0","series":null,"tags":["atv","fun"],"title":"安卓电视盒子的折腾之旅","uri":"/android-tv-box.zh/#x98h-pro"},{"categories":["tutorial"],"content":" 5 参考x98h pro盒子固件 slimboxtv: x98h-pro ","date":"2024-06-11","objectID":"/android-tv-box.zh/:5:0","series":null,"tags":["atv","fun"],"title":"安卓电视盒子的折腾之旅","uri":"/android-tv-box.zh/#参考"},{"categories":["tutorial"],"content":" 1 为什么要用工作区VSCode 作为一个轻量的编辑器，对比 IDE 很多功能并非集成。如果想打造成一个 IDE，那么就需要安装很多扩展，然而扩展越多，管理起来也越发困难，VSCode 也就越发“笨重”，例如，当我进行 cpp 开发的时候，python 与 go 的相关插件就不需要了，然而其默认也是开启的，我们当然可以手动关闭，有需要的时候再打开。然而，随着这样的扩展越来越多，手动控制扩展的开启与关闭就变得非常麻烦。 我认为 VSCode 的工作区（Work Space）诞生的一大重要原因就是扩展的管理。事实上，当我们打开 VSCode 的时候，其实就位于默认的工作区中。 ","date":"2024-05-25","objectID":"/vscode-workspace.zh/:1:0","series":null,"tags":["vscode"],"title":"VSCode 工作空间（Workspace）指北","uri":"/vscode-workspace.zh/#为什么要用工作区"},{"categories":["tutorial"],"content":" 2 工作区的创建假设我只会在 ~/code/blog/zwyb_blog 目录下用 VSCode 写博客，那么我用 VSCode 打开 ~/code/python 目录，我就可以点击 File -\u003e Save Workspace as，保存为 blog.code-workspace。 目前，其内容如下： json { \"folders\": [ { \"path\": \".\" }, ], \"settings\": {} } 可以看到，内容分为了 folders 与 settings 两大类，folders 表示处于该工作空间的文件夹所在目录，我们可以点击 File -\u003e Add Folder to Workspace 来添加其他项目文件夹目录到该工作区，例如我添加了 ~/code/blog/papermod 目录，添加后内容修改为如下： json { \"folders\": [ { \"path\": \".\" }, { \"path\": \"../papermod\" }, ], \"settings\": {} } 遗憾的是，VSCode 中不支持在配置文件中直接设置扩展的激活与否，需要手动在 VSCode 的扩展视图中点击齿轮按钮，设置 Disable(Workspace)。 可以先直接禁用所有的扩展，然后按需选择是仅在工作空间启用还是所有工作空间都启用，如下图所示： ","date":"2024-05-25","objectID":"/vscode-workspace.zh/:2:0","series":null,"tags":["vscode"],"title":"VSCode 工作空间（Workspace）指北","uri":"/vscode-workspace.zh/#工作区的创建"},{"categories":["tutorial"],"content":" 3 工作区的配置VSCode 的配置文件的级别可以分为 User、Workspace 与 Folder 三个级别，其中 Folder 级别表示文件夹下的 .vscode 文件夹中的 settings.json 文件。 配置文件的优先级为 Folder \u003e Workspace \u003e User，对于一个配置项，如果在更高优先级的配置文件中被设置了，那么该配置项会被覆盖。 例如，假设 ~/code/blog/zwyb_blog 目录下存在 .vscode/settings.json 文件，其内容为设置字体大小为 14，blog.code-workspace 中的 settings 部分设置字体大小为 13，用户配置文件中设置字体大小为 12，则打开 blog.code-workspace 工作区，打开 zwyb_blog 目录下的文件，字体大小显示为 14，对于非 zwyb_blog 目录下的文件，例如 papermod 目录下的文件，则字体大小为 13。 这里要注意的是，blog.code-workspace 中的设置内容，必须在你打开该工作空间时才会生效，例如 ~/code/blog/papermod 虽然位于 blog.code-workspace 中，但是 VSCode 直接打开该文件夹，blog.code-workspace 中的设置不会生效，该文件夹中的文件的字体仍为 12。 此外，使用 VSCode Remote 也能打开远程机器上的工作空间，与本地机器的工作空间区别不大，具体效果留待读者探索了。 ","date":"2024-05-25","objectID":"/vscode-workspace.zh/:3:0","series":null,"tags":["vscode"],"title":"VSCode 工作空间（Workspace）指北","uri":"/vscode-workspace.zh/#工作区的配置"},{"categories":["tutorial"],"content":" 1 前言在网站没有被搜索引擎收录之前，网站内容是无法通过搜索引擎搜索到的，因此我们手动让网站被 Google 和 Bing 收录。 ","date":"2024-05-15","objectID":"/blog-google-bing.zh/:1:0","series":null,"tags":["hugo","blog"],"title":"使博客被搜索引擎收录","uri":"/blog-google-bing.zh/#前言"},{"categories":["tutorial"],"content":" 2 Google进入 Google Search Console，点击 添加资源，资源类型选择 网址前缀，这里我的网址前缀为 https://blog.zwyyy456.tech/，验证方法选择通过 HTML 文件，按照提示，下载一个 google 开头的 html 文件，将这个文件放在 Hugo 博客文件目录的 static 目录下，这是因为 static 目录中的文件与目录在编译时，会被复制到 public 目录，即网站的根目录。 完成验证之后，下一步则是添加网站地图，如下图所示： Hugo 会自动为我们生成 sitemap.xml 文件，即站点地图，由于我的网站支持中英双语，因此站点地图的位置为 https://blog.zwyyy456.tech/zh/sitemap.xml 和 https://blog.zwyyy456.tech/en/sitemap.xml，如果是单语言的 Hugo 博客网站，则是 https://HugoExample.com/sitemap.xml。添加好站点地图之后等待谷歌处理数据即可。 ","date":"2024-05-15","objectID":"/blog-google-bing.zh/:2:0","series":null,"tags":["hugo","blog"],"title":"使博客被搜索引擎收录","uri":"/blog-google-bing.zh/#google"},{"categories":["tutorial"],"content":" 3 Bing进入 Bing Webmaster Tools，可以直接从 Google Search Console 导入网站，提交站点地图的方法是类似的。 ","date":"2024-05-15","objectID":"/blog-google-bing.zh/:3:0","series":null,"tags":["hugo","blog"],"title":"使博客被搜索引擎收录","uri":"/blog-google-bing.zh/#bing"},{"categories":["tutorial"],"content":" 4 为博客添加搜索功能我使用的博客主题是秉承简洁纯粹理念的 hugo_coder 主题，该主题不支持搜索功能，而我比较需要这个搜索功能，因此通过 Google 或者 Bing 的自定义搜索功能来为博客添加搜索功能是一个比较简单的做法，这里我使用的是 Bing 的自定义搜索功能。 ","date":"2024-05-15","objectID":"/blog-google-bing.zh/:4:0","series":null,"tags":["hugo","blog"],"title":"使博客被搜索引擎收录","uri":"/blog-google-bing.zh/#为博客添加搜索功能"},{"categories":["notes"],"content":" 1 $ 符号的功能Shell 中，$ 符号可以与数字或者其他符号组合在一起表示特殊的值或者变量，如下： sh #!/bin/bash echo $0 # $0 用于获取当前脚本文件名名称 echo \"The first parameter: $1\" # $1 表示第一个参数 echo \"The eleventh parameter: ${11}2\" echo \"The eleventh parameter: ${11}x\" echo \"The eleventh parameter: $11x\" echo \"The eleventh parameter: $12\" tmp=\"hello\" echo \"$tmp world\" 将以上脚本文件命名为 test.sh 并执行 bash test.sh 1 2 3 4 5 6 7 8 9 10 13 14，输出如下： txt test.sh The first parameter: 1 The eleventh parameter: 132 The eleventh parameter: 13x The eleventh parameter: 11x The eleventh parameter: 12 hello wolrd 这是因为，只有 $n 才能表示第 n 个参数（n 为单个数字），如果想表示第 11 个参数，就必须使用 ${11}（加上大括号）来表示，bash 会将 $12 处理为名为 12 的变量。 此外，$# 表示参数的个数，类似于程序中的 argc，$@ 表示所有参数的列表，在 bash 或者 zsh 中，$_ 表示上一个命令的最后一个参数，而 !! 则表示执行的上一条命令，$? 表示上一个命令的返回状态，为 0 表示命令成功执行。 $$ 表示当前进程的 pid。 例如： sh mkdir tmp cd $_ # 进入到了 tmp 目录 mkdir test sudo !! # 这里就是表示执行 sudo mkdir test ","date":"2024-05-09","objectID":"/missing-semester-shell.zh/:1:0","series":null,"tags":["cs"],"title":"计算机教育缺失的一课：Shell 工具与脚本","uri":"/missing-semester-shell.zh/#-符号的功能"},{"categories":["notes"],"content":" 2 shell 中定义函数与使用执行 nvim mcd.sh，将其内容修改为如下： text mcd () { mkdir -p \"$1\" cd \"$1\" } 然后保存，再执行 source mcd.sh，即在当前 shell 执行了 mcd.sh，而 ./mcd.sh 会创建一个子 shell 来执行，执行了 source mcd.sh 之后，当前 shell 中就有一个我们定义的名为 mcd 的函数了，在当前 shell 中，我们就可以使用 mcd 命令来创建并进入指定的目录了： 注意，这里不能用 fish，必须用 bash 或者兼容 bash 的 shell 例如 fish。 sh source mcd.sh mcd arm # 将进入创建的名为 arm 的目录中 ","date":"2024-05-09","objectID":"/missing-semester-shell.zh/:2:0","series":null,"tags":["cs"],"title":"计算机教育缺失的一课：Shell 工具与脚本","uri":"/missing-semester-shell.zh/#shell-中定义函数与使用"},{"categories":["notes"],"content":" 3 逻辑表达式shell 也支持逻辑表达式的与、或，如下图所示： 对于“或”运算，如果左侧的结果已经为真，那么就不会再去计算右侧的结果，因此 echo \"Oops fail\" 无输出，“与”运算的原理相同。 ","date":"2024-05-09","objectID":"/missing-semester-shell.zh/:3:0","series":null,"tags":["cs"],"title":"计算机教育缺失的一课：Shell 工具与脚本","uri":"/missing-semester-shell.zh/#逻辑表达式"},{"categories":["notes"],"content":" 4 变量当使用双引号来表示字符串时，shell 会对引号内的内容进行变量与命令替换，它将 () 包裹的内容视为命令，将 {} 包裹的内容视为变量，并进行替换，将 () 包裹的内容替换为输出结果，将 {} 包裹的内容替换为变量的值。 shell zwyyy in 🌐 armbian in ~/missing-semester/arm ❯ foo=$(pwd) zwyyy in 🌐 armbian in ~/missing-semester/arm ❯ echo $foo /home/zwyyy/missing-semester/arm zwyyy in 🌐 armbian in ~/missing-semester/arm ❯ echo \"We are in $(pwd)\" We are in /home/zwyyy/missing-semester/arm zwyyy in 🌐 armbian in ~/missing-semester/arm ❯ echo 'We are in $(pwd)' We are in $(pwd) zwyyy in 🌐 armbian in ~/missing-semester/arm ❯ echo \"we are in ${foo}\" we are in /home/zwyyy/missing-semester/arm 以下是一个使用到了前面所述的知识点的脚本： sh #! /bin/bash echo \"Starting program at $(date)\" echo \"Running program $0 with $# arguments with pid $$\" for file in \"$@\"; do grep foobar \"$file\" \u003e /dev/null 2\u003e /dev/null if [[ \"$?\" -ne 0 ]]; then echo \"File $file does not have any foobar, adding one\" echo \"# foorbar\" \u003e\u003e \"$file\" fi done 其中，`grep foobar “$file” \u003e /dev/null 2\u003e /dev/null ","date":"2024-05-09","objectID":"/missing-semester-shell.zh/:4:0","series":null,"tags":["cs"],"title":"计算机教育缺失的一课：Shell 工具与脚本","uri":"/missing-semester-shell.zh/#变量"},{"categories":["notes"],"content":" 5 shell 的一些缩写convert image.{png,jpg} 等价于 convert image.png image.jpg； 而 touch foo{,1,2,10} 等价于 touch foo foo1 foo2 foo10； 而 touch project{1,2}/src/test/test{1,2,3}.py 等价于 touch project1/src/test/test1.py project1/src/test/test2.py project1/src/test/test3.py project2/src/test/test1.py project2/src/test/test2.py project2/src/test/test3.py。 ","date":"2024-05-09","objectID":"/missing-semester-shell.zh/:5:0","series":null,"tags":["cs"],"title":"计算机教育缺失的一课：Shell 工具与脚本","uri":"/missing-semester-shell.zh/#shell-的一些缩写"},{"categories":["notes"],"content":" 6 与 Python 交互的 shell 脚本 py #!/usr/bin/python3 # test.py import sys for arg in reversed(sys.argv[1:]): print(arg) # foobar 其中，第一行注释 #!/usr/bin/python3 被称为 shebang，用于指定 python 脚本该由哪个解释器运行。 我们当然可以通过 python test.py 来运行该脚本，此时不需要 shebang，但假设我们希望通过 ./test.py 来运行，那么久需要 shebang 来告诉 shell，应该使用哪个 python 解释器来运行该脚本。 将 #!/usr/bin/python3 替换为 #!/usr/bin/env python3 能增强程序的可移植性，/usr/bin/env 是一个 Unix 程序，它会查找 python3 解释器的路径并执行它，因此，对于我的电脑来说，#!/usr/bin/env python3 就相当于 #!/usr/bin/env python3。 ","date":"2024-05-09","objectID":"/missing-semester-shell.zh/:6:0","series":null,"tags":["cs"],"title":"计算机教育缺失的一课：Shell 工具与脚本","uri":"/missing-semester-shell.zh/#与-python-交互的-shell-脚本"},{"categories":["notes"],"content":" 1 简介Json 格式的全称为 JavaScript Object Notation，是一种起源于编程语言 JavaScript 的序列化数据格式，其特点在于，可以通过特定的文本格式表达一定程度的复杂数据，被广泛应用于其他编程语言中。 ","date":"2024-05-04","objectID":"/json-startup.zh/:1:0","series":null,"tags":["json"],"title":"Json 快速入门","uri":"/json-startup.zh/#简介"},{"categories":["notes"],"content":" 2 六个构造字符Json 有六种有效符号，如下： 符号 名称 [ 左方括号 ] 右方括号 { 左花括号 } 右花括号 , 逗号 : 冒号 在这些符号之间的空格与换行在 Json 中没有实际意义，一般用于使 Json 代码更加规整。注意，Json 标准中无法表示注释。 ","date":"2024-05-04","objectID":"/json-startup.zh/:2:0","series":null,"tags":["json"],"title":"Json 快速入门","uri":"/json-startup.zh/#六个构造字符"},{"categories":["notes"],"content":" 3 五种数据类型Json 中存在 5 种数据类型，分别是 数字、字符串、数组、对象、字面名（也可以理解为保留值）。 ","date":"2024-05-04","objectID":"/json-startup.zh/:3:0","series":null,"tags":["json"],"title":"Json 快速入门","uri":"/json-startup.zh/#五种数据类型"},{"categories":["notes"],"content":" 3.1 数字数字是最基础的数据类型，可以是一个整数、也可以是一个小数 json 1234, 12.34 ","date":"2024-05-04","objectID":"/json-startup.zh/:3:1","series":null,"tags":["json"],"title":"Json 快速入门","uri":"/json-startup.zh/#数字"},{"categories":["notes"],"content":" 3.2 字符串类似其他编程语言中的字符串。 json \"Json\", \"中文\" ","date":"2024-05-04","objectID":"/json-startup.zh/:3:2","series":null,"tags":["json"],"title":"Json 快速入门","uri":"/json-startup.zh/#字符串"},{"categories":["notes"],"content":" 3.3 数组数组表示一串有固定的顺序的值，相比起 C++ 中的数组，Json 中的数组中的值的数据类型可以不同，数组中的值的元素类型也可以是 数组 或者 对象。 数组的格式如下：以 [ 作为起始，以 ] 作为结束，数组中的值之间以 , 分隔。 json [ 12345, \"start\", [\"end\"], {\"123\": \"45\"} ] ","date":"2024-05-04","objectID":"/json-startup.zh/:3:3","series":null,"tags":["json"],"title":"Json 快速入门","uri":"/json-startup.zh/#数组"},{"categories":["notes"],"content":" 3.4 对象对象可以简单理解为一系列的键值对。 对象基本格式是以 { 为起始，以 } 作为结束，每个键值对以 , 进行分割，键值对中的键与值利用 : 进行分隔。 json { \"key\": \"val\", \"height\": 2, \"sex\": \"male\" } ","date":"2024-05-04","objectID":"/json-startup.zh/:3:4","series":null,"tags":["json"],"title":"Json 快速入门","uri":"/json-startup.zh/#对象"},{"categories":["notes"],"content":" 4 两种字面名即 null 与 true 和 false。注意，字面名使用时是不加引号的！ ","date":"2024-05-04","objectID":"/json-startup.zh/:4:0","series":null,"tags":["json"],"title":"Json 快速入门","uri":"/json-startup.zh/#两种字面名"},{"categories":["tutorial"],"content":" 1 起因最近一两个月，时常碰到笔记本电脑死机的情况，具体表现为电脑卡死没反应，同时发出嗡嗡的电流声，前两天还出现了电脑蓝屏的情况，错误码为 “Clock Watchdog Timeout”，网上找了一圈，有不少人碰到了和我一样的问题，有个解决方案说要在电源模式下设置硬盘永不休眠，我尝试了，并没有用，推测可能的原因有以下几种： 笔记本过热，一般都是一边看视频一边打游戏时出现卡死的情况，并且我的笔记本电脑是外接了 4K 显示器在用，卡死的时候，能感觉到笔记本非常烫； 固态掉盘，用的海康威视 c2000 pro，据说有掉盘的先例； 奇奇怪怪的驱动、硬件兼容性问题； 正好，这个笔记本电脑的系统已经很久没有重装过了，里面的东西、配置也被我搞得挺乱了，干脆重装一遍系统，看看是否还有问题。 这篇文章主要是记录一下重装系统的过程和一些重要步骤以及要安装的软件。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:1:0","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#起因"},{"categories":["tutorial"],"content":" 2 备份需要备份的文件与文件夹都在 C:\\Users\\zwyyy 目录下，手动把要备份的文件夹打包，拷贝到了我的移动硬盘中去。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:2:0","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#备份"},{"categories":["tutorial"],"content":" 3 制作系统安装 U 盘首先，在微软官网下载 64 位的 Win11 系统镜像，下载好之后，利用 Rufus 软件将镜像写入到 U 盘中去。 然后是很重要的一步，如果直接开始安装系统，在安装过程中会发现无法识别 U 盘，对 11 代及以上的 Intel CPU 的笔记本，要识别 NVME 协议的固态硬盘，需要安装一个名为 Intel Rapid Storage Technology（IRST）的驱动程序，可以去笔记本厂商的官网下载对应的驱动，将驱动压缩包解压到系统安装 U 盘中即可，在安装系统，选择将 Windows 安装在哪里时，点击加载驱动程序，选择之前驱动程序解压到的那个目录，即可找到对应的驱动程序，加载了驱动程序之后，就能识别到硬盘了，之后的安装就是正常按照指引来就行了。 acer 下载驱动需要先下载一个序列号检测识别软件，识别到序列号之后，就能下载电脑型号的对应驱动程序了。 我的笔记本型号为 SWIFT SF314-511 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:3:0","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#制作系统安装-u-盘"},{"categories":["tutorial"],"content":" 4 驱动安装重装好系统之后发现触控板和指纹不可用，需要安装驱动，打开 设置 -\u003e Windows 更新 -\u003e 高级选项 -\u003e 可选更新 -\u003e 驱动程序更新，即可安装这些驱动程序。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:4:0","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#驱动安装"},{"categories":["tutorial"],"content":" 5 软件安装","date":"2024-03-03","objectID":"/win-reinstall.zh/:5:0","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#软件安装"},{"categories":["tutorial"],"content":" 5.1 Scoop打开 Microsoft Store，安装 Windows Terminal，然后将 Shell 设置为 Windows PowerShell，执行以下两条指令： sh Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUse Invoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression 就会自动帮你安装 Scoop，然后就能通过 Scoop 安装软件了，用起来类似 Mac 的 Homebrew。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:5:1","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#scoop"},{"categories":["tutorial"],"content":" 5.2 启用小鹤双拼手动添加注册表项目。 Windows + R 调出命令运行框，输入：regedit 后确认打开注册表； 打开以下路径：HKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\Settings\\CHS 新建字符串值，字符串名称为：UserDefinedDoublePinyinScheme0，值为：小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt 退出后进入微软拼音设置，即可看到小鹤双拼方案已存在，选择保存即可。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:5:2","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#启用小鹤双拼"},{"categories":["tutorial"],"content":" 5.3 编程相关首先，为 Scoop 添加 extras 库，执行 scoop install git 和 scoop bucket add extras 即可，如果要安装字体，执行 scoop bucket add nerd-fonts。 然后，执行以下命令安装软件： sh scoop install vscode scoop install sublime-text scoop bucket add nerd-fonts scoop install Cascadia-Code scoop install miniconda scoop install LXGWWenKai scoop install neovim scoop install wezterm scoop install neovide # 利用 Rust 编写的 neovim 跨平台 GUI scoop install llvm # C/C++ 的运行环境 scoop install pwsh # 新一代 powershell scoop install FiraMono-NF-Mono scoop install picgo # 截图并上传图床 scoop bucket add j178 https://github.com/j178/scoop-bucket.git scoop install j178/leetgo Neovim 的配置见 Neovim 的配置与使用。 Sublime Text4 的配置见 配置 Sublime Text4为 C++ 编辑器。 Wezterm 的配置见 Wezterm 的配置与使用 Vscode 的配置见 Vsocde 使用 clangd 以及博客中的其他相关内容。如果是手动下载安装的 pwsh，那么 vscode 会自动检测到这个 Powershell，创建终端时默认的 shell 就是 Powershell，但由于我的 Powershell 是通过 scoop 安装的，因此 vscode 无法自动检测到，如果希望让 vscode 的默认 shell 为 Powershell，那么需要在配置文件中添加如下内容： json \"terminal.integrated.profiles.windows\": { \"pwsh\": { \"icon\": \"terminal-powershell\", \"path\": [ \"C:\\\\Users\\\\zwyyy\\\\scoop\\\\shims\\\\pwsh.exe\" ] } }, \"terminal.integrated.defaultProfile.windows\": \"pwsh\" 此外，vscode 新增了一项名为粘滞滚动的特性，可以点击 View -\u003e Appearance -\u003e Sticky Scroll 关闭 Microsoft Store 中可以安装 Debian，安装好 Debian 之后要先在 Windows Terminal 中执行 wsl --install 来安装 WSL。 此外，还可以利用 scoop 来安装字体，例如 FiraMono Nerd Font Mono。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:5:3","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#编程相关"},{"categories":["tutorial"],"content":" 5.4 办公安装 Office 365，搜索 Microsoft 365，然后即可在官网下载安装工具，打开该安装工具之后，等待安装完成即可。 Microsoft Store 中可以免费安装 Pixpin 和 OneCommander，前者可以理解为 Snipaste 的替代，后者则是自带文件管理器的上位替代。 Edge 浏览器注意关闭安全 DNS，如下图所示: 通过 scoop 安装了 picgo 之后，其又拍云的图床配置如下图： 其中，bucket 应该是云存储设置的服务名称，加速域名和操作员就是又拍云中设置的对应的加速域名和操作员，Picgo 本身并不支持截图，只能将本地图片或者剪切板中的图片上传到图床，可以将 Pixpin 与 Picgo 组合起来使用。 我将 Picgo 的快速上传的快捷键设置为了 Ctrl + super + u。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:5:4","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#办公"},{"categories":["tutorial"],"content":" 5.5 游戏海豚加速器，可以免费加速炉石传说 90 天。 ak 加速器，每天 00:00 ~ 14:00 可以免费加速。 安装炉石传说时，语言不能选择中文，否则安装进度条会卡住，最后失败。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:5:5","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#游戏"},{"categories":["tutorial"],"content":" 5.6 笔记安装 RemNote。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:5:6","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#笔记"},{"categories":["tutorial"],"content":" 5.7 其他安装 IDM 时，去官网下载并安装，然后进入 163 邮箱，查找荔枝数码发送的授权邮件，里面有关键的授权码，利用这个授权码即可完成注册。 OneCommander: 非常好用的文件管理器，可以在 Microsoft Store 中获取并安装。 qq \u0026 wechat：去腾讯官网下载即可。 注意，qq 与微信不要把聊天记录的存储路径设在 OneDrive 会同步的目录，否则会导致 OneDrive 的图片中存在一大堆缩略图。 Mega 网盘：注意去下载测试版。 Keepass：注意数据库的存放位置就行。 安装 ContexMenuManager 以管理右键菜单。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:5:7","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#其他"},{"categories":["tutorial"],"content":" 5.8 配置可以将 GitHub 中的 dotfile repo 给 clone 到 C:\\Users\\zwyyy 目录下作为 .config 目录，许多程序，例如 wezterm 的配置文件都是位于 C:\\Users\\zwyyy\\.config 目录，当然，neovim 的配置文件位于 C:\\Users\\zwyyy\\AppData\\local\\nvim 目录中。 ","date":"2024-03-03","objectID":"/win-reinstall.zh/:5:8","series":null,"tags":["win11","dev"],"title":"Win11 重装记录","uri":"/win-reinstall.zh/#配置"},{"categories":["tutorial"],"content":" 1 前言本科写毕业论文的时候，是用的学校的 word 模板，体验比较糟糕，当时跟我一组的同学就是用的 Latex 的本科学位论文模板，当时由于我写本科毕业论文的时间比较紧迫了，所以没有折腾这些，此外，当时的 Latex 学位论文模板属于是纯民间支持的性质，而现在，学校已经半官方地支持了 Latex 学位论文模板，因此，研究生毕业论文我就准备使用 Latex 而不再使用 word 来写了。 ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:1:0","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#前言"},{"categories":["tutorial"],"content":" 2 模板介绍首先观察 main.tex，其中 \\input{contents/abstract} 就是表示会加载 main.tex 所在目录的的 contents 目录下的 abstract.tex 的内容，即摘要。 然后是 \\tablecontents 命令以生成目录，目录生成方式应该是由模板决定的。 以下这些则是正文内容： tex \\input{contents/intro} \\input{contents/math_and_citations} \\input{contents/floats} \\input{contents/summary} 我们可以观察一下 contents 目录下的 intro.tex，首先是 \\chapter{简介}，这里的大括号中的内容就是这一章的标题，后续则分别是一级标题、二级标题、三级标题、四级标题，对应的 Latex 语法如下： tex \\section{二级标题} \\subsection{三级标题} \\subsubsection{四级标题} 模板的默认字体应该就是宋体，模板中给出了手动指定该段落的字体的方法。 contents 目录下的 math_and_citations.tex 给出了 Latex 中的数学公式（包括字符）与引用文献的标注方法。 contents 目录下的 floats.tex 则是给出了 Latex 插入图片与表格的方法。 setup.tex 中则是封面以及 Latex 的样式控制的相关信息。 ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:2:0","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#模板介绍"},{"categories":["tutorial"],"content":" 3 SJTUThesis 模板食用方法","date":"2024-02-22","objectID":"/latex-sjtu.zh/:3:0","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#sjtuthesis-模板食用方法"},{"categories":["tutorial"],"content":" 3.1 Overleaf学校网络信息中心应该是根据 Overleaf 自己搭建了一个可以在线编译 Latex 的平台：Latex 文档助手。 首先去 SJTUThesis 的 GitHub 页面下载论文模板的 压缩包：master.zip，在平台上点击 创建新项目 -\u003e 上传项目，如下图所示： 点击项目，可以自行重命名，记得要在菜单处设置编译器为 XeLatex，默认的 pdfLaTex 会导致无法编译生成 PDF，如下图所示： 对于 Windows，如果安装了 IDM，那么需要取消 IDM 对该网站的下载的自动接管，否则会导致每次编译的时候，网站编译失败，无法在网站查看 PDF，同时 IDM 会提示你是否下载 PDF（该 PDF 是正常的编译结果）。 ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:3:1","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#overleaf"},{"categories":["tutorial"],"content":" 3.2 VsCode学校搭建的在线平台虽然能在线同步文档内容，省去了自行配置 Latex 环境，但仍有一些不方便的地方，例如要插入图片，需要自己手动上传 xxx.pdf，参考文献也是，并且编译速度较慢，今天使用的时候还碰到了服务器问题，故选择在自己的 Winodws 笔记本上搭建本地的 Latex 编译环境。 首先，执行 scoop install latex，则 scoop 会为你自动安装 MiKTeX，再执行 scoop install perl 以安装必须的工具。MiKTex 与 Tex Live 是 Latex 的两种发行版，MiKTeX 支持 install on the fly，即用到某个 package 时再进行安装，因此初次安装时，体积会比大而全的 TeX Live 小很多。当然，最关键的原因是，scoop 只能安装 MiKTeX。 安装好之后，在 VsCode 中还需要安装 LaTeX Workshop 插件，安装好之后，对于交大的毕业论文模板，只需要在编译的时候选择 Recipe: latexmk(xelatex) 编译即可，并在设置中将 latex-workshop.latex.recipe.default 修改为 lastUsed 以一直使用该选项来编译。 不知道换用其他模板之后是否还是这样，不过除了写论文，以后用到 LaTeX 的机会应该也挺少的。 之后，打开 MiKTeX 的设置，将 自动安装缺失的宏包 的选项设置为总是，如下图： 然后在 VsCode 中打开该模板项目，终端中执行 ./Compile.bat，就会编译生成 PDF，这个过程中 MiKTeX 会自动安装需要的宏包。 VsCode 中，快捷键 Ctrl + Alt + b 是编译 LaTeX 项目生成 PDF 的快捷键，PDF 生成目录可能需要执行两次编译。 ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:3:2","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#vscode"},{"categories":["tutorial"],"content":" 4 将 LaTeX 部署到服务器上","date":"2024-02-22","objectID":"/latex-sjtu.zh/:4:0","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#将-latex-部署到服务器上"},{"categories":["tutorial"],"content":" 4.1 安装 MiKTex由于博主平时使用的主力电脑是 MacBook 14 Pro，而之前的 Windows 笔记本存在每隔几天就可能死机的问题，因此博主本来是希望将 LaTeX 也部署在自己的 mac 上的，后面想到自己宿舍有一台 J3855u 的小主机（还有几个吃灰的 VPS），于是博主向 ChatGPT 咨询了一下 LaTeX 的性能要求，得出的结论是 J3855u 足以满足，因此干脆装在刷了 Debian 的小主机上，mac 通过 VsCode Remote 连接上去来编写。 由于 Tex Live 体积过大，有很多不必要的宏包，因此这里还是选择安装 MiKTex。安装教程可以参见 MiKTex 官方安装教程，执行以下命令即可安装： sh curl -fsSL https://miktex.org/download/key | sudo tee /usr/share/keyrings/miktex-keyring.asc \u003e /dev/null echo \"deb [signed-by=/usr/share/keyrings/miktex-keyring.asc] https://miktex.org/download/debian bookworm universe\" | sudo tee /etc/apt/sources.list.d/miktex.list sudo apt-get update sudo apt-get install miktex 执行完命令之后，安装还剩最后一步，考虑到我的 Debian 小主机没有 GUI，因此这里使用命令行来操作： sh miktexsetup finish # 完成安装，这里是安装给了当前用户，如果希望为所有用户安装，请执行 `sudo miktexsetup --shared=yes finish` initexmf --set-config-value [MPM]AutoInstall=1 # 设置自动安装缺失的宏包，如果前面选择了为所有用户安装，则应该执行 `sudo initexmf --admin --set-config-value [MPM]AutoInstall=1` 这里要注意的是，如果只为当前用户安装，那么需要将 ~/bin 添加到环境变量中，由于每个人使用的 Shell 不同，添加环境变量的方法也可能不同，这里不再赘述。 安装好之后，再安装 VSCode 的 LaTeX Workshop 插件，使用方法与前文一致。 ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:4:1","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#安装-miktex"},{"categories":["tutorial"],"content":" 4.2 使用自定义字体完成安装之后，执行 git clone https://github.com/sjtug/SJTUThesis.git 即可获取模板，cd SJTUThesis 之后，执行 make all 理论上即可编译生成 PDF，然而，在 Debian 上，该模板默认使用的中文字体是 Fandol，该字体年久失修，缺少许多中文字符，参照 在 Overleaf 上配置自定义中文字体。 首先找到 Windows 系统自带的「宋体」、「黑体」、「楷体」、「仿宋」的字体文件，一般存放在 C:\\Windows\\Fonts 目录下，文件名分别为 simsun.ttc、simhei.ttf、simkai.ttf、simfang.ttf。 我将它们放在了 ~/code/latex/fonts 目录下，模板项目位于 ~/code/latex/master-thesis 目录，然后在 main.tex 中配置字体，首先在模版类选项中添加 cjk-font=none 来关闭 ctex 的自动中文配置： tex \\documentclass[type=master, cjk-font=none]{sjtuthesis} 然后在 input{setup} 之前添加以下内容： tex % 设置字体路径 \\defaultfontfeatures{Path=../fonts/} % 设置中文字体 \\setCJKmainfont[ AutoFakeBold = 3, ItalicFont = simkai.ttf ]{simsun.ttc} \\setCJKsansfont[AutoFakeBold=3]{simhei.ttf} \\setCJKmonofont{simfang.ttf} \\setCJKfamilyfont{zhsong}{simsun.ttc}[ AutoFakeBold = 3, ItalicFont = simkai.ttf ] \\setCJKfamilyfont{zhhei}{simhei.ttf}[AutoFakeBold=3] \\setCJKfamilyfont{zhkai}{simkai.ttf} \\setCJKfamilyfont{zhfs}{simfang.ttf} \\newcommand*{\\songti}{\\CJKfamily{zhsong}} \\newcommand*{\\heiti}{\\CJKfamily{zhhei}} \\newcommand*{\\kaishu}{\\CJKfamily{zhkai}} \\newcommand*{\\fangsong}{\\CJKfamily{zhfs}} 之后再执行 make all 来编译生成 PDF 时，就不会报没有对应中文字符的错误了。 另外还有一种方法，就是先执行以下命令，将 Windows 的这些中文字体安装到系统： sh sudo mkdir /usr/share/fonts/winfonts sudo cp *.ttf /usr/share/fonts/winfonts # *.ttf 即你要安装的字体 sudo cp *.ttc /usr/share/fonts/winfonts sudo mkfontscale sudo mkfontdir sudo fc-cache -fsv 再查看系统中安装的中文字体： sh fc-list :lang=zh | grep sim 有输出，说明中文字体已经安装好了，然后修改模板类选项为 \\documentclass[type=master, cjk-font=windows]{sjtuthesis} 即可。 ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:4:2","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#使用自定义字体"},{"categories":["tutorial"],"content":" 5 插入参考文献我使用的文献管理软件是 zotero，要插入参考文献到 Latex 可以说非常方便，在 zotero 中，选中你要插入的那些文献，右键 -\u003e 导出条目，如下图所示： 然后选择格式为 BibLaTex，如下图所示， 之后则会导出生成一个 xxx.bib 文件，然后，我在我的 Latex 项目中新建了一个 myref 目录，将 xxx.bib 文件导入到了该目录中，并在 setup.tex 中添加 addbibiresourse{myref/xxx.bib}，然后就可以在正文中通过 \\cite{x1} 来进行引用了，其中 x1 是你要引用的文章在 xxx.bib 中的 id，即 @article{ 后面跟的内容（或者 @thesis{ 等），如下图所示： 注意，如果 setup.tex 中添加了 addbibiresourse{myref/xxx.bib} 内容，而对应目录不存在 xxx.bib 文件，则无法生成 main.bbl，从而生成的 PDF 的中所有参考文献都无法正常插入！ 至于其他格式的参考文献的插入，可以参见交大的 Latex 模板中的说明。 Better BibTex 首选项中，导出 -\u003e 字段设置为 abstract, file, url，即导出时不包括这三个字段。 ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:5:0","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#插入参考文献"},{"categories":["tutorial"],"content":" 6 插入图片Latex 中插入图片稍微有点麻烦，由于我的 Latex 的编译器是 XeLaTex，因此要插入的图片必须保存为 .eps 格式，对于 Windows 来说，可以执行 scoop install imagemagick 来下载安装图片转换软件，安装好之后，终端中进入图片所在的目录，执行 magick convert xxx.png xxx.eps 即可将 .png 格式的图片转换为 .eps 格式。 然后，在 Latex 项目中新建一个 mypic 目录，将 xxx.eps 导入到该目录中，在你需要插入图片的正文处，添加以下代码： 事实上，eps 已经是较为落后的格式了，容易出现奇怪的兼容性问题，导致无法成功编译生成 PDF。我在 Debian 上就碰到了样的问题，目前推荐将图片转换成 PDF 再插入到 LaTeX 中，而不是转换成 eps。Debian 上执行 sudo apt-get install imagemagick 安装好 imagemagick 之后，执行 convert xxx.png xxx.pdf 就能将 png 格式的图片转换成 PDF 格式。 tex \\begin{figure}[!htp] \\centering \\includegraphics[]{mypic/detect_along_edge.eps} % 大括号中为图片路径，中括号中可以添加图片的 height、weight 等大小参数 \\bicaption{沿边缘探测}{detection along the edge} % 图片的标题 \\label{fig:along_side_detect} % 图片的标签，用于在正文中引用 \\end{figure} \\begin{figure}[!htp] \\centering \\includegraphics[]{mypic/detect_along_edge.pdf} % 大括号中为图片路径，中括号中可以添加图片的 height、weight 等大小参数，注意这里使用的是 pdf！！！ \\bicaption{沿边缘探测}{detection along the edge} % 图片的标题 \\label{fig:along_side_detect} % 图片的标签，用于在正文中引用 \\end{figure} 例如 图 ~\\ref{fig:along_side_detect} 编译后就会显示 图 x-x，其中 x-x 即图片的编号。 ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:6:0","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#插入图片"},{"categories":["tutorial"],"content":" 7 插入公式Latex 中插入公式比较方便，以下代码便可以在 Latex 中插入两个公式： tex \\begin{equation} m = \\lfloor \\frac{X_{max}-X_{min}+W}{L} \\rfloor + 1, \\label{eq:m_cell} \\end{equation} \\begin{equation} n = \\lfloor \\frac{Y_{max}-Y_{min}+W}{L} \\rfloor + 1. \\label{eq:n_cell} % eq:n_cell 是公式的标签，用于在正文中引用，用法类似图片的 label \\end{equation} $\\lim\\limits_{x = 0}$ ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:7:0","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#插入公式"},{"categories":["tutorial"],"content":" 8 参考Latex编译（Miktex与texlive异同） SJTUThesis 说明 ","date":"2024-02-22","objectID":"/latex-sjtu.zh/:8:0","series":null,"tags":["latex"],"title":"利用 Latex 写毕业论文","uri":"/latex-sjtu.zh/#参考"},{"categories":["tutorial"],"content":" 1 iCloudiCloud 是 Mac 的默认云盘，Apple 为 Mac 提供了一定程度上的 iCloud 集成，在 Apple ID -\u003e iCloud -\u003e iCloud 云盘 中，可以选择让“桌面与文稿文件夹”也使用 iCloud 云盘，此时，你原先的 /Users/Documents 和 /Users/Desktop 会被替换为 iCloud/Documents 中的 文稿 - zwy - mbp14 以及 icloud/Desktop 中的 桌面 - zwy - mpb14 目录，同时 iCloud 中的 文稿 目录与 桌面 目录会被分别作为 Mac 的 /Users/Documents 与 /Users/Desktop 目录，推测是通过符号链接来实现的？ 此后所有的对 /Users/Docuements 与 /Users/Desktop 的修改都会反映到 iCloud 中。 要注意一点，推荐关闭 iCloud 的 优化 Mac 储存空间 功能，否则当你的 Mac 存储空间不足的时候，/Users/Documents 与 /Users/Desktop 目录中的内容会变成仅保存在 iCloud 云端，而本地没有保存内容，这会导致在这两个目录中执行 git 与 cd 等命令非常卡顿。 ","date":"2024-01-15","objectID":"/cloud-sync.zh/:1:0","series":null,"tags":["git"],"title":"Mac 与 win 之间的云同步处理","uri":"/cloud-sync.zh/#icloud"},{"categories":["tutorial"],"content":" 2 OneDriveWindows 也提供了对 OneDrive 的集成，但是开启之后，不像 iCloud 那么彻底，原先的 C:\\Users\\zwyyy\\Documents 与 C:\\Users\\zwyyy\\Desktop 目录依旧存在，只是文件管理器左侧显示的 桌面 与 文档 会指向 C:\\Users\\zwyyy\\OneDrive\\Desktop 和 C:\\Users\\zwyyy\\OneDrive\\Documents 两个目录，同时 Windows 的桌面显示的内容也被替换成了 C:\\Users\\zwyyy\\OneDrive\\Desktop 中的内容。 ","date":"2024-01-15","objectID":"/cloud-sync.zh/:2:0","series":null,"tags":["git"],"title":"Mac 与 win 之间的云同步处理","uri":"/cloud-sync.zh/#onedrive"},{"categories":["tutorial"],"content":" 3 最佳实践通过 git 进行版本管理 的代码文件不适合存放在云盘会自动同步的目录中，哪怕是使用 mega 这种自定义排除同步功能十分丰富的云盘，也不推荐，这是因为云盘对文件的同步容易被 git 视为修改，从而在 git pull 时发生 conflict，哪怕这个文件的内容你实际上没有修改。 推荐将 code 目录直接存放在 /Users/zwyyy/ 目录下（Mac）或者 C:\\Users\\zwyyy 目录下（Windows）。 代码文件统一存放在 code 目录下，blog 也存放在 code 目录下。 源代码编译时会产生大量的临时文件，这也是不推荐将代码源文件通过云同步工具进行同步的一个重要原因。 ","date":"2024-01-15","objectID":"/cloud-sync.zh/:3:0","series":null,"tags":["git"],"title":"Mac 与 win 之间的云同步处理","uri":"/cloud-sync.zh/#最佳实践"},{"categories":["tutorial"],"content":" 4 代码文件的自动同步代码文件一般通过 git 进行版本管理，因此不适合存放在云盘中进行同步，然而总有代码写了一部分，忘记 push 到 github，而回家之后，要接着修改代码的情况，那应该如何实现代码的自动同步呢？ 对 Mac 或者 Linux，解决方案为通过 crontab 自动执行 git push 命令，具体一点，即定时执行以下命令： sh git add -A git commit -m \"mac, auto sync\" git push ali main:mac # Linux 替换为 linux 分支，Windows 替换为 win 分支 Windows 应该差不多，即要求定时执行 powershell 脚本。 sh git add -A git commit -m \"win, auto push\" git push ali main:win 之后，假设回到家，发现之前忘记手动 push 了，那么只需要执行以下命令： sh git checkout mac # 切换到 mac 分支 git pull gitlab mac git checkout main git merge mac # 将本地的 mac 分支的更改合并到 main 分支中 git push origin main 对于 windows，则是： sh git checkout win git pull ali win git checkout main git merge win 根据当前作息，我将设置 mac 在 18:10 与 20:40 定时执行 push。 ","date":"2024-01-15","objectID":"/cloud-sync.zh/:4:0","series":null,"tags":["git"],"title":"Mac 与 win 之间的云同步处理","uri":"/cloud-sync.zh/#代码文件的自动同步"},{"categories":["tutorial"],"content":" 4.1 mac 设置 crontabmac 可以通过 crontab 工具实现定时执行 push 操作。为了保证 crontab 可以正常执行，我们需要做一点额外配置。 首先执行 crontab -e，修改为如下内容并退出保存： sh 6 18 * * * zsh /Users/zwyyy/.config/mac-push.sh 7 18 * * * zsh /Users/zwyyy/code/bean/mac-push.sh 8 18 * * * zsh /Users/zwyyy/code/leetcode/mac-push.sh 9 18 * * * zsh /Users/zwyyy/code/blog/zwyb_blog/mac-push.sh 36 20 * * * zsh /Users/zwyyy/.config/mac-push.sh 37 20 * * * zsh /Users/zwyyy/code/bean/mac-push.sh 38 20 * * * zsh /Users/zwyyy/code/leetcode/mac-push.sh 39 20 * * * zsh /Users/zwyyy/code/blog/zwyb_blog/mac-push.sh 然后执行 sudo launchctl list | grep cron 查看任务是否存在，我的输出如下： sh zwyyy@zwy-mbp14 ~/c/bean (main)\u003e sudo launchctl list | grep cron (base) 458 0 com.vix.cron 有输出说明任务存在。然后执行 locate com.vix.cron 查看启动项配置，如果有 WARNING，就执行系统提供的命令 sudo launchctl load -W /System/Library/LaunchDaemons/com.apple.locate.plist。 然后查看 /etc/crontab 是否存在，我这里是不存在的，需要执行 sudo touch /etc/crontab 来创建。 之后，可能需要给 crontab 完全磁盘访问权限，crontab 安装于 /usr/bin，我们打开 系统偏好设置 -\u003e 隐私与安全性 -\u003e 完全磁盘访问权限，将访达中的 crontab 图标拖进去，即可为 crontab 启用完全磁盘访问权限。 但是我的 crontab 执行的命令似乎并不需要完全磁盘访问权限，一般来说，应用需要访问 User 的 Documents、Desktop、Downloads、OneDrive 这几个目录会需要单独授予磁盘访问权限，对 crontab，我们无法单独授予对某个文件夹的访问权限，因此只能授予完全磁盘访问权限。 关于 crontab 是否需要完全磁盘访问权限，这一点还有待测试。 当前测试表明不需要完全磁盘访问权限。 ","date":"2024-01-15","objectID":"/cloud-sync.zh/:4:1","series":null,"tags":["git"],"title":"Mac 与 win 之间的云同步处理","uri":"/cloud-sync.zh/#mac-设置-crontab"},{"categories":["tutorial"],"content":" 4.2 Windows 设置定时任务以 Win11 操作系统为例，打开 任务计划程序，点击 任务计划程序库，然后点击右侧的 创建任务，在 触发器 标签处选择每日重复，在 操作 标签下，程序 选择 pwsh.exe，参数 设置为 -ExecutionPolicy Bypass -File \"C:\\path\\to\\your\\script.ps1\"。 其中 -ExecutionPolicy Bypass 表示 PowerShell 脚本的执行策略为 Bypass，即允许所有 PowerShell 脚本运行而不受任何限制，-File 之后则是要执行的脚本的具体路径。 ","date":"2024-01-15","objectID":"/cloud-sync.zh/:4:2","series":null,"tags":["git"],"title":"Mac 与 win 之间的云同步处理","uri":"/cloud-sync.zh/#windows-设置定时任务"},{"categories":["tutorial"],"content":" 1 简介主要使用基于 Debian 的 VPS 进行发种，流程上与纯粹的 Windows 平台发种略有不同，需要依赖命令行工具进行处理。 ","date":"2023-12-31","objectID":"/gpw-upload-tutorial.zh/:1:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/gpw-upload-tutorial.zh/#简介"},{"categories":["tutorial"],"content":" 2 mediainfo执行 sudo apt install mediainfo 即可安装 mediainfo，执行 mediainfo video_name 即可生成对应的 mediainfo。 可以利用 \u003e 将输出重定向到指定文件。 ","date":"2023-12-31","objectID":"/gpw-upload-tutorial.zh/:2:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/gpw-upload-tutorial.zh/#mediainfo"},{"categories":["tutorial"],"content":" 3 视频截图海豹要求三张原始分辨率的视频截图，我们可以利用 ffmpeg 来抓取截图。 执行 sudo apt install ffmpeg 即可安装 ffmpeg。 通过执行 ffmpeg -ss 00:08:06 -i $video_file -vframes 1 -f image2 -y test1.png 即可生成原始分辨率的 png 截图，其中 $video_file 要替换成对应的文件名。 ","date":"2023-12-31","objectID":"/gpw-upload-tutorial.zh/:3:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/gpw-upload-tutorial.zh/#视频截图"},{"categories":["tutorial"],"content":" 4 生成种子执行 sudo apt install mktorrent 安装 mktorrent，执行 mktorrent ","date":"2023-12-31","objectID":"/gpw-upload-tutorial.zh/:4:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/gpw-upload-tutorial.zh/#生成种子"},{"categories":["tutorial"],"content":" 5 脚本将 mediainfo 和 视频截图整合成了一个简单的 bash 脚本： sh #!/bin/bash video_file=\"\" # 遍历当前目录下所有 .mp4 或者 .mkv 结尾的文件 for file in *.mp4 *.mkv; do if [ -f \"$file\" ]; then video_file+=\"$file\" fi done echo \"Video files: $video_files\" mediainfo \"$video_file\" \u003elog.txt # ffmpeg -ss 00:08:06 -i $video_file -vframes 1 -f image2 -y test1.png ffmpeg -ss 00:06:06 -i $video_file -vframes 1 -f image2 -y test2.png ffmpeg -ss 00:10:06 -i $video_file -vframes 1 -f image2 -y test3.png 该脚本目前仅适用于目录下只有一个要做种的 mkv 文件的情况。 ","date":"2023-12-31","objectID":"/gpw-upload-tutorial.zh/:5:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/gpw-upload-tutorial.zh/#脚本"},{"categories":["tutorial"],"content":" 1 简介主要使用基于 Debian 的 VPS 进行发种，流程上与纯粹的 Windows 平台发种略有不同，需要依赖命令行工具进行处理。 ","date":"2023-12-31","objectID":"/vscode-leetcode-cookie/:1:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/vscode-leetcode-cookie/#简介"},{"categories":["tutorial"],"content":" 2 mediainfo执行 sudo apt install mediainfo 即可安装 mediainfo，执行 mediainfo video_name 即可生成对应的 mediainfo。 可以利用 \u003e 将输出重定向到指定文件。 ","date":"2023-12-31","objectID":"/vscode-leetcode-cookie/:2:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/vscode-leetcode-cookie/#mediainfo"},{"categories":["tutorial"],"content":" 3 视频截图海豹要求三张原始分辨率的视频截图，我们可以利用 ffmpeg 来抓取截图。 执行 sudo apt install ffmpeg 即可安装 ffmpeg。 通过执行 ffmpeg -ss 00:08:06 -i $video_file -vframes 1 -f image2 -y test1.png 即可生成原始分辨率的 png 截图，其中 $video_file 要替换成对应的文件名。 ","date":"2023-12-31","objectID":"/vscode-leetcode-cookie/:3:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/vscode-leetcode-cookie/#视频截图"},{"categories":["tutorial"],"content":" 4 生成种子执行 sudo apt install mktorrent 安装 mktorrent，执行 mktorrent ","date":"2023-12-31","objectID":"/vscode-leetcode-cookie/:4:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/vscode-leetcode-cookie/#生成种子"},{"categories":["tutorial"],"content":" 5 脚本将 mediainfo 和 视频截图整合成了一个简单的 bash 脚本： sh #!/bin/bash video_file=\"\" # 遍历当前目录下所有 .mp4 或者 .mkv 结尾的文件 for file in *.mp4 *.mkv; do if [ -f \"$file\" ]; then video_file+=\"$file\" fi done echo \"Video files: $video_files\" mediainfo \"$video_file\" \u003elog.txt # ffmpeg -ss 00:08:06 -i $video_file -vframes 1 -f image2 -y test1.png ffmpeg -ss 00:06:06 -i $video_file -vframes 1 -f image2 -y test2.png ffmpeg -ss 00:10:06 -i $video_file -vframes 1 -f image2 -y test3.png 该脚本目前仅适用于目录下只有一个要做种的 mkv 文件的情况。 ","date":"2023-12-31","objectID":"/vscode-leetcode-cookie/:5:0","series":null,"tags":["pt"],"title":"简单的 GPW 发种教程","uri":"/vscode-leetcode-cookie/#脚本"},{"categories":["tutorial"],"content":" 1 前言为了存储博客的图片，我需要一个图床，一开始本来是想用七牛云或者又拍云提供的免费存储服务和流量来做图床的，奈何它们都需要一个通过了备案的域名才能实现，于是退而求其次选择了 SM.MS，在 picgo 或者 upic 中配置 SM.MS 图床非常方便，填一个 token 即可，在科学加持的情况下，图片显示也是很快速的。 但是，由于我的博客很多内容是我自己的学习笔记，因此其中的图片内容也是很重要的，考虑到 SM.MS 的图床稳定性与国内的可直接访问性，当我的 zwyyy456.tech 域名通过备案之后，我就着手将图床从 SM.MS 迁移到了又拍云。 ","date":"2023-12-26","objectID":"/change-image-src-from-smms-to-upyun.zh/:1:0","series":null,"tags":["blog","hugo","image"],"title":"将博客的图床从 SM.MS 迁移到又拍云","uri":"/change-image-src-from-smms-to-upyun.zh/#前言"},{"categories":["tutorial"],"content":" 2 又拍云设置又拍云联盟的用户每月可获得 10GB 免费存储空间与 15GB 免费 CDN 流量，要加入又拍云联盟也很简单，只需要在网站地步添加又拍云 LOGO 与又拍云网站的对应链接即可。 在博客所属根目录下，将 layouts/partials/foot.html 的内容修改为如下： html \u003cfooter class=\"footer\"\u003e \u003csection class=\"container\"\u003e © {{ if (and .Site.Params.since (lt .Site.Params.since now.Year)) }} {{ .Site.Params.since }} - {{ end }} {{ now.Year }} {{ with .Site.Params.author }} {{ . }} {{ end }} · {{ if (and .Site.Params.license) }} {{ i18n \"licensed_under\" }} {{ .Site.Params.license | safeHTML }} · {{ end }} {{ i18n \"powered_by\" }} \u003ca href=\"https://gohugo.io/\" target=\"_blank\" rel=\"noopener\"\u003eHugo\u003c/a\u003e \u0026 \u003ca href=\"https://github.com/luizdepra/hugo-coder/\" target=\"_blank\" rel=\"noopener\"\u003eCoder\u003c/a\u003e \u0026 \u003ca href=\"https://www.upyun.com/?utm_source=lianmeng\u0026utm_medium=referral\"\u003e \u003cimg src='/img/upyun.svg' alt=\"又拍云\" width=\"53\" height=\"18\" style=\"fill: currentColor; position: relative; top: +3.5px;\"\u003e \u003c/a\u003e. {{ if (and .Site.Params.commit .GitInfo) }} [\u003ca href=\"{{ .Site.Params.commit }}/{{ .GitInfo.Hash }}\" target=\"_blank\" rel=\"noopener\"\u003e{{ .GitInfo.AbbreviatedHash }}\u003c/a\u003e] {{ end }} \u003cbr\u003e \u003ca href=\"https://beian.miit.gov.cn/\" target=\"_blank\"\u003e湘 ICP 备 2023038416 号\u003c/a\u003e \u003c/section\u003e \u003c/footer\u003e 顺便满足了备案的要求。 完成备案之后，进入又拍云控制台，“云存储服务”那里点击 创建服务，服务名称命名为 image-zwyyy（不可以和全网已有的服务名称重复），应用场景、存储类型、加速区域 都选择默认，授权操作员 选择 新建授权操作员，操作员 与 密码 这两栏自己定义，权限全部勾选，如下图： 创建好之后，进入 配置，在 域名管理 的这一栏下面，点击 域名绑定，绑定已备案域名的子域名，例如 test-upyun.zwyyy456.tech，输入该网址之后，要点击 Enter 才能点击 添加，如下图所示： 在阿里云处添加对应的 CNAME 解析，如下图所示： 然后进入 HTTPS 这一栏，点击 HTTPS 配置 旁边的管理，去 证书管理 处申购免费证书： 在 证书申购 处点击 补全 以补充相关信息： 之后点击提交，在 申请结果 处点击 操作 一栏下的 查看，在阿里云处添加对应的域名解析： 添加好之后结果如下： 之后再在又拍云处点击验证，结果如下： 然后即可回到 存储服务 的 HTTPS 配置处以开启 HTTPS 访问和强制 HTTPS 访问。 ","date":"2023-12-26","objectID":"/change-image-src-from-smms-to-upyun.zh/:2:0","series":null,"tags":["blog","hugo","image"],"title":"将博客的图床从 SM.MS 迁移到又拍云","uri":"/change-image-src-from-smms-to-upyun.zh/#又拍云设置"},{"categories":["tutorial"],"content":" 3 通过 iPic Mover 迁移图床之前尝试通过 picgo 的 migrator 插件迁移图床，发现它无法下载存储在 SM.MS 图床上的照片，后来发现了 iPic Mover 这个工具，它依托于 iPic，iPic 配置好图床之后，即可通过 iPic Mover 进行迁移，非常方便，不过 iPic 需要付费才能自定义图床，但是可以试用七天，完成迁移之后卸载掉即可。 此外，网上也有一些迁移的教程，大概是利用 SM.MS 的 API，写个代码，请求下载对应的图片，并上传至又拍云，然后将链接替换为又拍云的链接。 ","date":"2023-12-26","objectID":"/change-image-src-from-smms-to-upyun.zh/:3:0","series":null,"tags":["blog","hugo","image"],"title":"将博客的图床从 SM.MS 迁移到又拍云","uri":"/change-image-src-from-smms-to-upyun.zh/#通过-ipic-mover-迁移图床"},{"categories":["tutorial"],"content":" 4 Vercel + CloudFlare 重定向次数过多的问题进入 CloudFlare Dashboard，点击有问题的域名，打开左侧的 SSL/TLS 设置，在 Overview 中设置加密模式为完全或完全（严格）即可。 ","date":"2023-12-26","objectID":"/change-image-src-from-smms-to-upyun.zh/:4:0","series":null,"tags":["blog","hugo","image"],"title":"将博客的图床从 SM.MS 迁移到又拍云","uri":"/change-image-src-from-smms-to-upyun.zh/#vercel--cloudflare-重定向次数过多的问题"},{"categories":["tutorial"],"content":" 5 解决“代理情况下无法加载存放于又拍云对象存储的图片”的问题在 rule-provider 目录下 的 direct-rule.yaml 中，追加两条规则： yaml - DOMAIN-SUFFIX,b0.aicdn.com # upyun - DOMAIN-SUFFIX,pic-upyun.zwyyy456.tech ","date":"2023-12-26","objectID":"/change-image-src-from-smms-to-upyun.zh/:5:0","series":null,"tags":["blog","hugo","image"],"title":"将博客的图床从 SM.MS 迁移到又拍云","uri":"/change-image-src-from-smms-to-upyun.zh/#解决代理情况下无法加载存放于又拍云对象存储的图片的问题"},{"categories":["tutorial"],"content":" 1 问题描述前面提到，我会使用 Filen 来同步文件，例如当我在 macOS 上创建了 .md 文件而忘记 push 到 GitHub 时，回到宿舍，打开我 Windows 系统的 Acer 笔记本（后续以 Acer 指代该笔记本）时，Filen 会自动将 .md 文件同步到 Acer，然后当我在 Acer 上完成对该 .md 的编辑并 commit 时，就会提示如下内容： CR 表示 \\r，LF 表示 \\n txt warning: LF will be replaced by CRLF in content/posts/blog/n1-plex-music.zh.md. The file will have its original line endings in your working directory 我们在安装 Git 时，默认 core.autocrlf = true，即 Git 会认为，工作区的文件都应该用 \\r\\n 来换行，如果工作区因为新增（在这个情境下就是因为 Filen 把文件同步到了 Acer）或编辑出现了 \\n 换行符的文件，git add 这些文件时，发现准备提交的文件是 \\n 作为换行符，就会出现这个警告，并提示哪些文件是 \\n 换行的，但是 Git 不会对工作区这些文件做换行符的转换）。 工作区（Working Directory）：这是您本地文件系统中的目录，包含了项目的实际文件。您可以在工作区中进行文件的创建、编辑和删除操作。 暂存区（Staging Area）：也称为索引，是一个中间区域，用于准备要提交到Git存储库的更改。您可以使用 git add 命令将工作区中的文件和更改添加到暂存区，然后使用git commit命令将它们提交到存储库。 存储库（Repository）：存储库是Git用来保存项目的历史记录和元数据的地方。它包含了所有以前提交的版本、分支信息、标签和提交记录。存储库通常位于项目目录的.git子目录中。 core.autocrlf = true 表示在 commit 时，将工作区文件的换行符由 \\r\\n 转换为 \\n，即 Repository 的文件一定是 \\n 换行的，而在 checkout 或者 pull 时，会将 checkout 或者 pull 到本地的文件转换为 \\r\\n 换行，这就是 解决 macOS 上的 fish 出现的 ’et_color Unkown color ’ 问题 这篇文章碰到的问题的根本原因。 我先执行了 git pull，将 macOS 上对 .config 目录的修改同步到了本地，由于 fish_variables 在 macOS 上可能发生了修改，于是 pull 的时候，Windows 中的 ~/.config/fish/fish_variables 在从 Github pull 到本地时，换行符就被从 \\n 转换成了 \\r\\n，然后 \\r\\n 换行同步的文件就被 Filen 同步到了 macOS 上去了，macOS 上 fish 就无法正确识别 fish_variables 中定义的变量，就出现了 ’et_color Unkown color ’ 问题。 ","date":"2023-12-18","objectID":"/git-crlf-lf.zh/:1:0","series":null,"tags":["git","trick"],"title":"Git 如何避免 'warning: LF will be replaced by CRLF'","uri":"/git-crlf-lf.zh/#问题描述"},{"categories":["tutorial"],"content":" 2 解决方案首先，执行 git config --global core.autocrlf input，表示在 commit 时，将 \\r\\n 自动转换成 \\n，而 pull 或者 checkout 时，不转换 \\r\\n 或者 \\n，保持原样。 然后，我们需要修改 VsCode、NeoVim、Sublime Text 这三个编辑器的设置，让它们即使在 Windows 下也以 \\n 作为换行。 对 VsCode，设置中搜索 eol，修改为 \\n；对于 Sublime Text，修改 View -\u003e Line Endings 为 Unix；对于 Neovim，在 nvim/lua/config/options.lua 中追加 vim.opt.fileformat = 'unix'。 我平时会用到的编辑器就是以上三个。 这个解决方案比较暴力，就是保证不管是 Windows 还是 macOS 都使用 \\n 来进行换行。 ","date":"2023-12-18","objectID":"/git-crlf-lf.zh/:2:0","series":null,"tags":["git","trick"],"title":"Git 如何避免 'warning: LF will be replaced by CRLF'","uri":"/git-crlf-lf.zh/#解决方案"},{"categories":["tutorial"],"content":" 1 问题描述我的其中一个 Hugo 博客采用了 PaperMod 主题，另一个是 hugo-coder 主题，都是通过 Netlify 部署，昨天晚上发现，Netlify 显示 paper.191000.xyz 对应的站点部署失败。 问题日志显示： txt 12:26:05 PM: Waiting for other deploys from your team to complete. Check the queue: https://app.netlify.com/teams/zwyyy456/builds 12:26:20 PM: build-image version: 3ffff9df3d5419545acc1b673a54de348174406d (focal) 12:26:20 PM: buildbot version: 4613af4169363e3b38cfadfa4665d34cd1d1427b 12:26:20 PM: Fetching cached dependencies 12:26:20 PM: Starting to download cache of 106.8MB 12:26:22 PM: Finished downloading cache in 1.935s 12:26:22 PM: Starting to extract cache 12:26:23 PM: Finished extracting cache in 720ms 12:26:23 PM: Finished fetching cache in 2.7s 12:26:23 PM: Starting to prepare the repo for build 12:26:23 PM: Preparing Git Reference refs/heads/main 12:26:24 PM: Failed during stage \"preparing repo\": From https://github.com/zwyyy456/hugo_papermod_blog * branch main -\u003e FETCH_HEAD 1a77de2..dda4b64 main -\u003e origin/main warning: ae66501cc9d0ba080c7fcb5a852c0f9fe8649d0d:.gitmodules, multiple configurations found for \"submodule.themes/PaperMod.path\". Skipping second one! warning: ae66501cc9d0ba080c7fcb5a852c0f9fe8649d0d:.gitmodules, multiple configurations found for \"submodule.themes/PaperMod.url\". Skipping second one! Fetching submodule themes/PaperMod From https://github.com/adityatelange/hugo-PaperMod 0dfff4e..8411030 exampleSite -\u003e origin/exampleSite b288ede..0989c28 master -\u003e origin/master fatal: remote error: upload-pack: not our ref ea64dacc943c5a0d3163dd75dcc11d5e791a37b4 Errors during submodule fetch: themes/PaperMod : exit status 1 ","date":"2023-12-18","objectID":"/netlify-build-error.zh/:1:0","series":null,"tags":["hugo","trick","netlify"],"title":"解决 Netlify 部署 Hugo 静态博客时的 `fatal: remote error: upload-pack: not our ref` 问题","uri":"/netlify-build-error.zh/#问题描述"},{"categories":["tutorial"],"content":" 2 解决方案问题出在访问 https://github.com/adityatelange/hugo-PaperMod/tree/ea64dacc943c5a0d3163dd75dcc11d5e791a37b4 的结果已经是 404 了，大概就是 PaperMod 主题提交记录改变之类的原因导致的，而 Netlify 还在使用这个 sha 记录，解决方案也很简单，点击 retry -\u003e Clear cache and deploy site 即可。 对于 Git 的细节我并不清楚，这里的问题原因看看就好。 ","date":"2023-12-18","objectID":"/netlify-build-error.zh/:2:0","series":null,"tags":["hugo","trick","netlify"],"title":"解决 Netlify 部署 Hugo 静态博客时的 `fatal: remote error: upload-pack: not our ref` 问题","uri":"/netlify-build-error.zh/#解决方案"},{"categories":["tutorial"],"content":" 3 参考Fatal: remote error: upload-pack: not our ref ","date":"2023-12-18","objectID":"/netlify-build-error.zh/:3:0","series":null,"tags":["hugo","trick","netlify"],"title":"解决 Netlify 部署 Hugo 静态博客时的 `fatal: remote error: upload-pack: not our ref` 问题","uri":"/netlify-build-error.zh/#参考"},{"categories":["tutorial"],"content":" 1 问题简介我主要使用的 shell 是开箱即用的 fish，fish 的配置文件位于 ~/.config/fish 中，整个 .config 目录使用 Filen 实现在 macOS 和 Windows 之间的同步，并且使用 Git 进行版本管理。 当我昨天在 Windows 下修改了 .config/nvim 目录中的文件，将修改 push 到 GitHub 之后，今天在 Mac 上将修改 pull 到本地之后，fish 就出现了 'et_color: Unkown color ' 问题，如下图所示： ","date":"2023-12-18","objectID":"/win-macos-fish_variables.zh/:1:0","series":null,"tags":["trick","fish"],"title":"解决 macOS 上的 fish 出现的 'et_color Unkown color ' 问题","uri":"/win-macos-fish_variables.zh/#问题简介"},{"categories":["tutorial"],"content":" 2 解决方案检查 ~/.config/fish/fish_variables 文件，与 Filen 中记录的历史版本进行对比，发现每一行结尾都多了 \\x0d，经查阅资料， \\0d 表示回车，即 \\r，而 mac 默认的换行标识为 \\n。 删掉所有的 \\x0d 之后就正常了，而问题出现的原因也很清楚了，在编辑文件（也可能是 Git 同步）的时候，fish_variables 文件的换行被从 \\n 替换成了 \\r\\n，于是，就出现了上述的问题。 在我记忆中，我在 Windows 下应该是没有修改过 fish_variables文件的。 后续需要配置一下 Windows 下 Git 的换行符设置问题。 ","date":"2023-12-18","objectID":"/win-macos-fish_variables.zh/:2:0","series":null,"tags":["trick","fish"],"title":"解决 macOS 上的 fish 出现的 'et_color Unkown color ' 问题","uri":"/win-macos-fish_variables.zh/#解决方案"},{"categories":["tutorial"],"content":" 1 自定义字体RemNote 的默认字体用于代码块时，显示效果十分拉垮，i 与 e 这两个字母的看起来明显比 m 之类的字母更细。 RemNote 可以通过 Custom CSS 来自定义显示效果，关键在于找到对应的 CSS selector。 我们可以在 Firefox 上打开 www.remnote.com，点开一篇笔记，例如 200 秋招，然后鼠标划词选中内容，右键点击 检查，如下图所示： 因此，可以注意到，行内代码对应的 selector 为 .rn-code-node .w-full .font-mono，因此 Custom CSS 添加 css .rn-code-node .w-full, .font-mono { font-family: Monaco Nerd Font Mono; font-size: 14px } 而对于启用了 Lab 中的 rem code block 之后的代码块，使用同样的方式找到对应的 CSS selector： 因此 Custom CSS 添加 css .rn-code-node .w-full, .font-mono { font-family: Monaco Nerd Font Mono; font-size: 14px } 同时，对于 RemNote 的笔记中的字体，这里修改为 霞鹜文楷，很好看。 css .rn-editor__rem__body__text { font-family: \"LXGW WenKai\", \"霞鹜文楷\"; } mac 可以通过执行 brew install font-lxgw-wenkai --cask 来安装字体，系统中显示的字体名称为 霞鹜文楷，而 win 可以通过执行 scoop install LXGWWenKai 来安装，系统中显示的字体名称为 LXGW WenKai。 代码块与行内代码，实际上是我在 QQ 群里问到了 selector 之后，又用 Firefox 的开发者工具去验证这个 selector 而已。 ","date":"2023-12-14","objectID":"/remnote-tutorial.zh/:1:0","series":null,"tags":["remnote","trick"],"title":"RemNote 入门教程","uri":"/remnote-tutorial.zh/#自定义字体"},{"categories":["tutorial"],"content":" 2 筛选所有的 Todo remmacOS 下按下 cmd + p，然后输入 Todo，创建名为 Todo 的 rem，在这个 rem 中即可看到所有的 /todo rem。 ","date":"2023-12-14","objectID":"/remnote-tutorial.zh/:2:0","series":null,"tags":["remnote","trick"],"title":"RemNote 入门教程","uri":"/remnote-tutorial.zh/#筛选所有的-todo-rem"},{"categories":["tutorial"],"content":" 1 功能简介应该可以说是一台 AIO，利用 PVE 虚拟化多个系统，实现不同功能： 基于 Debian 的开发机，ssh 连接上去进行远程开发、编译； Nas，预计采用 TrueNAS SCALE； 其他服务，都通过 Docker 运行，考虑采用 FlatCar 这种容器化系统，也可能直接跑在 Debian 上。 qBittorrent; Immich; Memos; Restic; Plex Media Server CloudDrive2 IYUUPlus Alist Rclone ","date":"2023-12-04","objectID":"/nas-build.zh/:1:0","series":null,"tags":["nas","trick\""],"title":"Nas 预组","uri":"/nas-build.zh/#功能简介"},{"categories":["tutorial"],"content":" 2 硬件选择","date":"2023-12-04","objectID":"/nas-build.zh/:2:0","series":null,"tags":["nas","trick\""],"title":"Nas 预组","uri":"/nas-build.zh/#硬件选择"},{"categories":["tutorial"],"content":" 2.1 联想 RD450xCPU 拟采用 E5 2680v4。 优点：硬件成本低，机箱 + 主板 + CPU 仅需 ￥600，且有极强的扩展性； 缺点：功耗高，不带硬盘的待机功耗约为 80W，满载功耗约为 200W，无 GPU 硬件转码功能； ","date":"2023-12-04","objectID":"/nas-build.zh/:2:1","series":null,"tags":["nas","trick\""],"title":"Nas 预组","uri":"/nas-build.zh/#联想-rd450x"},{"categories":["tutorial"],"content":" 2.2 梵隆机箱主板可以选择 MATX 主板，CPU 考虑使用 12400？ 优点：功耗相比服务器更低，12400 待机功耗约 30W，待机功耗大概能低 50W？考虑到上海电费，一年能省下 50 * 24 /1000 * 365 * 0.75 = 300 元人民币左右，可以使用 GPU 硬件进行转码； 缺点：扩展性不如服务器，且硬件成本高，大概能高出 3 年的电费； ","date":"2023-12-04","objectID":"/nas-build.zh/:2:2","series":null,"tags":["nas","trick\""],"title":"Nas 预组","uri":"/nas-build.zh/#梵隆机箱"},{"categories":["tutorial"],"content":" 3 结论暂定，等毕业论文搞定之后考虑去 V2EX 和 CHH 上发帖咨询之后再决定。 2055 427 1038 ","date":"2023-12-04","objectID":"/nas-build.zh/:3:0","series":null,"tags":["nas","trick\""],"title":"Nas 预组","uri":"/nas-build.zh/#结论"},{"categories":["tutorial"],"content":" 1 Filen 介绍这里直接引用官网的介绍：“Zero knowledge end-to-end encrypted cloud storage, redefined”。 即这是一个端对端加密的同步盘，类似 Dropbox 和坚果云，不同于百度网盘、115、阿里云盘这样的资源盘，支持文件历史版本。 通过他人的邀请链接注册可以获得 20G 的初始容量，之后邀请 3 个人注册可以再获得 30G 的容量，就同步来说，50G 其实也够了，我趁着黑五促销，又买了 100G 的永久容量。 目前看来，它的同步功能做得不如坚果云，不支持 webdav，也没有云桥功能（虽然这个功能我用不到）但是坚果云不付费的限制比较多，而 Filen 付费与否只与容量相关。 此外，Filen 对我而言有一个杀手级别的功能，那就是支持设置 .filenignore，即采用类似 gitignore 的语法，不同步某些特定文件，例如 build 的产物等。 ","date":"2023-11-28","objectID":"/filen_use.zh/:1:0","series":null,"tags":["trick"],"title":"使用 Filen 同步文件夹","uri":"/filen_use.zh/#filen-介绍"},{"categories":["tutorial"],"content":" 2 文件夹同步设置前文提到，Filen 是一个同步盘，我的用途也是实现 mac 和 windows 笔记本之间的同步，主要包括配置文件、代码文件以及博客文本文件等。 本来 onedrive 的同步功能也还可以，但是不支持“指定特定文件夹不同步”让他在同步带 .git 的代码文件夹时，非常容易出问题。 同步文件夹的设置如下图： 点击 create one 就会让你选择一个本地的文件夹，选定好之后，settings-\u003esyncs 会多出一栏，点击右边的设置图标，即可配置 .filenignore，语法同 .gitignore，sync mode 一般选择 Two Way。然后点击 select remote location，可以选择要同步到云盘中的哪个文件夹，选择好之后就可以开始同步了。 ","date":"2023-11-28","objectID":"/filen_use.zh/:2:0","series":null,"tags":["trick"],"title":"使用 Filen 同步文件夹","uri":"/filen_use.zh/#文件夹同步设置"},{"categories":["tutorial"],"content":" 3 选择同步的文件夹目前，mac 上我同步了这些文件夹： 尽管除了 .ssh 和 Pictures 文件夹之外，其他文件夹都有通过 git 和进行 GitHub 进行版本管理与同步，但是难免有忘记 commit 和 push 的情况。例如，假设我在 mac 上对代码进行了修改，但是忘记 push 到 GitHub 了，然后回到了宿舍，此时宿舍的 Windows 笔记本无法获取到 mac 上对代码的修改，但有了 Filen 同步就不一样了，尽管 git 的状态与 mac 不一致，但源文件的修改是一致的，Windows 修改了之后，再 push 到 GitHub 上即可（实际上不 push 也没啥问题）。 ","date":"2023-11-28","objectID":"/filen_use.zh/:3:0","series":null,"tags":["trick"],"title":"使用 Filen 同步文件夹","uri":"/filen_use.zh/#选择同步的文件夹"},{"categories":["tutorial"],"content":" 4 文件组织","date":"2023-11-28","objectID":"/filen_use.zh/:4:0","series":null,"tags":["trick"],"title":"使用 Filen 同步文件夹","uri":"/filen_use.zh/#文件组织"},{"categories":["tutorial"],"content":" 4.1 mac 博客都存放在 ~/Documents/blog/ 目录下，会被自动上传到 iCloud 来进行备份； 代码文件分为两类： 可以直接在 mac 上运行的代码，例如 python，leetcode 直接存放在 ~/Documents/code 目录下，会被自动上传到 iCloud 进行备份； 需要 Linux 环境才能运行的代码，例如 webserver，存放在 OrbStack 的虚拟机的 ~/code 目录下； ","date":"2023-11-28","objectID":"/filen_use.zh/:4:1","series":null,"tags":["trick"],"title":"使用 Filen 同步文件夹","uri":"/filen_use.zh/#mac"},{"categories":["tutorial"],"content":" 4.2 Windows 博客都存放在 ~/OneDrive/Documents/blog/ 目录下，会被自动上传到 OneDrive 来进行备份； 代码文件分为两类： 可以直接在 Windows 上运行的代码，例如 python，leetcode 直接存放在 ~/OneDrive/Documents/code 目录下，会被自动上传到 OneDrive 进行备份； 需要 Linux 环境才能运行的代码，例如 webserver，存放在 WSL 的虚拟机的 ~/code 目录下； Filen 无法同步 WSL 中的文件夹，因此代码文件需要从 GitHub pull，可以先在 ~/OneDrive/Documents/code/xxx 中 push 到 GitHub，再从 WSL 中 pull。 ","date":"2023-11-28","objectID":"/filen_use.zh/:4:2","series":null,"tags":["trick"],"title":"使用 Filen 同步文件夹","uri":"/filen_use.zh/#windows"},{"categories":["tutorial"],"content":" 5 Filen 的缺点当然，Filen 也不是十全十美的，依旧存在一些问题： 客户端基于 Electron 开发，内存占用高，即使没有任何活动，内存占用也可能接近 600M； 不支持 webdav； 客户端无法直接管理云盘的文件夹，必须在网页端或者手机端管理； 无法同步 WSL 中的文件夹，但是 orbstack 创建的虚拟机中的文件夹似乎可以； ","date":"2023-11-28","objectID":"/filen_use.zh/:5:0","series":null,"tags":["trick"],"title":"使用 Filen 同步文件夹","uri":"/filen_use.zh/#filen-的缺点"},{"categories":[""],"content":" 1 定时器定时关闭连接首先，应该每个 EventLoop 包含一个 Timer，Timer 的主体结构是一个小顶堆，priority_queue\u003cpair\u003cdouble, Connection *\u003e\u003e，double 表示以微秒计数的超时时间 t，即当前时间如果大于 t，那么就超时了。 同时 Connection 需要额外添加一个变量，即 cnt，标志该 Connection 在小顶堆中的数量； channel 的回调函数中，需要将 Connection 的次数 + 1，同时再 push 这个 Connection 到小顶堆中。 每次 Loop 循环完成，就获取当前时间，进行一次 pop，直到堆顶的的元素的超时时间大于当前时间。 每次 pop 的时候，被 pop 的元素的 cnt 减一，如果减到 0 了，那么就调用 delete_conn_callback 函数。 由于每个 EventLoop 只由一个特定的线程负责，因此小顶堆不需要加锁来保护。 ","date":"2023-11-20","objectID":"/web-day13.zh/:1:0","series":null,"tags":[""],"title":"Web Day13：服务器完善","uri":"/web-day13.zh/#定时器定时关闭连接"},{"categories":[""],"content":" 2 日志系统同步日志：产生日志的同时就将其写入至文件中，即在 EventLoop 中，该 EventLoop 线程直接负责写入日志到文件（磁盘）。写日志的过程中，由于要写入磁盘，耗时比内存中的 IO 要长，很可能影响到服务器的效率。 异步日志：采用一个单独的线程，而非 EventLoop 线程来向磁盘写入日志，可以说是一个典型的生产者消费者模型。 分为日志前端和日志后端，前端就是生产者，也就是 I/O 线程这些，负责将日志写入到位于内存的 log_buffer 中，而消费者则是后端，负责将日志从 log_buffer 写入到磁盘中去。 前端线程会调用 current_buffer_-\u003eappend，写到 AsyncLogging 类的 写入到 current_buffer_，如果 current_buffer_ 满了，就调用 buffers_.push_back(std::move(currentBuffer_)); 移动到 buffer 队列中去。 然后 currentBuffer_ = std::move(nextBuffer_);，即把 nextBuffer_ 重用为 currentBuffer_。 后端线程函数threadFunc，会构建1个LogFile对象，用于控制log文件创建、写日志数据，创建2个空闲缓冲区 buffer1、buffer2，和一个待写缓冲队列 buffersToWrite，分别用于替换当前缓冲currentBuffer_、空闲缓冲nextBuffer_、已满缓冲队列buffers_，避免在写文件过程中，锁住缓冲和队列，导致前端无法写数据到后端缓冲。 threadFunc中，提供了一个loop，基本流程是这样的： 1）每次当已满缓冲队列中有数据时，或者即使没有数据但3秒超时，就将当前缓冲加入到已满缓冲队列（即使当前缓冲没满），将buffer1移动给当前缓冲，buffer2移动给空闲缓冲（如果空闲缓冲已移动的话）。 2）然后，再交换已满缓冲队列和待写缓冲队列，这样已满缓冲队列就为空，待写缓冲队列就有数据了。 3）接着，将待写缓冲队列的所有缓冲通过LogFile对象，写入log文件。 4）此时，待写缓冲队列中的缓冲，已经全部写到LogFile指定的文件中（也可能在内核缓冲中），擦除多余缓冲，只用保留两个，归还给buffer1和buffer2。 5）此时，待写缓冲队列中的缓冲没有任何用处，直接clear即可。 6）将内核高速缓存中的数据flush到磁盘，防止意外情况造成数据丢失。 ","date":"2023-11-20","objectID":"/web-day13.zh/:2:0","series":null,"tags":[""],"title":"Web Day13：服务器完善","uri":"/web-day13.zh/#日志系统"},{"categories":["notes"],"content":" 1 前言在 Day11 中，我们实现了一种最容易想到的 Reactor 多线程模式，即将每个 Channel 的任务分配给一个线程执行。 这个模式逻辑上有不少问题，例如线程池由 EventLoop 来持有，按理来说应该由 Server 类来管理，这是受到了 Channel 类的限制，Channel 类仅有 EventLoop 成员。 ","date":"2023-11-19","objectID":"/web-day12.zh/:1:0","series":null,"tags":["cpp","web server"],"title":"Web Day12：实现主从 Reactor 多线程模式","uri":"/web-day12.zh/#前言"},{"categories":["notes"],"content":" 2 主从 Reactor 模式主从 Reactor 模式有以下几个特点： 服务器一般只有一个 main reactor，可以有很多个 sub reactor； 服务器管理一个线程池，每个线程对应一个 sub reactor，每个 sub reactor 负责一部分 Connections 的事件循环，事件执行也在这个线程完成； main reactor 只负责 Acceptor 建立新连接，然后将这个连接分配给一个 sub Reactor。 ","date":"2023-11-19","objectID":"/web-day12.zh/:2:0","series":null,"tags":["cpp","web server"],"title":"Web Day12：实现主从 Reactor 多线程模式","uri":"/web-day12.zh/#主从-reactor-模式"},{"categories":["notes"],"content":" 3 Server 成员/todo，测试 accept 和 connect 的时候区分非阻塞与阻塞 Server 的成员包括一个 main_reactor 和 多个 sub_reactors，每个 sub_reactor 对应一个独有的 EventLoop，每个 sub_reactor 由一个线程负责。这就是所谓的 One Loop per Thread。 cpp class Server { private: EventLoop *main_reactor_; Acceptor *acceptor_; std::map\u003cint, Connection *\u003e connections_; std::vector\u003cEventLoop *\u003e sub_reactors_; ThreadPool *thpool_; public: Server(EventLoop *evl); ~Server(); void HandleReadEvent(int fd); void NewConn(Socket *serv_sock); void DeleteConn(int sockfd); }; ","date":"2023-11-19","objectID":"/web-day12.zh/:3:0","series":null,"tags":["cpp","web server"],"title":"Web Day12：实现主从 Reactor 多线程模式","uri":"/web-day12.zh/#server-成员"},{"categories":["notes"],"content":" 4 main reactor 的工作流程Server 创建的时候，会利用 main 函数的 loop 来初始化 Server，并利用 loop 来初始化 main_reactor_，和 acceptor_。 acceptor_ 会有绑定了服务器 ip 和端口的 socket。初始化 acceptor_ 的时候，会将 acceptor_-\u003enew_conn_callback_ 注册为 Server::NewConn(Socket *clnt_sock)，当有连接时，acceptor_ 调用 Acceptor::AcceptConn()，该函数会调用 Socket::Accept(InetAddress *) 来接受连接，以及调用 new_conn_callback_(clnt_sock)，实际上就是调用 Server::NewConn(Socket *clnt_sock)。 main_reactor_ 就是接受、建立连接的事件循环， cpp Server::Server(EventLoop *loop) : main_reactor_(loop), acceptor_(nullptr) { acceptor_ = new Acceptor(main_reactor_); std::function\u003cvoid(Socket *)\u003e callback = [this](auto \u0026\u0026PH1) { NewConn(std::forward\u003cdecltype(PH1)\u003e(PH1)); }; acceptor_-\u003eset_new_conn_callback(callback); // 注册回调函数 auto size = std::thread::hardware_concurrency(); // 获取 CPU 核心数? thpool_ = new ThreadPool(size); for (int i = 0; i \u003c size; ++i) { sub_reactors_.push_back(new EventLoop()); } for (int i = 0; i \u003c size; ++i) { auto sub_loop = [capture0 = sub_reactors_[i]] { capture0-\u003eLoop(); }; thpool_-\u003eadd_task(sub_loop); } } Acceptor::Acceptor(EventLoop *loop) : loop_(loop), sock_(nullptr), accept_ch_(nullptr) { sock_ = new Socket(); auto *addr = new InetAddress(\"127.0.0.1\", 6789); // 6789679 sock_-\u003eBind(addr); sock_-\u003eListen(); sock_-\u003eSetnonblocking(); // Acceptor 建议使用阻塞式 accept_ch_ = new Channel(loop_, sock_-\u003egetfd()); std::function\u003cvoid()\u003e callback = [this] { AcceptConn(); }; // accept_ch_-\u003eset_use_threadpool(false); // 主 Acceptor 不使用线程池 accept_ch_-\u003eset_read_callback(callback); accept_ch_-\u003eEnableReading(); delete addr; } void Acceptor::AcceptConn() { auto *clnt_addr = new InetAddress(); auto *clnt_sock = new Socket(sock_-\u003eAccpet(clnt_addr)); printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sock-\u003egetfd(), inet_ntoa(clnt_addr-\u003eget_addr().sin_addr), ntohs(clnt_addr-\u003eget_addr().sin_port)); clnt_sock-\u003eSetnonblocking(); new_conn_callback_(clnt_sock); delete clnt_addr; } void Server::NewConn(Socket *sock) { if (sock-\u003egetfd() != -1) { auto idx = sock-\u003egetfd() % sub_reactors_.size(); // 将连接随机分配到 sub_reactor auto *conn = new Connection(sub_reactors_[idx], sock); // 新建对应的 Connection 类 auto callback = [this](auto \u0026\u0026ph1) { DeleteConn(std::forward\u003cdecltype(ph1)\u003e(ph1)); }; conn-\u003eset_delete_conn_callback(callback); connections_[sock-\u003egetfd()] = conn; } } 一个连接对应一个 Connection 类，而 Connection 类创建的时候，会创建对应的 Channel，并注册 Channel 的回调函数，这个回调函数就是 Channel 用于处理读写事件的。 ","date":"2023-11-19","objectID":"/web-day12.zh/:4:0","series":null,"tags":["cpp","web server"],"title":"Web Day12：实现主从 Reactor 多线程模式","uri":"/web-day12.zh/#main-reactor-的工作流程"},{"categories":["notes"],"content":" 5 sub_reactor 的工作流程当 Server 被初始化时，会创建 k 个 sub_reactors，每个 sub_reactor 就是一个 EventLoop，这里没有什么 sub_acceptor。同时有 k 个子线程被创建出来，每个线程对应一个 sub_reactor。 子线程的任务很简单，每一个子线程对应着一个 EventLoop，任务就是一直执行 sub_reactors[i]-\u003eLoop()。 cpp void Server::NewConn(Socket *sock) { if (sock-\u003egetfd() != -1) { auto idx = sock-\u003egetfd() % sub_reactors_.size(); // 将连接随机分配到 sub_reactor auto *conn = new Connection(sub_reactors_[idx], sock); // 新建对应的 Connection 类 auto callback = [this](auto \u0026\u0026ph1) { DeleteConn(std::forward\u003cdecltype(ph1)\u003e(ph1)); }; conn-\u003eset_delete_conn_callback(callback); connections_[sock-\u003egetfd()] = conn; } } 始终要注意，一个 reactor 就是一个 EventLoop! 这里可以再注意一下建立连接的时候发生的事情，建立的 Conn 会根据取模的结果，分配给一个 sub_reactor，每个 sub_reactor 只会关系属于自己的那些 Connection。在 Loop() 中得到关注的 Connections 中的活跃的 Channel，然后执行这些 Channel 的回调函数。 Channel 的回调函数在 Connection 创建的时候被注册。 ","date":"2023-11-19","objectID":"/web-day12.zh/:5:0","series":null,"tags":["cpp","web server"],"title":"Web Day12：实现主从 Reactor 多线程模式","uri":"/web-day12.zh/#sub_reactor-的工作流程"},{"categories":["notes"],"content":" 1 需要完善的地方Day10 中，我们添加了一个简单的线程池，一个完整的 Reactor 模型已经成型。但这个线程池存在的问题还比较多，例如任务队列的取出、添加都存在拷贝，性能较差，只能用于学习。 正确操作应该使用右值移动、完美转发等来阻止拷贝。 另外，线程池只能接受 std::function\u003cvoid()\u003e 类型的函数，所以函数需要使用 Lambda 表达式来创建，或者 std::bind()，且无法得到返回值。 ","date":"2023-11-18","objectID":"/web-day11.zh/:1:0","series":null,"tags":["cpp","web server"],"title":"Web Day11：完成线程池以及加入一个简单的测试程序","uri":"/web-day11.zh/#需要完善的地方"},{"categories":["notes"],"content":" 2 利用模板 cpp class ThreadPool { private: std::vector\u003cstd::thread\u003e threads_; std::queue\u003cstd::function\u003cvoid()\u003e\u003e tasks_; std::mutex tasks_mtx_; std::condition_variable cv_; bool stop_; public: explicit ThreadPool(int size = 8); ~ThreadPool(); template \u003cclass F, class... Args\u003e auto add_task(F \u0026\u0026f, Args \u0026\u0026...args) -\u003e std::future\u003ctypename std::result_of\u003cF(Args...)\u003e::type\u003e; }; template \u003cclass F, class... Args\u003e auto ThreadPool::add_task(F \u0026\u0026f, Args \u0026\u0026...args) -\u003e std::future\u003ctypename std::result_of\u003cF(Args...)\u003e::type\u003e { using return_type = typename std::result_of\u003cF(Args...)\u003e::type; auto ptask = std::make_shared\u003cstd::packaged_task\u003creturn_type()\u003e\u003e( std::bind(std::forward\u003cF\u003e(f), std::forward\u003cArgs\u003e(args)...)); /* auto ptask = std::make_shared\u003cstd::packaged_task\u003creturn_type()\u003e\u003e([f = std::forward\u003cF\u003e(f), args = std::make_tuple(std::forward\u003cArgs\u003e(args)...)]() mutable { */ /* return std::apply(std::move(f), std::move(args)); */ /* }); */ std::future\u003creturn_type\u003e res = ptask-\u003eget_future(); { std::unique_lock\u003cstd::mutex\u003e lock(tasks_mtx_); // don't allow enqueueing after stopping the pool if (stop_) { throw std::runtime_error(\"enqueue on stopped ThreadPool\"); } tasks_.emplace([ptask]() { (*ptask)(); }); } cv_.notify_one(); return res; } ","date":"2023-11-18","objectID":"/web-day11.zh/:2:0","series":null,"tags":["cpp","web server"],"title":"Web Day11：完成线程池以及加入一个简单的测试程序","uri":"/web-day11.zh/#利用模板"},{"categories":["notes"],"content":" 3 代码说明在函数声明的部分有 cpp template \u003cclass F, class... Args\u003e auto add_task(F \u0026\u0026f, Args \u0026\u0026...args) -\u003e std::future\u003ctypename std::result_of\u003cF(Args...)\u003e::type\u003e; 这里谈谈我个人的一点理解，首先，是 template\u003cclass F, class... Args\u003e，这是函数模板，表示函数可以接受两种任意类型的参数，一个参数类型是暂定是 F，到编译阶段才会被推导出来。另一个参数则是可变模板参数，你可以理解为它可以接受多个不同类型的参数。 因此，单看 template\u003cclass F, class... Args\u003e，似乎和 template\u003cclass... Args\u003e 没有区别。 然而，后面的 std::future\u003ctypename std::result_of\u003cF(Args...)\u003e::type\u003e 则限定了 F 的类型一定是 callable 类型，后面简称函数类型。 cpp void EventLoop::add_thread(std::function\u003cvoid()\u003e func) { thread_pool_-\u003eadd_task(func); } 结合 add_task 的函数声明的要求，我们在通过调用 add_task 来实现 add_thread 的时候，只要求传递给 add_task 的第一个参数，必须是可调用类型，即 func，后面的参数可以再自行决定。 std::future\u003ctypename std::result_of\u003cF(Args...)\u003e::type\u003e 使用了 std::future 库，typename 用于指示编译器 std::result_of\u003cF(Args...)\u003e::type 是一个类型的关键字。 std::result_of 是一个类型推导表达式。用于确定调用类型为 F 的可调用对象（比如函数、函数指针、Lambda等）时，使用参数类型为 Args… 的参数列表所返回的类型。 std::future\u003ctypename std::result_of\u003cF(Args...)\u003e::type\u003e 通常用于异步编程中提交任务并且获取结果。 cpp using return_type = typename std::result_of\u003cF(Args...)\u003e::type; auto ptask = std::make_shared\u003cstd::packaged_task\u003creturn_type()\u003e\u003e( std::bind(std::forward\u003cF\u003e(f), std::forward\u003cArgs\u003e(args)...)); 注意 std::make_shared\u003cT\u003e(x) 中，x 是用来构造 T 类型的对象的参数。 std::packaged_task 是 C++ 标准库中的一个模板类，它表示可以异步执行的任务，并返回一个值。 std::packaged_task\u003creturn_type()\u003e`` 中 return_type`` 表示的是一个类型，为什么后面还跟着一个括号？ 这里的括号是 C++ 中用于表示返回值类型的语法，\u003creturn_type()\u003e 表示将 return_type 视为一个类型，表示 std::packaged_task 包装的任务将返回这个类型的值。 例如： cpp std::packaged_task\u003cint()\u003e task([]() { return 42; }); // 希望 std::packaged_task 包装的任务返回一个整数类型的结果 ","date":"2023-11-18","objectID":"/web-day11.zh/:3:0","series":null,"tags":["cpp","web server"],"title":"Web Day11：完成线程池以及加入一个简单的测试程序","uri":"/web-day11.zh/#代码说明"},{"categories":["notes"],"content":" 4 添加测试程序简单来说就是创建 n 个线程，每个线程发送接受相同的消息 k 次。 ./test -t 10000 -m 10 -w 5 ","date":"2023-11-18","objectID":"/web-day11.zh/:4:0","series":null,"tags":["cpp","web server"],"title":"Web Day11：完成线程池以及加入一个简单的测试程序","uri":"/web-day11.zh/#添加测试程序"},{"categories":["notes"],"content":" 5 Acceptor 的一点改进对于 Acceptor，接受连接的处理时间短、报文数据小，并且同一时间一般不会有特别多的新连接到来。所以 Acceptor 没必要采用 ET 模式，也没有必要采用线程池。 即然 Acceptor 不会成为性能瓶颈，那么最好使用阻塞式 socket。 所以，day11 的源码中做了以下改变： Acceptor 的 serv_sock 采用不设置成非阻塞； Acceptor 使用 LT 模式，Connection 使用 ET； Acceptor 建立连接不使用线程池，建立好连接之后，处理事件使用线程池； ","date":"2023-11-18","objectID":"/web-day11.zh/:5:0","series":null,"tags":["cpp","web server"],"title":"Web Day11：完成线程池以及加入一个简单的测试程序","uri":"/web-day11.zh/#acceptor-的一点改进"},{"categories":["notes"],"content":" 1 前言到 day9 的时候，一个单线程的服务器已经算写好了。Reactor 驱动大致成型。 服务器的启动流程大致如下，先创建 EventLoop 对象 loop（里面包含了 Epoll 对象），然后 Server 会利用 loop 实例化对象 server，Server 对象实例化时，Acceptor 类型的 acceptor_ 对象会被初始化, Acceptor 对象用于建立连接，会在 Server 的构造函数里回调函数 acceptor_-\u003enew_conn_callback_ 会被注册为 server-\u003eNewConn(Socket *clnt_sock) ，由 acceptor_-\u003eAcceptConn() 来调用。而 Acceptor 的构造函数中 Channel 类的实例 accept_ch_ 会被初始化，而回调函数 acceptr_ch-\u003ecallback_ 会被注册为 acceptor_-\u003eAcceptConn()，最终还是调用的 server-\u003eNewConn(Socket *clnt_sock)。 cpp Server::Server(EventLoop *loop) : loop_(loop), acceptor_(nullptr) { acceptor_ = new Acceptor(loop); std::function\u003cvoid(Socket *)\u003e callback = [this](auto \u0026\u0026PH1) { NewConn(std::forward\u003cdecltype(PH1)\u003e(PH1)); }; acceptor_-\u003eset_new_conn_callback(callback); } void Server::NewConn(Socket *sock) { auto *conn = new Connection(loop_, sock); // 这里应该是 clnt_sock std::function\u003cvoid(Socket *)\u003e callback = [this](auto \u0026\u0026PH1) { DeleteConn(std::forward\u003cdecltype(PH1)\u003e(PH1)); }; conn-\u003eset_delete_conn_callback(callback); connections_[sock-\u003egetfd()] = conn; } void Acceptor::AcceptConn() { auto *clnt_addr = new InetAddress(); auto *clnt_sock = new Socket(sock_-\u003eAccpet(clnt_addr)); printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sock-\u003egetfd(), inet_ntoa(clnt_addr-\u003eget_addr().sin_addr), ntohs(clnt_addr-\u003eget_addr().sin_port)); clnt_sock-\u003eSetnonblocking(); new_conn_callback_(clnt_sock); delete clnt_addr; } void Acceptor::set_new_conn_callback(std::function\u003cvoid(Socket *)\u003e \u0026callback) { new_conn_callback_ = callback; } 当建立连接的时候，会生成一个 Connection 实例，存储在 Sever 的 connections_ 变量中。connections_ 是 key 为 client fd，value 为建立的连接的指针 Connection *。并在，在建立连接时，Server::DelteConn 会被注册为 Connection 实例的回调函数 delete_conn_call_back_。当读取数据时，如果发现 read_bytes == 0，就会执行 delete_conn_call_back_ 来断开连接。 cpp void Server::DeleteConn(Socket *sock) { Connection *conn = connections_[sock-\u003egetfd()]; connections_.erase(sock-\u003egetfd()); delete conn; } 而 Connection 实例 conn 建立时，会创建一个 Channel 类的实例 clnt_ch， clng_ch-\u003ecallback_ 被设置为 conn-\u003eecho()。调用 clnt_ch-\u003eEnableReading() 会将该 clnt_ch-\u003efd 添加到 epoll 关注的文件描述符中去，对应的 ev 中会包含指向该 clnt_ch 的指针。 之后便是 loop-\u003eLoop() 一直循环了。 cpp void EventLoop::Loop() { while (!quit_) { auto chs = ep_-\u003ePoll(); // Poll 返回的是活跃的 Channel 的集合 for (auto *ch : chs) { ch-\u003eHandleEvent(); } } } 最后注意一下生命周期的管理，server 的析构函数会 delete acceptor_，而 acceptor_ 的析构函数 会 delete sock_, addr_, accept_ch_。loop 的析构函数会 delete ep_ 断开连接时，会 delete conn，从而 delete channel_, sock_, read_buffer_。 在 main 函数的 loop-\u003eLoop() 循环结束时，会 delete server 和 delete loop。 理论上 loop-\u003eLoop() 一直不会结束。 ","date":"2023-11-18","objectID":"/web-day10.zh/:1:0","series":null,"tags":["cpp","web server"],"title":"Web Day10：加入线程池到服务器","uri":"/web-day10.zh/#前言"},{"categories":["notes"],"content":" 2 添加线程池线程池说到底就是一个 vector\u003cstd::thread\u003e 加上一个任务队列组成。Channel 可以说是生产者，每次发生事件，就往任务队列中添加要执行的函数 callback_，添加完之后要唤醒因条件变量阻塞的线程（notify_one 或者 notify_all）。而线程创建的时候，绑定的函数就是往任务队列里面取任务，如果队列为空，就会阻塞在条件变量 cv_ 上，而释放锁。 cpp ThreadPool::ThreadPool(int size) : stop_(false) { for (int i = 0; i \u003c size; ++i) { // 线程创建成功 printf(\"create thread!\\n\"); auto func = [this]() { while (true) { std::function\u003cvoid()\u003e task; { std::unique_lock\u003cstd::mutex\u003e lock(tasks_mtx_); cv_.wait(lock, [this]() { return stop_ || !tasks_.empty(); }); if (stop_ \u0026\u0026 tasks_.empty()) { return; } task = tasks_.front(); printf(\"get task\\n\"); tasks_.pop(); } printf(\"run task!\\n\"); task(); } }; // 创建线程时绑定的函数 threads_.emplace_back(func); } printf(\"thread count: %d\\n\", threads_.size()); } void Channel::HandleEvent() { loop_-\u003eadd_thread(callback_); /* callback_(); */ } void EventLoop::add_thread(std::function\u003cvoid()\u003e func) { thread_pool_-\u003eadd_task(func); } void ThreadPool::add_task(std::function\u003cvoid()\u003e func) { { std::unique_lock\u003cstd::mutex\u003e lock(tasks_mtx_); printf(\"add task\\n\"); if (stop_) { throw std::runtime_error(\"ThreadPool already stop, can't add task any more\"); } tasks_.emplace(func); cv_.notify_one(); // 记得要唤醒线程 } } 说到底，就是把本来应该由 Channel 直接执行的任务，给挪到任务队列里面让线程池中的线程取出来去执行。 这里还有一个问题，那就是 Acceptor 的建立连接的任务，Channel 也会放到线程池里面让线程竞争得到执行权再执行，这样是不应该的。应该直接由主线程负责。 ","date":"2023-11-18","objectID":"/web-day10.zh/:2:0","series":null,"tags":["cpp","web server"],"title":"Web Day10：加入线程池到服务器","uri":"/web-day10.zh/#添加线程池"},{"categories":["notes"],"content":" 1 概述本节只是额外添加了一个读写的缓冲区，意义不甚明了。暂定。 ","date":"2023-11-18","objectID":"/web-day9.zh/:1:0","series":null,"tags":["cpp","web server"],"title":"Web Day9：建立读写缓冲类","uri":"/web-day9.zh/#概述"},{"categories":["tutorial"],"content":" 1 前言本文内容主要是我对 Mac 的所做的配置修改的一些记录。后续会随着时间更新，免得忘记自己对 Mac 做过什么修改了。 ","date":"2023-11-17","objectID":"/mac-dev-config.zh/:1:0","series":null,"tags":["mac","dev"],"title":"Mac 开发环境配置","uri":"/mac-dev-config.zh/#前言"},{"categories":["tutorial"],"content":" 2 安装 Command Line Tools for Xcode安装包下载 链接 ","date":"2023-11-17","objectID":"/mac-dev-config.zh/:2:0","series":null,"tags":["mac","dev"],"title":"Mac 开发环境配置","uri":"/mac-dev-config.zh/#安装-command-line-tools-for-xcode"},{"categories":["tutorial"],"content":" 3 安装 Homebrew执行 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" 即可。网络环境已自带科学。 大名鼎鼎的 Homebrew 无需多说，通过 Homebew 我安装了以下软件： 总的原则大概就是能用 homebrew 安装的都是使用 homebrew 安装，例如 Edge、VScode 等。 要注意的是，Homebrew 安装软件时，将软件分成了 Formulae 和 Casks 两大类，简单来说就是，有 gui 的就是 Casks，没有的就是 Formulae，安装带 GUI 的软件，例如 Neovide 时，安装指令为 brew install neovide --cask。 Homebrew 还可以用于安装字体，例如执行 brew install font-fira-mono-nerd-font --cask 即可安装 FiraMono 字体。 ","date":"2023-11-17","objectID":"/mac-dev-config.zh/:3:0","series":null,"tags":["mac","dev"],"title":"Mac 开发环境配置","uri":"/mac-dev-config.zh/#安装-homebrew"},{"categories":["tutorial"],"content":" 4 安装 Neovim执行 brew install neovim 即可，然后 cd ~/.config/ 执行 git clone git@github.com:zwyyy456/nvim_config.git \u0026\u0026 mv nvim_config nvim，之后终端中运行 nvim，就会自动配置 LazyVim。 详见 Neovim 的配置与使用。 ","date":"2023-11-17","objectID":"/mac-dev-config.zh/:4:0","series":null,"tags":["mac","dev"],"title":"Mac 开发环境配置","uri":"/mac-dev-config.zh/#安装-neovim"},{"categories":["tutorial"],"content":" 5 安装 miniconda直接执行 brew install miniconda 即可。 miniconda 应该会被安装到 /opt/homebrew/Caskroom/miniconda 目录下。 执行 nvim ~/.zshrc，添加如下内容： sh # \u003e\u003e\u003e conda initialize \u003e\u003e\u003e # !! Contents within this block are managed by 'conda init' !! __conda_setup=\"$('/opt/homebrew/Caskroom/miniconda/base/bin/conda' 'shell.zsh' 'hook' 2\u003e /dev/null)\" if [ $? -eq 0 ]; then eval \"$__conda_setup\" else if [ -f \"/opt/homebrew/Caskroom/miniconda/base/etc/profile.d/conda.sh\" ]; then . \"/opt/homebrew/Caskroom/miniconda/base/etc/profile.d/conda.sh\" else export PATH=\"/opt/homebrew/Caskroom/miniconda/base/bin:$PATH\" fi fi unset __conda_setup ","date":"2023-11-17","objectID":"/mac-dev-config.zh/:5:0","series":null,"tags":["mac","dev"],"title":"Mac 开发环境配置","uri":"/mac-dev-config.zh/#安装-miniconda"},{"categories":["tutorial"],"content":" 1 前言开发 web server 等项目，由于会使用到 Linux 的一些 API，用 Mac 来开发并不方便。我的 M1 Macbook Pro，由于采用了 arm 架构，使用虚拟机比较麻烦，并且虚拟机总觉得太笨重，不算方便。此外，也是由于 arm 架构的原因，使用 Docker 不方便，Docker Desktop 据说又卡又难用。 希望能有一个方案能同时解决以上两个问题（毕竟能用 docker 就能直接在 docker 里面跑 Debian 镜像了）。 经过一番搜索，发现了一个名为 OrbStack 的工具，可以理解为 Mac 上的 WSL，至于实现原理，这里不去深究。 OrbStack 使用起来非常方便，brew install orbstack 之后，执行 orbstack create debian orb-deb 就可以创建名为 orb-deb 的虚拟机了，虚拟机和 macOS 之间的文件访问非常方便。Linux 中可以直接访问 macOS 中的文件和目录，macOS 中也一样。并且 CPU / 磁盘 / 内存都是按需使用的。 此外，可以在 Linux 虚拟机中非常方便地执行 macOS 的命令，在 macOS 中执行虚拟机 Linux 中的命令也同样如此。 后面的内容都是 Debian 开发环境的配置了，不论是 OrbStack 的 Debian 还是 WSL 又或者是物理机、VPS 都适用。 本博客内容会随时间而更新，也是我对 Debian 系统做的修改和配置的一个记录。 ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:1:0","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#前言"},{"categories":["tutorial"],"content":" 2 换源阿里云的服务器可以无需执行此操作。 执行 vi /etc/apt/sources.list，将文件内容替换为以下内容 sh # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware # deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware 然后执行 sudo apt update。 ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:2:0","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#换源"},{"categories":["tutorial"],"content":" 3 创建 ssh 密钥并上传到 GitHub执行 ssh-keygen -t ed25519 -C \"zwyyy456@hotmail.com\"，然后一路按下 Enter，密钥对存放在~/.ssh文件夹下，id_ed25519.pub为公钥，id_ed25519为私钥。 注意看提示，一路按 Enter 则 passphrase 为空。 然后在 GitHub 设置的 SSH and GPG keys 的那一栏，新建 SSH Keys，内容就填 id_ed25519.pub 里的内容。 ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:3:0","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#创建-ssh-密钥并上传到-github"},{"categories":["tutorial"],"content":" 4 安装软件","date":"2023-11-17","objectID":"/debian-dev-config.zh/:4:0","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#安装软件"},{"categories":["tutorial"],"content":" 4.1 安装 fish本人习惯于使用 fish 作为默认 shell。 执行 sudo apt install fish \u0026\u0026 sudo chsh -s /usr/bin/fish 即可安装并将默认 shell 设置为 fish。 执行 git clone git@github.com:zwyyy456/dotfile.git ~/.config 即可，该 repo 里面是我自己的一些配置文件。fish 的配置文件位于 ~/.config/fish/config.fish。 ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:4:1","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#安装-fish"},{"categories":["tutorial"],"content":" 4.2 配置 C++ 开发环境参照 VsCode 使用 clangd 执行 sudo apt install clang clangd lldb cmake 安装 C++ 开发环境。 ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:4:2","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#配置-c-开发环境"},{"categories":["tutorial"],"content":" 4.3 Lazygit可以在 Lazygit 的 GitHub Release 界面下载对应的二进制包，以 lazygit_0.40.2_Linux_arm64.tar.gz 为例，利用 wget 下载后，执行 tar -zxvf \u003cfilename\u003e 即可解压到当前目录。将可执行文件 lazygit 移动到 /usr/local/bin 即可。 可以为 lazygit 添加别名为 lg。对于 fish，只需要在 ~/.config/fish/config.fish 中添加 alias lg 'lazygit' 即可。 ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:4:3","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#lazygit"},{"categories":["tutorial"],"content":" 4.4 安装 docker由于 macOS 中的 Debian 本来就是虚拟出来的，要使用 docker 可以直接由 OrbStack 管理，因此这里只讨论 WSL 和物理机中的 Debian 安装 docker。 对 WSL，编辑 /etc/wsl.conf ，追加以下内容 ini [boot] systemd=true 即可让 WSL 启用 systemd。 然后便能正常安装使用 docker 了。 参照tuna docker镜像源使用帮助 首先安装依赖: sh sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common 创建/etc/apt/keyrings文件夹，然后信任Docker的GPG公钥: sh curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 添加软件仓库: sh echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 执行安装: sh sudo apt update sudo apt install docker-ce 建立docker用户组: sh sudo groupadd docker sudo usermod -aG docker $USER 设置docker hub中科大镜像源： sh sudo vim /etc/docker/daemon.json 文件中加入: json { \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn/\"] } ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:4:4","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#安装-docker"},{"categories":["tutorial"],"content":" 4.5 Neovim这里需要编译 Neovim，因为是 arm 架构，x86_64 架构建议直接下载 .appimage 然后移动为 /usr/local/bin/nvim。 执行以下命令： sh sudo apt-get install ninja-build gettext cmake unzip curl git clone https://github.com/neovim/neovim cd neovim \u0026\u0026 git checkout stable make CMAKE_BUILD_TYPE=RelWithDebInfo # 开始编译 cd build \u0026\u0026 cpack -G DEB # 生成 Debian 系的软件包 sudo dpkg -i xxx.deb # 看你生成的 .deb 包的包名 如果是 .appiamge 包，那么移动为 /usr/local/bin/nvim 之后还要执行 sudo chmod +x /usr/local/bin/nvim 和 sudo apt install fuse3 libfuse2。后者是安装 .appimage 运行所需的依赖。 然后执行 git clone git@github.com:zwyyy456/nvim_config.git ~/.config/nvim。 之后运行 nvim，LazyVim 就会安装好对应插件。 由于阿里的服务器连接 Github 效果也不好，因此这里选择为 GitHub 设置使用镜像：git config --global url.\"https://mirror.ghproxy.com/https://github.com/\".insteadOf \"https://github.com/\"。 同时阿里的服务器 nvim 配置采用 onecloud 分支而非 main 分支； 至于 Neovim 的配置可以参考 Neovim 的配置与使用 ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:4:5","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#neovim"},{"categories":["tutorial"],"content":" 4.6 tmux执行 sudo apt install tmux 安装 tmux，编辑 ~/.tmux.conf 文件，追加以下内容： sh # 设置默认shell为Fish set -g default-shell /usr/bin/fish set -g allow-passthrough on ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:4:6","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#tmux"},{"categories":["tutorial"],"content":" 5 博客的同步方案整体来说通过 Filen 进行同步，免费用户通过邀请他人，最多可以获得 50GB 的存储空间，上传下载不限速不限流量。只是同步博客和代码文件已经够用了。 关键的一点是，Filen 同步文件是默认选项会排除 .git 这种以 . 开头的文件和文件夹，并且支持自定义 ignore（语法类似 .gitignore）。 Filen 还支持同步后再手动通过勾选的方式设置哪些文件夹之后不再同步。 OneDrive 和 iCloud 至今都不能支持这一点。iCloud 也就罢了，毕竟只是用来备份照片的。OneDrive 从功能定位上来说应该也是同步盘，却连这种基础功能都无法支持，真是拉跨。 因此，这里我设置了 Filen 同步 \\\\wsl.localhost\\Debian\\home\\zwyyy\\Documents\\blog 中的文件到云盘的 blog 目录，而 mac 则会同步 ~/Documents/blog 目录到云盘的 blog 目录。 这里最好是设置仅同步 content 目录以及 config.toml 等关键配置文件。 txt */archetypes/ */assets/ */i18n/ */layouts/ */static/ */themes/ */resources/ 此外，博客会尽量及时 push 到 GitHub。 比较遗憾的是，Filen 不支持本地分别设置两个文件夹同步到同一个云盘目录。 Filen 在同步 WSL 中的文件时会出现问题，如下图所示： 因此暂时将博客存放于 C:\\Users\\zwyyy\\OneDrive\\Documents\\blog 目录下，让 Filen 同步此目录，再通过 Git 同步到 WSL 中来，由于 OneDrive 同步无法忽略 .git 文件，因此尽量避免直接修改 C:\\Users\\zwyyy\\OneDrive\\Documents\\blog 中的内容并提交到 Github。 对 mac 而言，博客直接存放在 ~/Documents/blog 目录下并由 Filen 同步，iCloud 负责备份即可。 ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:5:0","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#博客的同步方案"},{"categories":["tutorial"],"content":" 6 Code 的同步方案Code 的同步方案同上，对 mac 而言，放在 ~/Documents/code 目录，iCloud 负责备份，Filen 负责同步，可以由 VsCode Remote 连接到 OrbStack 的虚拟机，并直接访问 mac 宿主机中的目录进行编辑。 此外，在 OrbStack 的虚拟机的目录中的代码文件，也可以被 Filen 顺利同步，这一点比起 WSL 来说要舒服很多。 ","date":"2023-11-17","objectID":"/debian-dev-config.zh/:6:0","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#code-的同步方案"},{"categories":["tutorial"],"content":" 7 安装 miniconda","date":"2023-11-17","objectID":"/debian-dev-config.zh/:7:0","series":null,"tags":["Debian","dev"],"title":"Debian 开发环境配置","uri":"/debian-dev-config.zh/#安装-miniconda"},{"categories":["notes"],"content":" 1 Acceptor 类一言以蔽之，Acceptor 类负责接受连接，调用 AcceptConn，到这里，接受连接已经完全由 Acceptor 类来负责。Acceptconn 会调用被注册的回调函数 new_conn_callback_(clnt_sock)，实际上就是调用 Server::NewConn(clnt_sock)，该函数会将 {clnt_fd, conn} 的键值对添加到 Server 类的 map 中去。 此外，还会为 Connection 类注册删除 Connection 的回调函数； cpp void Acceptor::AcceptConn() { auto *clnt_addr = new InetAddress(); auto *clnt_sock = new Socket(sock_-\u003eAccpet(clnt_addr)); printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sock-\u003egetfd(), inet_ntoa(clnt_addr-\u003eget_addr().sin_addr), ntohs(clnt_addr-\u003eget_addr().sin_port)); clnt_sock-\u003eSetnonblocking(); new_conn_callback_(clnt_sock); delete clnt_addr; } void Server::NewConn(Socket *sock) { auto *conn = new Connection(loop_, sock); // 这里应该是 clnt_sock std::function\u003cvoid(Socket *)\u003e callback = [this](auto \u0026\u0026PH1) { DeleteConn(std::forward\u003cdecltype(PH1)\u003e(PH1)); }; conn-\u003eset_delete_conn_callback(callback); connections_[sock-\u003egetfd()] = conn; Acceptor 的回调函数的注册过程发生在 Server 类的创建过程中。 ","date":"2023-11-16","objectID":"/web-day8.zh/:1:0","series":null,"tags":["cpp","web server"],"title":"Web Day8：抽象出 Connection 类","uri":"/web-day8.zh/#acceptor-类"},{"categories":["notes"],"content":" 2 Connection 类完成连接之后，客户端文件描述符就绪之后的处理函数，定义在了 Connection 类中，一个 Connection 对应着一个 Channel，每有一个 Connection 类被创建出来，这个 Connection 对应的 Channel 的回调函数就会被注册为 Connection 类中的处理函数； cpp Connection::Connection(EventLoop *loop, Socket *sock) : loop_(loop), sock_(sock), channel_(nullptr) { channel_ = new Channel(loop, sock-\u003egetfd()); int fd = sock_-\u003egetfd(); std::function\u003cvoid()\u003e callback = [this, fd]() { echo(fd); // Connection 类的事件处理函数 }; channel_-\u003eset_callback(callback); // 注册回调函数 channel_-\u003eEnableReading(); } void Channel::HandleEvent() { callback_(); } ","date":"2023-11-16","objectID":"/web-day8.zh/:2:0","series":null,"tags":["cpp","web server"],"title":"Web Day8：抽象出 Connection 类","uri":"/web-day8.zh/#connection-类"},{"categories":[""],"content":" 1 Acceptor 定义这里我的理解就是，一个 Acceptor 对应一个 EventLoop，当然也有一个独有 Channel，负责分发到对应的 epoll。 这里实际上是从 Server 中又分离出了一个 Acceptor，负责管理事件循环，服务器 socket 的创建与绑定，listen，同时由 Acceptor 来负责建立连接（逻辑上），调用的底层的建立连接的函数还是 Server::NewConn(Socket *)。 即实际上，Acceptor 类接管了之前 Server 类的工作。 cpp Acceptor::Acceptor(EventLoop *loop) : loop_(loop), sock_(nullptr), accept_ch_(nullptr), addr_(nullptr) { sock_ = new Socket(); addr_ = new InetAddress(\"127.0.0.1\", 8888); sock_-\u003eBind(addr_); sock_-\u003eListen(); sock_-\u003eSetnonblocking(); accept_ch_ = new Channel(loop_, sock_-\u003egetfd()); std::function\u003cvoid()\u003e callback = [this] { AcceptConn(); }; accept_ch_-\u003eset_callback(callback); accept_ch_-\u003eEnableReading(); } void Acceptor::AcceptConn() { new_conn_callback_(sock_); } void Acceptor::set_new_conn_callback(std::function\u003cvoid(Socket *)\u003e \u0026callback) { new_conn_callback_ = callback; } Server::Server(EventLoop *loop) : loop_(loop), acceptor_(nullptr) { acceptor_ = new Acceptor(loop); std::function\u003cvoid(Socket *)\u003e callback = [this](auto \u0026\u0026PH1) { NewConn(std::forward\u003cdecltype(PH1)\u003e(PH1)); }; acceptor_-\u003eset_new_conn_callback(callback); } 其中以下两行代码就是让 Acceptor 类可以调用 Server 类中的 NewConn 的关键： cpp std::function\u003cvoid(Socket *)\u003e callback = [this](auto \u0026\u0026PH1) { NewConn(std::forward\u003cdecltype(PH1)\u003e(PH1)); }; acceptor_-\u003eset_new_conn_callback(callback); 重申一遍，逻辑上由 Acceptor 类负责接受连接，但是底层还是由 Server 类来建立连接。 ","date":"2023-11-16","objectID":"/web-day7.zh/:1:0","series":null,"tags":[""],"title":"Web Day7：为服务器添加一个 Acceptor","uri":"/web-day7.zh/#acceptor-定义"},{"categories":["notes"],"content":" 1 事件驱动原先的代码中，不管是接受客户端连接还是处理客户端事件，都是围绕epoll来编程，可以说epoll是整个程序的核心，服务器做的事情就是监听epoll上的事件，然后对不同事件类型进行不同的处理。这种以事件为核心的模式又叫事件驱动，事实上几乎所有的现代服务器都是事件驱动的。和传统的请求驱动模型有很大不同，事件的捕获、通信、处理和持久保留是解决方案的核心结构。 ","date":"2023-11-15","objectID":"/web-day6.zh/:1:0","series":null,"tags":["cpp","web server"],"title":"Web Day6：EventLoop 类与事件驱动","uri":"/web-day6.zh/#事件驱动"},{"categories":["notes"],"content":" 2 将服务器改造成 Reactor 模式我们将服务器抽象成一个 Server 类，类中有一个 main-reactor，main-reactor 的核心是一个 EventLoop，即不断循环，一旦有事件发生，我们就会通过 ep-\u003ePoll 知晓，然后作出对应的处理。 ","date":"2023-11-15","objectID":"/web-day6.zh/:2:0","series":null,"tags":["cpp","web server"],"title":"Web Day6：EventLoop 类与事件驱动","uri":"/web-day6.zh/#将服务器改造成-reactor-模式"},{"categories":["notes"],"content":" 3 Channel 的修改day5 中，每个 channel 里面都含有一个 Epoll * 指针，表示它在哪个 epoll 实例中被关注，这里我们把 Epoll * 替换成了 EventLoop *，表示该 channel 处于哪个事件循环中，事实上 EventLoop 的关键成员就是 Epoll *。 ","date":"2023-11-15","objectID":"/web-day6.zh/:3:0","series":null,"tags":["cpp","web server"],"title":"Web Day6：EventLoop 类与事件驱动","uri":"/web-day6.zh/#channel-的修改"},{"categories":["notes"],"content":" 4 初始化流程首先创建 EventLoop 对象 loop，它会创建一个 Epoll 实例，核心就是 epfd，然后利用 loop 初始化 Server 对象，在这个过程中，会完成服务器的 serv_fd 的创建以及 bind，listen，同时将对应着 serv_fd 以及新建连接事件的 Channel 创建出来，将 Channel 的处理事件的回调函数设置为 NewConn；调用 serv_ch-\u003eEnableReading 会将关注的事件类型设置为 EPOLLIN | EPOLLET 并调用 loop-\u003eUpdateChannel(this) 最终调用 ep-\u003eUpdateChannel(ch)，从而将 serv_ch 对应的文件描述符添加到 epoll 关注的文件描述符列表或者修改。 cpp Server::Server(EventLoop *loop) : loop_(loop) { Socket *serv_sock = new Socket(); InetAddress *serv_addr = new InetAddress(\"127.0.0.1\", 8888); serv_sock-\u003eBind(serv_addr); serv_sock-\u003eListen(); serv_sock-\u003eSetnonblocking(); Channel *serv_ch = new Channel(loop, serv_sock-\u003egetfd()); std::function\u003cvoid()\u003e cb = [this, serv_sock] { NewConn(serv_sock); }; serv_ch-\u003eset_callback(cb); serv_ch-\u003eEnableReading(); } void Channel::EnableReading() { events = EPOLLIN | EPOLLET; loop_-\u003eUpdateChannel(this); } void EventLoop::UpdateChannel(Channel *ch) { ep_-\u003eUpdateChannel(ch); } void Epoll::UpdateChannel(Channel *ch) { int fd = ch-\u003egetfd(); struct epoll_event ev; memset(\u0026ev, 0, sizeof(ev)); ev.data.ptr = ch; ev.events = ch-\u003eget_events(); if (!ch-\u003eget_in_epoll()) { // 添加到 epoll 中 errif(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, \u0026ev) == -1, \"epoll add error!\\n\"); ch-\u003eset_in_epoll(); } else { errif(epoll_ctl(epfd, EPOLL_CTL_MOD, fd, \u0026ev) == -1, \"epoll mod error!\\n\"); } } void Server::NewConn(Socket *serv_sock) { InetAddress *clnt_addr = new InetAddress(); Socket *clnt_sock = new Socket(serv_sock-\u003eAccpet(clnt_addr)); printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sock-\u003egetfd(), inet_ntoa(clnt_addr-\u003eaddr.sin_addr), ntohs(clnt_addr-\u003eaddr.sin_port)); clnt_sock-\u003eSetnonblocking(); int sockfd = clnt_sock-\u003egetfd(); Channel *clnt_ch = new Channel(loop_, sockfd); std::function\u003cvoid()\u003e callback = [this, sockfd] { HandleReadEvent(sockfd); }; // 设定建立了连接的 ch 对应的回调函数 clnt_ch-\u003eset_callback(callback); clnt_ch-\u003eEnableReading(); } 上述代码就是有新连接到来时的函数调用流程。 ","date":"2023-11-15","objectID":"/web-day6.zh/:4:0","series":null,"tags":["cpp","web server"],"title":"Web Day6：EventLoop 类与事件驱动","uri":"/web-day6.zh/#初始化流程"},{"categories":["notes"],"content":" 5 新连接到来后当有新连接到来后，就会调用 ch-\u003eHandleEvent()，即我们绑定的回调函数 Server::NewConn(Socket *serv_sock)，它会建立连接，利用 accept 返回的文件描述符，创建 clnt_ch，并设置 clnt_ch 的回调函数为 Server::HandleReadEvent。 这样，当活跃的 channel 是 clnt_ch 时，就会执行读写事件。 cpp void EventLoop::Loop() { while (!quit_) { auto chs = ep_-\u003ePoll(); // Poll 返回的是活跃的 Channel 的集合 for (auto *ch : chs) { ch-\u003eHandleEvent(); } } } ","date":"2023-11-15","objectID":"/web-day6.zh/:5:0","series":null,"tags":["cpp","web server"],"title":"Web Day6：EventLoop 类与事件驱动","uri":"/web-day6.zh/#新连接到来后"},{"categories":["notes"],"content":" 1 Channel 类Channel 类相当于将 ep-\u003eaddFd 这一步拆成了两步，第一步是 ch-\u003eenablereading，它会调用 ep-\u003eUpdateChannel(this)，this 就是调用 enablereading 的那个 ch。 如何理解 Channel 类？可以认为每一个 ch 的实例，都对应着一个关注的文件描述符 fd 和一个要关注的事件类型 events，当前其实只有两类 Channel，一个是对应的服务器的 fd，另一类对应的是 accept 客户端的连接之后得到的 fd，ch-\u003eevents 是 fd 所在的 Channel 实例需要关注的事件类型。 而 active_events 表示该 Channel 当前发生的事件类型，在 ep-\u003ePoll() 中会被设置。 cpp auto Epoll::Poll(int timeout) -\u003e std::vector\u003cChannel *\u003e { std::vector\u003cChannel *\u003e active_channels; int nfds = epoll_wait(epfd, events, MAX_EVENTS, timeout); errif(nfds == -1, \"epoll wait error\\n\"); active_channels.reserve(nfds); for (int i = 0; i \u003c nfds; ++i) { Channel *ch = (Channel *)events[i].data.ptr; ch-\u003eset_active_events(events[i].events); active_channels.push_back(ch); } return active_channels; } 而在 ep-\u003eUpdateChannel(this) 这个过程中，会创建一个 struct epoll_event ev，表示 epoll 修改红黑树时，需要关注的事件。 ev 除了事件之外，还有一个可以由用户定义的 Union，它可以是文件描述符，也可以是一个指针，这里我们就让他指向 Channel 类的一个对象，Channel 类中本来就有文件描述了，所以 Union 解释为指针，功能明显更强大。 cpp struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ } __EPOLL_PACKED; typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; cpp void Epoll::UpdateChannel(Channel *ch) { int fd = ch-\u003egetfd(); struct epoll_event ev; memset(\u0026ev, 0, sizeof(ev)); ev.data.ptr = ch; // 将 ev.data 解释为指向 channel 的指针； ev.events = ch-\u003eget_events(); if (!ch-\u003eget_in_epoll()) { // 添加到 epoll 中 errif(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, \u0026ev) == -1, \"epoll add error!\\n\"); ch-\u003eset_in_epoll(); } else { errif(epoll_ctl(epfd, EPOLL_CTL_MOD, fd, \u0026ev) == -1, \"epoll mod error!\\n\"); } } ","date":"2023-11-15","objectID":"/web-day5.zh/:1:0","series":null,"tags":["cpp","web server"],"title":"Web Day 5 添加 Channel 类","uri":"/web-day5.zh/#channel-类"},{"categories":["notes"],"content":" 2 Epoll 的变化其他变化就是，Epoll 类中的 Poll 函数变成返回 vector\u003cChannel *\u003e，而不是返回 epoll_event。同时会设置 ch-\u003eactive_events，表示该 ch 正在发生的事件。 ","date":"2023-11-15","objectID":"/web-day5.zh/:2:0","series":null,"tags":["cpp","web server"],"title":"Web Day 5 添加 Channel 类","uri":"/web-day5.zh/#epoll-的变化"},{"categories":["notes"],"content":" 3 主循环中由于 ep-\u003ePoll 返回的是 Channel * 的集合，我们可以拿到 ch 对应的文件描述符和发生的事件，并对其进行处理。 ","date":"2023-11-15","objectID":"/web-day5.zh/:3:0","series":null,"tags":["cpp","web server"],"title":"Web Day 5 添加 Channel 类","uri":"/web-day5.zh/#主循环中"},{"categories":["tutorial"],"content":" 1 安装插件利用 Sublime Text4 的 package control 安装 NeoVintageous 插件。 ","date":"2023-11-08","objectID":"/sublime-neovim.zh/:1:0","series":null,"tags":["nvim"],"title":"Sublime Text4 使用 NeoVintageous 插件","uri":"/sublime-neovim.zh/#安装插件"},{"categories":["tutorial"],"content":" 2 启用ctrl + [作为esc点击sublime Text -\u003e settings -\u003esettings，编辑右侧的配置文件，添加\"vintageous_ctrl_keys\": true,。 ","date":"2023-11-08","objectID":"/sublime-neovim.zh/:2:0","series":null,"tags":["nvim"],"title":"Sublime Text4 使用 NeoVintageous 插件","uri":"/sublime-neovim.zh/#启用ctrl--作为esc"},{"categories":["tutorial"],"content":" 3 启用jk为esc点击sublime Text -\u003e settings -\u003esettings，编辑右侧的配置文件，添加\"vintageous_i_escape_jk\": true, ","date":"2023-11-08","objectID":"/sublime-neovim.zh/:3:0","series":null,"tags":["nvim"],"title":"Sublime Text4 使用 NeoVintageous 插件","uri":"/sublime-neovim.zh/#启用jk为esc"},{"categories":["tutorial"],"content":" 4 使yy会复制到系统剪贴板点击sublime Text -\u003e settings -\u003esettings，编辑右侧的配置文件，添加\"vintageous_use_sys_clipboard\": true, ","date":"2023-11-08","objectID":"/sublime-neovim.zh/:4:0","series":null,"tags":["nvim"],"title":"Sublime Text4 使用 NeoVintageous 插件","uri":"/sublime-neovim.zh/#使yy会复制到系统剪贴板"},{"categories":["tutorial"],"content":" 1 启用插件","date":"2023-11-08","objectID":"/vscode-neovim.zh/:1:0","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#启用插件"},{"categories":["tutorial"],"content":" 1.1 Win11插件设置：Settings-user页面，Neovim Executable Paths: Win32内容设置为C:\\Users\\zwyyy\\scoop\\apps\\neovim\\current\\bin\\nvim.exe，Neovim Init Vim Paths: Win32内容无需设置。 ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:1:1","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#win11"},{"categories":["tutorial"],"content":" 1.2 WSL插件设置：Settings-Remote [WSL:Debian]页面，Neovim Executable Paths: Linux内容设置为/usr/bin/nvim，Neovim Init Vim Paths: Linux内容无需设置。 ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:1:2","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#wsl"},{"categories":["tutorial"],"content":" 1.3 MacOS插件设置：Settings-user页面，Neovim Executable Paths: Darwin 内容设置为 /opt/homebrew/bin/nvim，Neovim Init Vim Paths: Darwin 内容无需设置。 key bindings 中查找ctrl+c，删除与neovim有关的两项，否则会导致插入模式下无法使用ctrl+c复制（我没有选择删除）。 ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:1:3","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#macos"},{"categories":["tutorial"],"content":" 2 设置 jk 为 esc","date":"2023-11-08","objectID":"/vscode-neovim.zh/:2:0","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#设置-jk-为-esc"},{"categories":["tutorial"],"content":" 2.1 已于 1.11.1 版本废弃编辑 keybings.json，添加 json { \"command\": \"vscode-neovim.compositeEscape1\", \"key\": \"j\", \"when\": \"neovim.mode == insert \u0026\u0026 editorTextFocus\", \"args\": \"j\" }, { \"command\": \"vscode-neovim.compositeEscape2\", \"key\": \"k\", \"when\": \"neovim.mode == insert \u0026\u0026 editorTextFocus\", \"args\": \"k\" } ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:2:1","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#已于-1111-版本废弃"},{"categories":["tutorial"],"content":" 3 使用 gc 作为注释快捷键","date":"2023-11-08","objectID":"/vscode-neovim.zh/:3:0","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#使用-gc-作为注释快捷键"},{"categories":["tutorial"],"content":" 3.1 已废弃原先解决方案是在 neovim 的配置目录的 lua/vscode/config 目录下新建 keymaps.lua 文件，内容为： lua local keymap = vim.keymap -- local opts = { noremap = true, silent = true } -- vscode.neovim用于注释代码的按键映射 keymap.set(\"v\", \"gc\", \"\u003cPlug\u003eVSCodeCommentary\") keymap.set(\"n\", \"gc\", \"\u003cPlug\u003eVSCodeCommentary\") keymap.set(\"o\", \"gc\", \"\u003cPlug\u003eVSCodeCommentary\") keymap.set(\"n\", \"gcc\", \"\u003cPlug\u003eVSCodeCommentaryLine\") 同时修改init.lua，添加require(\"vscode.config.keymaps\")。 注意的是，这一方案随着 vscode 的 vscode.neovim 插件的更新已经失效。需要利用 neovim 中的 comment 插件来实现。 ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:3:1","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#已废弃"},{"categories":["tutorial"],"content":" 3.2 comment.nvim利用 comment.nvim 来实现 vscode 的调用 gc 快捷键注释。 文件结构目录如下: txt ├── LICENSE ├── README.md ├── init.lua ├── lazy-lock.json ├── lazyvim.json ├── lua │ ├── config │ │ ├── autocmds.lua │ │ ├── keymaps.lua │ │ ├── lazy.lua │ │ └── options.lua │ ├── plugins │ │ ├── colorscheme.lua │ │ ├── disabled.lua │ │ └── example.lua │ └── vscode │ ├── config │ │ ├── keymaps.lua │ │ ├── lazy.lua │ │ └── options.lua │ └── plugins │ ├── comment.lua │ └── disabled.lua └── stylua.toml init.lua 的内容如下： lua if vim.g.vscode then -- if true then -- Vscoe extension require(\"vscode.config.options\") require(\"vscode.config.keymaps\") -- require(\"vscode.init\") require(\"vscode.config.lazy\") -- require(\"vscode.plugins.disabled\") else -- bootstrap lazy.nvim, LazyVim and your plugins require(\"config.lazy\") end lua/vscode/config/lazy.lua 的内容如下： lua local lazypath = vim.fn.stdpath(\"data\") .. \"/lazy/lazy.nvim\" if not vim.loop.fs_stat(lazypath) then vim.fn.system({ \"git\", \"clone\", \"--filter=blob:none\", \"https://github.com/folke/lazy.nvim.git\", \"--branch=stable\", -- latest stable release lazypath, }) end vim.opt.rtp:prepend(lazypath) require(\"lazy\").setup(\"vscode.plugins\") 由于 vscode.neovim 是使用本机的 neovim 作为后端的，lua/config/lazy.lua 这一段代码就是让 vscode.neovim 也能使用 lazy.nvim 来管理插件，并且能够启用 lua/vscode/plugins 中的插件。 lua/vscode/plugins/comment.lua 的内容如下： lua return { { \"numToStr/Comment.nvim\", lazy = false, }, } lua/vscode/config/lazy.lua 与 lua/vscode/plugins/comment.lua 配合起来即通过 lazy.nvim 插件管理并启用了 Comment.nvim 插件，之后 vscode 在 normal 模式下也可以通过 gc 或者 ngc（其中 n 表示数字）来注释一行或者多行了。 同时 lua/vscode/plugins/disabled.lua 在 vscode 中禁用了 neovim 的 tokyonight 主题，防止 vscode 的代码高亮出现异常。 ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:3:2","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#commentnvim"},{"categories":["tutorial"],"content":" 4 同步系统剪贴板lua/vscode/config/options.lua 中内容修改为： lua -- clipboard local opt = vim.opt opt.clipboard = \"unnamedplus\" -- Sync with system clipboard ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:4:0","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#同步系统剪贴板"},{"categories":["tutorial"],"content":" 5 与 LazyVim 的融合LazyVim 有一个 extras 机制，打开 nvim，输入 :LazyExtras，根据提示勾选 vscode 即可。 这样，init.lua 可以写成 lua require(\"config.lazy\") if vim.g.vscode then else require(\"config.osc52\") end 也可以实现 kgc 来注释多行代码。 但是依旧存在问题，此种模式虽然 VsCode 不再会出现高亮异常问题，但是 vscode-neovim 的 \u003cC-w\u003e(h/j/k/l) 会被 LazyVim 插件本身占用。 ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:5:0","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#与-lazyvim-的融合"},{"categories":["tutorial"],"content":" 6 使用 neovim 的一些插件Comment.nvim 已安装，还需要安装 flash.nvim，以及 nvim-treesitter、nvim-treesitter-textobjects 和 nvim-ts-context-commentstring 即可。 见配置文件仓库。 ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:6:0","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#使用-neovim-的一些插件"},{"categories":["tutorial"],"content":" 7 总结配置文件已存放于远程仓库 neovim_config ","date":"2023-11-08","objectID":"/vscode-neovim.zh/:7:0","series":null,"tags":["nvim","vscode"],"title":"vscode使用 vscode-neovim 插件","uri":"/vscode-neovim.zh/#总结"},{"categories":["notes"],"content":" 1 1. 多态，虚函数","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-多态虚函数"},{"categories":["notes"],"content":" 1.1 1. 什么是多态，如何实现多态(⭐⭐)所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为；C++的多态分为编译时多态和运行时多态，编译时多态也称为为静态联编，通过重载和模板来实现，运行时多态称为动态联编，通过继承和虚函数来实现 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-什么是多态如何实现多态"},{"categories":["notes"],"content":" 1.2 2. 虚函数的实现机制(⭐⭐⭐)虚函数是通过虚函数表来实现的，虚函数表包含了一个类(所有)的虚函数的地址，在有虚函数的类对象中，它内存空间的头部会有一个虚函数表指针(虚表指针)，用来管理虚函数表。当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当我们用一个父类的指针来操作子类对象的时候，它可以指明实际所调用的函数 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-虚函数的实现机制"},{"categories":["notes"],"content":" 1.3 3. 虚函数调用是在编译时确定还是运行时确定的，如何确定调用哪个函数当使用指针或引用调用虚函数的时候，是运行时确定，通过查找虚函数表中的函数地址确定 而使用普通变量调用虚函数的时候，是编译器确定的，此时没有多态 虚函数表是在编译阶段生成的，存放在只读数据段.rodata(和全局常量、字符串常量存放在一起) ","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-虚函数调用是在编译时确定还是运行时确定的如何确定调用哪个函数"},{"categories":["notes"],"content":" 1.4 4. 在(基类的)构造函数和析构函数中调用虚函数会怎么样(⭐⭐)从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）；因为调用构造函数的时候，是先进行父类成分的构造，再进行子类的构造。在父类构造期间，子类的特有成分还没有被初始化，此时下降到调用子类的虚函数，使用这些尚未初始化的数据一定会出错；同理，调用析构函数的时候，先对子类的成分进行析构，当进入父类的析构函数的时候，子类的特有成分已经销毁，此时是无法再调用虚函数实现多态的 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:4","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-在基类的构造函数和析构函数中调用虚函数会怎么样"},{"categories":["notes"],"content":" 1.5 5. C 语言可以实现虚函数机制吗，如何实现需要做的工作：手动构造父子关系、创建虚函数表、设置虚表指针并指向虚函数表、填充虚函数表；当虚函数重写的时候还需要手动修改函数指针等等 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:5","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-c-语言可以实现虚函数机制吗如何实现"},{"categories":["notes"],"content":" 1.6 6. 重载、重写和隐藏的区别(⭐⭐) 重载指的是同一个名字的函数，具有不同的参数列表（参数类型、个数），或不同的返回类型，根据参数列表和返回类型决定调用哪一个函数； 重写（覆盖）指的是，派生类中的函数重写了基类中的虚函数，重写的基类的中函数必须被声明为virtual，并且返回值，参数列表和基类中的函数一致(除非返回类型是基类/派生类的指针/引用)； 隐藏是指，派生类中的同名函数把基类中的同名函数隐藏了，包括所有的重载版本，不论是不是虚函数都会隐藏 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:6","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#6-重载重写和隐藏的区别"},{"categories":["notes"],"content":" 1.7 7. 模板类可以有虚函数吗，模板函数可以是虚函数吗 模板类可以使用虚函数。但使用模板类定义不同的类型则是两个完全不同的类，即使两个泛型参数是父类和子类关系，两个泛型变量也没有任何父子关系 模板函数不能是虚函数。编译器都期望在处理类的定义的时候就能确定这个类的虚函数表的大小，如果允许有类的虚成员模板函数，那么就必须要求编译器提前知道程序中所有对该类的虚成员模板函数有多少个版本，才能分配虚函数表的大小，而这是不可行的 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:7","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#7-模板类可以有虚函数吗模板函数可以是虚函数吗"},{"categories":["notes"],"content":" 1.8 8. 内联函数可以是虚函数吗，静态函数可以是虚函数吗(⭐⭐) 内联函数表示在编译阶段进⾏函数体的替换操作(内联函数实际上不是函数)，⽽虚函数意味着在运⾏期间进⾏类型确定，要经过函数调用的过程，所以内联函数不能是虚函数(将函数同时声明inline virtual编译器会直接忽略inline) 静态函数不属于类对象而属于类，静态成员函数没有 this 指针，所以无法找到虚表，也就无法实现虚函数重写的功能，所以不能是虚函数 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:8","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#8-内联函数可以是虚函数吗静态函数可以是虚函数吗"},{"categories":["notes"],"content":" 1.9 9. 多个基类的同名虚函数覆写问题(⭐)假设一个子类继承两个基类，这两个基类都有一个虚函数func，那么直接用子类变量调用func就会出现歧义，因为不知道是哪一个func，其实就是不知道使用哪个虚表的信息 如果用这两个基类的指针指向这个子类变量，那么用这两个基类指针就能成功调用这个虚函数了，因为两个基类指针确定了是使用自己类的虚表 若子类又覆写了这个同名的虚函数，此时会将两个虚表中的该函数全部覆写，那直接用子类变量也能直接调用func，此时没有歧义，因为两个虚函数实现是一样的了 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:1:9","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#9-多个基类的同名虚函数覆写问题"},{"categories":["notes"],"content":" 2 2. 内存与继承","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-内存与继承"},{"categories":["notes"],"content":" 2.1 1. C++ 中类对象的内存模型(布局)是怎么样的(⭐⭐⭐) 如果是有虚函数的话，虚函数表的指针始终存放在内存空间的头部 除了虚函数之外，内存空间会按照类的继承顺序(父类到子类)和字段的声明顺序布局 如果有多继承，每个包含虚函数的父类都会有自己的虚函数表，并且按照继承顺序布局(虚表指针 + 字段）；如果子类重写父类虚函数，都会在每一个相应的虚函数表中更新相应地址；如果子类有自己的新定义的虚函数或者非虚成员函数，也会加到第一个虚函数表的后面 如果有菱形继承，并采用了虚继承，则内存空间排列顺序为：各个父类(包含虚表)、子类、公共基类(虚基类，包含虚表)，并且各个父类不再拷贝虚基类中的数据成员 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-c-中类对象的内存模型布局是怎么样的"},{"categories":["notes"],"content":" 2.2 2. 菱形继承存在什么问题，如何解决会存在二义性的问题，因为两个父类会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，也会导致编译错误。可以采用虚继承的方法解决这个问题，这样就只会创造一份公共基类的实例，不会造成二义性 在钻石继承时，使用最高层的公共基类指向最底层的派生类，就会报错，因为编译器不知道是指向哪个派生类的基类区域 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-菱形继承存在什么问题如何解决"},{"categories":["notes"],"content":" 2.3 3. C++ 是如何做内存管理的（有哪些内存区域）(⭐⭐⭐) 堆，使用malloc、free动态分配和释放空间，能分配较大的内存 栈，为函数的局部变量分配内存，能分配较小的内存 全局/静态存储区，用于存储全局变量和静态变量 常量存储区，专门用来存放常量 自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-c-是如何做内存管理的有哪些内存区域"},{"categories":["notes"],"content":" 2.4 4. C++ 内存有哪些段 代码段.text存放函数代码 .bss段存放未初始化的全局变量，未初始化的全局静态变量和局部静态变量 数据段.data存放已经初始化的全局变量，已初始化的全局静态变量和局部静态变量 只读数据段.rodata存放全局常量、字符串常量和虚函数表 堆存放动态分配内存的数据 栈存放局部变量和函数中声明的非静态变量 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:4","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-c-内存有哪些段"},{"categories":["notes"],"content":" 2.5 5. 堆和栈的内存有什么区别(⭐⭐⭐) 堆中的内存需要手动申请和手动释放，栈中内存是由OS自动申请和自动释放 堆能分配的内存较大（4G：32位机器），栈能分配的内存较小（1M） 在堆中分配和释放内存会产生内存碎片，栈不会产生内存碎片 堆的分配效率低，栈的分配效率高 堆地址从低向上，栈由高向下 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:5","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-堆和栈的内存有什么区别"},{"categories":["notes"],"content":" 2.6 6. C++和 C 分别使用什么函数来做内存的分配和释放，有什么区别，能否混用(⭐⭐)C 使用malloc / free，C++ 使用new / delete，前者是 C 语言中的库函数，后者是 C++ 语言的运算符，对于自定义对象，malloc / free只进行分配内存和释放内存，无法调用其构造函数和析构函数，只有new / delete能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间，不能混用，具体区别如下： new分配内存空间无需指定分配内存大小，malloc需要； new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型； new是从自由存储区获得内存，malloc从堆中获取内存； 对于类对象，new/delete会调用构造函数/析构函数，malloc/free不会（核心区别） ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:6","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#6-c和-c-分别使用什么函数来做内存的分配和释放有什么区别能否混用"},{"categories":["notes"],"content":" 2.7 7. 什么是内存对齐(字节对齐)，为什么要做内存对齐，如何对齐(⭐⭐⭐) 内存对齐的原因：为了提高 CPU 存取数据的效率，计算机从内存中取数据是按照一个固定长度的。比如在 32 位机上，CPU 每次都是取 32bit 数据的，也就是 4 字节；若不进行对齐，要取出两块地址中的数据，进行掩码和移位等操作，写入目标寄存器内存，效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度 对其原则(类和结构体同样适用)： 结构体变量的首地址能够被其最宽基本类型成员的对齐值所整除 结构体内每一个成员的相对于起始地址的偏移量能够被该变量的大小整除 结构体总体大小能够被最宽成员大小整除 如果不满足这些条件，编译器就会进行一个填充(padding) 如何对齐：声明数据结构时，字节对齐的数据依次声明，然后小成员组合在一起，能省去一些浪费的空间，不要把小成员参杂声明在字节对齐的数据之间 空类 / 结构体占 1 字节(为了能对空类取地址，从而用了 1 字节的占位符)，若有了一个虚函数，那就有了虚指针，不再是空类，64 位系统下指针占 8 字节，此时类大小为 8 字节 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:7","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#7-什么是内存对齐字节对齐为什么要做内存对齐如何对齐"},{"categories":["notes"],"content":" 2.8 8. delete 和 delete[] 的区别，delete[] 如何知道要 delete 多少次(⭐) 若是基本类型，delete和delete[]效果是一样的，因为系统会自动记录分配的空间，然后释放；对于自定义数据类型而言（比如类）就不行了，delete 仅仅释放数组第一个元素的内存空间，且仅调用了第一个对象的析构函数，但delete[]会调用数组所有元素的析构函数，并释放所有内存空间 在new []一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，这个数据就存在分配空间的最前面*p的位置，返回的指针是*p + 4，在 delete[]时就可以取出这个保存的数，就知道了需要调用析构函数多少次了 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:8","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#8-delete-和-delete-的区别delete-如何知道要-delete-多少次"},{"categories":["notes"],"content":" 2.9 9. 在类的成员函数中能否 delete this(⭐)delete this就是显式调用了析构函数，并释放内存。在析构函数被私有，或者智能指针引用计数归零时，会使用到这句话 在类的成员函数可以调用delete this，并且delete this之后还可以调用该对象的其他成员，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。当一个类对象声明时，系统会为其分配内存空间。在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中 因为成员函数并不在类的内存中，所以即使用一个类的空指针，比如A *p = nullptr，这个指针p依旧能调用类的函数，但前提依旧是这个成员函数不访问任何类的数据成员 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:9","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#9-在类的成员函数中能否-delete-this"},{"categories":["notes"],"content":" 2.10 10. 如何在已经分配好的内存进行对象构造(⭐)一种方式是使用placement new，调用方式为new(ptr) XXX()，XXX()表示调用类的构造函数，比如下面代码 C++ class A { int val; }; int main() { auto mem = malloc(sizeof(A)); auto p = new(mem) A(); # 此时两个指针指向同一位置 assert((void*)p == (void*)mem); return 0; } 使用placement new有三个注意点：必须有足够内存放对象；指针地址应该对齐，比如32位系统，指针的地址应该是4的整数倍；需要显式的调用析构函数来销毁对象 在new的过程中，经过了三次操作：调用operator new分配内存，调用构造函数，返回指针，这个operator new可以重载，原型为void* operator new(size_t sz) 将内存和构造分离，可以使用allocator类，先分配内存，再显式构造对象 C++ int main() { std::allocator\u003cA\u003e alloc; # 分配一个A对象的内存，用指针 p 指向 auto p = alloc.allocate(1); # 调用 A 的构造函数，构造在 p 指向的内存，构造函数的形参写在 p 后面 alloc.construct(p, ...); # 调用析构函数 p-\u003e~A()，但是不释放内存 alloc.destroy(p); # 释放内存 alloc.deallocate(p, 1); return 0; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:10","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#10-如何在已经分配好的内存进行对象构造"},{"categories":["notes"],"content":" 2.11 11. new / delete 的重载重载new和delete，实际上是重载operator new和operator delete函数，若重载这两个函数，就必须保证是正确的，并且担负了控制动态内存分配的职责 这两个函数会被误以为重载了new和delete，实际上只是改变了内存分配的方式，我们不能改变new运算符和delete运算符的基本含义 标准库定义了这两个函数共八个版本，可以重载任意的版本，下面列出四个 C++ void* operator new(size_t); # 分配一个对象 void* operator new[](size_t); # 分配一个数组 void* operator delete(void*) noexcept; # 释放一个对象 void* operator delete[](void*) noexcept; # 释放一个数组 注意到operator new返回值必须是void*，并且所有的operator delete承诺不抛出异常 我们可以使用malloc和free来重载上述两个函数 C++ void* operator new(size_t size) { if(void *mem = malloc(size)) return mem; else throw bal_alloc(); } void operator delete(void *mem) noexcept { free(mem); } 析构函数可以显式调用，析构函数只负责销毁对象，但是并不释放内存 C++ string *sp = new string(\"value\"); sp-\u003e~string(); ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:11","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#11-new--delete-的重载"},{"categories":["notes"],"content":" 2.12 12. 如何让类只能在堆/栈上创建(⭐) 这涉及到C++创建类的两种方法，静态建立和动态建立： 静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如A a; 动态建立：使用 new关键字在堆空间上创建对象，首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如A *p = new A; 只能在堆上构建，就是不能直接调用构造函数，只能通过new进行调用，可以将构造函数声明为protected，提供一个public的静态函数来调用new + 构造函数来返回对象，并将析构函数设置为protected，为保证能释放内存，需要写一个额外的destory函数来释放内存delete this，这就类似于单例模式 只能在栈上构建，就是不能调用operator new，只要将这个函数声明为私有即可，并且要把delete也声明为私有，如下代码所示，注意operator new是一个固定的函数，参数和返回值都是固定的 C++ class A { private: # 注意函数的第一个参数和返回值都是固定的 void *operator new(size_t t) {} # 重载了 new 就需要重载 delete void operator delete(void *ptr) noexcept {} public: A() {} ~A() {} }; ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:12","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#12-如何让类只能在堆栈上创建"},{"categories":["notes"],"content":" 2.13 13. 类成员的初始化顺序使用构造函数初始化类的成员变量，构造函数分为初始化列表和构造函数体两个部分。在初始化列表中，每个变量的初始化顺序只和在类内定义变量的顺序有关；在构造函数体内，则和写的赋值语句顺序有关 C++ class A { private: int a; int b; public: # 出错，先初始化 a, 此时 b 还没有值, 初始化列表的初始化顺序和语句顺序没关系, 只和变量定义顺序有关 A(int v1): b(v1), a(b + v1) {} }; ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:13","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#13-类成员的初始化顺序"},{"categories":["notes"],"content":" 2.14 14. 数组访问越界会访问到什么结果数组中的元素作为连续的内存地址存储，当访问数据越界时，它会尝试读取或写入内存中的未分配空间，这可能包括其他变量、数据结构、程序代码等。这可能会导致覆盖其他变量或数据结构的值，结果是不可预测的，可能会导致程序崩溃或产生不正确的结果，甚至会对系统产生影响 并非每次越界访问都会导致程序崩溃，程序崩溃一般发生在下面的情况： 内存读取和写入非法地址时：试图读取或写入未分配的内存空间，这个地址可能并非指向任何有效的内存位置，这将导致程序崩溃 覆盖其他变量或数据结构的值时：越界访问时可能会覆盖其他变量或数据结构的值，导致程序状态受到破坏 发生了缓冲区(IO)溢出时：当存储在缓冲区中的数据超过了缓冲区的容量时，可能会发生缓冲区溢出。缓冲区溢出有时会导致程序崩溃或者产生不正确的结果 堆栈溢出时：如果在函数调用过程中，堆栈空间不足以支持函数所需的所有局部变量及其上下文信息（例如函数调用和返回地址等），就会发生堆栈溢出 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:14","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#14-数组访问越界会访问到什么结果"},{"categories":["notes"],"content":" 2.15 15. public 继承和 private 继承 公有继承意味着 is - a 的关系，也就是派生类是基类的一种特例，在基类的所有行为在派生类也应该成立，基类的所有成员在派生类也有意义，所以成员函数的实现和接口均被继承了 私有继承意味着根据某物实现，也就是派生类具备基类的某些特性，但是基类和派生类并没有实际的关系。首先，私有继承会导致派生类不能转换成基类，其次，所有基类的成员都会在派生类内变成私有成员。因此，基类的所有成员函数只能在类内调用，在类外全都无法调用，这就是成员函数的实现被继承，而接口全被略去(因为在类外都无法调用) 一个空类会占有 1 个字节大小，但是继承一个空类，就会优化掉这个 1 个字节大小 组合就是在一个类中将其他类声明为成员变量，复合意味着 has - a 的关系，这和公有继承的含义完全不同 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:2:15","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#15-public-继承和-private-继承"},{"categories":["notes"],"content":" 3 3. 类型转换","date":"2023-11-07","objectID":"/cpp_interview.zh/:3:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-类型转换"},{"categories":["notes"],"content":" 3.1 1. C++ 有哪些类型转换的方法(关键字)，各自有什么作用(⭐) const_cast：把const属性去掉，或者添加const，const_cast只能用于指针或引用，并且只能改变底层const static_cast：可以实现 C++ 中内置基本数据类型之间的相互转换，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查），它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用于包含底层const的对象 dynamic_cast：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用，若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常。dynamic_cast是在运行时进行安全性检查；使用dynamic_cast父类一定要有虚函数，否则编译不通过 reinterpret_cast：此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和 C 风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形，这和操作符并不安全 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:3:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-c-有哪些类型转换的方法关键字各自有什么作用"},{"categories":["notes"],"content":" 3.2 2. static_cast 和 dynamic_cast 的异同点static_cast和dynamic_cast有以下区别： static_cast用于非多态类型的转换，如基本数据类型之间的转换。它的转换是在编译期完成的，在运行期不会进行任何检查。如果static_cast的转换不安全，可能会导致程序运行时错误(将父类对象转换成子类对象就是不安全行为，static_cast不进行运行期间检查，这种转换可能会导致内存访问错误) dynamic_cast主要用于多态类型之间的转换，例如基类指针向下转换为派生类指针、派生类指针向上转换为基类指针等。它的操作是在运行期完成的，会检查是否可以安全地进行类型转换(需要有虚函数，才能进行运行期间检查)。如果失败，它会返回一个空指针或者抛出一个std::bad_cast异常 static_cast的性能比dynamic_cast更高，因为它不需要进行运行时的类型检查 static_cast和dynamic_cast两者都有一个共同的限制：它们只适用于有继承关系的类之间的转换，对于没有继承关系的类，不能使用这两种类型的转换 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:3:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-static_cast-和-dynamic_cast-的异同点"},{"categories":["notes"],"content":" 3.3 3. dynamic_cast 的原理dynamic_cast用于将基类指针或引用安全地转换成派生类指针或引用。它能够在运行时检查类型信息，从而实现安全的转换，实现原理主要包括两个步骤： 通过类型信息表type_info进行类型检查：dynamic_cast在执行类型转换时，首先会获取当前对象的type_info指针，然后匹配目标类型的type_info指针，如果匹配成功，则进行类型转换；反之，返回一个空指针或抛出std::bad_cast异常 计算偏移量进行指针调整：如果类型检查成功，dynamic_cast会计算当前对象和目标类型之间的偏移量，然后进行指针调整，这个偏移量是通过虚函数表动态计算的，因此dynamic_cast只适用于具有继承关系且包含虚函数的类对象之间的转化 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:3:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-dynamic_cast-的原理"},{"categories":["notes"],"content":" 3.4 4. RTTIRTTI（Run-Time Type Information，运行时类型信息）是C++的一个特性，用于在程序运行时确定对象的类型。RTTI 可以通过dynamic_cast和typeid实现，在需要检查对象类型的时候，可以用dynamic_cast进行类型转换，如果转换失败则返回 NULL 指针，否则返回指向目标类型的指针；也可以使用typeid获取对象的类型信息，返回类型为std::type_info RTTI 的主要作用有： 确定对象的类型：当需要在程序运行时检查对象的类型时，RTTI 提供了一种简单而有效的方法 实现多态：RTTI 是实现多态的基础。在面向对象编程中，多态是一个重要的概念，它指的是同一个函数调用可能会根据传递参数的不同而产生不同的行为。RTTI 可以识别出对象在继承层次结构中的位置，从而可以正确地调用相应的函数 辅助代码调试：当程序出现异常或错误时，可以使用 RTTI 输出对象的类型信息，从而帮助开发人员更快地找到问题所在 需要注意的是，使用 RTTI 可能会带来一定的性能损失，因此在一些性能敏感的场景下应该尽量避免使用 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:3:4","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-rtti"},{"categories":["notes"],"content":" 3.5 5. 浮点数和误差(⭐⭐)float的存储，是包括符号位(1位)+指数位(8位)+尾数位(23)位，可以表示为公式 $$ float = (1.a)*2^b $$ 指数位的表示值范围为$[2^{-8}, 2^8 - 1]$，所以浮点数的最大值为$1.1….×2^{127}$，逼近$2^{128}$，约等于$3.4×10^{38}$，所以通常说浮点数可以表示的数字范围是$[-3.4×10^{38},3.4×10^{38}]$ 但这个看似比int范围广的多的数据范围，是以精度损失为代价的，虽然底层存储的指数位和小数位值是固定的，但是当指数位表示的值从负数变成正数，变成十进制时，也就是从一个很小的小数不断变成一个很大的整数，小数位不断丢失(因为乘以了2的次方，小数全部变成了整数部分)，所以浮点数可以表示的有效数字只有 7 位，整数值+小数值顶多只有 7 位有效 考虑整数情况，因为有$23$位尾数，因此float类型可以精确表示$2^{23}$个不重复的二进制小数。这意味着，float类型可以精确表示$23$位二进制小数，再乘上指数项$2^n$，加上科学计数法默认的整数部分的$1$，所以浮点数可以完全精确表示的整数范围是$[-16777216,16777216]=[-2^{24},2^{24}]$ 但是这个范围以外的整数，除非能表示成$[0, 16777215]$之间的一个数字进行位移$×2^n$的模式，否则都会丢失精度，会出现对这个值$+1$，但是浮点数显示的值不变，也就是损失了整数位的精度 考虑小数情况，一个小数要拆分成多个二进制次方的小数和形式，比如$0.75=0.5+0.25$，转换成二进制$0.11$，但一些小数会导致二进制无限循环，只能逼近小数，导致精度误差，比如$0.7$只能表示成$0.1011001100…$ 下图为float和double的精度范围 可见，当float在千万级别时，精度是 1，已经无法感知小数位的变化，为了保证有一位小数的精度，至少要保证float在百万以内，所以说，浮点数的整数 + 小数部门是固定长度的，大的浮点数基本没有小数精度了 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:3:5","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-浮点数和误差"},{"categories":["notes"],"content":" 4 4. 指针","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-指针"},{"categories":["notes"],"content":" 4.1 1. C++ 中的智能指针有哪些，各自有什么作用(⭐⭐)智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针shared_ptr, 独占指针unique_ptr和弱指针weak_ptr shared_ptr ：多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间 unique_ptr：保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr） weak_ptr：用来解决shared_ptr相互引用时的死锁问题。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr ","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-c-中的智能指针有哪些各自有什么作用"},{"categories":["notes"],"content":" 4.2 2. shared_ptr 的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr 是不是线程安全的(⭐) shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至 0 时就会自动销毁这个对象 具体实现： 构造函数：将指针指向该对象，引用计数置为 1 拷贝构造函数：将指针指向该对象，引用计数++ 赋值运算符：= 号左边的shared_ptr的引用计数 -1，右边的shared_ptr的引用计数 +1，如果左边的引用计数降为 0，销毁shared_ptr指向对象，释放内存空间 shared_ptr的引用计数本身是安全且无锁的(使用了原子操作)，但是对对象的访问并不是线程安全的 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-shared_ptr-的实现原理是什么构造函数拷贝构造函数和赋值运算符怎么写shared_ptr-是不是线程安全的"},{"categories":["notes"],"content":" 4.3 3. 如何创建 shared_ptr，能不能使用普通指针创建(⭐)可以调用make_share方法，或者使用new关键字(但必须直接初始化) C++ shared_ptr\u003cint\u003e p1 = make_shared\u003cint\u003e(42); shared_ptr\u003cint\u003e p2(new int(1024)); 不要直接使用普通指针给智能指针初始化，否则当智能指针变量的引用计数归零后，会自动释放内存，此时的普通指针就成了空悬指针 C++ void process(shared_ptr\u003cint\u003e ptr) { # 某些操作 } int *p = new int(1024); process(shared_ptr\u003cint\u003e(p)); # 用内置指针创建智能指针，引用计数为1，函数结束后引用计数为0，释放了指向的内存，也就是内置指针指向的内存 int j = *p; # 报错，p已经是空悬指针 补充一点： shared_ptr的大小是裸指针的两倍，因为还要保存引用计数的信息，若自定义了删除器和分配器也会保存，这些额外信息统一存在一个叫控制块的数据结构内 一个对象的控制块由首次指向该对象的shared_ptr得到。在使用make_shared时候会创建一个控制块；使用一个unique_ptr变量创建shared_ptr对象也会创建控制块；当用一个裸指针作为参数创建一个shared_ptr时候也会得到一个控制块 正是因为用裸指针创建shared_ptr会创建一个控制块，若用同一个裸指针创建两个shared_ptr对象，那就会得到两个不同的控制块，且每个控制块记录的引用计数都是1，如下面代码所示 C++ auto pw = new Widget; std::shared_ptr\u003cWidget\u003e spw1(pw); std::shared_ptr\u003cWidget\u003e spw2(pw); 那么当这两个shared_ptr变量离开作用域被销毁后，会对同一对象执行两次析构函数，第二次析构函数就会导致未定义情况 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-如何创建-shared_ptr能不能使用普通指针创建"},{"categories":["notes"],"content":" 4.4 4. 创建智能指针什么时候使用 make 函数，什么时候使用 new创建智能指针，一般都是使用make系列函数，即make_shared, make_unique，不仅在创建变量的时候很方便 C++ auto upw1(std::make_unique\u003cWidget\u003e()); # 只要声明一次类型 std::unique_ptr\u003cWidget\u003e upw2(new Widget); # 要声明两次类型 而且可以避免潜在可能的内存泄漏，比如下面的代码，一个函数接受一个shared_ptr和一个int值，我们用一个函数的返回值来给这个int形参传值 C++ void processWidget(std::shared_ptr\u003cWidget\u003e spw, int priority); processWidget(std::shared_ptr\u003cWidget\u003e(new Widget), computePriority()); 编译器对这个函数调用，会先执行new Widget，生成一个指向Widget的裸指针，但是第二步不一定是创建shared_ptr，也可能是调用computePriority函数，若在调用computePriority过程中出现异常，并且此时shared_ptr还没有接管这个裸指针指向的对象，就导致了内存泄漏 并且使用make函数，可以只进行一次内存分配，如下面代码所示 C++ std::shared_ptr\u003cWidget\u003e spw(new Widget); auto spw2 = std::make_shared\u003cWidget\u003e(); 因为shared_ptr是需要给控制块分配内存的，所以用裸指针创建shared_ptr对象需要两次内存分配，先给裸指针指向的Widget分配内存，再给shared_ptr需要的控制块分配内存，而make_shared直接将分配对象内存和控制块内存一步解决 但是make系列函数不能传入自定义的删除器，所以当想使用自定义删除器的时候，还是要用new创建智能指针 C++ auto widgetDeleter = [](Widget *pw) {...}; std::unique_ptr\u003cWidget, decltype(widgetDeleter)\u003e upw(new Widget, widgetDeleter); ","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:4","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-创建智能指针什么时候使用-make-函数什么时候使用-new"},{"categories":["notes"],"content":" 4.5 5. 指针和引用的区别(⭐⭐) 指针本质是一个变量，有自己的内存空间；引用只是一个别名，并不占内存 指针可以指向其他的对象；引用不能指向其他的对象，初始化之后就不能改变了 指针可以初始化为nullptr；引用必须被初始化为一个已有对象的引用 指针可以是多级指针；引用只能是一级 对指针sizeof得到的是指针变量的大小；对引用sizeof得到的是指向对象的大小 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:5","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-指针和引用的区别"},{"categories":["notes"],"content":" 4.6 6. 什么时候应该用指针，什么时候应该用引用(⭐⭐)引用比指针更安全，并且可读性更高，引用在大部分情况下都是优先选项，除非有以下情况： 当可能需要指向空对象的时候，使用指针而非引用，因为引用必须指向一个对象不能置空 当可能要改变指向的情况下，使用指针而非引用，因为引用不可以改变指向 尤其当在重载运算符的时候，比如[]，这肯定要返回引用，不然每次使用该运算符访问对象都要加解引用符号* 引用用于对象的表面，而指针用于对象的内部 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:6","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#6-什么时候应该用指针什么时候应该用引用"},{"categories":["notes"],"content":" 4.7 7. 函数指针参数传递和引用参数传递有什么区别(⭐) 指针参数传递本质上是值传递，它所传递的是⼀个地址值。值传递过程中，被调函数的形参作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从⽽形成了实参的⼀个副本 引⽤参数传递过程中，被调函数的形参也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量 引⽤传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的⼀个局部变量，但是任何对于引⽤参数的处理都会通过⼀个间接寻址的⽅式操作到主调函数中的相关变量。⽽对于指针传递的参数，如果改变被调函数中的指针地址，不会改变实参指针的指向地址，若想用形参指针改变实参指针的指向，必须使用指针的指针或指针的引用 从编译的⻆度来讲，程序在编译时分别将指针和引⽤添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，⽽引⽤在符号表上对应的地址值为引⽤对象的地址值。符号表⽣成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），⽽引⽤对象则不能修改 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:7","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#7-函数指针参数传递和引用参数传递有什么区别"},{"categories":["notes"],"content":" 4.8 8. 野指针和空悬指针的区别野指针(wild pointer)：就是没有被初始化过的指针 悬空指针：是指针最初指向的内存已经被释放了的⼀种指针 ⽆论是野指针还是悬空指针，都是指向⽆效(不安全不可控)内存区域的指针。 访问无效的内存区域将导致未定义行为 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:8","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#8-野指针和空悬指针的区别"},{"categories":["notes"],"content":" 4.9 9. RAII(⭐)RAII（Resource Acquisition Is Initialization）含义为资源获取即初始化，也就是使用局部对象来管理资源的技术。这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入 比如说，可以用一个类封装一个动态内存，调用构造函数时申请空间分配内存，变量离开作用域会自动调用析构函数释放内存 智能指针就是 RAII 的一种实现，将内存的申请和释放全部交给了编译器处理 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:4:9","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#9-raii"},{"categories":["notes"],"content":" 5 5. 关键字","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-关键字"},{"categories":["notes"],"content":" 5.1 1. const 的作用，指针常量和常量指针，const 修饰的函数能否重载(⭐) const修饰符用来定义常量，具有不可变性。在类中，被const修饰的成员函数，不能修改类中的数据成员； 若形参是值类型，加const不构成重载；若为指针或引用类型，加const构成重载 若给成员函数的this加上const构成重载，返回值加static不构成重载，修改返回值类型也不构成重载，函数的签名是函数名称和参数列表，是通过不同的参数实现重载的 常量指针(const pointer)是指指针本身是常量，不能修改指向的地址值，但是能修改指向的对象的值 指针常量(pointer to const)是指指针指向一个常量，可以修改指针的指向地址，但是不能通过指针修改指向对象的值 C++ int x = 2; int y = 3; // 常量指针，不能修改指向 int *const p1 = \u0026x; // 报错，常量指针不能修改指向 p1 = \u0026y; // 指针常量 const int* p2 = \u0026x; // 报错，指针常量不能修改指向对象的值 *p2 = 3; ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-const-的作用指针常量和常量指针const-修饰的函数能否重载"},{"categories":["notes"],"content":" 5.2 2. static 的作用，static 变量什么时候初始化(⭐⭐⭐)static即静态的意思，可以对变量和函数进行修饰。分三种情况 当用于文件作用域的时候（即在.h/.cpp文件中直接修饰变量和函数），static意味着这些变量和函数只在本文件可见，其他文件是看不到也无法使用的，可以避免重定义的问题 当用于函数作用域时，即作为局部静态变量时，意味着这个变量是全局的，只会进行一次初始化，不会在每次调用时进行重置，但只在这个函数内可见 当用于类的声明时，即静态数据成员和静态成员函数，static表示这些数据和函数是所有类对象共享的一种属性，而非每个类对象独有 static变量在类的声明中不占用内存，因此必须在.cpp文件中定义类静态变量以分配内存(需要在main函数外给其分配内存，比如int A::a = 2，或者直接在类内赋初值)，全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；局部静态变量在第一次使用时分配内存并初始化 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-static-的作用static-变量什么时候初始化"},{"categories":["notes"],"content":" 5.3 3. extern 的作用当它与\"C\"一起连用时，如: extern \"C\" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是 C++ 的；当它作为一个对函数或者全局变量的外部声明，提示编译器遇到此变量或函数时，在其它模块.cpp中寻找其定义 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-extern-的作用"},{"categories":["notes"],"content":" 5.4 4. explicit 的作用标明类的构造函数是显式的，不能进行隐式转换，比如 C++ class A { public: int val; explicit A(int v): val(v) {} }; int main() { vector\u003cA\u003e ve; ve.push_back(1); # 报错，禁止隐式转换 ve.push_back(A(1)); # 正确，显式调用构造函数 return 0; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:4","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-explicit-的作用"},{"categories":["notes"],"content":" 5.5 5. constexpr 的作用，和 const 区别constexpr是C++11引入的关键字，用于在编译时求值的常量表达式。它可以用于定义常量变量或函数，并具有类型和编译时类型检查。constexpr定义的常量必须是能在编译时确定值的表达式，不能包含运行时的操作，有点类似于define，在编译期直接替换，就不占用内存了 const和constexpr都是C++中用于定义常量的关键字，但它们有以下几个不同点： 修饰符的适用范围： const：可以用于修饰变量、函数参数、成员函数、成员变量等。它可以用于运行时常量和编译时常量 constexpr：主要用于修饰变量和函数，用于声明编译时常量 求值时机： const：在运行时求值，即在程序运行期间才确定其值 constexpr：在编译时求值，即在编译期间就能确定其值 表达式限制： const：可以用任何常量表达式来初始化，包括运行时的函数调用和动态内存分配等 constexpr：要求表达式在编译期间就能确定其值，不能包含运行时操作，如函数调用、动态内存分配等 类型限制： const：可以用于任何数据类型，包括内置类型、用户自定义类型等 constexpr：要求常量的类型必须是字面值类型（Literal Type），包括内置字面值类型和满足一定条件的用户自定义字面值类型（如构造函数是constexpr） 编译时优化： const：不一定会进行编译时优化 constexpr：在编译时求值，可以进行更多的编译时优化，例如在编译期间替换常量表达式 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:5","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-constexpr-的作用和-const-区别"},{"categories":["notes"],"content":" 5.6 6. volatile 的作用(⭐⭐)跟编译器优化有关，告诉编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的备份 更重要的作用是避免指令重排，一个变量被加上volatile，就必然会按照程序写的顺序执行，保证了多线程时对值读写和判断的正确性 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:6","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#6-volatile-的作用"},{"categories":["notes"],"content":" 5.7 7. mutable 的作用可变的意思，类中声明为const的函数可以修改类中声明了mutable的非静态成员 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:7","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#7-mutable-的作用"},{"categories":["notes"],"content":" 5.8 8. auto 和 decltype 的作用和区别用于实现类型自动推导，让编译器来推导变量的类型；auto不能用于函数传参(在C++14允许对lambda表达式的参数使用auto)和推导数组类型，但deltype可以 auto默认推断的类型是没有任何const和引用，需要手动添加，比如const auto \u0026 decltype会保留传入参数的所有类型关键词，包括const和引用，比如 C++ const int i = 0; const int \u0026ref = i; # decltype(ref) 类型为 const int\u0026 并且可以给decltype传入的参数加一个小括号，表示转化成引用类型，比如 C++ int x = 0; # decltype((x)) 类型为 int\u0026 在 C++11 中，decltype可以用于函数的尾后返回类型，表示函数的返回类型依赖于函数的某个参数，一般用于模板函数 C++ template\u003ctypename Container, typename Index\u003e auto authAndAccess(Container \u0026\u0026c, Index i) -\u003e decltype(std::forward\u003cContainer\u003e(c)[i]) { return std::forward\u003cContainer\u003e(c)[i]; } 在 C++14 中，可以直接将decltype和auto放在一起decltype(auto)，让编译器自行推导返回类型，省略尾后返回类型 C++ template\u003ctypename Container, typename Index\u003e decltype(auto) authAndAccess(Container \u0026\u0026c, Index i) { return std::forward\u003cContainer\u003e(c)[i]; } auto可以在同行声明多个变量，但是必须auto推导出来的类型相同，可以把auto就看成某个特定类型，这是唯一的 auto也能推导出指针和函数指针，任何函数的名字本身就是指向这个函数的指针，不论加不加\u0026都可以进行推导 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:8","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#8-auto-和-decltype-的作用和区别"},{"categories":["notes"],"content":" 5.9 9. using 和 typedef 区别两个关键字都可以用于给类型取别名，使用using会更直观一些 C++ typedef void (*FP)(int, const std::string\u0026); using FP = void (*)(int, const std::stting\u0026); 但只有using可以直接给模板取别名，称为别名模板 C++ template\u003ctypename T\u003e using MyAllocList = std::list\u003cT, MyAlloc\u003cT\u003e\u003e; 并且使用using可以消除对依赖类型加typename的过程，比如先使用typedef创建一个别名模板，必须用一个结构体包装 C++ template\u003ctypename T\u003e struct MyAllocList { typedef std::list\u003cT, MyAlloc\u003cT\u003e\u003e type; }; 现在想使用这个别名模板的类型创建一个变量，就必须在前面加上typename强调这是一个类型 C++ template\u003ctypename T\u003e class Widget{ private: typename MyAllocList\u003cT\u003e::type list; }; 但直接使用using创建别名模板，就不用使用结构体封装，也就不需要加typename了，编译器知道这是一个类型而非变量 C++ template\u003ctypename T\u003e using MyAllocList = std::list\u003cT, MyAlloc\u003cT\u003e\u003e; template\u003ctypename T\u003e class Widget{ private: MyAllocList\u003cT\u003e list; }; ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:9","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#9-using-和-typedef-区别"},{"categories":["notes"],"content":" 5.10 10. 限定作用域枚举类型C++98 的枚举类型称为不限定作用域的枚举类型enum，而 C++11 新加的枚举类型称为限定作用域的枚举类型enum class C++ enum Color { black, white, red }; # C++98 enum class Color { black, white, red }; # C++11 前者声明的几个枚举名字在Color有效的作用域都有效，所以就不能创建同名的变量了(污染了变量名空间)，而后者只在枚举内部可见，在外部使用必须用作用域符号才能得到 C++ enum Color { black, white, red }; auto white = false; # 错误，white 已经声明过了 enum class Color { black, white, red }; auto white = false; # 正确 auto a = Color::white; # 需要使用作用域符进行访问 并且enum class没有任何转化到其他类型的隐式转换(只能使用显式转换)，而enum可以隐式转换到int 这也就意味着，enum class类型的变量只能和自己类型的变量进行比较，不存在加减法，就和一个类变量没什么区别了 隐式转换在大部分都会出现问题，只有在和tuple一起使用的时候enum的隐式转换才有一定意义 C++ # 元组包括用户名称，用户的邮件地址和用户的数值 using UerInfo = std::tuple\u003cstd::string, std::string, std::size_t\u003e; # 枚举变量名与元组每个值的含义对应 enum UserInfoFields { uiName, uiEmail, uiValue }; UerInfo uInfo; # 避免记忆元组每个变量是什么含义，直接用 enum 变量隐式转换到 int 来解决 auto val = std::get\u003cuiName\u003e(uInfo); 编译器会选择一个整数型别作为枚举类型的底层型别，enum class默认是int，enum会根据枚举变量的值来确定性，所以enum class可以只做声明，先不定义内部的枚举变量，而enum要么需要定义内部的枚举变量，要么必须显式指定底层型别 C++ enum class Color; # 允许前置声明，默认底层类型为 int enum Color; # 不允许前置声明，必须指定类型 enum Color: std::uint32_t; # 指定底层类型为 uint32 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:10","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#10-限定作用域枚举类型"},{"categories":["notes"],"content":" 5.11 11. 删除函数给函数加上delete关键字，保证其无法被调用，这一般是禁止编译器为类生成拷贝构造函数和赋值运算符函数，比如对于流对象，不能进行拷贝和赋值，所有的流对象继承于basic_ios类 C++ template \u003cclass charT, class traits = char_traits\u003ccharT\u003e\u003e class basic_ios : public ios_base { public: basic_ios(const basic_ios \u0026) = delete; basic_ios\u0026 operator=(const basic_ios\u0026) = delete; } 删除函数访问等级一般设定为public，编译器会先校验函数可访问性，再判断是否为删除函数，这样可以确保delete特性得到表现 任何函数都可以是删除函数，包括普通函数和模板函数 对于一个普通函数，使用删除函数可以避免隐式转换导致出现预期的结果 C++ bool isLucky(int number); # 判断一个数字是不是幸运数字 # 但是 int 类型可以由非常多的类型隐式转换得到，比如 char,bool,float,double，这些调用就不符合预期了 # 为避免隐式转换出现，将这些类型作为形参的函数设定为删除函数 bool isLucky(char) = delete; bool isLucky(bool) = delete; bool isLucky(double) = delete; # 此时再使用 char,bool,double 调用此函数就会报错了 对于一个模板函数，使用删除函数可以阻止特定类型的模板被实例化 比如一个模板函数，需要一个指针类型参数，但是不希望传入一个void*或者char* C++ template \u003ctypename T\u003e void processPointer(T* ptr); template \u003c\u003e void processPointer\u003cvoid\u003e(void*) = delete; template \u003c\u003e void processPointer\u003cchar\u003e(char*) = delete; ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:11","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#11-删除函数"},{"categories":["notes"],"content":" 5.12 12. lambda 和 function 区别，内存大小(⭐)C++的 lambda 和 function 都是函数对象，它们可以在函数中定义并作为参数传递 lambda 表达式，使得开发人员可以在代码块中编写匿名函数。lambda 表达式通常被用来编写轻量级的回调函数或即席函数，以便将其传递到 STL 算法中。lambda 表达式可以“捕获”它们所在函数的变量，并且具有比函数对象更简单的语法 function 对象则是一个可调用对象封装，是一个通用的函数包装器，允许将任何可调用对象存储为单一、多态的函数类型(就是可以封装虚函数)并调用它们。function 对象可以存储于容器或在其他地方进行复制或传递 使用auto创建一个变量表示一个 lambda 表达式，一个 lambda 表达式是一个 lambda 类，可认为其重载了operator ()运算符，变成了可调用对象 其内存大小和捕捉的变量有关，每个捕捉的变量都会存储在这个 lambda 类中。值捕捉就是将这个变量值直接拷贝在类中，根据其在 lambda 出现的顺序依次拷贝在类中，所以会出现内存对齐，比如说char + short + int + long long大小为16，而char + int + short + long long大小为24；引用捕捉就是将这个变量的地址，也就是一个指针拷贝在类中，在 32 位系统中，一个指针占 4 个字节，所以大小为引用捕捉个数乘以 4 注意空类占 1 个字节，所以若 lambda 表达式没有捕捉任何变量，只使用了函数传入的参数，那么这个 lambda 类占 1 字节 lambda 表达式不能捕捉静态变量，但是可以使用静态变量，所以在 lambda 表达式中使用的任何静态变量均不计算内存大小 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:12","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#12-lambda-和-function-区别内存大小"},{"categories":["notes"],"content":" 5.13 13. C++ 如何实现 C# 多播委托机制(⭐)多播委托就是可以注册多个函数，然后调用一次委托，调用多个函数，可以直接使用函数指针或者函数对象来实现，其实两者的声明都可以看成是委托的一种声明，有返回类型和参数，只需要用一个数组存储函数指针或者函数对象即可 对于全局函数和成员函数，在绑定到函数对象或者函数指针时，有着不同的操作：全局函数的名称本身就是函数指针，可以直接传递进去；非静态成员函数不可以直接被类名访问到，所以需要一个类对象间接调用，可以使用lambda的方式 下面代码展示了实现多播委托的方式，分别添加了全局函数和成员函数 C++ #include \u003ciostream\u003e #include \u003cfunctional\u003e #include \u003cvector\u003e // 定义委托类型 typedef std::function\u003cvoid(const std::string\u0026)\u003e MyDelegate; // 委托的调用列表 std::vector\u003cMyDelegate\u003e delegates; // 添加委托函数到调用列表 void AddDelegate(const MyDelegate\u0026 delegate) { delegates.push_back(delegate); } // 调用所有委托函数 void InvokeDelegates(const std::string\u0026 message) { for (const auto\u0026 delegate : delegates) { delegate(message); } } // 全局函数作为委托调用对象 void GlobalFunction(const std::string\u0026 message) { std::cout \u003c\u003c \"Global Function: \" \u003c\u003c message \u003c\u003c std::endl; } // 类成员函数作为委托调用对象 class MyClass { public: void MemberFunction(const std::string\u0026 message) { std::cout \u003c\u003c \"Member Function: \" \u003c\u003c message \u003c\u003c std::endl; } }; int main() { // 添加全局函数和类成员函数到调用列表 AddDelegate(GlobalFunction); MyClass obj; AddDelegate([\u0026obj](const std::string\u0026 message) { obj.MemberFunction(message); }); // 调用所有委托函数 InvokeDelegates(\"Hello, World!\"); return 0; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:13","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#13-c-如何实现-c-多播委托机制"},{"categories":["notes"],"content":" 5.14 14. lambda 表达式的值捕捉和引用捕捉(⭐⭐) 值捕捉将在 lambda 表达式创建时外部局部变量的值复制到 lambda 对象内部，以保证在 lambda 对象被调用时，外部变量的值不会被修改，并且值捕捉的变量值是在定义 lambda 表达式时候的值决定的 引用捕捉则是使用外部局部变量的引用，在lambda表达式执行期间对外部变量进行修改时，也会影响到外部变量本身，并且引用捕捉的值是由调用 lambda 表达式时候的值决定的 注意，lambda 表达式捕捉的不包括静态变量，静态变量可以在里面使用，但是并没有捕捉这个静态变量，所以在外部修改静态变量，就会影响 lambda 表达式内部的实际值 C++ int main() { static int x = 2; auto f = [=] () { return x; }; x++; # 此时输出 3，外部修改这个静态变量会影响 lambda 内捕捉到的这个静态变量值 cout \u003c\u003c f() \u003c\u003c endl; return 0; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:14","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#14-lambda-表达式的值捕捉和引用捕捉"},{"categories":["notes"],"content":" 5.15 15. sizeof(⭐)sizeof用于求一个变量的大小，对于数组int nums[10]和指针int *p = nums，会输出数组的大小40和一个指针的大小4（假设在32位系统，64位是8），sizeof能通过变量的类型信息判断这个变量的大小，其实和反射时候的元数据差不多 编译器在分析源代码的过程中，会对每个变量、表达式、函数等进行语法和语义分析，并为其确定类型信息。编译器会根据变量的声明、赋值、函数调用等语句来推断变量的类型，并将这些类型信息保存在符号表中 在编译过程中，当遇到sizeof运算符时，编译器会根据运算符后面的表达式来查找符号表，获取相应的类型信息。根据类型信息，编译器可以计算出相应的大小 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:15","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#15-sizeof"},{"categories":["notes"],"content":" 5.16 16. typeid在C++中，typeid是一个运算符，用于获取对象的类型信息，typeid的实现是通过使用一种叫做类型信息结构（type_info）的机制来实现的。每个具体的类型在编译时都会生成一个唯一的type_info对象，用于表示该类型的信息 type_info对象通常包含了以下类型信息： 类型的名称 类型的大小 类型的对齐要求 在运行时，当使用typeid运算符获取对象的类型信息时，编译器会生成一段代码来检索该对象的type_info对象，并返回该对象的引用或指针 具体的实现细节可能因编译器和标准库的不同而有所差异。在某些实现中，type_info对象可能是一个全局变量，而在其他实现中，可能是一个虚表或其他数据结构的一部分 typeid运算符只能用于具有多态性（即至少有一个虚函数）的类型。对于非多态类型或非完整类型（如不完整的类声明或不完整的数组类型），使用typeid运算符会导致编译器错误 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:5:16","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#16-typeid"},{"categories":["notes"],"content":" 6 6. 左值右值，构造函数","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#6-左值右值构造函数"},{"categories":["notes"],"content":" 6.1 1. 什么是左值和右值，什么是右值引用，为什么要引入右值引用(⭐⭐) 左值就是具有可寻址的存储单元，并且能由用户改变其值的量，比如常见的变量。左值具有持久的状态，直到离开作用域才销毁；右值表示即将销毁的临时对象，具有短暂的状态，比如字面值常量，返回非引用类型的表达式等，会生成右值 右值引用就是必须绑定到右值的引用，右值引用只能绑定到即将销毁的对象，因此可以自由地移动其资源 右值引用是为了支持移动操作而引出的一个概念，它只能绑定到一个将要销毁的对象，使用右值引用的移动操作可以避免无谓的拷贝，提高性能。使用std::move()函数可以将一个左值转换为右值引用 补充：i++ 返回的是右值，返回递增前的值，而 ++i 返回的是左值，递增后再返回这个变量 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1--什么是左值和右值什么是右值引用为什么要引入右值引用"},{"categories":["notes"],"content":" 6.2 2. 为什么要自己定义拷贝构造函数，什么是深拷贝和浅拷贝 拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化当前对象时做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被delete掉，那么另一个类里面的指针就会变成空悬指针 这也正是深拷贝和浅拷贝的区别，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-为什么要自己定义拷贝构造函数什么是深拷贝和浅拷贝"},{"categories":["notes"],"content":" 6.3 3. 什么是移动构造函数，和拷贝构造函数的区别移动构造函数需要传递的参数是一个右值引用，移动构造函数不分配新内存，而是接管传递而来对象的内存，并在移动之后把源对象销毁 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-什么是移动构造函数和拷贝构造函数的区别"},{"categories":["notes"],"content":" 6.4 4. 什么情况下会调用拷贝构造函数类的对象需要拷⻉时，拷⻉构造函数将会被调⽤，以下的情况都会调⽤拷⻉构造函数： ⼀个对象以值传递的⽅式传⼊函数体，需要拷⻉构造函数创建⼀个临时对象压⼊到栈空间中 ⼀个对象以值传递的⽅式从函数返回，需要执⾏拷⻉构造函数创建⼀个临时对象作为返回值 ⼀个对象需要通过另外⼀个对象进⾏初始化 补充：函数返回值类型的临时变量，编译器会进行 RVO(Return Value Optimization) 优化，直接将这个临时变量构造在接受返回值的变量上，只进行了一次构造函数，省略了拷贝构造函数 RVO 发生有两个条件：局部对象的类型和函数返回值类型相同，返回的就是局部变量本身 如下面代码所示，先构造出对象a，输出一次INIT，然后再调用get函数获取一个类变量给c，此时只输出了一次INIT，所以只触发了一次构造，没有拷贝的过程 C++ class A { public: int val; A(int v): val(v) { cout \u003c\u003c \"INIT\" \u003c\u003c endl; } A(const A\u0026 a): val(a.val) { cout \u003c\u003c \"KK\" \u003c\u003c endl;} A(A\u0026\u0026 a): val(a.val) { cout \u003c\u003c \"YY\" \u003c\u003c endl;} A get() { return A(3); } }; int main() { A a(2); A c = a.get(); return 0; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:4","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-什么情况下会调用拷贝构造函数"},{"categories":["notes"],"content":" 6.5 5. 为什么拷贝构造函数的形参必须是引用类型，不能是值类型(⭐)为了防⽌递归调⽤。当⼀个对象需要以值⽅式进⾏传递时，编译器会⽣成代码调⽤它的拷⻉构造函数⽣成⼀个副本，如果类 A 的拷⻉构造函数的参数不是引⽤传递，⽽是采⽤值传递，那么就⼜需要为了创建传递给拷⻉构造函数的参数的临时对象，⽽⼜⼀次调⽤类 A 的拷⻉构造函数，这就是⼀个⽆限递归 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:5","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-为什么拷贝构造函数的形参必须是引用类型不能是值类型"},{"categories":["notes"],"content":" 6.6 6. 构造/析构函数可以抛出异常吗(⭐⭐)构造函数中可以抛出异常，但必须保证在构造函数抛出异常之前，把系统资源释放掉，防止内存泄露，可以使用智能指针构造对象来确保构造函数出现异常时会析构对象，或者使用函数try语句块，这不仅能处理构造函数还能处理析构函数 C++ template \u003ctypename T\u003e Bolb\u003cT\u003e::Blob(std::initializer_list\u003cT\u003e il) try: data(std::make_shared\u003cstd::vector\u003cT\u003e\u003e(il)) { # 执行初始化赋值操作 }catch(const std::bad_alloc \u0026e) { handle_out_of_memory(e); } 析构函数不能抛出异常，会导致析构函数未全部释放内存，从而出现内存泄漏 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:6","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#6-构造析构函数可以抛出异常吗"},{"categories":["notes"],"content":" 6.7 7. 完美转发，引用折叠(⭐)当函数模板参数为右值引用的时候，即使是一个左值也能绑定到右值上，这就是std::move函数能正常工作的基础 C++ template \u003ctypename T\u003e void f3(T\u0026\u0026); f3(i); # i 是一个int，此时 T = int\u0026 那么就出现了f3\u003cint\u0026\u003e(int\u0026 \u0026\u0026)的情况，此时会发生引用折叠，int\u0026 \u0026\u0026会被简化成int\u0026，有下面两种引用折叠： X\u0026 \u0026，X\u0026 \u0026\u0026，X\u0026\u0026 \u0026都被折叠成X\u0026，X\u0026\u0026 \u0026\u0026被折叠成X\u0026\u0026 总而言之，当型别推导和类型参数中有一个引用为左值引用，折叠后得到左值引用，否则得到右值引用 所以，当函数参数是一个指向模板参数类型参数的右值引用，比如T\u0026\u0026，则它可以绑定到一个左值，并且若实参是一个左值，则推断出的模板参数类型将为左值引用，发生引用折叠后变成一个普通的左值引用T\u0026 所以右值引用类型的模板参数称为万能引用，既可以传入左值也能传入右值，并且会保留传入参数的左值和右值特性 模板转发就是一些模板函数将一个或多个实参带类型原封不动的转发给别的函数，也就是在模板函数中调用其他函数 为了保持原始实参的类型可以被转发到其他函数，可以使用utility库中的forward函数，forward必须通过显式模板参数来调用，返回显示模板参数的右值引用，也就是forward\u003cT\u003e返回类型为T\u0026\u0026 比如下面的代码，实现里面完美转发 C++ template \u003ctypename F, typename T1, typename T2\u003e void flip(F f, T1 \u0026\u0026t1, T2 \u0026\u0026t2) { f(std::forward\u003cT1\u003e(t1), std::forward\u003cT2\u003e(t2)); } 因为有引用折叠的特点，传递进入一个左值，函数实参将发生引用折叠，得到一个左值引用，经过forward传递后，再通过引用折叠，得到的还是一个左值引用，所以传入的左值会保留左值引用的特性，传入的右值会保留右值引用的特性 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:7","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#7-完美转发引用折叠"},{"categories":["notes"],"content":" 6.8 8. move 和 forward标准库中，两个函数的实现为 C++ template \u003ctypename T\u003e typename std::remove_reference\u003cT\u003e::type\u0026\u0026 move(T\u0026\u0026 arg) noexcept { return static_cast\u003ctypename std::remove_reference\u003cT\u003e::type\u0026\u0026\u003e(arg); } template \u003ctypename T\u003e T\u0026\u0026 forward(typename std::remove_reference\u003cT\u003e::type\u0026 arg) noexcept { return static_cast\u003cT\u0026\u0026\u003e(arg); } 当形参类别为右值引用，证明该绑定的对象可以移动，所以需要使用move对其进行操作以优化性能 C++ class Widget { public: Widget(Widget\u0026\u0026 rhs): name(std::move(rhs.name)), p(std::move(rhs.p)) {} private: std::string name; srd::shared_ptr\u003cint\u003e p; } 当形参类别为万能引用，他实际上可能是左值，也可能是右值，所以需要forward对其进行操作 万能引用的前提：必须是T\u0026\u0026的形式，这个T必须是进行推导的模板参数，不允许加上const C++ class Widget { public: template\u003ctypename T\u003e void setName(T\u0026\u0026 newName) { name = std::forward\u003cT\u003e(newName); } } 在值返回的函数中，若返回的对象是一个绑定到右值引用或者万能引用的对象，在返回这个值的时候，应该使用move或者forward对其进行操作 比如一个实现矩阵加法的函数，位于运算符左侧的矩阵已知是一个右值(因此其存储空间可以复用，来保存矩阵的和) 使用move之后，lhs会被移入函数返回值存储的位置，避免了拷贝，否则直接返回return lhs会发生一次拷贝 C++ Matrix operator+(Matrix\u0026\u0026 lhs, const Matrix\u0026 rhs) { lhs += rhs; return std::move(lhs); } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:8","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#8-move-和-forward"},{"categories":["notes"],"content":" 6.9 9. 编译器默认生成的特种函数(⭐)类的特种函数是指六个函数：默认构造函数、析构函数、拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符 类的设计有一个三大律的原则，也就是声明了拷贝构造函数、拷贝赋值运算符和析构函数的任意一者，那就应该把另外两者也进行声明，因为声明了其中一个函数，都说明类存在资源管理情况，最常见的就是有动态内存，所以这三个函数的默认行为对于动态内存的处理都不得当，应该手动实现 类会自动生成这六大特种函数的情况如下： 默认构造函数：当类内不包含任何构造函数(包括普通构造、拷贝构造和移动构造)的时候才会自动生成 析构函数：当类内不包含任何析构函数的时候会自动生成，仅当基类的析构函数为虚函数，派生类的析构函数才是虚函数 拷贝构造函数：当类内不包含声明的拷贝构造函数时会自动生成，但当声明了移动操作，则会隐式删除此函数 拷贝赋值运算符：当类内不包含声明的拷贝赋值运算符时会自动生成，但当声明了移动操作，则会隐式删除此函数 移动构造函数和移动赋值函数：仅当类内不包含声明的拷贝操作，移动操作和析构函数时才会自动生成 有一个细节，当类中有常量或引用成员，就不会自动生成拷贝赋值运算符 但是若类内声明了成员模板函数实现了构造函数等功能，编译器仍然会生成默认的特种函数，比如 C++ class Widget { template\u003ctypename T\u003e Widget(const T\u0026 rhs); # 以任意类型构造Widget template\u003ctypename T\u003e Widget\u0026 operator = (const T\u0026 rhs); # 以任意类型对Widget赋值 }; 编译器会始终生成Widget类的拷贝和移动操作，即使这些模板函数的实例化实现了拷贝构造函数和拷贝赋值运算符的功能 由于基类是否包含拷贝和移动操作会对派生类的拷贝和移动产生影响，所以基类可以显式的将所有特种函数写出来，并使用default指定编译器生成默认行为 C++ class Base { public: virtual ~Base() = default; Base(const Base\u0026) = default; Base\u0026 operator = (const Base\u0026) = default; Base(Base \u0026\u0026) = default; Base\u0026 operator = (Base\u0026\u0026) = default; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:6:9","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#9-编译器默认生成的特种函数"},{"categories":["notes"],"content":" 7 7. 内联函数与宏","date":"2023-11-07","objectID":"/cpp_interview.zh/:7:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#7-内联函数与宏"},{"categories":["notes"],"content":" 7.1 1. 内联函数有什么作用，存不存在什么缺点(⭐⭐) 作用是使编译器在函数调用点上展开函数，可以避免函数调用的开销 内联函数的缺点是可能造成代码膨胀，尤其是递归的函数，会造成大量内存开销。内联函数难以调试，每次修改会重新编译头文件，增加编译时间 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:7:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-内联函数有什么作用存不存在什么缺点"},{"categories":["notes"],"content":" 7.2 2. 什么时候不能实现内联(⭐)虚函数，函数体积过大，有递归(递归是在运行期间才知道执行多少次的，内联发生在编译期间，自然不知道展开多少次) 有可变数目参数，通过函数指针调用，调用者异常类型不同 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:7:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-什么时候不能实现内联"},{"categories":["notes"],"content":" 7.3 3. define 和 const 有什么区别(⭐⭐) 定义不同：define 是C++预处理器的指令，用于定义宏；const是C++关键字，用于定义常量 作用对象不同：define 定义的宏，可以是函数，对象，类型；const 只能定义常量 编译器处理时间不同：define 会在预处理阶段展开； const 常量会以在编译期进行分析和处理 类型和安全检查不同：define 没有任何类型检查，仅仅是代码展开；const 常量有具体类型，编译器会进行类型检查 存储方式不同：define 在预处理阶段直接进行代码展开，存储在程序的代码段中； const 常量会分配内存，存储在程序的数据段中 作用域规则不同：define 宏不存在作用域规则，直到遇到 undef 时，才会失效； const 常量存在作用域规则 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:7:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3--define-和-const-有什么区别"},{"categories":["notes"],"content":" 8 8. STL","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#8-stl"},{"categories":["notes"],"content":" 8.1 1. STL各种容器的底层实现(⭐⭐⭐) vector，底层是一块具有连续内存的数组，vector的核心在于其长度自动可变。vector的数据结构主要由三个迭代器(指针)来完成：指向首元素的start，指向尾元素的finish和指向内存末端的end_of_storage。vector的扩容机制是：当目前可用的空间不足时，分配目前空间的两倍或者目前空间加上所需的新空间大小（取较大值），容量的扩张必须经过“重新配置、元素移动、释放原空间”等过程 list，底层是一个循环双向链表，链表结点和链表分开独立定义的，结点包含pre、next指针和data数据 deque，双向队列，由分段连续空间构成，每段连续空间是一个固定的大小的缓冲区(数组)，由一个中控器来控制。它必须维护一个中控器指针，还要维护start和finish两个迭代器，分别指向第一个缓冲区，和最后一个缓冲区。deque可以在前端或后端进行扩容，这些指针和迭代器用来控制分段缓冲区之间的跳转 stack和queue，栈和队列。它们都是由deque作为底层容器实现的，他们是一种容器配接器，修改了deque的接口，具有自己独特的性质（此二者也可以用list作为底层实现）；stack是deque封住了头端的开口，先进后出，queue是deque封住了尾端的开口，先进先出 priority_queue，优先队列。是由以vector作为底层容器，以heap作为处理规则，heap的本质是一个完全二叉树 set和map，底层都是由红黑树实现的。红黑树是一种二叉搜索树，但是它多了一个颜色的属性。红黑树的性质如下：1）每个结点非红即黑；2）根节点是黑的；3）如果一个结点是红色的，那么它的子节点就是黑色的；4）任一结点到树尾端（NULL）的路径上含有的黑色结点个数必须相同。通过以上定义的限制，红黑树确保没有一条路径会比其他路径多出两倍以上；因此，红黑树是一种弱平衡二叉树，相对于严格要求平衡的平衡二叉树来说，它的旋转次数少，所以对于插入、删除操作较多的情况下，通常使用红黑树 补充：平衡二叉树(AVL)和红黑树的区别：AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的 rebalance（旋转操作），导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-stl各种容器的底层实现"},{"categories":["notes"],"content":" 8.2 2. STL怎么做内存管理的，Allocator次级分配器的原理，内存池的优势和劣势(⭐⭐) 为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，STL 采用了两级配置器，当分配的空间大小超过128byte 时，会使用第一级空间配置器，直接使用malloc(), realloc(), free()函数进行内存空间的分配和释放。当分配的空间大小小于 128byte 时，将使用第二级空间配置器，采用了内存池技术，通过自由链表来管理内存 二级配置器的内存池管理技术：每次配置一大块内存，并维护对应的自由链表。配置器共要维护 16 个自由链表，存放在一个数组里，分别管理大小为 8 - 128byte 不等的内存块。分配空间的时候，首先根据所需空间的大小（调整为 8byte 的倍数）找到对应的自由链表中相应大小的链表，并从链表中取出第一个可用的区块；回收的时候也是一样的步骤，先找到对应的自由链表，并插到第一个区块的位置 优点：避免外部内存碎片，不需要频繁从用户态切换到内核态，性能高效 缺点：仍然会造成一定的内存浪费，会产生内部碎片，比如申请 120byte 就必须分配 128byte ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-stl怎么做内存管理的allocator次级分配器的原理内存池的优势和劣势"},{"categories":["notes"],"content":" 8.3 3. STL 容器的 push_back 和 emplace_back 的区别 push_back实现插入元素，是先创建一个临时变量(一次构造函数)，再将这个临时对象移动(调用移动构造函数)或者拷贝(当无法移动时，调用拷贝构造函数，并且拷贝完会销毁这个临时变量)到vector后面 emplace_back实现插入元素，则直接在vector尾部的空间创建这个元素，只调用一次构造函数 但当添加的元素已经是构造好的，比如直接添加一个类对象，那么这两个都只会调用一次拷贝构造函数，性能相同 总而言之，emplace_back在以下三种情况下，能得到比push_back更好的性能： 待添加的值是以构造而非赋值的方式加入容器(即传递了一个临时变量，直接在容器的内存上构造，从而减少了构造和析构的成本) 传递的实参型别与容器持有之物的型别不同(即传入的是构造函数参数时，不需要创建和析构临时对象) 容器不会因为存在重复值而拒绝添加此值(也就是除了map, unordered_map, set, unordered_set以外的容器都行) ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-stl-容器的-push_back-和-emplace_back-的区别"},{"categories":["notes"],"content":" 8.4 4. STL 容器的 reserve 和 resize 区别(⭐⭐)这两个函数只适用于vector, string reserve(n)只实现分配内存，并不创建对象，如果要求的内存大于当前容量capacity，则会重新分配内存，然后移动元素，释放之前的元素；当需求的内存小于等于当前容量，则啥事情也不会发生，永远不会减少内存空间 resize(n, t)可以将容器大小改变成n，新添的元素初始化为t，对于类类型，这个t要么是已有的类变量，要么显式调用构造函数，若当前长度大于n，就会删去多的元素，并释放内存 对于一个空的vector，使用reserve(10)只会改变capacity = 10，不改变size；但使用resize(10)不仅会改变capacity = 10，还会填充元素，使得size = 10 还有一个shrink_to_fit(n)，适用于vector, string, deque，请求将capacity减小到和size相同，从而退回不需要的内存空间，但是具体会不会释放空间也不确定，可能会忽略这个请求 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:4","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-stl-容器的-reserve-和-resize-区别"},{"categories":["notes"],"content":" 8.5 5. STL 容器中的迭代器作用，与指针的区别迭代器⽤于提供⼀种⽅法顺序访问⼀个聚合对象中各个元素, ⽽⼜不需暴露该对象的内部表示 迭代器不是指针，是类模板，表现的像指针。迭代器封装了指针，重载了指针的⼀些操作符，提供了⽐指针更⾼级的⾏为，可以根据不同类型的数据结构来实现不同的递增递减等操作。迭代器返回的是对象引⽤⽽不是对象的值 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:5","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-stl-容器中的迭代器作用与指针的区别"},{"categories":["notes"],"content":" 8.6 6. STL 容器调用 insert，erase 后哪些迭代器会失效 容器底层数据结构类型 具体容器 insert后 erase后 数组类型 vector, string, deque, array 若未重新分配内存，插入点之后的所有迭代器失效；若重新分配内存，所有迭代器失效 删除节点之后的所有迭代器失效 链表类型 list, forward_list 不会使得任何迭代器失效 指向删除节点的迭代器失效 树状类型 map, set, multimap, multiset 不会使得任何迭代器失效 指向删除节点的迭代器失效 哈希表类型 unordered_map, unordered_set, ... 不会使得任何迭代器失效 指向删除节点的迭代器失效 所以在可能出现insert, erase，或者push_back, pop_back等删改元素个数的操作中，begin, end迭代器一定要每次循环重新获得，不能用变量预存这两个迭代器，尤其是end迭代器，基本都会失效 insert会返回插入点的迭代器，erase会返回删除点下一个元素的迭代器，所以想在循环中用迭代器遍历，且添加删除元素，一定要用函数的返回值更新迭代器，比如 C++ unordered_map\u003cint, int\u003e hash; # 假设添加了一些元素后进行遍历 # 一定要手动更新迭代器的位置, 不能依赖于循环 for(auto it = hash.begin(); it != hash.end(); ) { # 一定要获取新的迭代器, 删除之前的 it 已经失效了 if(it-\u003esecond == 0) it = hash.erase(it); else ++it; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:6","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#6-stl-容器调用-inserterase-后哪些迭代器会失效"},{"categories":["notes"],"content":" 8.7 7. string 的内存大小string的实现有很多版本，string对象大小范围可能是char*指针大小的 1 倍到 7 倍，详见《Effective STL》第 15 条 一个常见的实现是指针大小的四倍，每个string对象包括四项内容，第一项是其分配器allocator的一份拷贝，第二项是字符串的大小，第三项是字符串的容量，第四项是一个指针，该指针指向一个动态分配的内存，包括一个引用计数和字符串的值 另一种实现的大小和指针相同，每个string对象只包含了一个指针，指向一个动态内存，动态内存包含与string的一切数据：大小、容量、引用计数和值 引用计数使得一个string对象被拷贝或复制时，只有指向同一字符串的引用计数被增加，而不是整个字符串被复制；并且string实现中使用了写时复制，即只有当一个string对象被修改时才发生复制，避免了不必要的内存分配和复制 并不是所有的string实现都使用了引用计数，可以使用预处理宏关闭引用计数 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:7","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#7-string-的内存大小"},{"categories":["notes"],"content":" 8.8 8. STL 的线程安全问题 线程安全的情况：多个读取者是安全的，多线程可能同时读取一个容器的内容，这将正确地执行；当然，在读取时不能有任何写入者操作这个容器。对不同容器的多个写入者是安全的，多线程可以同时写不同的容器 线程不安全的情况：对同一个容器进行多线程的读写、写操作。在每次调用容器的成员函数期间都要锁定该容器。在每个容器返回的迭代器的生存期之内都要锁定该容器。在每个在容器上调用的算法执行期间锁定该容器 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:8","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#8-stl-的线程安全问题"},{"categories":["notes"],"content":" 8.9 9. STL 的 sort 有哪些排序算法(⭐) 若数据长度较小(小于等于16)，就会使用插入排序 若递归深度过大(里面有个专门计算递归深度的函数)，则使用堆排序 其他情况下使用快速排序 优先使用快速排序，是因为：快速排序是顺序访问数据的，而堆排序是跳着访问的，影响缓存命中率；对于同样的数据，堆排序所需要的交换次数大于快速排序，快速排序的交换次数不会比逆序数多 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:9","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#9-stl-的-sort-有哪些排序算法"},{"categories":["notes"],"content":" 8.10 10. 基于比较的排序算法的最低复杂度为什么是 NlgN排序算法的最低时间复杂度为O(NlgN)是由于排序算法中最常用的比较排序的性质决定的。比较排序的基本思想是通过比较两个记录大小来确定它们在序列中的相对位置，所以其时间复杂度与比较次数有关。一般情况下，一个排序算法都需要进行O(NlgN)次比较才能完成对含有N个数据元素的数据序列进行排序，可以通过决策树模型来证明 决策树模型是一种描述在最坏情况下排序算法执行次数的方法。每一次比较都可以看作是树上的一个节点。如果有 N 个待排序的数据元素，那么它们共有N!种排列组合（即叶子结点数量）。由于每一次比较将会减少数据元素的可交换状态，因此我们可以假设该判定树是一棵二叉树，按照二叉树的结构分布各个叶节点。同时，由于一棵深度为h的二叉树最多拥有2 ^ h个叶节点，所以得到N! ≤ 2 ^ h，即h ≥ logN!，进而证明决策树的最低深度下限为logN! ≈ NlogN 因此，基于比较的排序算法的最低时间复杂度为O(NlgN) ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:10","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#10-基于比较的排序算法的最低复杂度为什么是-nlgn"},{"categories":["notes"],"content":" 8.11 11. vector 扩容(⭐)vector在尾部插入一个元素，最优复杂度为O(1)，最坏复杂度为O(N)，平均复杂度是O(1)，考虑下面的情况 假设有n个元素插入vector，倍增因子为m，那么会触发$log_m^n$次的扩容，每次扩容需要拷贝所有元素，所以n次插入的总操作次数为 $$ \\large \\begin{align} n+\\sum_{i=1}^{log_m^n}m^i\u0026=n+m+m^2+...+m^{log_m^n} \\\\ \u0026=n+\\frac{m(1-m^{log_m^n})}{1-m} \\\\ \u0026=n+\\frac{m(n-1)}{m-1} \\\\ \u0026\\approx n + \\frac{mn}{m-1} \\end{align} $$ 所以，均摊下来每次操作时间为$O((n+\\frac{mn}{m-1})/n)=O(\\frac{m}{m-1})$，这是一个常数，因此平均复杂度为O(1) 在扩容的时候，要对元素进行拷贝，如果这个元素的类型定义了移动操作，并且该移动操作承诺不抛出异常noexpect，vector扩容时候就会使用移动操作而非拷贝操作 noexcept通常使用在移动构造，移动赋值和swap这些函数中 noexcept不能随便使用，若一个声明noexcept的函数抛出异常，会直接终止进程，调用std::terminate() 不应该过早的给函数加上noexcept，否则调用此函数的调用方也会声明成noexcept，如果后面把该函数的noexcept去掉，却不修改调用方的代码，就会导致异常抛出到调用方时直接终止进程 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:8:11","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#11-vector-扩容"},{"categories":["notes"],"content":" 9 9. 泛型与多线程","date":"2023-11-07","objectID":"/cpp_interview.zh/:9:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#9-泛型与多线程"},{"categories":["notes"],"content":" 9.1 1. 为什么模板函数的定义和实现要放在一个程序文件中当主函数调用了模板函数，就会发生实例化，模板函数的实例化是在编译阶段完成的，若在编译阶段找不到模板函数的实现，就无法实例化(假如和普通函数一样，定义写在.h文件中，实现写在.cpp文件中，.h文件不会#include这个.cpp文件，所以.h文件就找不到这个模板函数的定义) 而非模板函数是在链接阶段处理的，此时所有文件被整合在一起，所以就没有了找不到实现的问题了 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:9:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-为什么模板函数的定义和实现要放在一个程序文件中"},{"categories":["notes"],"content":" 9.2 2. 原子 atomic(⭐⭐)C++ 的atomic是一种线程安全的特殊数据类型，用于实现多线程编程中的原子操作。它可以保证对一个共享变量的读写操作在不同线程之间具有原子性，即不会出现因多线程的交互带来的数据竞争、死锁等问题。C++11 标准引入了\u003catomic\u003e头文件，并增加了一组atomic库函数和模板，使得在 C++ 中实现并发编程变得更加容易 atomic类型提供了一些原子操作函数，通过这些原子操作函数可以对共享变量进行原子操作，同时保证各个线程对于共享变量的访问操作的互斥性。通常情况下，使用atomic会比使用mutex和lock_guard等同步机制更加高效，因为它们不需要进行上下文切换和线程阻塞操作 但是原子操作只是保证多线程读写的原子性，不能保证指令不会重排，必须对原子变量进行原子操作，才能保证操作的指令不会重排，比如下面的例子 C++ std::atomic\u003cbool\u003e flag1(false); std::atomic\u003cbool\u003e flag2(false); // thread1 执行 void setFlags() { // 使用原子操作，保证了 flag1,flag2 赋值顺序不会被重排 // 若直接写 flag1 = true, flag2 = true，那可能会指令重排 flag1.store(true, std::memory_order_relaxed); flag2.store(true, std::memory_order_relaxed); } // thread2 执行 void readFlags() { // 此时 flag1 必然在 flag2 前赋值，所以 flag2 值必然是 true if(flag1 == true) cout \u003c\u003c flag2 \u003c\u003c endl; } 也可以给变量加上volatile避免指令重排，但是不能解决多线程对同一变量的读写一致性问题 mutex用于加锁，通过lock, unlock解决线程安全问题 C++ #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cmutex\u003e std::mutex mtx; // 全局互斥锁 void printMessage(const std::string\u0026 message) { mtx.lock(); // 加锁 for (int i = 0; i \u003c 5; ++i) { std::cout \u003c\u003c message \u003c\u003c std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(500)); // 暂停一段时间 } mtx.unlock(); // 解锁 } int main() { std::thread t1(printMessage, \"Thread 1\"); std::thread t2(printMessage, \"Thread 2\"); t1.join(); t2.join(); return 0; } 由于在加锁解锁过程中，可能出现异常，那么mutex.unlock()有可能就不会被执行出现死锁，使用lock_guard可以通过RAII的方式管理锁，实现自动的加锁和解锁，避免了异常出现时导致的死锁情况 C++ #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cmutex\u003e // 全局互斥锁 std::mutex mtx; void printMessage(const std::string\u0026 message) { // 使用lock_guard自动管理互斥锁 std::lock_guard\u003cstd::mutex\u003e lock(mtx); for (int i = 0; i \u003c 5; ++i) { std::cout \u003c\u003c message \u003c\u003c std::endl; // 暂停一段时间 std::this_thread::sleep_for(std::chrono::milliseconds(500)); } } int main() { std::thread t1(printMessage, \"Thread 1\"); std::thread t2(printMessage, \"Thread 2\"); t1.join(); t2.join(); return 0; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:9:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-原子-atomic"},{"categories":["notes"],"content":" 9.3 3. 模板的特例化在某些情况下，通用模板的定义对一些特定类型是不适用的，此时需要写特定类型的模板，可以特例化函数模板和类模板 当特例化一个函数模板的时候，必须为原模板的每一个模板参数提供实参，为了强调这个是模板函数，虽然没有了模板参数类型，但是还应该在前面写上template\u003c\u003e，这就是全特例化 C++ template \u003c\u003e int compare(const char* const \u0026p1, const char* const \u0026p2) { return strcmp(p1, p2); } 与函数模板不同，类模板特例化不必为所有模板参数提供实参(注意和全特例化区别，仍然有尖括号的类型参数)， 这种称为部分特例化，也可以只特例化类的成员函数 C++ template \u003c\u003e void Foo\u003cint\u003e::Bar() { # 定义实例化函数 } 重载模板和特例化模板并不相同，重载会影响函数匹配，编译器在匹配过程中，将重载版本作为候选之一来选择最佳匹配函数，但是特例化不影响函数匹配，并没有给编译器在函数匹配中多一个选择，而是为模板的一个特殊实例提供不同于原模板的特殊定义 下面代码展现了函数模板，函数模板全特例化和偏特例化 C++ #include \u003ciostream\u003e // 函数模板 template \u003ctypename T\u003e void print(const T\u0026 value) { std::cout \u003c\u003c \"General template: \" \u003c\u003c value \u003c\u003c std::endl; } // 函数模板的全特例化 template \u003c\u003e void print\u003cint\u003e(const int\u0026 value) { std::cout \u003c\u003c \"Specialization for int: \" \u003c\u003c value \u003c\u003c std::endl; } // 函数模板的偏特例化 template \u003ctypename T\u003e void print\u003cT*\u003e(T* value) { std::cout \u003c\u003c \"Partial specialization for pointer: \" \u003c\u003c *value \u003c\u003c std::endl; } int main() { int num = 10; int* ptr = \u0026num; print(\"Hello\"); // 调用通用模板 print(3.14); // 调用通用模板 print(num); // 调用全特例化模板 print(ptr); // 调用偏特例化模板 return 0; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:9:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-模板的特例化"},{"categories":["notes"],"content":" 9.4 3. 元编程为了实现运行高性能，元编程将运行期间的消耗转移到编译期，下面代码用模板实现计算斐波那契数列 C++ template\u003cint N\u003e struct Fibonacci { static constexpr int value = Fibonacci\u003cN-1\u003e::value + Fibonacci\u003cN-2\u003e::value; }; template\u003c\u003e struct Fibonacci\u003c0\u003e { static constexpr int value = 0; }; template\u003c\u003e struct Fibonacci\u003c1\u003e { static constexpr int value = 1; }; int main() { constexpr int n = 10; int result = Fibonacci\u003cn\u003e::value; std::cout \u003c\u003c \"Fibonacci(\" \u003c\u003c n \u003c\u003c \") = \" \u003c\u003c result \u003c\u003c std::endl; return 0; } ","date":"2023-11-07","objectID":"/cpp_interview.zh/:9:4","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-元编程"},{"categories":["notes"],"content":" 9.5 4. move 和 forward(⭐)两个函数用于在泛型中传播参数，其中move用于传递右值对象，forward用于传递万能引用对象 这两个函数都用到了remove_reference，这是一个模板类，其中用typedef定义了别名，如下所示 C++ template\u003ctypename _Tp\u003e struct remove_reference { typedef _Tp type; }; // 左值引用版本 template\u003ctypename _Tp\u003e struct remove_reference\u003c_Tp\u0026\u003e { typedef _Tp type; }; // 右值引用版本 template\u003ctypename _Tp\u003e struct remove_reference\u003c_Tp\u0026\u0026\u003e { typedef _Tp type; }; 可见，不论传入的是什么类型，type均为该变量最原始的类型，去除了一切引用 move函数将传入的参数强制转换成右值类型，然后返回该参数类型的右值引用类型 C++ template \u003ctypename T\u003e typename std::remove_reference\u003cT\u003e::type\u0026\u0026 move(T\u0026\u0026 arg) noexcept { return static_cast\u003ctypename std::remove_reference\u003cT\u003e::type\u0026\u0026\u003e(arg); } forward函数分为两种，一种是左值版本，一种是右值版本 C++ template \u003ctypename T\u003e T\u0026\u0026 forward(typename std::remove_reference\u003cT\u003e::type\u0026 arg) noexcept { return static_cast\u003cT\u0026\u0026\u003e(arg); } template \u003ctypename T\u003e T\u0026\u0026 forward(typename std::remove_reference\u003cT\u003e::type\u0026\u0026 arg) noexcept { static_assert(!std::is_lvalue_reference\u003cT\u003e::value, \"Invalid rvalue reference\"); return static_cast\u003cT\u0026\u0026\u003e(arg); } 注意传入的参数类型，对于左值版本，类型为type\u0026，对于右值版本，类型为type\u0026\u0026，并且在右值版本中，增加了静态断言static_assert，当不是左值时候，也就是右值时候，才能调用该函数 在调用std::move时，只需要将变量传入即可，比如std::move(arg)，但是调用std::forward时候，必须传入变量类型，比如std::forward\u003cT\u003e(arg)，这是因为两个函数实现不同 move的参数就是一个万能引用，不论传入左值右值都可以，forward中参数的引用类型其实是泛型类型T的一部分，不能直接通过模板推导得到，注意typename std::remove_reference\u003cT\u003e::type\u0026\u0026并不是万能引用，只有T\u0026\u0026才是 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:9:5","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-move-和-forward"},{"categories":["notes"],"content":" 9.6 5. 类型萃取 Type TraitsC++的类型萃取（Type Traits）是一种编程技术，用于在编译时获取与类型相关的信息。它可以通过模板元编程技术来检查和操作类型的特性，以便在编译时进行类型安全的操作 类型萃取可以用于以下情况： 1.类型判断：可以通过类型萃取来判断一个类型是否具有某些特性，例如判断一个类型是否是指针类型、是否是整数类型等 2.类型转换：可以使用类型萃取来进行类型转换，例如将一个类型转换为另一个类型，或者将一个类型转换为相应的指针类型 3.类型属性查询：可以通过类型萃取来查询一个类型的属性，例如查询一个类型的大小、对齐方式等 比如判断一个类是否继承了另一个类，可以通过std::is_base_of\u003cBase, Derived\u003e::value这个值，如果为true则是有直接继承关系，间接继承需要使用std::is_convertible ","date":"2023-11-07","objectID":"/cpp_interview.zh/:9:6","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-类型萃取-type-traits"},{"categories":["notes"],"content":" 9.7 6. 多线程 join 和 detach在 C++ 中，线程的join和detach是用于管理线程的两种方法 join: 当一个线程调用join方法时，它会等待被调用的线程执行完毕，然后再继续执行。换句话说，调用join的线程会阻塞直到被调用的线程完成。这样可以确保在主线程退出之前，所有的子线程都已经执行完毕。在调用join之后，被调用的线程的资源会被回收，包括线程的堆栈和线程控制块 detach: 当一个线程调用detach方法时，它会将被调用的线程分离，使得该线程可以独立运行，与调用detach的线程无关。被调用的线程在运行结束后会自动释放资源，而不需要等待调用detach的线程。这意味着调用detach之后，你不能再通过join来等待被调用的线程执行完毕 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:9:7","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#6-多线程-join-和-detach"},{"categories":["notes"],"content":" 10 10. 工程问题","date":"2023-11-07","objectID":"/cpp_interview.zh/:10:0","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#10-工程问题"},{"categories":["notes"],"content":" 10.1 1. 编译链接原理，从 C++ 源文件到可执行文件的过程(⭐⭐⭐)包括四个阶段：预处理阶段、编译阶段、汇编阶段、连接阶段 预处理阶段处理头文件包含关系，对预编译命令进行替换，生成预编译文件； 编译阶段将预编译文件编译，生成汇编文件 汇编阶段将汇编文件转换成机器码，生成可重定位目标文件（.obj文件） 链接阶段，将多个目标文件和所需要的库连接成可执行文件（.exe文件） ","date":"2023-11-07","objectID":"/cpp_interview.zh/:10:1","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#1-编译链接原理从-c-源文件到可执行文件的过程"},{"categories":["notes"],"content":" 10.2 2. 在 main 函数之前，程序进行了哪些操作 设置栈指针：为栈分配位置，用来放一些局部变量和其他数据 初始化静态和全局变量：把全局和静态变量初始化，放入全局/静态存储区 将未初始化的全局变量赋初值：将未设置初值的值类型全局变量赋初值(注意这是赋初值，和初始化不同)，将全局的类类型变量调用默认构造函数(没有默认构造函数就会报错) main函数传入参数：传入argc和argv，分别表示main函数的参数和参数内容 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:10:2","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#2-在-main-函数之前程序进行了哪些操作"},{"categories":["notes"],"content":" 10.3 3. 写个函数，在 main 函数之前会执行1.使用 gcc 扩展，在函数前加上__attribute((constructor))，标记该函数在main前执行 2.全局静态变量初始化和赋值在main函数前执行，只要让该变量的赋值为一个函数返回值即可 3.在main函数前写一个lambda表达式，让一个全局变量的值为这个表达式的返回值 C++ __attribute((constructor))void before() { printf(\"before main 1\\n\"); } int test1() { cout \u003c\u003c \"before main 2\" \u003c\u003c endl; return 1; } static int i = test1(); int a = []() { cout \u003c\u003c \"before main 3\" \u003c\u003c endl; return 0; }(); ","date":"2023-11-07","objectID":"/cpp_interview.zh/:10:3","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#3-写个函数在-main-函数之前会执行"},{"categories":["notes"],"content":" 10.4 4. 动态库和静态库含义，区别和优缺点(⭐⭐⭐)库是写好的现有的，成熟的，可以复用的代码。库有两种：静态库.lib和动态库.dll。所谓静态、动态是指链接阶段采用静态链接还是动态链接 静态库，是因为在链接阶段，会将汇编生成的目标文件与引用到的库一起链接打包到可执行文件中，这种链接方式称为静态链接。一个静态库可以简单看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件 静态库的优点： 库加载的速度很快 程序在运行时则不再需要该静态库，移植方便 静态库的缺点： 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件 一旦静态库发生改变，全部文件都要重新编译(因为静态库结合到了可执行文件中) 一旦有多个程序都包含这个静态库，那就会出现静态库的多份拷贝，十分浪费内存 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题 动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新 动态库的优点： 动态库把对一些库函数的链接载入推迟到程序运行的时期 节省内存，多个程序、进程使用一个动态库（因此动态库也称为共享库） 用户只要更新动态库，无需像静态库更新时候要重编译全部文件 动态库的缺点： 发布程序时，需要将动态库提供给用户，因为程序运行时需要动态库的存在 动态库没有被打包到应用程序中，加载速度相对较慢 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:10:4","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#4-动态库和静态库含义区别和优缺点"},{"categories":["notes"],"content":" 10.5 5. 函数调用的过程(⭐⭐)函数调用分为：函数参数传递，保存现场、函数栈帧开辟、函数执行、返回值传递、函数栈帧回退、恢复现场 1.函数参数传递：在调用函数时，需要向函数传递参数 2.保存现场：在调用函数前，需要将当前函数的现场保存起来，以备后续返回到该函数时能够继续执行。现场包括当前函数中需要用到的所有寄存器以及其他资源（如栈帧等） 3.函数栈帧开辟：当函数被调用时，CPU 会将函数的返回地址、参数等信息压入栈中 4.函数执行：在函数体内，按照函数定义的顺序执行函数内的语句 5.返回值传递：当函数执行完毕后，需要将结果返回给调用函数。在调用函数时，函数返回值一般通过寄存器或栈来传递 6.函数栈帧回退：将当前函数开辟的栈帧释放掉 7.恢复现场：在返回函数之前，需要先将之前保存的现场信息恢复，以保证程序的正常执行 比如以下代码 C++ int fun1(int a, int b) { int c = a + b; return c; } int main() { int a = fun1(10, 20); return 0; } 首先知道ebp为栈底寄存器，esp为栈顶寄存器，push为压入操作，在栈顶存放数据，栈顶寄存器esp上移 在未调用函数前，main的栈顶和栈底如下 然后进行函数代入 将函数参数代入，压入栈，参数在main函数的栈顶之上 接着开辟fun函数的栈帧 重新设置了栈顶和栈底，并保存了main函数的栈底 然后函数执行完成，函数返回值，将寄存器的值写入接受返回值的常量 最后将fun的栈顶esp指向fun的栈底ebp 再将栈顶esp移动8位，消除函数调用的参数，实现函数栈帧回退，回到main的栈帧 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:10:5","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#5-函数调用的过程"},{"categories":["notes"],"content":" 10.6 6. .exe文件包含哪些信息(⭐⭐) 机器码（Machine Code）：.exe 文件包含了可执行程序的机器码，即计算机可以直接执行的二进制指令。这些指令由编译器将源代码编译生成，并且按照特定的格式和结构组织 数据段（Data Segment）：.exe 文件中还包含了程序所需的静态数据（如全局变量、静态变量等）和常量数据。这些数据在程序执行期间是不可修改的 代码段（Code Segment）：.exe 文件中还包含了程序的代码段，即程序的指令序列。代码段包含了程序的函数、方法、过程等，以及它们的入口点和执行顺序 资源（Resources）：.exe 文件可能还包含了程序所需的附加资源，如图标、位图、字符串、音频文件等。这些资源可以通过调用相关的 API 函数来访问和使用 符号表（Symbol Table）：符号表记录了程序中的符号（如函数名、变量名）和对应的地址信息。这些信息可以在调试和符号解析时使用 导入表（Import Table）和导出表（Export Table）：导入表记录了程序所依赖的外部函数和库，导出表记录了程序暴露给其他程序使用的函数和库。这些信息在链接和运行时起到重要的作用 其他元数据：.exe 文件可能还包含一些元数据信息，如编译器版本、编译时间、程序的入口点等 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:10:6","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#6-exe文件包含哪些信息"},{"categories":["notes"],"content":" 10.7 7. SOA 和 AOS 内存分布SOA（Structure of Arrays）和 AOS（Array of Structures）是两种不同的数据布局方式，常用于优化内存访问和数据并行性 在 AOS 布局中，数据以结构体（或对象）的形式存储在连续的内存块中。每个结构体包含多个字段，这些字段在内存中彼此相邻。这种布局方式适合于以结构体为单位进行操作和访问数据的场景。例如，如果需要按照每个对象的属性进行迭代或访问，AOS 布局可以提供更好的局部性，因为相关的数据在内存中是连续的 而在 SOA 布局中，数据按字段拆分并存储在不同的内存块中。每个内存块只包含一个字段的数据，并且相同字段的数据在内存中是连续的。这种布局方式适合于按字段进行操作和访问数据的场景。例如，在进行向量计算或数据并行处理时，SOA 布局可以提供更好的内存访问模式和数据并行性，因为相同字段的数据可以在同一时间内被并行处理 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:10:7","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#7-soa-和-aos-内存分布"},{"categories":["notes"],"content":" 10.8 8. C++ 内存泄漏检查检查 C++ 的内存泄漏，除了对new / delete进行匹配检查以外，还能使用一些内存检查工具，比如 Memcheck Memcheck 工具利用 Valgrind 框架模拟了一个虚拟的 CPU 和内存管理器，通过在目标程序的二进制代码中插入额外的指令，将每个内存访问操作都重定向到 Valgrind 的内存管理器中来进行内存错误检测 Valgrind 的内存管理器会维护一个影子内存，它与目标程序的内存空间大小相同，用于记录每个内存块的使用情况。当目标程序进行内存读取或写入操作时，Valgrind 会拦截这些操作，并通过检查影子内存来判断是否存在内存错误 基本的流程如下： 代码解析：Memcheck 通过解析目标程序的二进制代码，获取程序的控制流信息和内存操作指令 内存跟踪：Memcheck 在运行目标程序的过程中，通过为每个分配的内存块维护一张内存映射表，跟踪每个内存块的使用情况 内存访问检测：当目标程序进行内存读取或写入操作时，Memcheck 会拦截这些操作，并通过检查内存映射表来判断该内存操作是否存在错误 内存错误检测：如果 Memcheck 检测到目标程序中的内存操作存在错误，如使用未初始化的内存、内存泄漏、越界访问等，它会在运行时给出警告或报错信息，并指出具体的错误位置 内存泄漏检测：Memcheck 还会跟踪目标程序中的内存分配和释放操作，并记录已分配但未释放的内存块。在程序运行结束时，Memcheck 会检查是否存在内存泄漏，并给出相应的报告 ","date":"2023-11-07","objectID":"/cpp_interview.zh/:10:8","series":null,"tags":["cpp"],"title":"C++ 面经","uri":"/cpp_interview.zh/#8-c-内存泄漏检查"},{"categories":["tutorial"],"content":" 1 简介Vimium 则继承了 Vim 中的常用键位，让你在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。 ","date":"2023-11-05","objectID":"/vimium.zh/:1:0","series":null,"tags":["vim"],"title":"Vimium: 让你像使用 Vim 那样控制浏览器","uri":"/vimium.zh/#简介"},{"categories":["tutorial"],"content":" 2 Vim 快速上手首先，在浏览器界面中输入 ? 即可唤出 Vimium 的默认快捷键列表。 ","date":"2023-11-05","objectID":"/vimium.zh/:2:0","series":null,"tags":["vim"],"title":"Vimium: 让你像使用 Vim 那样控制浏览器","uri":"/vimium.zh/#vim-快速上手"},{"categories":["tutorial"],"content":" 3 常用快捷键","date":"2023-11-05","objectID":"/vimium.zh/:3:0","series":null,"tags":["vim"],"title":"Vimium: 让你像使用 Vim 那样控制浏览器","uri":"/vimium.zh/#常用快捷键"},{"categories":["tutorial"],"content":" 3.1 页面滚动与导航 快捷键 操作 j 向下滚动 k 向上滚动 h 向左滚动 l 向右滚动 u 向上滚动半屏 d 向下滚动半屏 r 重新加载当前页面 gg 移动到页面顶部 G 移动到页面底部 ","date":"2023-11-05","objectID":"/vimium.zh/:3:1","series":null,"tags":["vim"],"title":"Vimium: 让你像使用 Vim 那样控制浏览器","uri":"/vimium.zh/#页面滚动与导航"},{"categories":["tutorial"],"content":" 3.2 打开页面 快捷键 操作 yy 将当前页面的网址拷贝到剪贴板 yf 拷贝一条链接，会让你二次选择 p 在当前 tab 打开剪贴板中的链接 P 新建页面打开剪贴板中的链接 o 在当前 tab 打开特定网址或者书签、历史记录中的网址 O 在新 tab 中打开特定网址或者书签、历史记录中的网址 T 在打开的 tab 中搜索 b 在当前 tab 打开书签中的某网址 B 在新 tab 中打开书签中的某网址 ","date":"2023-11-05","objectID":"/vimium.zh/:3:2","series":null,"tags":["vim"],"title":"Vimium: 让你像使用 Vim 那样控制浏览器","uri":"/vimium.zh/#打开页面"},{"categories":["tutorial"],"content":" 3.3 查找 快捷键 操作 / 进入查找模式 n 向下循环查找 N 向上循环查找 ","date":"2023-11-05","objectID":"/vimium.zh/:3:3","series":null,"tags":["vim"],"title":"Vimium: 让你像使用 Vim 那样控制浏览器","uri":"/vimium.zh/#查找"},{"categories":["tutorial"],"content":" 3.4 历史导航 快捷键 操作 H 后退 L 前进 ","date":"2023-11-05","objectID":"/vimium.zh/:3:4","series":null,"tags":["vim"],"title":"Vimium: 让你像使用 Vim 那样控制浏览器","uri":"/vimium.zh/#历史导航"},{"categories":["tutorial"],"content":" 3.5 操作 tab 快捷键 操作 K, gt 移动到下一个 tab J, gt 移动到上一个 tab g0 移动到第一个 tab g$ 移动到最后一个 tab t 创建新 tab yt 复制当前 tab 一份 x 关闭当前 tab X 恢复关闭的 tab alt + p pin / unpin 当前 tab ","date":"2023-11-05","objectID":"/vimium.zh/:3:5","series":null,"tags":["vim"],"title":"Vimium: 让你像使用 Vim 那样控制浏览器","uri":"/vimium.zh/#操作-tab"},{"categories":["tutorial"],"content":" 3.6 其他 快捷键 操作 f 在当前 tab 打开页面中的某个链接，会需要你二次选择 F 在新 tab 中打开页面中的某个链接，会需要你二次选择 ","date":"2023-11-05","objectID":"/vimium.zh/:3:6","series":null,"tags":["vim"],"title":"Vimium: 让你像使用 Vim 那样控制浏览器","uri":"/vimium.zh/#其他"},{"categories":["tutorial"],"content":" 1 Vim 快捷键这一部分是 Vim 的默认快捷键，例如 gg、dd 等。 ","date":"2023-11-05","objectID":"/nvim_keymap.zh/:1:0","series":null,"tags":["neovim","geek","tips"],"title":"Neovim 快捷键配置","uri":"/nvim_keymap.zh/#vim-快捷键"},{"categories":["tutorial"],"content":" 1.1 normal 模式快捷键 按键 操作 按键 操作 i 切换到插入模式 : 切换到命令模式 h 左移一个字符 j 下移一个字符 k 上移一个字符 l 右移一个字符 0 移至行首 $ 移至行尾 ^ 移至本行第一个非空字符 w 向右移动一个单词 W 向右移动一个单词（以空格分隔） 2w 向右移动两个单词 2W 向右移动两个单词（以空格分隔） b 向左移动一个单词 B 向左移动一个单词（以空格分隔） 2b 向左移动 2 个单词 2B 向左移动 2 个单词（以空格分隔） G 移至文档末尾 gg 移至文档首行 a 光标后插入 A 移至行末插入 o 光标下插入一行 O 光标上插入一行 x 删除光标处字符 dw 删除一个词 d0 删至行首 d$ 删至行尾 d) 删至句末 dgg 删至文件开头 dG 删至文件末尾 dd 删除该行 2dd 删除两行 r 替换当前字符 R 切换到 REPLACE 模式 u 撤回操作 \u003cC-r\u003e 重做撤回的操作 yy 复制当前行 p 在当前行之后粘贴内容 P 在当前行之前粘贴内容 v 打开 VISUAL 模式菜单 V 切换到逐行选择的 VISUAL 模式 / 向后搜索 ? 向前搜索 n 下一个搜索结果 N 上一个搜索结果 g goto 菜单 gd 跳转到定义 gcc 注释当前行 \u003cC-w\u003e window 菜单 \u003cC-w\u003es 水平拆分窗口 \u003cC-w\u003ev 垂直拆分窗口 \u003cC-q\u003e V-BLOCK 模式 其中，\u003cC-w\u003es 表示同时按下 Ctrl 和 w 键，再马上按下 s 键。 ","date":"2023-11-05","objectID":"/nvim_keymap.zh/:1:1","series":null,"tags":["neovim","geek","tips"],"title":"Neovim 快捷键配置","uri":"/nvim_keymap.zh/#normal-模式快捷键"},{"categories":["tutorial"],"content":" 1.2 VISUAL 模式下的快捷键 按键 操作 按键 操作 ~ 切换大小写 d 删除 c 变更 y 拷贝 \u003e 增加锁进 \u003c 减少缩进 ","date":"2023-11-05","objectID":"/nvim_keymap.zh/:1:2","series":null,"tags":["neovim","geek","tips"],"title":"Neovim 快捷键配置","uri":"/nvim_keymap.zh/#visual-模式下的快捷键"},{"categories":["tutorial"],"content":" 2 Neovim 的快捷键这一部分是 neovim 使用 LazyVim 配置之后设置的一些快捷键。 当然，原始状态的 neovim 可能就有这些快捷键了。 注意，打开 neovim 之后，我们可以通过 : 进入命令模式后，可以利用 cd /x/xx 来移动到对应的目录。 注意，此后 :xx 即表示在命令模式下输入 xx。 :checkhealth 命令用于检测 Neovim 的工作状态，可以根据结果提示来安装缺少的组件。 :Mason 是由 mason.nvim 插件提供的命令，用于呼出 mason.nvim 的管理界面，可以用来管理 LSP 插件，如下图所示： 通过 \u003cleader\u003ee 或者 \u003cleader\u003eE 可以在侧边栏打开文件浏览窗口，该窗口的操作快捷键如下： 按键 操作 按键 操作 j 下移 k 上移 \u003ccr\u003e 打开 a 新建文件或目录 A 新建目录 d 删除 r 重命名 c 复制 m 移动 q 关闭窗口 \u003cleader\u003ee 是打开从终端打开 nevoim 时所处目录的文件浏览窗口，\u003cleader\u003eE 则是当前文件所处目录的文件浏览窗口。 通过 :te，我们可以在 Neovim 新建一个 buffer（这里的 buffer 可以理解为标签页），这个新的 buffer 中则是一个命令行标签页，如下图所示： 我们可以通过 :bn 切换到下一个 buffer，通过 :bp 切换到上一个 buffer。 通过 \u003cleader\u003eb，我们会进入到关于 buffer 的快捷键操作界面，如下图所示： 当我们通过 :te 打开一个终端时，我们默认是处于 Normal 模式的，按下 i 则会切换到 Terminal 模式，然后就能像正常终端那样输入命令了，如果要切换回 Normal 模式，可以连按两次 \u003cesc\u003e 或者按下 \u003cC-\\\u003e 再按下 \u003cC-n\u003e。 我们可以通过 \u003cC-w\u003e 或者 \u003cleader\u003ew 来进入窗口的快捷键操作界面，例如，我们可以通过 \u003cC-w\u003ev 可以将 Neovim 分成左右两个窗口，此时如果再输入 :te，那么原先的编辑器和终端则会默认一个占据左边的窗口，一个占据右边的窗口，如下图所示。 ","date":"2023-11-05","objectID":"/nvim_keymap.zh/:2:0","series":null,"tags":["neovim","geek","tips"],"title":"Neovim 快捷键配置","uri":"/nvim_keymap.zh/#neovim-的快捷键"},{"categories":[""],"content":" 1 Description","date":"2023-10-23","objectID":"/798.smallest-rotation-with-highest-score/:1:0","series":null,"tags":[""],"title":"798.smallest Rotation With Highest Score","uri":"/798.smallest-rotation-with-highest-score/#description"},{"categories":[""],"content":" 798. Smallest Rotation with Highest Score (Hard)You are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point. For example, if we have nums = [2,4,1,3,0], and we rotate by k = 2, it becomes [1,3,0,2,4]. This is worth 3 points because 1 \u003e 0 \\[no points\\], 3 \u003e 1 \\[no points\\], 0 \u003c= 2 \\[one point\\], 2 \u003c= 3 \\[one point\\], 4 \u003c= 4 \\[one point\\]. Return the rotation index k that corresponds to the highest score we can achieve if we rotated nums by it. If there are multiple answers, return the smallest such index k. Example 1: text Input: nums = [2,3,1,4,0] Output: 3 Explanation: Scores for each k are listed below: k = 0, nums = [2,3,1,4,0], score 2 k = 1, nums = [3,1,4,0,2], score 3 k = 2, nums = [1,4,0,2,3], score 3 k = 3, nums = [4,0,2,3,1], score 4 k = 4, nums = [0,2,3,1,4], score 3 So we should choose k = 3, which has the highest score. Example 2: text Input: nums = [1,3,0,2,4] Output: 0 Explanation: nums will always have 3 points no matter how it shifts. So we will choose the smallest k, which is 0. Constraints: 1 \u003c= nums.length \u003c= 10⁵ 0 \u003c= nums[i] \u003c nums.length ","date":"2023-10-23","objectID":"/798.smallest-rotation-with-highest-score/:0:0","series":null,"tags":[""],"title":"798.smallest Rotation With Highest Score","uri":"/798.smallest-rotation-with-highest-score/#798-smallest-rotation-with-highest-scorelink-hard"},{"categories":[""],"content":" 1 SolutionThis problem is somewhat intricate. When we perform cyclic rotations by $k$, it is equivalent to rotating the array to the left by $k$ positions. We can discuss two scenarios: When $k \\leq i$, after the move, $nums[i]$ will be at index $i - k$. We require that $nums[i] \\leq i - k$, which means $0 \\leq k \\leq i - nums[i]$. When $k \u003e i$, after the move, $nums[i]$ will be at index $i - k + n$. We require that $nums[i] \\leq i - k + n$, which means $i \u003c k \\leq i - nums[i] + n$. Hence, we iterate through the $nums$ array, and for each $nums[i]$, we determine the range of movement counts $k$ that satisfy the conditions. In other words, if we have an array $a$, we need to increment $a[k] + 1$ for every valid $k$ within this range. Finally, we find the maximum $a[k]$ and its corresponding $k$, which represents the interval modification. We can consider optimizing this process using a difference array. ","date":"2023-10-23","objectID":"/798.smallest-rotation-with-highest-score/:1:0","series":null,"tags":[""],"title":"798.smallest Rotation With Highest Score","uri":"/798.smallest-rotation-with-highest-score/#solution"},{"categories":[""],"content":" 2 Code cpp class Solution { public: int bestRotation(vector\u003cint\u003e \u0026nums) { int n = nums.size(); vector\u003cint\u003e diff(n); for (int i = 0; i \u003c n; ++i) { if (i - nums[i] \u003c 0) { if (i - nums[i] + n \u003e i) { if (i + 1 \u003c n) { diff[i + 1] += 1; } if (i - nums[i] + n \u003c n - 1) { diff[i - nums[i] + n + 1] -= 1; } } } else { diff[0] += 1; if (i - nums[i] \u003c n - 1) { diff[i - nums[i] + 1] -= 1; } if (i + 1 \u003c n) { diff[i + 1] += 1; } } } int sum = diff[0], mx = diff[0]; int res = 0; for (int i = 1; i \u003c n; ++i) { sum += diff[i]; if (sum \u003e mx) { res = i; mx = sum; } } return res; } }; ","date":"2023-10-23","objectID":"/798.smallest-rotation-with-highest-score/:2:0","series":null,"tags":[""],"title":"798.smallest Rotation With Highest Score","uri":"/798.smallest-rotation-with-highest-score/#code"},{"categories":["leetcode"],"content":" 1 问题描述798. 得分最高的最小轮调 (Hard) 给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]] 的形式。此后，任何值小于或等于其索 引的项都可以记作一分。 例如，数组为 nums = [2,4,1,3,0]，我们按 k = 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 \u003e 0 \\[不计分\\]、 3 \u003e 1 \\[不计分\\]、 0 \u003c= 2 \\[计 1 分\\]、 2 \u003c= 3 \\[计 1 分\\]， 4 \u003c= 4 \\[计 1 分\\]。 在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最 小的下标 k 。 示例 1： text 输入：nums = [2,3,1,4,0] 输出：3 解释： 下面列出了每个 k 的得分： k = 0, nums = [2,3,1,4,0], score 2 k = 1, nums = [3,1,4,0,2], score 3 k = 2, nums = [1,4,0,2,3], score 3 k = 3, nums = [4,0,2,3,1], score 4 k = 4, nums = [0,2,3,1,4], score 3 所以我们应当选择 k = 3，得分最高。 示例 2： text 输入：nums = [1,3,0,2,4] 输出：0 解释： nums 无论怎么变化总是有 3 分。 所以我们将选择最小的 k，即 0。 提示： 1 \u003c= nums.length \u003c= 10⁵ 0 \u003c= nums[i] \u003c nums.length ","date":"2023-10-23","objectID":"/798.smallest-rotation-with-highest-score.zh/:1:0","series":null,"tags":["difference array"],"title":"798. 得分最高的最小轮调 (Hard)","uri":"/798.smallest-rotation-with-highest-score.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路这一题比较难思考，按 $k$ 进行轮调，等价于数组向左旋转 $k$ 位，我们分情况讨论： 当 $k \u003c= i$ 时，移动后的 $nums[i]$ 位于索引 $i - k$ 处，要求 $nums[i] \u003c= i - k$，即有 $0 \u003c= k \u003c= i - nums[i]$； 当 $k \u003e i$ 时，移动后的 $nums[i]$ 位于索引 $i - k + n$ 处，要求 $nums[i] \u003c= i - k + n$，即有 $i \u003c k \u003c= i - nums[i] + n$。 于是，我们遍历 $nums$ 数组，对每个 $nums[i]$，我们找出能满足条件的移动次数 $k$ 的范围，即假设我们有一个数组 $a$，我们需要对这个范围里每一个满足条件的 $k$，都执行 $a[k] + 1$，最后找到最大的 $a[k]$ 对应的 $k$，即区间修改；因此，我们可以考虑利用差分数组来优化这一过程。 ","date":"2023-10-23","objectID":"/798.smallest-rotation-with-highest-score.zh/:2:0","series":null,"tags":["difference array"],"title":"798. 得分最高的最小轮调 (Hard)","uri":"/798.smallest-rotation-with-highest-score.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int bestRotation(vector\u003cint\u003e \u0026nums) { int n = nums.size(); vector\u003cint\u003e diff(n); for (int i = 0; i \u003c n; ++i) { if (i - nums[i] \u003c 0) { if (i - nums[i] + n \u003e i) { if (i + 1 \u003c n) { diff[i + 1] += 1; } if (i - nums[i] + n \u003c n - 1) { diff[i - nums[i] + n + 1] -= 1; } } } else { diff[0] += 1; if (i - nums[i] \u003c n - 1) { diff[i - nums[i] + 1] -= 1; } if (i + 1 \u003c n) { diff[i + 1] += 1; } } } int sum = diff[0], mx = diff[0]; int res = 0; for (int i = 1; i \u003c n; ++i) { sum += diff[i]; if (sum \u003e mx) { res = i; mx = sum; } } return res; } }; ","date":"2023-10-23","objectID":"/798.smallest-rotation-with-highest-score.zh/:3:0","series":null,"tags":["difference array"],"title":"798. 得分最高的最小轮调 (Hard)","uri":"/798.smallest-rotation-with-highest-score.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1201. Ugly Number III (Medium) An ugly number is a positive integer that is divisible by a, b, or c. Given four integers n, a, b, and c, return the nᵗʰ ugly number. Example 1: text Input: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3ʳᵈ is 4. Example 2: text Input: n = 4, a = 2, b = 3, c = 4 Output: 6 Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4ᵗʰ is 6. Example 3: text Input: n = 5, a = 2, b = 11, c = 13 Output: 10 Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5ᵗʰ is 10. Constraints: 1 \u003c= n, a, b, c \u003c= 10⁹ 1 \u003c= a * b * c \u003c= 10¹⁸ It is guaranteed that the result will be in range [1, 2 * 10⁹]. ","date":"2023-10-17","objectID":"/1201.ugly-number-iii/:1:0","series":null,"tags":["math"],"title":"1201. Ugly Number III (Medium)","uri":"/1201.ugly-number-iii/#description"},{"categories":["leetcode"],"content":" 2 SolutionBinary search + inclusion-exclusion principle. In this approach, we perform a binary search for the value of the nth ugly number, denoted as $val$. If $val$ is less than the result ($res$), then its position in the sequence must be less than $n$. To determine its position, we apply the inclusion-exclusion principle. It’s important to note that $a, b, c$ may not be coprime, so you should use their least common multiple! ","date":"2023-10-17","objectID":"/1201.ugly-number-iii/:2:0","series":null,"tags":["math"],"title":"1201. Ugly Number III (Medium)","uri":"/1201.ugly-number-iii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool check(int n, long a, long b, long c, long target) { long ab = a * b / gcd(a, b); long bc = b * c / gcd(b, c); long ac = a * c / gcd(a, c); long abc = ab * c / gcd(ab, c); return target / a + target / b + target / c - target / ab - target / bc - target / ac + target / abc \u003c n; } int nthUglyNumber(int n, int a, int b, int c) { long l = 0, r = 2e10; while (l \u003c r) { long mid = l + (r - l) / 2; if (check(n, a, b, c, mid)) { l = mid + 1; } else { r = mid; } } return l; } }; ","date":"2023-10-17","objectID":"/1201.ugly-number-iii/:3:0","series":null,"tags":["math"],"title":"1201. Ugly Number III (Medium)","uri":"/1201.ugly-number-iii/#code"},{"categories":["leetcode"],"content":" 1 问题描述1201. 丑数 III (Medium) 给你四个整数： n 、 a 、 b 、 c ，请你设计一个算法来找出第 n 个丑数。 丑数是可以被 a 或 b 或 c 整除的 正整数 。 示例 1： text 输入：n = 3, a = 2, b = 3, c = 5 输出：4 解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2： text 输入：n = 4, a = 2, b = 3, c = 4 输出：6 解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。 示例 3： text 输入：n = 5, a = 2, b = 11, c = 13 输出：10 解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。 示例 4： text 输入：n = 1000000000, a = 2, b = 217983653, c = 336916467 输出：1999999984 提示： 1 \u003c= n, a, b, c \u003c= 10^9 1 \u003c= a * b * c \u003c= 10^18 本题结果在 [1, 2 * 10^9] 的范围内 ","date":"2023-10-17","objectID":"/1201.ugly-number-iii.zh/:1:0","series":null,"tags":["math","binary search"],"title":"1201. 丑数 III (Medium)","uri":"/1201.ugly-number-iii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路二分 + 容斥原理。 我们要二分的就是第 $n$ 个丑数的值 $val$，如果 $val \u003c res$，那么它的序数一定小于 $n$。 判断序数的方法即容斥原理，这里要注意 $a, b, c$ 不一定互质，要取最小公倍数！ ","date":"2023-10-17","objectID":"/1201.ugly-number-iii.zh/:2:0","series":null,"tags":["math","binary search"],"title":"1201. 丑数 III (Medium)","uri":"/1201.ugly-number-iii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool check(int n, long a, long b, long c, long target) { long ab = a * b / gcd(a, b); long bc = b * c / gcd(b, c); long ac = a * c / gcd(a, c); long abc = ab * c / gcd(ab, c); return target / a + target / b + target / c - target / ab - target / bc - target / ac + target / abc \u003c n; } int nthUglyNumber(int n, int a, int b, int c) { long l = 0, r = 2e10; while (l \u003c r) { long mid = l + (r - l) / 2; if (check(n, a, b, c, mid)) { l = mid + 1; } else { r = mid; } } return l; } }; ","date":"2023-10-17","objectID":"/1201.ugly-number-iii.zh/:3:0","series":null,"tags":["math","binary search"],"title":"1201. 丑数 III (Medium)","uri":"/1201.ugly-number-iii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2652. Sum Multiples (Easy) Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7. Return an integer denoting the sum of all numbers in the given range satisfying the constraint. Example 1: text Input: n = 7 Output: 21 Explanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21. Example 2: text Input: n = 10 Output: 40 Explanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40. Example 3: text Input: n = 9 Output: 30 Explanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30. Constraints: 1 \u003c= n \u003c= 10³ ","date":"2023-10-17","objectID":"/2652.sum-multiples/:1:0","series":null,"tags":["math"],"title":"2652. Sum Multiples (Easy)","uri":"/2652.sum-multiples/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem can be solved with brute force due to the given small data range, but there are also non-bruteforce methods. Another approach is to use the principle of inclusion-exclusion. The desired result can be expressed as $3*\\lfloor{\\frac{n}{3}}\\rfloor + 5*\\lfloor{\\frac{n}{5}}\\rfloor + 7*\\lfloor{\\frac{n}{7}}\\rfloor - 15*\\lfloor{\\frac{n}{15}}\\rfloor - 21*\\lfloor{\\frac{n}{21}}\\rfloor - 35*\\lfloor{\\frac{n}{35}}\\rfloor + 105*\\lfloor{\\frac{n}{105}}\\rfloor$. This is because $3, 5, 7$ are coprime, so we can write it this way. Otherwise, the denominators in the latter part should be their least common multiple. ","date":"2023-10-17","objectID":"/2652.sum-multiples/:2:0","series":null,"tags":["math"],"title":"2652. Sum Multiples (Easy)","uri":"/2652.sum-multiples/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int solve(int n, int k) { return k * (1 + n) * n / 2; } int sumOfMultiples(int n) { return solve(n / 3, 3) + solve(n / 5, 5) + solve(n / 7, 7) - solve(n / 15, 15) - solve(n / 21, 21) - solve(n / 35, 35) + solve(n / 105, 105); } }; ","date":"2023-10-17","objectID":"/2652.sum-multiples/:3:0","series":null,"tags":["math"],"title":"2652. Sum Multiples (Easy)","uri":"/2652.sum-multiples/#code"},{"categories":["leetcode"],"content":" 1 问题描述","date":"2023-10-17","objectID":"/2652.sum-multiples.zh/:1:0","series":null,"tags":["math"],"title":"2652. 倍数求和 (Easy)","uri":"/2652.sum-multiples.zh/#问题描述"},{"categories":["leetcode"],"content":" 2652. 倍数求和 (Easy)给你一个正整数 n ，请你计算在 [1，n] 范围内能被 3、 5、 7 整除的所有整数之和。 返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。 示例 1： text 输入：n = 7 输出：21 解释：在 [1, 7] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7 。数字之和为 21 。 示例 2： text 输入：n = 10 输出：40 解释：在 [1, 10] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9、10 。数字之和为 40 。 示例 3： text 输入：n = 9 输出：30 解释：在 [1, 9] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9 。数字之和为 30 。 提示： 1 \u003c= n \u003c= 10³ ","date":"2023-10-17","objectID":"/2652.sum-multiples.zh/:0:0","series":null,"tags":["math"],"title":"2652. 倍数求和 (Easy)","uri":"/2652.sum-multiples.zh/#2652-倍数求和link-easy"},{"categories":["leetcode"],"content":" 1 解题思路这题由于数据范围给的小，暴力就能过，但是也有非暴力的方法。 还可以采用容斥原理来解决。 所求结果为 $3*\\lfloor{\\frac{n}{3}}\\rfloor + 5*\\lfloor{\\frac{n}{5}}\\rfloor + 7*\\lfloor{\\frac{n}{7}}\\rfloor - 15*\\lfloor{\\frac{n}{15}}\\rfloor - 21*\\lfloor{\\frac{n}{21}}\\rfloor - 35*\\lfloor{\\frac{n}{35}}\\rfloor + 105*\\lfloor{\\frac{n}{105}}\\rfloor$。 这里是因为 $3, 5, 7$ 互质所以可以直接这么写，否则后面的分母应该是它们的最小公倍数才对。 ","date":"2023-10-17","objectID":"/2652.sum-multiples.zh/:1:0","series":null,"tags":["math"],"title":"2652. 倍数求和 (Easy)","uri":"/2652.sum-multiples.zh/#解题思路"},{"categories":["leetcode"],"content":" 2 代码 cpp class Solution { public: int solve(int n, int k) { return k * (1 + n) * n / 2; } int sumOfMultiples(int n) { return solve(n / 3, 3) + solve(n / 5, 5) + solve(n / 7, 7) - solve(n / 15, 15) - solve(n / 21, 21) - solve(n / 35, 35) + solve(n / 105, 105); } }; ","date":"2023-10-17","objectID":"/2652.sum-multiples.zh/:2:0","series":null,"tags":["math"],"title":"2652. 倍数求和 (Easy)","uri":"/2652.sum-multiples.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description446. Arithmetic Slices II - Subsequence (Hard) Given an integer array nums, return the number of all the arithmetic subsequences of nums. A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences. For example, [1, 1, 2, 5, 7] is not an arithmetic sequence. A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array. For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10]. The test cases are generated so that the answer fits in 32-bit integer. Example 1: text Input: nums = [2,4,6,8,10] Output: 7 Explanation: All arithmetic subsequence slices are: [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10] Example 2: text Input: nums = [7,7,7,7,7] Output: 16 Explanation: Any subsequence of this array is arithmetic. Constraints: 1 \u003c= nums.length \u003c= 1000 -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 ","date":"2023-10-17","objectID":"/446.arithmetic-slices-ii-subsequence/:1:0","series":null,"tags":["dynamic programming"],"title":"446. Arithmetic Slices II - Subsequence (Hard)","uri":"/446.arithmetic-slices-ii-subsequence/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem evidently calls for a dynamic programming approach. For instance, let $dp[i]$ denote the length of the subsequence ending with nums[i]. To transition from $dp[j]$, we must be aware of $nums[i] - nums[j]$. Consequently, the $dp$ array requires two dimensions: the first dimension represents the index of the array $nums$, and the second dimension denotes the difference $diff$. As $diff$ can be substantial and even negative, we employ a hash table for record-keeping. Hence, vector\u003cunordered_map\u003clong, long\u003e\u003e dp. Furthermore, there’s the requirement that the array length must be at least $3$. Eliminating sequences of length $2$ during the state transition process can be somewhat intricate. However, we can easily remove length-$2$ sequences after computation by subtracting $\\binom{n}{2}$ from the result. ","date":"2023-10-17","objectID":"/446.arithmetic-slices-ii-subsequence/:2:0","series":null,"tags":["dynamic programming"],"title":"446. Arithmetic Slices II - Subsequence (Hard)","uri":"/446.arithmetic-slices-ii-subsequence/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e \u0026nums) { if (nums.size() \u003c 3) { return 0; } int n = nums.size(); int res = 0; vector\u003cunordered_map\u003clong, long\u003e\u003e dp(n); for (int i = 1; i \u003c n; ++i) { for (int j = 0; j \u003c i; ++j) { long diff = (long)nums[i] - nums[j]; dp[i][diff] += 1 + dp[j][diff]; res += 1 + dp[j][diff]; } } return res - n * (n - 1) / 2; } }; ","date":"2023-10-17","objectID":"/446.arithmetic-slices-ii-subsequence/:3:0","series":null,"tags":["dynamic programming"],"title":"446. Arithmetic Slices II - Subsequence (Hard)","uri":"/446.arithmetic-slices-ii-subsequence/#code"},{"categories":["leetcode"],"content":" 1 问题描述446. 等差数列划分 II - 子序列 (Hard) 给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。 如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。 例如， [1, 3, 5, 7, 9]、 [7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。 再例如， [1, 1, 2, 5, 7] 不是等差序列。 数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。 例如， [2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 题目数据保证答案是一个 32-bit 整数。 示例 1： text 输入：nums = [2,4,6,8,10] 输出：7 解释：所有的等差子序列为： [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10] 示例 2： text 输入：nums = [7,7,7,7,7] 输出：16 解释：数组中的任意子序列都是等差子序列。 提示： 1 \u003c= nums.length \u003c= 1000 -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 ","date":"2023-10-17","objectID":"/446.arithmetic-slices-ii-subsequence.zh/:1:0","series":null,"tags":["dynamic programming"],"title":"446. 等差数列划分 II - 子序列 (Hard)","uri":"/446.arithmetic-slices-ii-subsequence.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路这题很明显需要使用动态规划来解决，例如以 $dp[i]$ 表示以 nums[i] 结尾的子序列的长度，那么要如何从 $dp[j]$ 转移过来呢？要从 $dp[j]$ 转移过来，我们必须知道 $nums[i] - nums[j]$，因此，$dp$ 需要两个维度，第一个维度表示数组 $nums$ 的索引，第二个维度表示差 $diff$，由于 $diff$ 可能很大，还可能为负数，所以我们采用哈希表来记录。 因此 vector\u003cunordered_map\u003clong, long\u003e\u003e dp。 此外，还有一个问题，那就是题目要求数组长度至少为 $3$，而要在状态转移过程中排除掉长度为 $2$ 的序列数是比较麻烦的，其实我们可以等计算完之后再去除长度为 $2$ 的队列，即减去 $\\binom{n}{2}$。 ","date":"2023-10-17","objectID":"/446.arithmetic-slices-ii-subsequence.zh/:2:0","series":null,"tags":["dynamic programming"],"title":"446. 等差数列划分 II - 子序列 (Hard)","uri":"/446.arithmetic-slices-ii-subsequence.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e \u0026nums) { if (nums.size() \u003c 3) { return 0; } int n = nums.size(); int res = 0; vector\u003cunordered_map\u003clong, long\u003e\u003e dp(n); for (int i = 1; i \u003c n; ++i) { for (int j = 0; j \u003c i; ++j) { long diff = (long)nums[i] - nums[j]; dp[i][diff] += 1 + dp[j][diff]; res += 1 + dp[j][diff]; } } return res - n * (n - 1) / 2; } }; ","date":"2023-10-17","objectID":"/446.arithmetic-slices-ii-subsequence.zh/:3:0","series":null,"tags":["dynamic programming"],"title":"446. 等差数列划分 II - 子序列 (Hard)","uri":"/446.arithmetic-slices-ii-subsequence.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description260. Single Number III (Medium) Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order. You must write an algorithm that runs in linear runtime complexity and uses only constant extra space. Example 1: text Input: nums = [1,2,1,3,2,5] Output: [3,5] Explanation: [5, 3] is also a valid answer. Example 2: text Input: nums = [-1,0] Output: [-1,0] Example 3: text Input: nums = [0,1] Output: [1,0] Constraints: 2 \u003c= nums.length \u003c= 3 * 10⁴ -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 Each integer in nums will appear twice, only two integers will appear once. ","date":"2023-10-16","objectID":"/260.single-number-iii/:1:0","series":null,"tags":["bit ops"],"title":"260. Single Number III (Medium)","uri":"/260.single-number-iii/#description"},{"categories":["leetcode"],"content":" 2 SolutionInitially, perform bitwise XOR on all numbers. Assuming the elements to be identified are denoted as $a$ and $b$, the result of the XOR operation is $c = a \\oplus b$. Consider obtaining the lowbit of $c$, which is $c \u0026 (-c)$. This enables us to categorize all elements into two groups: one with $nums[i] \u0026 lowbit = 0$ and the other with non-zero values. Notably, $a$ and $b$ each belong to one of these groups. If the XOR result of all elements in the first group is $a$, then the XOR result of all elements in the second group is $b$. ","date":"2023-10-16","objectID":"/260.single-number-iii/:2:0","series":null,"tags":["bit ops"],"title":"260. Single Number III (Medium)","uri":"/260.single-number-iii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e singleNumber(vector\u003cint\u003e\u0026 nums) { long res = 0; int n = nums.size(); for (int i = 0; i \u003c n; ++i) { res = res ^ nums[i]; } long c = (res \u0026 (-res)); int res1 = 0, res2 = 0; for (int i = 0; i \u003c n; ++i) { if (nums[i] \u0026 c) { res1 = res1 ^ nums[i]; } else { res2 = res2 ^ nums[i]; } } return {res1, res2}; } }; ","date":"2023-10-16","objectID":"/260.single-number-iii/:3:0","series":null,"tags":["bit ops"],"title":"260. Single Number III (Medium)","uri":"/260.single-number-iii/#code"},{"categories":["leetcode"],"content":" 1 问题描述260. 只出现一次的数字 III (Medium) 给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两 个元素。你可以按 任意顺序 返回答案。 你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。 示例 1： text 输入：nums = [1,2,1,3,2,5] 输出：[3,5] 解释：[5, 3] 也是有效的答案。 示例 2： text 输入：nums = [-1,0] 输出：[-1,0] 示例 3： text 输入：nums = [0,1] 输出：[1,0] 提示： 2 \u003c= nums.length \u003c= 3 * 10⁴ -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 除两个只出现一次的整数外， nums 中的其他数字都出现两次 ","date":"2023-10-16","objectID":"/260.single-number-iii.zh/:1:0","series":null,"tags":["bit ops"],"title":"260. 只出现一次的数字 III (Medium)","uri":"/260.single-number-iii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先对所有数取异或，假设要找出来的元素分别为 $a$ 和 $b$，那么异或的结果就是 $c = a \\oplus b$，我们考虑求 $c$ 的 lowbit，即 $c \u0026 (-c)$，那么我们就可以把所有元素分成两类，一类是 $nums[i] \u0026 lowbit = 0$，另一类是不为 $0$，$a$ 和 $b$ 一定是各属于一类，如果第一类元素的所有值的异或就是 $a$，那么第二类所有元素的异或值就是 $b$。 ","date":"2023-10-16","objectID":"/260.single-number-iii.zh/:2:0","series":null,"tags":["bit ops"],"title":"260. 只出现一次的数字 III (Medium)","uri":"/260.single-number-iii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e singleNumber(vector\u003cint\u003e\u0026 nums) { long res = 0; int n = nums.size(); for (int i = 0; i \u003c n; ++i) { res = res ^ nums[i]; } // 找出 res 的第一个 1 long c = (res \u0026 (-res)); int res1 = 0, res2 = 0; for (int i = 0; i \u003c n; ++i) { if (nums[i] \u0026 c) { res1 = res1 ^ nums[i]; } else { res2 = res2 ^ nums[i]; } } return {res1, res2}; } }; ","date":"2023-10-16","objectID":"/260.single-number-iii.zh/:3:0","series":null,"tags":["bit ops"],"title":"260. 只出现一次的数字 III (Medium)","uri":"/260.single-number-iii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description137. Single Number II (Medium) Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: text Input: nums = [2,2,3,2] Output: 3 Example 2: text Input: nums = [0,1,0,1,0,1,99] Output: 99 Constraints: 1 \u003c= nums.length \u003c= 3 * 10⁴ -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 Each element in nums appears exactly three times except for one element which appears once. ","date":"2023-10-16","objectID":"/137.single-number-ii/:1:0","series":null,"tags":["bit ops"],"title":"137. Single Number II (Medium)","uri":"/137.single-number-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionTo ensure a space complexity of $O(1)$, we must contemplate the binary representation of nums, specifically tallying the sum of each digit in nums[i]. Given that only one element appears once, while others manifest thrice, we can apply a modulo operation of this sum by 3. The resulting outcome represents the digits of the sought-after element. ","date":"2023-10-16","objectID":"/137.single-number-ii/:2:0","series":null,"tags":["bit ops"],"title":"137. Single Number II (Medium)","uri":"/137.single-number-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int singleNumber(vector\u003cint\u003e \u0026nums) { vector\u003cint\u003e cnt(32); int n = nums.size(); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c 32; ++j) { cnt[j] += ((nums[i] \u003e\u003e j) \u0026 0x1); } } for (int i = 0; i \u003c 32; ++i) { cnt[i] = cnt[i] % 3; } int res = 0; for (int i = 0; i \u003c 32; ++i) { res |= (cnt[i] \u003c\u003c i); } return res; } }; ","date":"2023-10-16","objectID":"/137.single-number-ii/:3:0","series":null,"tags":["bit ops"],"title":"137. Single Number II (Medium)","uri":"/137.single-number-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述","date":"2023-10-16","objectID":"/137.single-number-ii.zh/:1:0","series":null,"tags":["bit ops"],"title":"137. 只出现一次的数字 II (Medium)","uri":"/137.single-number-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 137. 只出现一次的数字 II (Medium)给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。 请你找出并 返回那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。 示例 1： text 输入：nums = [2,2,3,2] 输出：3 示例 2： text 输入：nums = [0,1,0,1,0,1,99] 输出：99 提示： 1 \u003c= nums.length \u003c= 3 * 10⁴ -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 ","date":"2023-10-16","objectID":"/137.single-number-ii.zh/:0:0","series":null,"tags":["bit ops"],"title":"137. 只出现一次的数字 II (Medium)","uri":"/137.single-number-ii.zh/#137-只出现一次的数字-iilink-medium"},{"categories":["leetcode"],"content":" 1 解题思路要想保证空间复杂度为 $O(1)$，我们需要考虑 nums 的二进制表示，即统计 nums[i] 的每一位上的数的和，由于只有一个元素出现一次，其他都出现了三次，那么我们对这个和 $ \\mod 3$，得到的结果就是待找出的元素的每一位上的数。 ","date":"2023-10-16","objectID":"/137.single-number-ii.zh/:1:0","series":null,"tags":["bit ops"],"title":"137. 只出现一次的数字 II (Medium)","uri":"/137.single-number-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 2 代码 cpp class Solution { public: int singleNumber(vector\u003cint\u003e \u0026nums) { vector\u003cint\u003e cnt(32); int n = nums.size(); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c 32; ++j) { cnt[j] += ((nums[i] \u003e\u003e j) \u0026 0x1); } } for (int i = 0; i \u003c 32; ++i) { cnt[i] = cnt[i] % 3; } int res = 0; for (int i = 0; i \u003c 32; ++i) { res |= (cnt[i] \u003c\u003c i); } return res; } }; ","date":"2023-10-16","objectID":"/137.single-number-ii.zh/:2:0","series":null,"tags":["bit ops"],"title":"137. 只出现一次的数字 II (Medium)","uri":"/137.single-number-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2906. Construct Product Matrix (Medium) Given a 0-indexed 2D integer matrix grid of size n * m, we define a 0-indexed 2D matrix p of size n * m as the product matrix of grid if the following condition is met: Each element p[i][j] is calculated as the product of all elements in grid except for the element grid[i][j]. This product is then taken modulo 12345. Return the product matrix of grid. Example 1: text Input: grid = [[1,2],[3,4]] Output: [[24,12],[8,6]] Explanation: p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24 p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12 p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8 p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6 So the answer is [[24,12],[8,6]]. Example 2: text Input: grid = [[12345],[2],[1]] Output: [[2],[0],[0]] Explanation: p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2. p[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0. So p[0][1] = 0. p[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0. So p[0][2] = 0. So the answer is [[2],[0],[0]]. Constraints: 1 \u003c= n == grid.length \u003c= 10⁵ 1 \u003c= m == grid[i].length \u003c= 10⁵ 2 \u003c= n * m \u003c= 10⁵ 1 \u003c= grid[i][j] \u003c= 10⁹ ","date":"2023-10-16","objectID":"/2906.construct-product-matrix/:1:0","series":null,"tags":["prefix sum"],"title":"2906. Construct Product Matrix (Medium)","uri":"/2906.construct-product-matrix/#description"},{"categories":["leetcode"],"content":" 2 SolutionFore and aft decomposition, metamorphosing the matrix from two dimensions to one, specifically as $idx = i * n + j$, subsequently procuring the prefix product array and the suffix product array. It is imperative to emphasize that during the calculation of these aforementioned prefixes and suffixes, modular operations must be duly executed. ","date":"2023-10-16","objectID":"/2906.construct-product-matrix/:2:0","series":null,"tags":["prefix sum"],"title":"2906. Construct Product Matrix (Medium)","uri":"/2906.construct-product-matrix/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e constructProductMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int m = grid.size(), n = grid[0].size(); const int mod = 12345; vector\u003cint\u003e prefix(m * n + 1, 1); vector\u003cint\u003e suffix(m * n + 1, 1); for (int i = 1; i \u003c= m * n; ++i) { prefix[i] = ((prefix[i - 1] % mod) * (grid[(i - 1) / n][(i - 1) % n] % mod)) % mod; int j = m * n + 1 - i; suffix[i] = ((suffix[i - 1] % mod) * (grid[(j - 1) / n][(j - 1) % n] % mod)) % mod; } vector\u003cvector\u003cint\u003e\u003e p(m, vector\u003cint\u003e(n, 0)); for (int i = 0; i \u003c m; ++i) { for (int j = 0; j \u003c n; ++j) { int idx = i * n + j; p[i][j] = (prefix[idx] % mod * (suffix[m * n - idx - 1] % mod)) % mod; } } return p; } }; ","date":"2023-10-16","objectID":"/2906.construct-product-matrix/:3:0","series":null,"tags":["prefix sum"],"title":"2906. Construct Product Matrix (Medium)","uri":"/2906.construct-product-matrix/#code"},{"categories":["leetcode"],"content":" 1 问题描述2906. 构造乘积矩阵 (Medium) 给你一个下标从 0 开始、大小为 n * m 的二维整数矩阵 grid ，定义一个下标从 0 开始、大小为 n * m 的的二维矩阵 p。如果满足以下条件，则称 p 为 grid 的 乘积矩阵 ： 对于每个元素 p[i][j] ，它的值等于除了 grid[i][j] 外所有元素的乘积。乘积对 12345 取余数。 返回 grid 的乘积矩阵。 示例 1： text 输入：grid = [[1,2],[3,4]] 输出：[[24,12],[8,6]] 解释：p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24 p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12 p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8 p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6 所以答案是 [[24,12],[8,6]] 。 示例 2： text 输入：grid = [[12345],[2],[1]] 输出：[[2],[0],[0]] 解释：p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2 p[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0 ，所以 p[0][1] = 0 p[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0 ，所以 p[0][2] = 0 所以答案是 [[2],[0],[0]] 。 提示： 1 \u003c= n == grid.length \u003c= 10⁵ 1 \u003c= m == grid[i].length \u003c= 10⁵ 2 \u003c= n * m \u003c= 10⁵ 1 \u003c= grid[i][j] \u003c= 10⁹ ","date":"2023-10-16","objectID":"/2906.construct-product-matrix.zh/:1:0","series":null,"tags":["prefix sum"],"title":"2906. 构造乘积矩阵 (Medium)","uri":"/2906.construct-product-matrix.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路前后缀分解，将矩阵从二维转换为一维，即 $idx = i * n + j$，然后求出前缀乘积数组与后缀乘积数组，注意求取前后缀的时候要取模。 ","date":"2023-10-16","objectID":"/2906.construct-product-matrix.zh/:2:0","series":null,"tags":["prefix sum"],"title":"2906. 构造乘积矩阵 (Medium)","uri":"/2906.construct-product-matrix.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e constructProductMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int m = grid.size(), n = grid[0].size(); const int mod = 12345; vector\u003cint\u003e prefix(m * n + 1, 1); vector\u003cint\u003e suffix(m * n + 1, 1); for (int i = 1; i \u003c= m * n; ++i) { prefix[i] = ((prefix[i - 1] % mod) * (grid[(i - 1) / n][(i - 1) % n] % mod)) % mod; int j = m * n + 1 - i; suffix[i] = ((suffix[i - 1] % mod) * (grid[(j - 1) / n][(j - 1) % n] % mod)) % mod; } vector\u003cvector\u003cint\u003e\u003e p(m, vector\u003cint\u003e(n, 0)); for (int i = 0; i \u003c m; ++i) { for (int j = 0; j \u003c n; ++j) { int idx = i * n + j; p[i][j] = (prefix[idx] % mod * (suffix[m * n - idx - 1] % mod)) % mod; } } return p; } }; ","date":"2023-10-16","objectID":"/2906.construct-product-matrix.zh/:3:0","series":null,"tags":["prefix sum"],"title":"2906. 构造乘积矩阵 (Medium)","uri":"/2906.construct-product-matrix.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1074. Number of Submatrices That Sum to Target (Hard) Given a matrix and a target, return the number of non-empty submatrices that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 \u003c= x \u003c= x2 and y1 \u003c= y \u003c= y2. Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'. Example 1: text Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 Output: 4 Explanation: The four 1x1 submatrices that only contain 0. Example 2: text Input: matrix = [[1,-1],[-1,1]], target = 0 Output: 5 Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix. Example 3: text Input: matrix = [[904]], target = 0 Output: 0 Constraints: 1 \u003c= matrix.length \u003c= 100 1 \u003c= matrix[0].length \u003c= 100 -1000 \u003c= matrix[i] \u003c= 1000 -10^8 \u003c= target \u003c= 10^8 ","date":"2023-10-13","objectID":"/1074.number-of-submatrices-that-sum-to-target/:1:0","series":null,"tags":["prefix sum","tips"],"title":"1074. Number of Submatrices That Sum to Target (Hard)","uri":"/1074.number-of-submatrices-that-sum-to-target/#description"},{"categories":["leetcode"],"content":" 2 SolutionIt can be transmuted into a one-dimensional prefix sum. We may commence by enumerating the left boundary and right boundary of the rectangle. Once the left and right boundaries are firmly established, we can embark upon the solution with the perspective of a one-dimensional prefix sum. Naturally, in this context, we necessitate the antecedent computation of the one-dimensional prefix sum for each row of data. The temporal complexity ascertains itself to be $O(n^3)$. The solution of 363. Max Sum of Rectangle No Larger Than K (Hard) is similar. ","date":"2023-10-13","objectID":"/1074.number-of-submatrices-that-sum-to-target/:2:0","series":null,"tags":["prefix sum","tips"],"title":"1074. Number of Submatrices That Sum to Target (Hard)","uri":"/1074.number-of-submatrices-that-sum-to-target/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int numSubmatrixSumTarget(vector\u003cvector\u003cint\u003e\u003e \u0026matrix, int target) { // 二维前缀和 // 枚举左右边界，转换为一维前缀和 int m = matrix.size(), n = matrix[0].size(); vector\u003cvector\u003cint\u003e\u003e rowsum(m, vector\u003cint\u003e(n + 1)); int res = 0; for (int i = 0; i \u003c m; ++i) { for (int j = 1; j \u003c= n; ++j) { rowsum[i][j] = rowsum[i][j - 1] + matrix[i][j - 1]; } } for (int i = 0; i \u003c n; ++i) { for (int j = i + 1; j \u003c= n; ++j) { // 左闭右开 unordered_map\u003cint, int\u003e record; record[0] = 1; int sum = 0; for (int k = 1; k \u003c= m; ++k) { sum += rowsum[k - 1][j] - rowsum[k - 1][i]; if (record.find(sum - target) != record.end()) { res += record[sum - target]; } ++record[sum]; } } } return res; } }; ","date":"2023-10-13","objectID":"/1074.number-of-submatrices-that-sum-to-target/:3:0","series":null,"tags":["prefix sum","tips"],"title":"1074. Number of Submatrices That Sum to Target (Hard)","uri":"/1074.number-of-submatrices-that-sum-to-target/#code"},{"categories":["leetcode"],"content":" 1 问题描述1074. 元素和为目标值的子矩阵数量 (Hard) 给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。 子矩阵 x1, y1, x2, y2 是满足 x1 \u003c= x \u003c= x2 且 y1 \u003c= y \u003c= y2 的所有单元 matrix[x][y] 的集合。 如果 (x1, y1, x2, y2) 和 (x1', y1', x2', y2') 两个子矩阵中部分坐标不同（如： x1 != x1'），那么 这两个子矩阵也不同。 示例 1： text 输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 输出：4 解释：四个只含 0 的 1x1 子矩阵。 示例 2： text 输入：matrix = [[1,-1],[-1,1]], target = 0 输出：5 解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。 示例 3： text 输入：matrix = [[904]], target = 0 输出：0 提示： 1 \u003c= matrix.length \u003c= 100 1 \u003c= matrix[0].length \u003c= 100 -1000 \u003c= matrix[i] \u003c= 1000 -10^8 \u003c= target \u003c= 10^8 ","date":"2023-10-13","objectID":"/1074.number-of-submatrices-that-sum-to-target.zh/:1:0","series":null,"tags":["prefix sum","tips"],"title":"1074. 元素和为目标值的子矩阵数量 (Hard)","uri":"/1074.number-of-submatrices-that-sum-to-target.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路碰到这个题，我的第一反应就是二维前缀和，以 $prefix[i][j]$ 表示前 $i * j$ 个方块里的数字之和，那么子矩阵 $x_1，y_1，x_2，y_2$ 的数字之和为 $prefix[x_2 + 1][y_2 + 1] - prefix[x1][y_2 + 1] - prefix[x2 + 1][y1] + prefix[x1][y1]$，但是这样需要枚举 $x_1, y_1, x_2, y_2$，时间复杂度是 $O(n^4)$。 其实还有一种方案，可以转换为一维前缀和。我们可以先枚举矩形的左边界和右边界，当左边界和右边界都确定下来之后，就可以用一维前缀和的思路去解决了，当然，这里我们需要预先处理出每行数据的一维前缀和。时间复杂度为 $O(n^3)$。 363. 矩形区域不超过 K 的最大数值和 (Hard) 的解法是类似的。 ","date":"2023-10-13","objectID":"/1074.number-of-submatrices-that-sum-to-target.zh/:2:0","series":null,"tags":["prefix sum","tips"],"title":"1074. 元素和为目标值的子矩阵数量 (Hard)","uri":"/1074.number-of-submatrices-that-sum-to-target.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int numSubmatrixSumTarget(vector\u003cvector\u003cint\u003e\u003e \u0026matrix, int target) { // 二维前缀和 // 枚举左右边界，转换为一维前缀和 int m = matrix.size(), n = matrix[0].size(); vector\u003cvector\u003cint\u003e\u003e rowsum(m, vector\u003cint\u003e(n + 1)); int res = 0; for (int i = 0; i \u003c m; ++i) { for (int j = 1; j \u003c= n; ++j) { rowsum[i][j] = rowsum[i][j - 1] + matrix[i][j - 1]; } } for (int i = 0; i \u003c n; ++i) { for (int j = i + 1; j \u003c= n; ++j) { // 左闭右开 unordered_map\u003cint, int\u003e record; record[0] = 1; int sum = 0; for (int k = 1; k \u003c= m; ++k) { sum += rowsum[k - 1][j] - rowsum[k - 1][i]; if (record.find(sum - target) != record.end()) { res += record[sum - target]; } ++record[sum]; } } } return res; } }; ","date":"2023-10-13","objectID":"/1074.number-of-submatrices-that-sum-to-target.zh/:3:0","series":null,"tags":["prefix sum","tips"],"title":"1074. 元素和为目标值的子矩阵数量 (Hard)","uri":"/1074.number-of-submatrices-that-sum-to-target.zh/#代码"},{"categories":[""],"content":" 1 Descriptio2251. Number of Flowers in Full Bloom (Hard) You are given a 0-indexed 2D integer array flowers, where flowers[i] = [startᵢ, endᵢ] means the iᵗʰ flower will be in full bloom from startᵢ to endᵢ ( inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the iᵗʰ person will arrive to see the flowers. Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the iᵗʰ person arrives. Example 1: text Input: flowers = [[1,6],[3,7],[9,12],[4,13]], poeple = [2,3,7,11] Output: [1,2,2,2] Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive. For each person, we return the number of flowers in full bloom during their arrival. Example 2: text Input: flowers = [[1,10],[3,3]], poeple = [3,3,2] Output: [2,2,1] Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive. For each person, we return the number of flowers in full bloom during their arrival. Constraints: 1 \u003c= flowers.length \u003c= 5 * 10⁴ flowers[i].length == 2 1 \u003c= startᵢ \u003c= endᵢ \u003c= 10⁹ 1 \u003c= people.length \u003c= 5 * 10⁴ 1 \u003c= people[i] \u003c= 10⁹ ","date":"2023-10-06","objectID":"/2251.number-of-flowers-in-full-bloom/:1:0","series":null,"tags":[""],"title":"2251. Number of Flowers in Full Bloom (Hard)","uri":"/2251.number-of-flowers-in-full-bloom/#descriptio"},{"categories":[""],"content":" 2 SolutionDivide the flowers array into two arrays: one representing the time when flowers bloom and the other for the time when they wither, both sorted in ascending order. Subsequently, for each query, one merely needs to determine how many flowers have bloomed by the current time and how many have withered. Given the sorted nature of these arrays, binary search can be employed for efficient implementation. ","date":"2023-10-06","objectID":"/2251.number-of-flowers-in-full-bloom/:2:0","series":null,"tags":[""],"title":"2251. Number of Flowers in Full Bloom (Hard)","uri":"/2251.number-of-flowers-in-full-bloom/#solution"},{"categories":[""],"content":" 3 Code cpp class Solution { public: int upper(vector\u003cint\u003e \u0026arr, int time) { int l = 0, r = arr.size(); while (l \u003c r) { int mid = l + (r - l) / 2; if (arr[mid] \u003c= time) { l = mid + 1; } else { r = mid; } } return l; } int lower(vector\u003cint\u003e \u0026arr, int time) { int l = 0, r = arr.size(); while (l \u003c r) { int mid = l + (r - l) / 2; if (arr[mid] \u003c time) { l = mid + 1; } else { r = mid; } } return l; } vector\u003cint\u003e fullBloomFlowers(vector\u003cvector\u003cint\u003e\u003e \u0026flowers, vector\u003cint\u003e \u0026people) { // 二分 int n = flowers.size(); vector\u003cint\u003e start(n), end(n); for (int i = 0; i \u003c n; ++i) { start[i] = flowers[i][0]; end[i] = flowers[i][1]; } sort(start.begin(), start.end()); sort(end.begin(), end.end()); vector\u003cint\u003e ans; for (int time : people) { int res = upper(start, time) - lower(end, time); ans.push_back(res); } return ans; } }; ","date":"2023-10-06","objectID":"/2251.number-of-flowers-in-full-bloom/:3:0","series":null,"tags":[""],"title":"2251. Number of Flowers in Full Bloom (Hard)","uri":"/2251.number-of-flowers-in-full-bloom/#code"},{"categories":[""],"content":" 1 问题描述2251. 花期内花的数目 (Hard) 给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [startᵢ, endᵢ] 表示第 i 朵 花的 花期 从 startᵢ 到 endᵢ （都 包含）。同时给你一个下标从 0 开始大小为 n 的整数 数组 people ， people[i] 是第 i 个人来看花的时间。 请你返回一个大小为 n 的整数数组 answer ，其中 answer[i] 是第 i 个人到达时在花期内花的 **数目 ** 。 示例 1： text 输入：flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11] 输出：[1,2,2,2] 解释：上图展示了每朵花的花期时间，和每个人的到达时间。 对每个人，我们返回他们到达时在花期内花的数目。 示例 2： text 输入：flowers = [[1,10],[3,3]], people = [3,3,2] 输出：[2,2,1] 解释：上图展示了每朵花的花期时间，和每个人的到达时间。 对每个人，我们返回他们到达时在花期内花的数目。 提示： 1 \u003c= flowers.length \u003c= 5 * 10⁴ flowers[i].length == 2 1 \u003c= startᵢ \u003c= endᵢ \u003c= 10⁹ 1 \u003c= people.length \u003c= 5 * 10⁴ 1 \u003c= people[i] \u003c= 10⁹ ","date":"2023-10-06","objectID":"/2251.number-of-flowers-in-full-bloom.zh/:1:0","series":null,"tags":[""],"title":"2251. 花期内花的数目 (Hard)","uri":"/2251.number-of-flowers-in-full-bloom.zh/#问题描述"},{"categories":[""],"content":" 2 解题思路","date":"2023-10-06","objectID":"/2251.number-of-flowers-in-full-bloom.zh/:2:0","series":null,"tags":[""],"title":"2251. 花期内花的数目 (Hard)","uri":"/2251.number-of-flowers-in-full-bloom.zh/#解题思路"},{"categories":[""],"content":" 2.1 二分将 flowers 数组拆分成花朵开花时间的数组和枯萎时间的数组，均按照时间升序排列。 那么，对每一个查询，我们只需要查询到当前时间，有多少花朵盛开，以及有多少花朵枯萎即可，由于是有序数组，可以使用二分查找来实现。 ","date":"2023-10-06","objectID":"/2251.number-of-flowers-in-full-bloom.zh/:2:1","series":null,"tags":[""],"title":"2251. 花期内花的数目 (Hard)","uri":"/2251.number-of-flowers-in-full-bloom.zh/#二分"},{"categories":[""],"content":" 2.2 差分差分需要对花朵的盛开与枯萎时间进行离散化，使其分别对应一个下标。 离散化的方案类似于 327. 区间和的个数 ","date":"2023-10-06","objectID":"/2251.number-of-flowers-in-full-bloom.zh/:2:2","series":null,"tags":[""],"title":"2251. 花期内花的数目 (Hard)","uri":"/2251.number-of-flowers-in-full-bloom.zh/#差分"},{"categories":[""],"content":" 3 代码 cpp class Solution { public: int upper(vector\u003cint\u003e \u0026arr, int time) { int l = 0, r = arr.size(); while (l \u003c r) { int mid = l + (r - l) / 2; if (arr[mid] \u003c= time) { l = mid + 1; } else { r = mid; } } return l; } int lower(vector\u003cint\u003e \u0026arr, int time) { int l = 0, r = arr.size(); while (l \u003c r) { int mid = l + (r - l) / 2; if (arr[mid] \u003c time) { l = mid + 1; } else { r = mid; } } return l; } vector\u003cint\u003e fullBloomFlowers(vector\u003cvector\u003cint\u003e\u003e \u0026flowers, vector\u003cint\u003e \u0026people) { // 二分 int n = flowers.size(); vector\u003cint\u003e start(n), end(n); for (int i = 0; i \u003c n; ++i) { start[i] = flowers[i][0]; end[i] = flowers[i][1]; } sort(start.begin(), start.end()); sort(end.begin(), end.end()); vector\u003cint\u003e ans; for (int time : people) { int res = upper(start, time) - lower(end, time); ans.push_back(res); } return ans; } }; ","date":"2023-10-06","objectID":"/2251.number-of-flowers-in-full-bloom.zh/:3:0","series":null,"tags":[""],"title":"2251. 花期内花的数目 (Hard)","uri":"/2251.number-of-flowers-in-full-bloom.zh/#代码"},{"categories":["notes"],"content":" 1 介绍考虑原数组为 $[1, 3, 3, 5, 8]$，我们对相邻元素做差，用 $a_i - a_{i - 1}$，可以得到一个差分数组 $[1, 2, 0, 2, 3]$ $diff$，我们认为 $a_{-1}$ 为 $0$，因此 $$diff[i] = \\begin{cases} a[0] \u0026 i = 0 \\newline a[i] - a[i - 1] \u0026 i \u003e 0\\end{cases}$$ ","date":"2023-10-06","objectID":"/difference_array.zh/:1:0","series":null,"tags":["data structure and algorithms","difference array"],"title":"差分数组","uri":"/difference_array.zh/#介绍"},{"categories":["notes"],"content":" 2 性质差分数组往往和前缀和数组放在一块讨论，事实上，差分数组的前缀和即可还原出原数组。即： $$ a[k] = \\sum\\limits_{i = 0}^k diff[i]$$ 差分数组还有一个非常重要的性质，那就是它可以将区间修改（将区间中的每个元素都加一个值或者减一个值）变成单点修改。 例如，加入我们要将区间 $[i, j]$ 中的每个元素都加 $c$，那么我们只需要将 $diff[i]$ 加 $c$，并将 $diff[j + 1]$ 减去 $c$ 即可，由这个差分数组取前缀和还原出来的原数组，就是我们修改后的原数组。 ","date":"2023-10-06","objectID":"/difference_array.zh/:2:0","series":null,"tags":["data structure and algorithms","difference array"],"title":"差分数组","uri":"/difference_array.zh/#性质"},{"categories":["leetcode"],"content":" 1 Descriptio","date":"2023-10-05","objectID":"/2136.earliest-possible-day-of-full-bloom/:1:0","series":null,"tags":["greedy algorithm"],"title":"2136.earliest Possible Day of Full Bloom","uri":"/2136.earliest-possible-day-of-full-bloom/#descriptio"},{"categories":["leetcode"],"content":" 2136. Earliest Possible Day of Full Bloom (Hard)You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each: plantTime[i] is the number of full days it takes you to plant the iᵗʰ seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total. growTime[i] is the number of full days it takes the iᵗʰ seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever. From the beginning of day 0, you can plant the seeds in any order. Return the earliest possible day where all seeds are blooming. Example 1: text Input: plantTime = [1,4,3], growTime = [2,3,1] Output: 9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms. One optimal way is: On day 0, plant the 0ᵗʰ seed. The seed grows for 2 full days and blooms on day 3. On days 1, 2, 3, and 4, plant the 1ˢᵗ seed. The seed grows for 3 full days and blooms on day 8. On days 5, 6, and 7, plant the 2ⁿᵈ seed. The seed grows for 1 full day and blooms on day 9. Thus, on day 9, all the seeds are blooming. Example 2: text Input: plantTime = [1,2,3,2], growTime = [2,1,2,1] Output: 9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms. One optimal way is: On day 1, plant the 0ᵗʰ seed. The seed grows for 2 full days and blooms on day 4. On days 0 and 3, plant the 1ˢᵗ seed. The seed grows for 1 full day and blooms on day 5. On days 2, 4, and 5, plant the 2ⁿᵈ seed. The seed grows for 2 full days and blooms on day 8. On days 6 and 7, plant the 3ʳᵈ seed. The seed grows for 1 full day and blooms on day 9. Thus, on day 9, all the seeds are blooming. Example 3: text Input: plantTime = [1], growTime = [1] Output: 2 Explanation: On day 0, plant the 0ᵗʰ seed. The seed grows for 1 full day and blooms on day 2. Thus, on day 2, all the seeds are blooming. Constraints: n == plantTime.length == growTime.length 1 \u003c= n \u003c= 10⁵ 1 \u003c= plantTime[i], growTime[i] \u003c= 10⁴ ","date":"2023-10-05","objectID":"/2136.earliest-possible-day-of-full-bloom/:0:0","series":null,"tags":["greedy algorithm"],"title":"2136.earliest Possible Day of Full Bloom","uri":"/2136.earliest-possible-day-of-full-bloom/#2136-earliest-possible-day-of-full-bloomlink-hard"},{"categories":["leetcode"],"content":" 1 SolutionTo commence, let us establish that cross-seeding does not yield a more optimal timeframe: Let us assume two seeds, denoted as $a$ and $b$. Without cross-seeding, we proceed by either planting $a$ first and then $b,\" or vice versa. This is due to the fact that when cross-seeding, the completion time for the first seed is delayed, while the planting time for the second seed remains unchanged. Hence, it is implausible for this practice to result in a more favorable timeframe. This rationale extends to scenarios involving multiple seeds. Furthermore, let us substantiate the necessity of prioritizing the seed with the maximum $growtime.$ This is because the total planting time remains constant. Consequently, at a minimum, it requires $totalplanttime + growtime_x$ time, where $x$ represents the last planted seed. Thus, for the final seed planted, a smaller $growtime$ is more favorable. By tracing this reasoning backwards, it becomes evident that $growtime$ should systematically decrease in a sequential fashion. ","date":"2023-10-05","objectID":"/2136.earliest-possible-day-of-full-bloom/:1:0","series":null,"tags":["greedy algorithm"],"title":"2136.earliest Possible Day of Full Bloom","uri":"/2136.earliest-possible-day-of-full-bloom/#solution"},{"categories":["leetcode"],"content":" 2 Code cpp class Solution { public: int earliestFullBloom(vector\u003cint\u003e \u0026plantTime, vector\u003cint\u003e \u0026growTime) { int time = accumulate(plantTime.begin(), plantTime.end(), 0); int cur = 0; int n = plantTime.size(); vector\u003cint\u003e ids(n); for (int i = 0; i \u003c n; ++i) { ids[i] = i; } auto cmp = [\u0026growTime](int i, int j) { return growTime[i] \u003e growTime[j]; }; sort(ids.begin(), ids.end(), cmp); for (int i = 0; i \u003c n; ++i) { int idx = ids[i]; cur += plantTime[idx]; time = max(time, cur + growTime[idx]); } return time; } }; ","date":"2023-10-05","objectID":"/2136.earliest-possible-day-of-full-bloom/:2:0","series":null,"tags":["greedy algorithm"],"title":"2136.earliest Possible Day of Full Bloom","uri":"/2136.earliest-possible-day-of-full-bloom/#code"},{"categories":["leetcode"],"content":" 1 问题描述2136. 全部开花的最早一天 (Hard) 你有 n 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你 两个下标从 0 开始的整数数组 plantTime 和 growTime ，每个数组的长度都是 n ： plantTime[i] 是 播种 第 i 枚种子所需的 完整天数 。每天，你只能为播种某一枚种子而劳作。 无须 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 plantTime[i] 之后才算完成。 growTime[i] 是第 i 枚种子完全种下后生长所需的 完整天数。在它生长的最后一天 之后 ，将会 开花并且永远 绽放 。 从第 0 开始，你可以按 任意 顺序播种种子。 返回所有种子都开花的 最早 一天是第几天。 示例 1： text 输入：plantTime = [1,4,3], growTime = [2,3,1] 输出：9 解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 一种最优方案是： 第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。 第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。 第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。 因此，在第 9 天，所有种子都开花。 示例 2： text 输入：plantTime = [1,2,3,2], growTime = [2,1,2,1] 输出：9 解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 一种最优方案是： 第 1 天，播种第 0 枚种子，种子生长 2 整天。并在第 4 天开花。 第 0、3 天，播种第 1 枚种子。种子生长 1 整天，并在第 5 天开花。 第 2、4、5 天，播种第 2 枚种子。种子生长 2 整天，并在第 8 天开花。 第 6、7 天，播种第 3 枚种子。种子生长 1 整天，并在第 9 天开花。 因此，在第 9 天，所有种子都开花。 示例 3： text 输入：plantTime = [1], growTime = [1] 输出：2 解释：第 0 天，播种第 0 枚种子。种子需要生长 1 整天，然后在第 2 天开花。 因此，在第 2 天，所有种子都开花。 提示： n == plantTime.length == growTime.length 1 \u003c= n \u003c= 10⁵ 1 \u003c= plantTime[i], growTime[i] \u003c= 10⁴ ","date":"2023-10-05","objectID":"/2136.earliest-possible-day-of-full-bloom.zh/:1:0","series":null,"tags":["greedy algorithm"],"title":"2136. 全部开花的最早一天 (Hard)","uri":"/2136.earliest-possible-day-of-full-bloom.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先证明，交叉播种，不会使得时间更优： 我们假设两个种子 $a$ 和 $b$，假设不交叉播种，即先种完 $a$ 再种 $b$，或者先种完 $b$，再种 $a$，这是因为交叉种植时，第一颗种子的播种完成时间被延后了，但是第二颗种子的播种时间不变，因此不可能使得时间更优，可以推广到多个种子的情形。 再证明要优先种植 $growtime$ 最大的种子，这是因为总的播种时间是一定的，因此至少需要 $totalplanttime + growtime_x$ 的时间，$x$ 表示最后一个种植的种子，因此，最后一个种植的种子，$growtime$ 越小越好，从最后一个依次往前推，可得 $growtime$ 应当依次递减。 ","date":"2023-10-05","objectID":"/2136.earliest-possible-day-of-full-bloom.zh/:2:0","series":null,"tags":["greedy algorithm"],"title":"2136. 全部开花的最早一天 (Hard)","uri":"/2136.earliest-possible-day-of-full-bloom.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int earliestFullBloom(vector\u003cint\u003e \u0026plantTime, vector\u003cint\u003e \u0026growTime) { int time = accumulate(plantTime.begin(), plantTime.end(), 0); int cur = 0; int n = plantTime.size(); vector\u003cint\u003e ids(n); for (int i = 0; i \u003c n; ++i) { ids[i] = i; } auto cmp = [\u0026growTime](int i, int j) { return growTime[i] \u003e growTime[j]; }; sort(ids.begin(), ids.end(), cmp); for (int i = 0; i \u003c n; ++i) { int idx = ids[i]; cur += plantTime[idx]; time = max(time, cur + growTime[idx]); } return time; } }; ","date":"2023-10-05","objectID":"/2136.earliest-possible-day-of-full-bloom.zh/:3:0","series":null,"tags":["greedy algorithm"],"title":"2136. 全部开花的最早一天 (Hard)","uri":"/2136.earliest-possible-day-of-full-bloom.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description188. Best Time to Buy and Sell Stock IV (Hard) You are given an integer array prices where prices[i] is the price of a given stock on the iᵗʰ day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: text Input: k = 2, prices = [2,4,1] Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: text Input: k = 2, prices = [3,2,6,5,0,3] Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Constraints: 1 \u003c= k \u003c= 100 1 \u003c= prices.length \u003c= 1000 0 \u003c= prices[i] \u003c= 1000 ","date":"2023-10-05","objectID":"/188.best-time-to-buy-and-sell-stock-iv/:1:0","series":null,"tags":["dynamic programming"],"title":"188. Best Time to Buy and Sell Stock IV (Hard)","uri":"/188.best-time-to-buy-and-sell-stock-iv/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirstly, we may categorize the status of stocks into two states: the acquired and unheld states. Given that a maximum of $k$ transactions can be executed, we thereby have a total of $2k$ potential states. Hence, it is plausible to instantiate an array as follows: vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(2 * k + 1)). Employing dynamic programming, this conundrum is resolvable. The rationale behind selecting an array length of $2k + 1$ is to accommodate negative indices when transitioning from known states. 123. Best Time to Buy and Sell Stock III and 309. Best Time to Buy and Sell Stock with Cooldown both lend themselves to analogous problem-solving approaches. ","date":"2023-10-05","objectID":"/188.best-time-to-buy-and-sell-stock-iv/:2:0","series":null,"tags":["dynamic programming"],"title":"188. Best Time to Buy and Sell Stock IV (Hard)","uri":"/188.best-time-to-buy-and-sell-stock-iv/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maxProfit(int k, vector\u003cint\u003e \u0026prices) { vector\u003cvector\u003cint\u003e\u003e dp(prices.size() + 1, vector\u003cint\u003e(2 * k + 1, 0)); for (int j = 1; j \u003c= 2 * k; j++) { if (j % 2 == 1) dp[0][j] = -prices[0]; } for (int i = 1; i \u003c= prices.size(); i++) { for (int j = 1; j \u003c= 2 * k; j++) { if (j % 2 == 1) dp[i][j] = max(dp[i - 1][j - 1] - prices[i - 1], dp[i - 1][j]); else dp[i][j] = max(dp[i - 1][j - 1] + prices[i - 1], dp[i - 1][j]); } } return dp[prices.size()][2 * k]; } }; ","date":"2023-10-05","objectID":"/188.best-time-to-buy-and-sell-stock-iv/:3:0","series":null,"tags":["dynamic programming"],"title":"188. Best Time to Buy and Sell Stock IV (Hard)","uri":"/188.best-time-to-buy-and-sell-stock-iv/#code"},{"categories":["leetcode"],"content":" 1 问题描述188. 买卖股票的最佳时机 IV (Hard) 给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。 注意： 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： text 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： text 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获 得利润 = 3-0 = 3 。 提示： 1 \u003c= k \u003c= 100 1 \u003c= prices.length \u003c= 1000 0 \u003c= prices[i] \u003c= 1000 ","date":"2023-10-05","objectID":"/188.best-time-to-buy-and-sell-stock-iv.zh/:1:0","series":null,"tags":["dynamic programming"],"title":"188. 买卖股票的最佳时机 IV (Hard)","uri":"/188.best-time-to-buy-and-sell-stock-iv.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，我们可以将股票的状态分为已买入以及未持有两种状态，由于最多可以完成 $k$ 比交易，那么我们一共可以有 $2k$ 种状态。 因此可以创建一个 vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(2 * k + 1)) 的数组，使用动态规划来解决，之所以数组长度是 $2k + 1$，是为了从已知状态转移时下标出现负数。 123. 买卖股票的最佳时机 III 和 309. 买卖股票的最佳时机含冷冻期 都可以使用类似的思路来解决。 ","date":"2023-10-05","objectID":"/188.best-time-to-buy-and-sell-stock-iv.zh/:2:0","series":null,"tags":["dynamic programming"],"title":"188. 买卖股票的最佳时机 IV (Hard)","uri":"/188.best-time-to-buy-and-sell-stock-iv.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxProfit(int k, vector\u003cint\u003e \u0026prices) { vector\u003cvector\u003cint\u003e\u003e dp(prices.size() + 1, vector\u003cint\u003e(2 * k + 1, 0)); for (int j = 1; j \u003c= 2 * k; j++) { if (j % 2 == 1) dp[0][j] = -prices[0]; } for (int i = 1; i \u003c= prices.size(); i++) { for (int j = 1; j \u003c= 2 * k; j++) { if (j % 2 == 1) dp[i][j] = max(dp[i - 1][j - 1] - prices[i - 1], dp[i - 1][j]); else dp[i][j] = max(dp[i - 1][j - 1] + prices[i - 1], dp[i - 1][j]); } } return dp[prices.size()][2 * k]; } }; ","date":"2023-10-05","objectID":"/188.best-time-to-buy-and-sell-stock-iv.zh/:3:0","series":null,"tags":["dynamic programming"],"title":"188. 买卖股票的最佳时机 IV (Hard)","uri":"/188.best-time-to-buy-and-sell-stock-iv.zh/#代码"},{"categories":["dfs"],"content":" 1 Description310. Minimum Height Trees (Medium) A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [aᵢ, bᵢ] indicates that there is an undirected edge between the two nodes aᵢ and bᵢ in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h)) are called minimum height trees (MHTs). Return a list of all MHTs$ root labels. You can return the answer in any order. The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. Example 1: text Input: n = 4, edges = [[1,0],[1,2],[1,3]] Output: [1] Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT. Example 2: text Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] Output: [3,4] Constraints: 1 \u003c= n \u003c= 2 * 10⁴ edges.length == n - 1 0 \u003c= aᵢ, bᵢ \u003c n aᵢ != bᵢ All the pairs (aᵢ, bᵢ) are distinct. The given input is guaranteed to be a tree and there will be no repeated edges. ","date":"2023-09-19","objectID":"/310.minimum-height-trees/:1:0","series":null,"tags":["tree","dfs","bfs","dynamic programming"],"title":"310. Minimum Height Trees (Medium)","uri":"/310.minimum-height-trees/#description"},{"categories":["dfs"],"content":" 2 SolutionInitially, we designate node 0 as the root node and compute the maximum height $f$ for each subtree. Here, $f(pa)$ signifies the maximum height for the subtree rooted at node $pa$, and $f(u)$ denotes the maximum height for the subtree rooted at node $u$. The maximum height for the subtree rooted at $u$ can be determined as the maximum among the following values: The maximum height for the subtree rooted at $u$, i.e., $f(u)$. This represents the maximum height attainable in the current tree structure with $u$ pointing towards its child nodes. The maximum height attainable towards the parent node $pa$, denoted as $g(u)$. $g(pa) + 1$, which corresponds to the maximum height achievable in the direction from $pa$ towards its parent node. $h_{pa}$, representing the maximum height achievable from $pa$ downwards (but not in the direction of $u$). If $f(pa)$ is achieved in the direction from $pa$ to $u$, then $h_{pa} = f_2(pa) + 1$. Otherwise, $h_{pa} = f(pa) + 1$. Here, $f_2(pa)$ signifies the second-largest height for the subtree rooted at $pa$. Importantly, we require that the subtree associated with the second-largest height $f_2$ and the subtree corresponding to the maximum height $f$ should not share the same child node. Consequently, when calculating $f$, we must keep track of which child node of $pa$ contributes to $f(pa)$. Additionally, we need to compute $f_2$. In cases where $pa$ has only one child node $u$, $f_2(pa)$ is set to 1, and $f(pa) = f(u) + 1$. ","date":"2023-09-19","objectID":"/310.minimum-height-trees/:2:0","series":null,"tags":["tree","dfs","bfs","dynamic programming"],"title":"310. Minimum Height Trees (Medium)","uri":"/310.minimum-height-trees/#solution"},{"categories":["dfs"],"content":" 3 code cpp class Solution { public: using pii = pair\u003cint, int\u003e; pii geth(vector\u003cvector\u003cint\u003e\u003e \u0026graph, int parent, vector\u003cint\u003e \u0026max_idx, int cur, vector\u003cpii\u003e \u0026heights) { int hmx = 1, hnd = 0; // max, second for (int idx : graph[cur]) { if (idx == parent) { continue; } auto [h1, h2] = geth(graph, cur, max_idx, idx, heights); if (h1 + 1 \u003e= hmx) { hnd = hmx; hmx = h1 + 1; max_idx[cur] = idx; } else if (h1 + 1 \u003e= hnd) { hnd = h1 + 1; } } heights[cur] = {hmx, hnd}; return {hmx, hnd}; } void bfs(vector\u003cvector\u003cint\u003e\u003e \u0026graph, int parent, vector\u003cint\u003e \u0026max_idx, int cur, vector\u003cpii\u003e \u0026heights, vector\u003cint\u003e \u0026res) { queue\u003ctuple\u003cint, int, int\u003e\u003e q; q.push({0, heights[0].first, 1}); vector\u003cint\u003e vis(graph.size()); vis[0] = 1; while (!q.empty()) { auto [idx, f_idx, g_idx] = q.front(); res[idx] = max(res[idx], max(f_idx, g_idx)); q.pop(); for (int next : graph[idx]) { if (vis[next] == 1) { continue; } vis[next] = 1; int gpa = 0; if (max_idx[idx] == next) { // gpa = heights[idx].second + 1; // } else { gpa = heights[idx].first + 1; } q.push({next, heights[next].first, max(g_idx + 1, gpa)}); } } } vector\u003cint\u003e findMinHeightTrees(int n, vector\u003cvector\u003cint\u003e\u003e \u0026edges) { vector\u003cvector\u003cint\u003e\u003e graph(n); for (auto \u0026vec : edges) { graph[vec[0]].push_back(vec[1]); graph[vec[1]].push_back(vec[0]); } vector\u003cpii\u003e heights(n); vector\u003cint\u003e max_idx(n); geth(graph, 0, max_idx, 0, heights); vector\u003cint\u003e res(n); bfs(graph, 0, max_idx, 0, heights, res); int min_res = 1e5; for (int i = 0; i \u003c n; ++i) { min_res = min(min_res, res[i]); } cout \u003c\u003c endl; vector\u003cint\u003e ans; for (int i = 0; i \u003c n; ++i) { if (res[i] == min_res) { ans.push_back(i); } } return ans; } }; ","date":"2023-09-19","objectID":"/310.minimum-height-trees/:3:0","series":null,"tags":["tree","dfs","bfs","dynamic programming"],"title":"310. Minimum Height Trees (Medium)","uri":"/310.minimum-height-trees/#code"},{"categories":["dfs"],"content":" 1 问题描述310. 最小高度树 (Medium) 树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵 树。 给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条无 向边。 可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中， 具有最小高度的树（即， min(h)）被称为 最小高度树 。 请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。 树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。 示例 1： text 输入：n = 4, edges = [[1,0],[1,2],[1,3]] 输出：[1] 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 示例 2： text 输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] 输出：[3,4] 提示： 1 \u003c= n \u003c= 2 * 10⁴ edges.length == n - 1 0 \u003c= aᵢ, bᵢ \u003c n aᵢ != bᵢ 所有 (aᵢ, bᵢ) 互不相同 给定的输入 保证 是一棵树，并且 不会有重复的边 ","date":"2023-09-19","objectID":"/310.minimum-height-trees.zh/:1:0","series":null,"tags":["tree","dfs","bfs","dynamic programming"],"title":"310. 最小高度树 (Medium)","uri":"/310.minimum-height-trees.zh/#问题描述"},{"categories":["dfs"],"content":" 2 解题思路 首先，我们以节点 0 为根结点，计算出每个子树的最大高度 $f$。即 $f(pa)$ 表示以结点 pa 为根结点的子树的最大高度，$f(u)$ 表示以结点 u 为根结点的子树的最大高度。 那么，以 u 为根结点的子树的最大高度，由以下几个值的最大值取得： 以 u 为根结点的子树的最大高度，即 $f(u)$，这个是当前树结构下，u 往子结点的方向所能取到的最大高度； u 向父结点，即 pa 的方向所能取到的最大高度，记为 $g(u)$； $g(pa) + 1$，即 pa 往它的父结点的方向所能取到的最大高度； pa 向下（但是不往 u 的方向）所能取到的最大高度 $h_{pa}$； 如果 $f(pa)$ 是由 pa 到 u 的方向取得的，那么 $h_{pa} = f_2(pa) + 1$ 否则 $h_{pa} = f(pa) + 1$ 其中，$f_2(pa)$ 表示以 pa 为根结点的子树的次大高度，这里我们要求次大高度对应的 pa 的子结点与最大高度对应的子结点不能是同一个子结点，因此我们在求 $f$ 的时候，必须记录 $f(pa)$ 由哪个子结点取得，同时我们还要求 $f_2$。 即如果 pa 只有一个子结点 u，那么 $f_2(pa) = 1$，$f(pa) = f(u) + 1$。 ","date":"2023-09-19","objectID":"/310.minimum-height-trees.zh/:2:0","series":null,"tags":["tree","dfs","bfs","dynamic programming"],"title":"310. 最小高度树 (Medium)","uri":"/310.minimum-height-trees.zh/#解题思路"},{"categories":["dfs"],"content":" 3 代码 cpp class Solution { public: using pii = pair\u003cint, int\u003e; pii geth(vector\u003cvector\u003cint\u003e\u003e \u0026graph, int parent, vector\u003cint\u003e \u0026max_idx, int cur, vector\u003cpii\u003e \u0026heights) { int hmx = 1, hnd = 0; // 最大值与次大值 for (int idx : graph[cur]) { if (idx == parent) { continue; } auto [h1, h2] = geth(graph, cur, max_idx, idx, heights); if (h1 + 1 \u003e= hmx) { hnd = hmx; hmx = h1 + 1; max_idx[cur] = idx; } else if (h1 + 1 \u003e= hnd) { hnd = h1 + 1; } } heights[cur] = {hmx, hnd}; return {hmx, hnd}; } void bfs(vector\u003cvector\u003cint\u003e\u003e \u0026graph, int parent, vector\u003cint\u003e \u0026max_idx, int cur, vector\u003cpii\u003e \u0026heights, vector\u003cint\u003e \u0026res) { queue\u003ctuple\u003cint, int, int\u003e\u003e q; q.push({0, heights[0].first, 1}); vector\u003cint\u003e vis(graph.size()); vis[0] = 1; while (!q.empty()) { auto [idx, f_idx, g_idx] = q.front(); res[idx] = max(res[idx], max(f_idx, g_idx)); q.pop(); // 还需要一个 visit 数组 for (int next : graph[idx]) { if (vis[next] == 1) { continue; } vis[next] = 1; int gpa = 0; if (max_idx[idx] == next) { // 最大值从 next 取到 gpa = heights[idx].second + 1; // 次大值 + 1 } else { gpa = heights[idx].first + 1; } q.push({next, heights[next].first, max(g_idx + 1, gpa)}); // cout \u003c\u003c next \u003c\u003c \" \" \u003c\u003c heights[next].first \u003c\u003c \" \" \u003c\u003c g_idx + 1 \u003c\u003c \" \" \u003c\u003c gpa \u003c\u003c endl; } } } vector\u003cint\u003e findMinHeightTrees(int n, vector\u003cvector\u003cint\u003e\u003e \u0026edges) { // 求一个根结点的最大高度和次大高度 vector\u003cvector\u003cint\u003e\u003e graph(n); for (auto \u0026vec : edges) { graph[vec[0]].push_back(vec[1]); graph[vec[1]].push_back(vec[0]); } vector\u003cpii\u003e heights(n); vector\u003cint\u003e max_idx(n); geth(graph, 0, max_idx, 0, heights); vector\u003cint\u003e res(n); bfs(graph, 0, max_idx, 0, heights, res); int min_res = 1e5; for (int i = 0; i \u003c n; ++i) { min_res = min(min_res, res[i]); } cout \u003c\u003c endl; vector\u003cint\u003e ans; for (int i = 0; i \u003c n; ++i) { if (res[i] == min_res) { ans.push_back(i); } } return ans; } }; ","date":"2023-09-19","objectID":"/310.minimum-height-trees.zh/:3:0","series":null,"tags":["tree","dfs","bfs","dynamic programming"],"title":"310. 最小高度树 (Medium)","uri":"/310.minimum-height-trees.zh/#代码"},{"categories":[""],"content":" 1 Description331. Verify Preorder Serialization of a Binary Tree (Medium) One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as '#'. For example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where '#' represents a null node. Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree. It is guaranteed that each comma-separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid. For example, it could never contain two consecutive commas, such as \"1,,3\". Note: You are not allowed to reconstruct the tree. Example 1: text Input: preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\" Output: true Example 2: text Input: preorder = \"1,#\" Output: false Example 3: text Input: preorder = \"9,#,#,1\" Output: false Constraints: 1 \u003c= preorder.length \u003c= 10⁴ preorder consist of integers in the range [0, 100] and '#' separated by commas ','. ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree/:1:0","series":null,"tags":[""],"title":"331. Verify Preorder Serialization of a Binary Tree (Medium)","uri":"/331.verify-preorder-serialization-of-a-binary-tree/#description"},{"categories":[""],"content":" 2 Solution","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree/:2:0","series":null,"tags":[""],"title":"331. Verify Preorder Serialization of a Binary Tree (Medium)","uri":"/331.verify-preorder-serialization-of-a-binary-tree/#solution"},{"categories":[""],"content":" 2.1 ReductionEssentially, this approach remains rooted in recursive thinking. During the pre-order traversal, it is noticeable that each leaf node is invariably followed by two null nodes. Therefore, we can reverse this process by reducing a continuous sequence of one non-empty node and two empty nodes into a single empty node. This process somewhat resembles a match-three game and can be implemented using a stack. In the end, we can determine whether there is only one remaining empty node in the stack to make the final judgment. ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree/:2:1","series":null,"tags":[""],"title":"331. Verify Preorder Serialization of a Binary Tree (Medium)","uri":"/331.verify-preorder-serialization-of-a-binary-tree/#reduction"},{"categories":[""],"content":" 2.2 RecursionThe recursive approach draws inspiration from 剑指 Offer 37. 序列化二叉树 (Hard). However, the key difference lies in the fact that we only need to determine whether the left subtree and right subtree meet the requirements, without the necessity of returning their root nodes. ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree/:2:2","series":null,"tags":[""],"title":"331. Verify Preorder Serialization of a Binary Tree (Medium)","uri":"/331.verify-preorder-serialization-of-a-binary-tree/#recursion"},{"categories":[""],"content":" 3 Code","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree/:3:0","series":null,"tags":[""],"title":"331. Verify Preorder Serialization of a Binary Tree (Medium)","uri":"/331.verify-preorder-serialization-of-a-binary-tree/#code"},{"categories":[""],"content":" 3.1 Reduction cpp class Solution { public: void string2vec(string \u0026preorder, vector\u003cstring\u003e \u0026strs) { for (int i = 0; i \u003c preorder.size(); ++i) { int r = i; while (r \u003c preorder.size() \u0026\u0026 preorder[r] != ',') { ++r; } strs.push_back(preorder.substr(i, r - i)); i = r; } } bool isValidSerialization(string preorder) { vector\u003cstring\u003e strs; string2vec(preorder, strs); int n = strs.size(); stack\u003cstring\u003e stk; for (int i = 0; i \u003c n; ++i) { if (strs[i] != \"#\") { stk.push(strs[i]); } else { while (stk.size() \u003e= 2 \u0026\u0026 stk.top() == \"#\") { stk.pop(); if (stk.top() == \"#\") { return false; } stk.pop(); } stk.push(\"#\"); } } return stk.size() == 1 \u0026\u0026 stk.top() == \"#\"; } }; ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree/:3:1","series":null,"tags":[""],"title":"331. Verify Preorder Serialization of a Binary Tree (Medium)","uri":"/331.verify-preorder-serialization-of-a-binary-tree/#reduction-1"},{"categories":[""],"content":" 4 Recursion cpp class Solution { public: void string2vec(string \u0026preorder, vector\u003cstring\u003e \u0026strs) { for (int i = 0; i \u003c preorder.size(); ++i) { int r = i; while (r \u003c preorder.size() \u0026\u0026 preorder[r] != ',') { ++r; } strs.push_back(preorder.substr(i, r - i)); i = r; } } bool dfs(vector\u003cstring\u003e \u0026strs, int \u0026idx) { if (idx \u003e= strs.size()) { return false; } if (strs[idx] == \"#\") { ++idx; return true; } ++idx; return dfs(strs, idx) \u0026\u0026 dfs(strs, idx); } bool isValidSerialization(string preorder) { vector\u003cstring\u003e strs; string2vec(preorder, strs); int idx = 0; return dfs(strs, idx) \u0026\u0026 idx == strs.size(); } }; ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree/:4:0","series":null,"tags":[""],"title":"331. Verify Preorder Serialization of a Binary Tree (Medium)","uri":"/331.verify-preorder-serialization-of-a-binary-tree/#recursion-1"},{"categories":["leetcode"],"content":" 1 问题描述331. 验证二叉树的前序序列化 (Medium) 序列化二叉树的一种方法是使用 前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如 果它是一个空节点，我们可以使用一个标记值记录，例如 #。 例如，上面的二叉树可以被序列化为字符串 \"9,3,4,#,#,1,#,#,2,#,6,#,#\"，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法 。 保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。 你可以认为输入格式总是有效的 例如它永远不会包含两个连续的逗号，比如 \"1,,3\" 。 注意： 不允许重建树。 示例 1: text 输入: preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\" 输出: true 示例 2: text 输入: preorder = \"1,#\" 输出: false 示例 3: text 输入: preorder = \"9,#,#,1\" 输出: false 提示: 1 \u003c= preorder.length \u003c= 10⁴ preorder 由以逗号 “，” 分隔的 [0,100] 范围内的整数和 “#” 组成 ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree.zh/:1:0","series":null,"tags":["stack","dfs","tree"],"title":"331.verify Preorder Serialization of a Binary Tree","uri":"/331.verify-preorder-serialization-of-a-binary-tree.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree.zh/:2:0","series":null,"tags":["stack","dfs","tree"],"title":"331.verify Preorder Serialization of a Binary Tree","uri":"/331.verify-preorder-serialization-of-a-binary-tree.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 归约本质上还是一种递归的思想，在前序遍历时，我们可以注意到，每个叶子结点必定跟随两个 null，因此，我们可以反过来，将连续的一个非空结点和两个空结点，归约为一个空结点，这个过程有点像消消乐，可以利用栈来实现这个过程，最后根据栈是否只剩下一个空结点来判断。 ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree.zh/:2:1","series":null,"tags":["stack","dfs","tree"],"title":"331.verify Preorder Serialization of a Binary Tree","uri":"/331.verify-preorder-serialization-of-a-binary-tree.zh/#归约"},{"categories":["leetcode"],"content":" 2.2 递归递归的思路参照 剑指 Offer 37. 序列化二叉树 (Hard)，不同之处在于我们只需要判断左子树和右子树是否满足要求而已，不需要返回它们的头结点。 ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree.zh/:2:2","series":null,"tags":["stack","dfs","tree"],"title":"331.verify Preorder Serialization of a Binary Tree","uri":"/331.verify-preorder-serialization-of-a-binary-tree.zh/#递归"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree.zh/:3:0","series":null,"tags":["stack","dfs","tree"],"title":"331.verify Preorder Serialization of a Binary Tree","uri":"/331.verify-preorder-serialization-of-a-binary-tree.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 归约 cpp class Solution { public: void string2vec(string \u0026preorder, vector\u003cstring\u003e \u0026strs) { for (int i = 0; i \u003c preorder.size(); ++i) { int r = i; while (r \u003c preorder.size() \u0026\u0026 preorder[r] != ',') { ++r; } strs.push_back(preorder.substr(i, r - i)); i = r; } } bool isValidSerialization(string preorder) { vector\u003cstring\u003e strs; string2vec(preorder, strs); int n = strs.size(); stack\u003cstring\u003e stk; for (int i = 0; i \u003c n; ++i) { if (strs[i] != \"#\") { stk.push(strs[i]); } else { while (stk.size() \u003e= 2 \u0026\u0026 stk.top() == \"#\") { stk.pop(); if (stk.top() == \"#\") { return false; } stk.pop(); } stk.push(\"#\"); } } return stk.size() == 1 \u0026\u0026 stk.top() == \"#\"; } }; ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree.zh/:3:1","series":null,"tags":["stack","dfs","tree"],"title":"331.verify Preorder Serialization of a Binary Tree","uri":"/331.verify-preorder-serialization-of-a-binary-tree.zh/#归约-1"},{"categories":["leetcode"],"content":" 4 递归 cpp class Solution { public: void string2vec(string \u0026preorder, vector\u003cstring\u003e \u0026strs) { for (int i = 0; i \u003c preorder.size(); ++i) { int r = i; while (r \u003c preorder.size() \u0026\u0026 preorder[r] != ',') { ++r; } strs.push_back(preorder.substr(i, r - i)); i = r; } } bool dfs(vector\u003cstring\u003e \u0026strs, int \u0026idx) { if (idx \u003e= strs.size()) { return false; } if (strs[idx] == \"#\") { ++idx; return true; } ++idx; return dfs(strs, idx) \u0026\u0026 dfs(strs, idx); } bool isValidSerialization(string preorder) { vector\u003cstring\u003e strs; string2vec(preorder, strs); int idx = 0; return dfs(strs, idx) \u0026\u0026 idx == strs.size(); } }; ","date":"2023-09-13","objectID":"/331.verify-preorder-serialization-of-a-binary-tree.zh/:4:0","series":null,"tags":["stack","dfs","tree"],"title":"331.verify Preorder Serialization of a Binary Tree","uri":"/331.verify-preorder-serialization-of-a-binary-tree.zh/#递归-1"},{"categories":["leetcode"],"content":" 1 Description1462. Course Schedule IV (Medium) There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [aᵢ, bᵢ] indicates that you must take course aᵢ first if you want to take course bᵢ. For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1. Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c. You are also given an array queries where queries[j] = [uⱼ, vⱼ]. For the jᵗʰ query, you should answer whether course uⱼ is a prerequisite of course vⱼ or not. Return a boolean array answer , where answer[j] is the answer to the jᵗʰ query. Example 1: text Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]] Output: [false,true] Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0. Course 0 is not a prerequisite of course 1, but the opposite is true. Example 2: text Input: numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]] Output: [false,false] Explanation: There are no prerequisites, and each course is independent. Example 3: text Input: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]] Output: [true,true] Constraints: 2 \u003c= numCourses \u003c= 100 0 \u003c= prerequisites.length \u003c= (numCourses * (numCourses - 1) / 2) prerequisites[i].length == 2 0 \u003c= aᵢ, bᵢ \u003c= n - 1 aᵢ != bᵢ All the pairs [aᵢ, bᵢ] are unique. The prerequisites graph has no cycles. 1 \u003c= queries.length \u003c= 10⁴ 0 \u003c= uᵢ, vᵢ \u003c= n - 1 uᵢ != vᵢ ","date":"2023-09-12","objectID":"/1462.course-schedule-iv/:1:0","series":null,"tags":["topo sort"],"title":"1462.course Schedule Iv","uri":"/1462.course-schedule-iv/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe must still incorporate topological sorting into the solution. During the process of topological sorting, we also need to traverse all the courses. If the course being traversed is a prerequisite for cur, it will certainly be a prerequisite for next as well. ","date":"2023-09-12","objectID":"/1462.course-schedule-iv/:2:0","series":null,"tags":["topo sort"],"title":"1462.course Schedule Iv","uri":"/1462.course-schedule-iv/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cbool\u003e checkIfPrerequisite(int numCourses, vector\u003cvector\u003cint\u003e\u003e \u0026prerequisites, vector\u003cvector\u003cint\u003e\u003e \u0026queries) { vector\u003cvector\u003cint\u003e\u003e ispre(numCourses, vector\u003cint\u003e(numCourses, 0)); vector\u003cvector\u003cint\u003e\u003e graph(numCourses); vector\u003cint\u003e indeg(numCourses); for (auto \u0026vec : prerequisites) { int x = vec[0], y = vec[1]; graph[x].push_back(y); ++indeg[y]; } queue\u003cint\u003e q; for (int i = 0; i \u003c numCourses; ++i) { if (indeg[i] == 0) { q.push(i); } } while (!q.empty()) { auto cur = q.front(); q.pop(); for (int next : graph[cur]) { ispre[cur][next] = 1; for (int i = 0; i \u003c numCourses; ++i) { if (ispre[i][cur] == 1) { ispre[i][next] = 1; } } if (--indeg[next] == 0) { q.push(next); } } } vector\u003cbool\u003e ans; ans.reserve(queries.size()); for (auto \u0026qry : queries) { ans.push_back(ispre[qry[0]][qry[1]] == 1); } return ans; } }; ","date":"2023-09-12","objectID":"/1462.course-schedule-iv/:3:0","series":null,"tags":["topo sort"],"title":"1462.course Schedule Iv","uri":"/1462.course-schedule-iv/#code"},{"categories":["leetcode"],"content":" 1 问题描述1462. 课程表 IV (Medium) 你总共需要上 numCourses 门课，课程编号依次为 0 到 numCourses-1 。你会得到一个数组 prerequisit e ，其中 prerequisites[i] = [aᵢ, bᵢ] 表示如果你想选 bᵢ 课程，你 必须 先选 aᵢ 课程。 有的课会有直接的先修课程，比如如果想上课程 1 ，你必须先上课程 0 ，那么会以 [0,1] 数对的形式 给出先修课程数对。 先决条件也可以是 间接 的。如果课程 a 是课程 b 的先决条件，课程 b 是课程 c 的先决条件，那 么课程 a 就是课程 c 的先决条件。 你也得到一个数组 queries ，其中 queries[j] = [uⱼ, vⱼ]。对于第 j 个查询，您应该回答课程 uⱼ 是 否是课程 vⱼ 的先决条件。 返回一个布尔数组 answer ，其中 answer[j] 是第 j 个查询的答案。 示例 1： text 输入：numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]] 输出：[false,true] 解释：课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。 示例 2： text 输入：numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]] 输出：[false,false] 解释：没有先修课程对，所以每门课程之间是独立的。 示例 3： text 输入：numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]] 输出：[true,true] 提示： 2 \u003c= numCourses \u003c= 100 0 \u003c= prerequisites.length \u003c= (numCourses * (numCourses - 1) / 2) prerequisites[i].length == 2 0 \u003c= aᵢ, bᵢ \u003c= n - 1 aᵢ != bᵢ 每一对 [aᵢ, bᵢ] 都 不同 先修课程图中没有环。 1 \u003c= queries.length \u003c= 10⁴ 0 \u003c= uᵢ, vᵢ \u003c= n - 1 uᵢ != vᵢ ","date":"2023-09-12","objectID":"/1462.course-schedule-iv.zh/:1:0","series":null,"tags":["topo sort"],"title":"1462. 课程表 IV (Medium)","uri":"/1462.course-schedule-iv.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路还是要用到拓扑排序，并且在拓扑排序的过程中，我们还需要遍历所有的课程，如果遍历到的课程是 cur 的先修课，那么它一定是 next 的先修课。 ","date":"2023-09-12","objectID":"/1462.course-schedule-iv.zh/:2:0","series":null,"tags":["topo sort"],"title":"1462. 课程表 IV (Medium)","uri":"/1462.course-schedule-iv.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cbool\u003e checkIfPrerequisite(int numCourses, vector\u003cvector\u003cint\u003e\u003e \u0026prerequisites, vector\u003cvector\u003cint\u003e\u003e \u0026queries) { vector\u003cvector\u003cint\u003e\u003e ispre(numCourses, vector\u003cint\u003e(numCourses, 0)); vector\u003cvector\u003cint\u003e\u003e graph(numCourses); vector\u003cint\u003e indeg(numCourses); for (auto \u0026vec : prerequisites) { int x = vec[0], y = vec[1]; graph[x].push_back(y); ++indeg[y]; } queue\u003cint\u003e q; for (int i = 0; i \u003c numCourses; ++i) { if (indeg[i] == 0) { q.push(i); } } while (!q.empty()) { auto cur = q.front(); q.pop(); for (int next : graph[cur]) { ispre[cur][next] = 1; for (int i = 0; i \u003c numCourses; ++i) { if (ispre[i][cur] == 1) { ispre[i][next] = 1; } } if (--indeg[next] == 0) { q.push(next); } } } vector\u003cbool\u003e ans; ans.reserve(queries.size()); for (auto \u0026qry : queries) { ans.push_back(ispre[qry[0]][qry[1]] == 1); } return ans; } }; ","date":"2023-09-12","objectID":"/1462.course-schedule-iv.zh/:3:0","series":null,"tags":["topo sort"],"title":"1462. 课程表 IV (Medium)","uri":"/1462.course-schedule-iv.zh/#代码"},{"categories":[""],"content":" 1 问题描述本人有一台无公网 ip 的 Debian 主机，为了能够远程连接上去写代码，因此配置好了 frp，frp 服务商是公益性质的 mossfrp，之前都正常运行，vscode remote 可以正常连接上去使用，体验与本地开发基本一致。然而昨天，突然就莫名其妙地出现了问题，当我 vscode 连接上去之后，会很快断开连接，然后显示重连失败，如下图所示： 在 vscode 也看不到相关的日志输出。试过重启大法，依旧无效。 ","date":"2023-09-11","objectID":"/vscode-frp-solve.zh/:1:0","series":null,"tags":[""],"title":"解决 vscode remote 无法通过 frp 连接到内网机器的问题","uri":"/vscode-frp-solve.zh/#问题描述"},{"categories":[""],"content":" 2 问题解决本着排除法的原则，我借同学的 windows 电脑上的测试了一下，在它的电脑上，vscode remote 是能正常通过 frp 连接到我的内网机器的，并且不会出现自动断开的情况。此时，我推测可能是 vscode 或者操作系统的问题（这个概率不大）。 后来在 vscode 的 github 的 issue 中一搜，已经有相关的 issue 了，是 vscode remote 这个扩展在 0.106.1 版本的问题，可以通过降级插件或者切换到最新的预览版解决，又或者是将 remote.SSH.useExecServer 设置为 false。 ","date":"2023-09-11","objectID":"/vscode-frp-solve.zh/:2:0","series":null,"tags":[""],"title":"解决 vscode remote 无法通过 frp 连接到内网机器的问题","uri":"/vscode-frp-solve.zh/#问题解决"},{"categories":["leetcode"],"content":" 1 Description109. Convert Sorted List to Binary Search Tree (Medium) Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balancedbinary search tree. Example 1: text Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST. Example 2: text Input: head = [] Output: [] Constraints: The number of nodes in head is in the range [0, 2 * 10⁴]. -10⁵ \u003c= Node.val \u003c= 10⁵ ","date":"2023-09-11","objectID":"/109.convert-sorted-list-to-binary-search-tree/:1:0","series":null,"tags":["dfs","tree"],"title":"109. Convert Sorted List to Binary Search Tree (Medium)","uri":"/109.convert-sorted-list-to-binary-search-tree/#description"},{"categories":["leetcode"],"content":" 2 SolutionInitially, if we substitute a linked list with an array, it becomes quite convenient to accomplish the task within a temporal complexity of $O(n)$. Subsequently, since a linked list cannot facilitate random access in $O(1)$ time akin to an array, it is not amenable to an array-centric approach. Primarily, we must contemplate that performing an in-order traversal on a binary search tree yields an ascending order list. Therefore, we can also derive a binary search tree through a process akin to an in-order traversal. That is to say, first, calculate the left child node, the root node being the current node under traversal, followed by the computation of the right child node. ","date":"2023-09-11","objectID":"/109.convert-sorted-list-to-binary-search-tree/:2:0","series":null,"tags":["dfs","tree"],"title":"109. Convert Sorted List to Binary Search Tree (Medium)","uri":"/109.convert-sorted-list-to-binary-search-tree/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: TreeNode *dfs(int l, int r, ListNode **head) { if (l \u003e= r) { return nullptr; } int mid = l + (r - l) / 2; TreeNode *left = dfs(l, mid, head); TreeNode *root = new TreeNode((*head)-\u003eval); root-\u003eleft = left; *head = (*head)-\u003enext; root-\u003eright = dfs(mid + 1, r, head); return root; } TreeNode *sortedListToBST(ListNode *head) { ListNode *tail = head; int cnt = 0; while (tail != nullptr) { ++cnt; tail = tail-\u003enext; } return dfs(0, cnt, \u0026head); } }; ","date":"2023-09-11","objectID":"/109.convert-sorted-list-to-binary-search-tree/:3:0","series":null,"tags":["dfs","tree"],"title":"109. Convert Sorted List to Binary Search Tree (Medium)","uri":"/109.convert-sorted-list-to-binary-search-tree/#code"},{"categories":["leetcode"],"content":" 1 问题描述109. 有序链表转换二叉搜索树 (Medium) 给定一个单链表的头节点 head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。 示例 1: text 输入: head = [-10,-3,0,5,9] 输出: [0,-3,9,-10,null,5] 解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。 示例 2: text 输入: head = [] 输出: [] 提示: head 中的节点数在 [0, 2 * 10⁴] 范围内 -10⁵ \u003c= Node.val \u003c= 10⁵ ","date":"2023-09-11","objectID":"/109.convert-sorted-list-to-binary-search-tree.zh/:1:0","series":null,"tags":["dfs","tree"],"title":"109. 有序链表转换二叉搜索树 (Medium)","uri":"/109.convert-sorted-list-to-binary-search-tree.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，如果将链表换成数组，可以很方便地在 $O(n)$ 时间内完成，然后由于链表无法像数组那样在 $O(1)$ 时间内实现随机访问，因此不能套用数组的思路。 我们首先要想到，对二叉搜索树进行中序遍历，就能得到一个升序链表，那么我们也可以通过一个类似中序遍历的过程，得到二叉搜索树。即先计算左子结点，根结点就是当前遍历到的链表结点，然后计算右子结点。 ","date":"2023-09-11","objectID":"/109.convert-sorted-list-to-binary-search-tree.zh/:2:0","series":null,"tags":["dfs","tree"],"title":"109. 有序链表转换二叉搜索树 (Medium)","uri":"/109.convert-sorted-list-to-binary-search-tree.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: TreeNode *dfs(int l, int r, ListNode **head) { if (l \u003e= r) { return nullptr; } int mid = l + (r - l) / 2; TreeNode *left = dfs(l, mid, head); TreeNode *root = new TreeNode((*head)-\u003eval); root-\u003eleft = left; *head = (*head)-\u003enext; root-\u003eright = dfs(mid + 1, r, head); return root; } TreeNode *sortedListToBST(ListNode *head) { // 牢记，二叉搜索树的中序遍历结果是一个升序数组 ListNode *tail = head; int cnt = 0; while (tail != nullptr) { ++cnt; tail = tail-\u003enext; } return dfs(0, cnt, \u0026head); } }; ","date":"2023-09-11","objectID":"/109.convert-sorted-list-to-binary-search-tree.zh/:3:0","series":null,"tags":["dfs","tree"],"title":"109. 有序链表转换二叉搜索树 (Medium)","uri":"/109.convert-sorted-list-to-binary-search-tree.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述99. 恢复二叉搜索树 (Medium) 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下 ，恢复这棵树 。 示例 1： text 输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 的左孩子，因为 3 \u003e 1 。交换 1 和 3 使二叉搜索树有效。 示例 2： text 输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 \u003c 3 。交换 2 和 3 使二叉搜索树有效。 提示： 树上节点的数目在范围 [2, 1000] 内 -2³¹ \u003c= Node.val \u003c= 2³¹ - 1 进阶： 使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用 O(1) 空间的解决方案吗？ ","date":"2023-09-08","objectID":"/99.recover-binary-search-tree.zh/:1:0","series":null,"tags":["tree"],"title":"99. 恢复二叉搜索树 (Medium)","uri":"/99.recover-binary-search-tree.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路这里就直接考虑 $O(1)$ 时间复杂度的解法了，首先我们知道，对二叉搜索树进行中序遍历，其结点值是严格递增的，因此，我们可以利用这一点来找出被交换的两个节点。 我们考虑一个递增序列，然后交换序列中任意两个元素，如果这两个元素是相邻的，那么当我们遍历时，会出现一次 $a_{i} \u003c a_{i - 1}$ 的情况；而如果这两个元素不相邻，那么会出现两次 $a_{i} \u003c a_{i - 1}$ 的情况。我们将出现 $a_{i} \u003c a_{i - 1}$ 的元素对都存入数组 vec，那么 vec.size() == 2 || vec.size() == 4，我们交换数组的首元素与尾元素的值即可。 我们在中序遍历时，可以用 prev 表示遍历的上一个节点的指针，比较 root-\u003eval 与 pre-\u003eval 的值，判断序列是否严格递增，如果不是，将 root 和 pre 依次 push_back 到 vec 中去，最后交换 vec[0]-\u003eval 和 vec.back()-\u003eval。 带 prev 的中序遍历的模板如下： cpp void midtra(TreeNode *root, TreeNode **prev) { if (root == nullptr) { return; } midtra(root-\u003eleft, prev); *prev = root; midtra(root-\u003eright, prev); } ","date":"2023-09-08","objectID":"/99.recover-binary-search-tree.zh/:2:0","series":null,"tags":["tree"],"title":"99. 恢复二叉搜索树 (Medium)","uri":"/99.recover-binary-search-tree.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: void midtra(TreeNode *root, TreeNode **prev, vector\u003cTreeNode *\u003e \u0026wrong) { if (root == nullptr) { return; } midtra(root-\u003eleft, prev, wrong); if (*prev != nullptr) { if (root-\u003eval \u003c (*prev)-\u003eval) { wrong.push_back(*prev); wrong.push_back(root); } } *prev = root; midtra(root-\u003eright, prev, wrong); } void recoverTree(TreeNode *root) { // 中序遍历 vector\u003cTreeNode *\u003e wrong; TreeNode *node = nullptr; midtra(root, \u0026node, wrong); swap(wrong[0]-\u003eval, wrong.back()-\u003eval); } }; ","date":"2023-09-08","objectID":"/99.recover-binary-search-tree.zh/:3:0","series":null,"tags":["tree"],"title":"99. 恢复二叉搜索树 (Medium)","uri":"/99.recover-binary-search-tree.zh/#代码"},{"categories":[""],"content":" 1 Description99. Recover Binary Search Tree (Medium) You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. Example 1: text Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 \u003e 1. Swapping 1 and 3 makes the BST valid. Example 2: text Input: root = [3,1,4,null,null,2] Output: [2,1,4,null,null,3] Explanation: 2 cannot be in the right subtree of 3 because 2 \u003c 3. Swapping 2 and 3 makes the BST valid. Constraints: The number of nodes in the tree is in the range [2, 1000]. -2³¹ \u003c= Node.val \u003c= 2³¹ - 1 Follow up: A solution using O(n) space is pretty straight-forward. Could you devise a constant O(1) space solution? ","date":"2023-09-08","objectID":"/99.recover-binary-search-tree/:1:0","series":null,"tags":[""],"title":"99. Recover Binary Search Tree (Medium)","uri":"/99.recover-binary-search-tree/#description"},{"categories":[""],"content":" 2 SolutionIn this context, we shall consider a solution with a time complexity of $O(1)$. Initially, it is worth noting that when conducting an in-order traversal of a binary search tree, the node values strictly follow an ascending order. Consequently, we may exploit this insight to identify the two nodes that have been swapped. Let us contemplate an ascending sequence and the exchange of any two elements within it. If these two elements happen to be adjacent, then during our traversal, a situation will arise wherein $a_{i} \u003c a_{i - 1}$. On the other hand, if these two elements are not adjacent, we will encounter $a_{i} \u003c a_{i - 1}$ twice. We shall store all such pairs of elements where $a_{i} \u003c a_{i - 1}$ in an array called vec. Therefore, it follows that vec.size() == 2 || vec.size() == 4, and to rectify the situation, we need only swap the values of the first and last elements in the array. As we traverse in an in-order manner, we can employ the prev variable to represent the pointer to the previous node in the traversal. By comparing the values of root-\u003eval and prev-\u003eval, we can ascertain whether the sequence adheres strictly to the increasing order. If it does not, we shall consecutively push_back both root and prev into the vec array, and finally, perform a swap between vec[0]-\u003eval and vec.back()-\u003eval. Below is a template for an in-order traversal incorporating the prev variable: cpp void midtra(TreeNode *root, TreeNode **prev) { if (root == nullptr) { return; } midtra(root-\u003eleft, prev); *prev = root; midtra(root-\u003eright, prev); } ","date":"2023-09-08","objectID":"/99.recover-binary-search-tree/:2:0","series":null,"tags":[""],"title":"99. Recover Binary Search Tree (Medium)","uri":"/99.recover-binary-search-tree/#solution"},{"categories":[""],"content":" 3 Code cpp class Solution { public: void midtra(TreeNode *root, TreeNode **prev, vector\u003cTreeNode *\u003e \u0026wrong) { if (root == nullptr) { return; } midtra(root-\u003eleft, prev, wrong); if (*prev != nullptr) { if (root-\u003eval \u003c (*prev)-\u003eval) { wrong.push_back(*prev); wrong.push_back(root); } } *prev = root; midtra(root-\u003eright, prev, wrong); } void recoverTree(TreeNode *root) { // 中序遍历 vector\u003cTreeNode *\u003e wrong; TreeNode *node = nullptr; midtra(root, \u0026node, wrong); swap(wrong[0]-\u003eval, wrong.back()-\u003eval); } }; ","date":"2023-09-08","objectID":"/99.recover-binary-search-tree/:3:0","series":null,"tags":[""],"title":"99. Recover Binary Search Tree (Medium)","uri":"/99.recover-binary-search-tree/#code"},{"categories":["leetcode"],"content":" 1 问题描述31. 下一个排列 (Medium) 整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如， arr = [1,2,3] ，以下这些都可以视作 arr 的排列： [1,2,3]、 [1,3,2]、 [3,1,2]、 [2 ,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典 顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如 果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如， arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地， arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。 必须 原地 修改，只允许使用 额外常数空间。 示例 1： text 输入：nums = [1,2,3] 输出：[1,3,2] 示例 2： text 输入：nums = [3,2,1] 输出：[1,2,3] 示例 3： text 输入：nums = [1,1,5] 输出：[1,5,1] 提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 100 ","date":"2023-08-08","objectID":"/31.next-permutation.zh/:1:0","series":null,"tags":["stack"],"title":"31. 下一个排列 (Medium)","uri":"/31.next-permutation.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路要找到下一个排列，假设我们需要交换 nums[l] 和 nums[r]，需要满足这样的约束条件： $l$ 尽可能大； 在 $l$ 尽可能大的情况下，$nums[r]$ 尽可能小。 完成交换后，对 l 之后的元素从小到大排序。 我们需要从右往左遍历，使用一个单调递增栈，如果当前元素大于等于栈顶元素，即将当前元素的索引入栈，否则，$l$ 就是当前元素的索引，$r$ 就是栈中满足 $nums[r] \u003e nums[l]$ 的最小的 nums[r] 对应的 $r$。 这里其实不需要使用栈，从右往左遍历两次即可，第一次寻找 $l$，第二次寻找 $r$。 ","date":"2023-08-08","objectID":"/31.next-permutation.zh/:2:0","series":null,"tags":["stack"],"title":"31. 下一个排列 (Medium)","uri":"/31.next-permutation.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: void nextPermutation(vector\u003cint\u003e \u0026nums) { int n = nums.size(); int resr = 0, resl = -1; int rnum = nums[n - 1], lnum = nums[n - 1]; for (int i = n - 1; i \u003e= 0; --i) { if (nums[i] \u003e= rnum) { resr = i; rnum = nums[i]; } else if (nums[i] \u003c rnum) { resl = i; lnum = nums[i]; break; } } for (int i = n - 1; i \u003e resl; --i) { if (nums[i] \u003e lnum \u0026\u0026 nums[i] \u003c rnum) { resr = i; rnum = nums[i]; } } if (resl \u003c 0) { sort(nums.begin(), nums.end()); } else { swap(nums[resl], nums[resr]); sort(nums.begin() + resl + 1, nums.end()); } } }; ","date":"2023-08-08","objectID":"/31.next-permutation.zh/:3:0","series":null,"tags":["stack"],"title":"31. 下一个排列 (Medium)","uri":"/31.next-permutation.zh/#代码"},{"categories":[""],"content":" 1 Solution","date":"2023-08-04","objectID":"/287.find-the-duplicate-number/:1:0","series":null,"tags":[""],"title":"287.find the Duplicate Number","uri":"/287.find-the-duplicate-number/#solution"},{"categories":[""],"content":" 1.1 Binary searchThe duality of this section is somewhat convoluted. Let us assume that the repeated digit is denoted by $k$. For the array nums, there are more than $k$ occurrences of numbers between $1$ and $k$. Therefore, for a given $mid$, if the count of numbers between $1$ and $mid$ exceeds $mid$, this indicates that $mid \\geq k$, otherwise $mid \u003c k$. ","date":"2023-08-04","objectID":"/287.find-the-duplicate-number/:1:1","series":null,"tags":[""],"title":"287.find the Duplicate Number","uri":"/287.find-the-duplicate-number/#binary-search"},{"categories":[""],"content":" 1.2 Two pointersHere, we can visualize the array as a singly-linked list. Index i of the array represents a pointer to the linked list node, while nums[i] represents a pointer to the next node. The presence of duplicate integers indicates the existence of a cycle in this linked list. Therefore, we can apply the two-pointer technique to find the entrance of the cycle. ","date":"2023-08-04","objectID":"/287.find-the-duplicate-number/:1:2","series":null,"tags":[""],"title":"287.find the Duplicate Number","uri":"/287.find-the-duplicate-number/#two-pointers"},{"categories":["leetcode"],"content":" 1 问题描述287. 寻找重复数 (Medium) 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存 在一个重复的整数。 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。 示例 1： text 输入：nums = [1,3,4,2,2] 输出：2 示例 2： text 输入：nums = [3,1,3,4,2] 输出：3 提示： 1 \u003c= n \u003c= 10⁵ nums.length == n + 1 1 \u003c= nums[i] \u003c= n nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 进阶： 如何证明 nums 中至少存在一个重复的数字? 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？ ","date":"2023-08-04","objectID":"/287.find-the-duplicate-number.zh/:1:0","series":null,"tags":["binary search","two pointers"],"title":"287. 寻找重复数 (Medium)","uri":"/287.find-the-duplicate-number.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-08-04","objectID":"/287.find-the-duplicate-number.zh/:2:0","series":null,"tags":["binary search","two pointers"],"title":"287. 寻找重复数 (Medium)","uri":"/287.find-the-duplicate-number.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 二分查找这里的二段性有一点绕，我们假设重复的数字是 $k$，那么对于数组 nums，有 $[1, k]$ 之间的数的个数大于 $k$；因此，对于 $mid$，如果 $[1, mid]$ 之间的数的个数大于 $mid$，说明 $mid \\geq k$，否则说明 $mid \u003c k$。 ","date":"2023-08-04","objectID":"/287.find-the-duplicate-number.zh/:2:1","series":null,"tags":["binary search","two pointers"],"title":"287. 寻找重复数 (Medium)","uri":"/287.find-the-duplicate-number.zh/#二分查找"},{"categories":["leetcode"],"content":" 2.2 双指针这里我们可以把数组想像成一个单向链表。 数组索引 i 是指向链表结点的指针，$nums[i]$ 则是指向下一个结点的指针，存在重复的整数说明这个链表存在环。那么，我们就可以使用快慢双指针的办法，来找到环的入口。 ","date":"2023-08-04","objectID":"/287.find-the-duplicate-number.zh/:2:2","series":null,"tags":["binary search","two pointers"],"title":"287. 寻找重复数 (Medium)","uri":"/287.find-the-duplicate-number.zh/#双指针"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-08-04","objectID":"/287.find-the-duplicate-number.zh/:3:0","series":null,"tags":["binary search","two pointers"],"title":"287. 寻找重复数 (Medium)","uri":"/287.find-the-duplicate-number.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 二分查找 cpp class Solution { public: int findDuplicate(vector\u003cint\u003e\u0026 nums) { int n = nums.size() - 1; int l = 1, r = n + 1; while (l \u003c r) { int mid = l + (r - l) / 2; int cnt = 0; for (int i = 0;i \u003c n + 1; ++i) { if (nums[i] \u003c= mid) { ++cnt; } } if (cnt \u003e mid) { r = mid; }else { l = mid + 1; } } return l; } }; ","date":"2023-08-04","objectID":"/287.find-the-duplicate-number.zh/:3:1","series":null,"tags":["binary search","two pointers"],"title":"287. 寻找重复数 (Medium)","uri":"/287.find-the-duplicate-number.zh/#二分查找-1"},{"categories":["leetcode"],"content":" 3.2 双指针 cpp class Solution { public: int findDuplicate(vector\u003cint\u003e \u0026nums) { // 快慢指针 int fast = 0, slow = 0; while (1) { fast = nums[nums[fast]]; slow = nums[slow]; if (fast == slow) { break; } } slow = 0; int finder = fast; while (slow != finder) { slow = nums[slow]; finder = nums[finder]; } return slow; } }; ","date":"2023-08-04","objectID":"/287.find-the-duplicate-number.zh/:3:2","series":null,"tags":["binary search","two pointers"],"title":"287. 寻找重复数 (Medium)","uri":"/287.find-the-duplicate-number.zh/#双指针-1"},{"categories":["notes"],"content":" 1 思路与实现添加系统调用就不多说了。 整体流程应该是这样的，lab 的提示中，要求我们定义一个 vma 结构体，vma 的定义如下；然后 lab 的提示要求我们声明一个大小为 $16$ 的 vma 数组，并按需要从该数组分配，问题来了，数组在哪里声明呢？考虑到每个进程都有自己的虚拟地址空间，因此，每个进程都有自己的 virtual memory areas，要分配 vma 的时候，应该从每个进程自己的 vma 数组进行分配，于是，我们可以考虑为 struct proc 添加 struct vma areas[NVMA] 字段。 c struct vma { int fd; int rw_flag; uint64 start; uint64 cur; uint len; int state; int flags; }; struct proc { // 已有的省略不写 struct vma areas[NVMA]; }; 在 vma 的定义中，start 表示起始地址，$[start, cur)$ 这一段虚拟地址（左闭右开）是已经绑定了 pp 的，pp 的数据与 file 绑定。 那么我们如何实现 sys_mmap 呢？这里可以参照 sbrk，递增 p-\u003esz，然后仿照 allocproc，寻找状态为 UNUSED 的 vma，分配给本次 sys_mmap。注意如果文件本身是 read_only，并且以 MAP_SHARED 模式进行 map，那么 flags 不能为 PROT_WRITE，write only 的情况同理（即文件不可读）。 c uint64 sys_mmap(void) { uint len, offset; int prot, flags, fd; struct file *f; // 读取参数 if (argint(1, (int *)\u0026len) \u003c 0 || argint(2, \u0026prot) \u003c 0 || argint(3, \u0026flags) \u003c 0 || argint(5, (int *)\u0026offset) \u003c 0) { return -1; } if (argfd(4, \u0026fd, \u0026f) \u003c 0) { return -1; } struct proc *p = myproc(); if (!f-\u003ewritable \u0026\u0026 (prot \u0026 PROT_WRITE) \u0026\u0026 (flags \u0026 MAP_SHARED)) { return BADADDR; } if (!f-\u003ereadable \u0026\u0026 (prot \u0026 PROT_READ) \u0026\u0026 (flags \u0026 MAP_SHARED)) { return BADADDR; } struct vma *area; for (area = p-\u003eareas; area \u003c p-\u003eareas + NVMA; ++area) { if (area-\u003estate == UNUSED) { // 找到了空闲的 area area-\u003estate = USED; area-\u003erw_flag = prot; area-\u003eflags = flags; area-\u003estart = p-\u003esz; area-\u003ecur = p-\u003esz; area-\u003eoffset = offset; p-\u003esz += len; area-\u003elen = len; area-\u003ef = f; filedup(area-\u003ef); return area-\u003estart; } } return BADADDR; } 这里，我将 sys_mmap 的实现写在了 sysfile.c 中，这样就可以直接使用 argfd 来获取文件描述符和对应的 file 指针了，如果定义在 sysproc.c 中，那么通过 p-\u003eofile[fd] 也可以获取文件描述符对应的 file 指针。 内核态中，虚拟地址到物理地址是直接映射的！除了 PHYSTOP 之上的部分。 这里我将 page fault 的下的处理封装成了一个函数 mmap_handle，出现 page fault，首先查看出现 page fualt 的虚拟地址是否位于 vma 中，如果是，得到对应的 vma 的指针 area，然后调用 mmap_handle(wrong_addr, area, r_scause)。 mmap_handle 的流程如下，首先判断 page fault 是否是我们所预期的，然后申请物理内存，map VP 与 PP（注意 pte_flag 不要漏掉 PTE_U），然后将文件的数据根据偏移量，读到对应的虚拟地址中去。读完之后，将 area-\u003ecur 和 area-\u003eoffset 都增加读取的数据的字节数，同时减少 area-\u003elen，area-\u003elen 表示 vma 中还有多少空余空间。 c int mmap_handle(uint64 wrong_addr, struct vma *area, uint64 scause) { struct proc *p = myproc(); if (scause == 13 \u0026\u0026 !(area-\u003erw_flag \u0026 PROT_READ)) { printf(\"read a file that can't be read\\n\"); return -1; } if (scause == 15 \u0026\u0026 !(area-\u003erw_flag \u0026 PROT_WRITE)) { printf(\"write a file that is read-only\\n\"); return -1; } char *mem = kalloc(); if (mem == 0) { printf(\"without free mem\\n\"); p-\u003ekilled = 1; } memset(mem, 0, PGSIZE); uint64 lb = PGROUNDDOWN(area-\u003ecur); int pte_flag = PTE_U; if (area-\u003erw_flag \u0026 PROT_READ) { pte_flag |= PTE_R; } if (area-\u003erw_flag \u0026 PROT_WRITE) { pte_flag |= PTE_W; } if (area-\u003erw_flag \u0026 PROT_EXEC) { pte_flag |= PTE_X; } uint area_pg = PGSIZE - (area-\u003ecur - lb); printf(\"area_pg: %p, cur: %p\\n\", area_pg, area-\u003ecur); area_pg = area_pg \u003c= area-\u003elen ? area_pg : area-\u003elen; printf(\"mappages\\n\"); if (mappages(p-\u003epagetable, lb, PGSIZE, (uint64)mem, pte_flag) != 0) { printf(\"mappage failed\\n\"); kfree(mem); uvmdealloc(p-\u003epagetable, lb + PGSIZE, lb); return -1; } ilock(area-\u003ef-\u003eip); if (readi(area-\u003ef-\u003eip, 0, (uint64)mem + area-\u003ecur - lb, area-\u003eoffset, area_pg) \u003c 0) { printf(\"readi failed\\n\"); kfree(mem); return -1; } iunlock(area-\u003ef-\u003eip); area-\u003eoffset += area_pg; area-\u003ecur += area_pg; area-\u003elen -= area_pg; return 0; } 整体流程如下，首先 对于 sys_munmap，我们先读取参数 addr 和 len，然后执行 unmap(addr, len);，unmap 定义与 proc.c 中，在 defs.h 中声明即可，作业中已经说明了，要进行 munmap 的虚拟地址区间，要么左端点与 area 重合，要么右端点与 area 重合，如果左右端点都重合，说明整个文件都被解除 map 了，并且文件以 MAP_SHARED 方式 mmap 且可写，那么执行 filewrite(area-\u003ef, addr, len) 将这段虚拟内存的内容写回到文件中，直接全写回即可（反正作业中一次也不会 map 很多个 page）；写回之后，我们要执行 fileclose(area-\u003ef) 来递减 f-\u003erefcnt。 最后调用 uvmunmap，解除 VP 与 PP 的映射关系。 c uint64 unmap(uint64 addr, uint len) { struct vma *area; struct proc *p = myproc(); for (area = p-\u003eareas; area \u003c p-\u003eareas + NVMA; ++area) { // 左端点与 area 起始位置重合 if (addr == area-\u003estart) { area-\u003estart -= len; break; } if (addr + len == area-\u003ecur + area-\u003elen) { area-\u003ecur -= len; area-\u003elen += len; break; } } if (area == p-\u003eareas + NVMA) { printf(\"no matached a","date":"2023-08-03","objectID":"/xv6-lab11.zh/:1:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab11: Mmap","uri":"/xv6-lab11.zh/#思路与实现"},{"categories":["notes"],"content":" 2 总结之前看 csapp 的虚拟内存那一章的时候，书里面有提到 virtual memory area 的概念，当时不是很理解为什么需要一个这玩意，做了本次 lab 之后，对 linux 中的 vm_area 也算有所理解，本 lab 中，vm_area 是直接以数组形式存储的，每次都要 $O(n)$ 的时间才能找到对应的 area，而在 Linux 中，vm_area 是以红黑树的形式组织的，找到 vaddr 对应的 area，只需要 $O(\\log n)$ 的时间。（当然，这也是因为我们只有 $16$ 个 area，而 Linux 中 area 的数量要多得多）。 ","date":"2023-08-03","objectID":"/xv6-lab11.zh/:2:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab11: Mmap","uri":"/xv6-lab11.zh/#总结"},{"categories":["notes"],"content":" 1 Large files这个作业需要我们将 xv6 的最大文件大小从 12 + 256 Bytes 修改为 11 + 256 + 256 * 256 Bytes。 为了达成这个目标，我们需要使用二级索引块，对 inode 的 addrs 字段，首先将 NDIRECT 从 $12$ 修改为 $11$，即前 $11$ 个 block 是 direct block，addrs[NDIRECT] 对应的块是一个一级索引块，这个块中的每个元素（共 BSIZE / sizeof(uint) 个元素）都是一个数据块的编号；而 addrs[NDIRECT + 1] 是一个二级索引块，这个块中的每个元素都是一级索引块的编号，由编号找到一级索引块，然后再由以及索引块找到数据块。 这个作业的主要任务就是修改 bmap 和 itrunc 两个函数。 先修改 fs.h 中的 NDIRECT 的相关定义： c #define FSMAGIC 0x10203040 #define NDIRECT 11 #define NINDIRECT (BSIZE / sizeof(uint)) #define NDINDIRECT (NINDIRECT * NINDIRECT) #define MAXFILE (NDIRECT + NINDIRECT + NDINDIRECT) struct dinode { short type; // File type short major; // Major device number (T_DEVICE only) short minor; // Minor device number (T_DEVICE only) short nlink; // Number of links to inode in file system uint size; // Size of file (bytes) uint addrs[NDIRECT + 2]; // Data block addresses }; 注意 file.h 中的 inode 结构体也要做相应的修改。 修改 bmap 函数，用商来表示一级块的编号，模来表示数据块的编号。 c static uint bmap(struct inode *ip, uint bn) { uint addr, *a; struct buf *bp; if (bn \u003c NDIRECT) { if ((addr = ip-\u003eaddrs[bn]) == 0) ip-\u003eaddrs[bn] = addr = balloc(ip-\u003edev); return addr; } bn -= NDIRECT; if (bn \u003c NINDIRECT) { // Load indirect block, allocating if necessary. if ((addr = ip-\u003eaddrs[NDIRECT]) == 0) ip-\u003eaddrs[NDIRECT] = addr = balloc(ip-\u003edev); bp = bread(ip-\u003edev, addr); a = (uint *)bp-\u003edata; if ((addr = a[bn]) == 0) { a[bn] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); return addr; } bn -= NINDIRECT; if (bn \u003c NDINDIRECT) { if ((addr = ip-\u003eaddrs[NDIRECT + 1]) == 0) { addr = balloc(ip-\u003edev); ip-\u003eaddrs[NDIRECT + 1] = addr; } struct buf *tmp_buf = bread(ip-\u003edev, addr); uint *arr_tmp = (uint *)tmp_buf-\u003edata; uint lv1_addr; if ((lv1_addr = arr_tmp[bn / NINDIRECT]) == 0) { lv1_addr = balloc(ip-\u003edev); arr_tmp[bn / NINDIRECT] = lv1_addr; log_write(tmp_buf); } brelse(tmp_buf); bp = bread(ip-\u003edev, lv1_addr); a = (uint *)bp-\u003edata; if ((addr = a[bn % NINDIRECT]) == 0) { a[bn % NINDIRECT] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); return addr; } panic(\"bmap: out of range\"); } 修改 itrunc，如果了解 inode 的数据在磁盘中分布方式的话，free 起来也很简单，照着原先的 itrunc 写就好了。先释放数据块，然后释放这些数据块对应的一级索引块，最后释放这些数据块对应的二级索引块。 c void itrunc(struct inode *ip) { int i, j; struct buf *bp; uint *a; for (i = 0; i \u003c NDIRECT; i++) { if (ip-\u003eaddrs[i]) { bfree(ip-\u003edev, ip-\u003eaddrs[i]); ip-\u003eaddrs[i] = 0; } } if (ip-\u003eaddrs[NDIRECT]) { bp = bread(ip-\u003edev, ip-\u003eaddrs[NDIRECT]); a = (uint *)bp-\u003edata; for (j = 0; j \u003c NINDIRECT; j++) { if (a[j]) bfree(ip-\u003edev, a[j]); } brelse(bp); bfree(ip-\u003edev, ip-\u003eaddrs[NDIRECT]); ip-\u003eaddrs[NDIRECT] = 0; } if (ip-\u003eaddrs[NDIRECT + 1]) { bp = bread(ip-\u003edev, ip-\u003eaddrs[NDIRECT + 1]); a = (uint *)bp-\u003edata; for (int j = 0; j \u003c NINDIRECT; ++j) { if (a[j]) { struct buf *sub_bp = bread(ip-\u003edev, a[j]); uint *addr = (uint *)sub_bp-\u003edata; for (int k = 0; k \u003c NINDIRECT; ++k) { if (addr[k]) { bfree(ip-\u003edev, addr[k]); } } brelse(sub_bp); bfree(ip-\u003edev, a[j]); } } brelse(bp); bfree(ip-\u003edev, ip-\u003eaddrs[NDIRECT + 1]); ip-\u003eaddrs[NDIRECT + 1] = 0; } ip-\u003esize = 0; iupdate(ip); } ","date":"2023-08-01","objectID":"/xv6-lab10.zh/:1:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab10: file system","uri":"/xv6-lab10.zh/#large-files"},{"categories":["notes"],"content":" 2 Symbolic links首先要搞清楚硬连接（hard link）与符号连接（soft link or symbolic link）之间的区别。 int link(const char *target, const char *path)，我们要为 target 创建一个路径为 path 的硬链接。在硬链接的情况下，两个路径对应着同一个 inode，我们可以先看一下 xv6 中 sys_link 的实现，它的核心在于调用 dirlink 在 path 的父目录下，创建对应的 directory entry，而这个 entry（即 dirent）的 inum 和目标文件的 inum 是相同的，即当我们通过 dirlookup 调用 iget 来获取 inode 的指针时，两个指针指向的是同一个 inode。 而符号链接 int symlink(const char *target, const char *path) 则不一样，path 对应的 inode（记为 ip） 和 target 对应的 inode（记为 tp） 并不是同一个，只不过在 ip 的数据块中，存储的是 tp 的路径，即字符串 target。同时 ip-\u003etype 是 T_SYMLINK。 明确了符号链接与硬链接的区别，这个作业就不难写了（我当时把符号链接跟硬链接搞混了，折腾了很久）。 添加系统调用的步骤不再赘述。直接思考如何实现 sys_symlink。思路很简单，利用 create 创建一个 inode，注意这里创建的 inode（即返回的 inode 的指针）是带锁的！然后利用 writei 将数据（即字符串 target）写入到 inode，注意这里应该是 kernel page table 下，writei 自身会调用 iupdate，因此不需要我们手动调用 iupdate。 inode 是直写的，修改了 inode 的数据必须调用 iupdate 更新到磁盘。 注意整个流程需要用 begin_op 和 end_op 包裹起来，iput 也会调用 iupdate，而 iupdate 会调用 log_write。 c uint64 sys_symlink(void) { char path[MAXPATH]; char target[MAXPATH]; struct inode *ip; // printf(\"symlink\\n\"); if (argstr(0, target, MAXPATH) \u003c 0 || argstr(1, path, MAXPATH) \u003c 0) { return -1; } begin_op(); // maxpath 为 128，即需要 128 个字节，一个 block 是 1024 个字节 if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) { // create 返回的是锁定的 ip end_op(); return -1; } // printf(\"start_symlink_loop\\n\"); if ((writei(ip, 0, (uint64)target, 0, MAXPATH)) \u003c MAXPATH) { iunlockput(ip); end_op(); return -1; } // iupdate(ip); iunlockput(ip); end_op(); return 0; } 同时，我们还需要修改 sys_open，添加判断 ip-\u003etype 是否为 T_SYMLINK 的处理逻辑，并且需要防止符号链接形成环路，即需要限制循环次数，我这里定为 #define R_MAX_DEPTH 12（这里之前没注意提示的内容，被死循环卡了挺久的）。 c uint64 sys_open(void) { char path[MAXPATH]; int fd, omode; struct file *f; struct inode *ip; int n; if ((n = argstr(0, path, MAXPATH)) \u003c 0 || argint(1, \u0026omode) \u003c 0) return -1; begin_op(); if (omode \u0026 O_CREATE) { ip = create(path, T_FILE, 0, 0); if (ip == 0) { end_op(); return -1; } } else { if ((ip = namei(path)) == 0) { end_op(); return -1; } ilock(ip); if (ip-\u003etype == T_DIR \u0026\u0026 omode != O_RDONLY) { iunlockput(ip); end_op(); return -1; } } if (ip-\u003etype == T_DEVICE \u0026\u0026 (ip-\u003emajor \u003c 0 || ip-\u003emajor \u003e= NDEV)) { iunlockput(ip); end_op(); return -1; } if (ip-\u003etype == T_SYMLINK \u0026\u0026 !(omode \u0026 O_NOFOLLOW)) { int read_num; int recur_times = 0; while (ip-\u003etype == T_SYMLINK) { if ((read_num = readi(ip, 0, (uint64)path, 0, MAXPATH)) \u003c MAXPATH) { iunlockput(ip); end_op(); return -1; } iunlockput(ip); ip = namei(path); // printf(\"symlink, path: %s %d\\n\", path, 2); if (ip == 0 || recur_times++ \u003e= R_MAX_DEPTH) { end_op(); return -1; } ilock(ip); } } if ((f = filealloc()) == 0 || (fd = fdalloc(f)) \u003c 0) { if (f) fileclose(f); iunlockput(ip); end_op(); return -1; } if (ip-\u003etype == T_DEVICE) { f-\u003etype = FD_DEVICE; f-\u003emajor = ip-\u003emajor; } else { f-\u003etype = FD_INODE; f-\u003eoff = 0; } f-\u003eip = ip; f-\u003ereadable = !(omode \u0026 O_WRONLY); f-\u003ewritable = (omode \u0026 O_WRONLY) || (omode \u0026 O_RDWR); if ((omode \u0026 O_TRUNC) \u0026\u0026 ip-\u003etype == T_FILE) { itrunc(ip); } iunlock(ip); end_op(); return fd; } ","date":"2023-08-01","objectID":"/xv6-lab10.zh/:2:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab10: file system","uri":"/xv6-lab10.zh/#symbolic-links"},{"categories":["notes"],"content":" 1 Memory allocator这一题很简单，主要任务，就是为每个 cpu 维护一个空闲物理内存的链表 freelist，xv6 默认使用的结构体 kmem，其中包含一个 freelist 供所有的 cpu 使用。我们要做的，就是把 freelist 修改成 freelist 的数组，即 struct run *freelist[NCPU]，其中 NCPU 是定义于 kernel/params.h 的宏，对应 cpu 的个数。 kmem 中的 spinlock 是用来保护 freelist 的，既然 freelist 变成了数组，那么也需要有 NCPU 个 spinlock。因此，修改 kmem 为如下结构体： c struct { struct spinlock lock[NCPU]; struct run *freelist[NCPU]; // for each cpu, allocate a freelist } kmem; 接着，我们需要修改 kinit，让它初始化每个 spinlock。 c void kinit() { char lockname[6] = {'k', 'm', 'e', 'm', '0', 0}; for (int i = 0; i \u003c NCPU; ++i) { lockname[4] = '0' + i; initlock(kmem.lock + i, lockname); } freerange(end, (void *)PHYSTOP); } 接着，我们需要修改 freerange，使得 freerange 将范围内所有的空闲内存都分配给运行 freerange 的 cpu 的 freelist。这里我们定义了一个新的函数 kfree_cpu 来实现这一功能（记得在 defs.h 中声明），这里要注意一点，调用 cpuid() 以及使用它的结果之前，要关闭外部中断防止定时器中断切走线程，之后再开启中断。 c void freerange(void *pa_start, void *pa_end) { char *p; p = (char *)PGROUNDUP((uint64)pa_start); push_off(); int cid = cpuid(); for (; p + PGSIZE \u003c= (char *)pa_end; p += PGSIZE) { kfree_cpu(p, cid); } pop_off(); } void kfree_cpu(void *pa, int cid) { struct run *r; if (((uint64)pa % PGSIZE) != 0 || (char *)pa \u003c end || (uint64)pa \u003e= PHYSTOP) { panic(\"kfree\"); } memset(pa, 1, PGSIZE); r = (struct run *)pa; r-\u003enext = kmem.freelist[cid]; kmem.freelist[cid] = r; } kfree 也要作对应修改，将空闲内存添加到运行 kfree 的 cpu 的 freelist 中。 c void kfree(void *pa) { struct run *r; if (((uint64)pa % PGSIZE) != 0 || (char *)pa \u003c end || (uint64)pa \u003e= PHYSTOP) panic(\"kfree\"); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run *)pa; push_off(); int cid = cpuid(); // acquire(\u0026kmem.lock); r-\u003enext = kmem.freelist[cid]; kmem.freelist[cid] = r; pop_off(); // release(\u0026kmem.lock); } 最后还要修改 kalloc，从运行 kalloc 的 cpu 的 freelist 分配，如果 freelist 为空（即 r == 0），那么就从其它 cpu 的 freelist 处获取，这里存在 race condition，需要上锁，完成操作之后再解锁。 c void *kalloc(void) { struct run *r; // alloc 的时候，需要上锁，考虑到当前 cpu 的 freelist 为空，需要使用锁 // acquire(\u0026kmem.lock); push_off(); int cid = cpuid(); r = kmem.freelist[cid]; if (r) { kmem.freelist[cid] = r-\u003enext; } else { // 遍历其他 cpu 的 freelist，找一个有空闲块的 cpu 的 freelist for (int i = 1; i \u003c NCPU; ++i) { int idx = (cid + i) % NCPU; acquire(\u0026kmem.lock[idx]); r = kmem.freelist[idx]; if (r) { kmem.freelist[idx] = r-\u003enext; release(\u0026kmem.lock[idx]); break; } release(\u0026kmem.lock[idx]); } } pop_off(); // release(\u0026kmem.lock); if (r) memset((char *)r, 5, PGSIZE); // fill with junk return (void *)r; } ","date":"2023-07-29","objectID":"/xv6-lab9.zh/:1:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab9: Locks","uri":"/xv6-lab9.zh/#memory-allocator"},{"categories":["notes"],"content":" 2 Buffer cacheTODO(zwyyy): clockintr 中，为什么要 wakeup(\u0026tickslock); 这个实验室需要我们重新设计 bcache 的数据结构，从单纯的链表变成哈希表，哈希表的 bucket 数量在提示中说明了，可以为 $13$。一开始的时候，我想着不如不使用 bcache，直接另外设计一个哈希表，哈希表的每个 bucket 是一个无虚拟头结点的双向链表，但是写好之后发现一直发生死锁，搞得 bget 非常复杂，尤其是哈希表的 bucket 中的元素要移动到另一个 bucket 中时。 后来将数据结构改成了如下形式： c struct entry { struct buf head; // val struct spinlock lock; }; struct { struct spinlock lock; struct buf buf[NBUF]; struct entry table[NBUCKET]; // Linked list of all buffers, through prev/next. // Sorted by how recently the buffer was used. // head.next is most recent, head.prev is least. } bcache; 即 bcache 有三个成员变量，lock、buf 数组 buf 和哈希表 table，table 其实相当于是一个数组，数组中的元素是一个 spinlock 和一个 struct buf 链表的虚拟头结点，相比原始的 bcache，可以理解为把一个链表分成了 NBUCKET 个链表，同时每个链表有一个 spinlock 来保护链表的数据，链表中结点的插入、删除与原始的 bcache 类似。 但由于我们不需要通过链表的顺序来实现 lru 策略，因此，插入的时候直接作为对应链表的虚拟头结点的 next 即可，即作为实际的头结点。 在 bget 中，最难实现的部分，就是选择一个 victim buf，然后将它重用为当前 block 的 cache。在这里非常容易出现死锁之类的问题，事实上，为了保护这里的 invariant，即一个 block 只能有一份 block cache，并且只会选择 refcnt == 0 的 buf 作为 victim buf，需要用到 bcache.lock 和哈希表的 bucket 的 spinlock，而我一开始只使用了哈希表的 bucket 的 spinlock，加上没有虚拟头结点导致链表的插入、删除相对麻烦，因此不是发生 panic 就是死锁。 ","date":"2023-07-29","objectID":"/xv6-lab9.zh/:2:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab9: Locks","uri":"/xv6-lab9.zh/#buffer-cache"},{"categories":["notes"],"content":" 2.1 binit明确了数据结构和思路之后，让我们来一步步实现，首先是 binit，它要实现的功能可以说分为两步： 初始化 bcache，即 bcache 的 spinlock 和哈希表，前面提到，哈希表可以理解为把原来 bcache 中的链表分解成了 NBUCKET 个链表，对每个链接，让头结点的 next 和 prev 都指向头结点自身来表示链表为空； 初始化哈希表中的 NBUCKET 个链表，以及每个链表的 spinlock。原始的 bio.c 中，需要把 NBUF 个 buf 插入到 bcache 的链表中去，而这里我们需要把 NBUF 个 buf 插入到这 NBUCKET 个链表中去，根据 buf 在 buf 数组中的索引对 NBUCKET 取的模的值，来判断它应该放到哪个链表中去。 c void binit(void) { initlock(\u0026bcache.lock, \"bcache\"); for (int i = 0; i \u003c NBUCKET; ++i) { bcache.table[i].head.next = \u0026bcache.table[i].head; bcache.table[i].head.prev = \u0026bcache.table[i].head; // lockname[6] = 'a' + i; initlock(\u0026bcache.table[i].lock, \"bucket\"); } struct buf *b; for (int i = 0; i \u003c NBUF; ++i) { int key = i % NBUCKET; // 无论 table 中的链表是否为空，都可以这样来处理 b = bcache.buf + i; b-\u003ekey = key; b-\u003enext = bcache.table[key].head.next; b-\u003eprev = \u0026bcache.table[key].head; initsleeplock(\u0026b-\u003elock, \"buffer\"); bcache.table[key].head.next-\u003eprev = b; bcache.table[key].head.next = b; } } ","date":"2023-07-29","objectID":"/xv6-lab9.zh/:2:1","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab9: Locks","uri":"/xv6-lab9.zh/#binit"},{"categories":["notes"],"content":" 2.2 bgetbget 的实现也可以分成两部分： block cache 存在于 bcache 中； block cache 不存在于 bcache 中，需要从 bcache 中寻找 victim buf，然后重用它。 block cache 存在 bcache 的情况下，处理很简单，我们首先由 (dev + 1) * blockno 计算出 target block cahce 的 key，然后 key % NBUCKET 确定该 block cache 位于哪个 bucket，然后对该 bucket 上锁（因为我们需要修改 block cache 的 b-\u003erefcnt），遍历 bucket 的链表，找到 dev 与 blockno 都对应的那个 block cache b，然后递增 b-\u003erefcnt，释放 bucket 的链表的锁。然后请求 b 的 sleeplock，这里主要是考虑到 b 可能要将内容写入到磁盘，需要花费很长时间，同时不希望 b 的内容被其他进程看到，更不希望被修改，所以请求 sleeplock，最后 return b； bcache 中没有这个 block 的 cache 的情况下，处理逻辑就非常复杂了，首先我们需要寻找一个 victim buf，victim buf 一定是 refcnt == 0 的所有 buf 中，ticks 值最小的那个。并且，我们需要保证，当前进程始终持有 victim 所在的 bucket 的锁。 我一开始是这样做的：每次遍历一个 bucket 的链表时持有锁，遍历完就释放，当遍历完所有 bucket 确定下来 victim 之后，需要将 victim 从所在 bucket 中移除，此时先申请bucket 的 spinlock，完成删除之后再释放；然后申请 key 对应的 bucket 的 spinlock，将 victim 插入到 key 对应的 bucket 中，然后释放 spinlock。 这样做的问题在于，找到了 victim 和将 victim 从当前 bucket 中移除时，有一段空隙，当前进程并没有持有 victim 所在的 bucket 的锁，那么此时其他进程就可能修改 victim 的值，例如将 refcnt 从 $0$ 设置为了 $1$，那么就会出现两个 disk block 对应同一个 block cache 的错误情况。 因此，必须保证当前进程始终持有 victim 所在 bucket 的锁，直到将 victim 从当前 bucket 中移除为止。 我是这样实现了，遍历所有的 bucket 来寻找 victim，先申请当前 bucket 的锁，假设没有满足条件的 victim，那么就释放正在遍历的 bucket 的锁，然后开始遍历下一个 bucket；假设找到了满足条件的 victim，如果旧的 victim 和这个新的 victim 不在同一个 bucket 中，那么释放旧 victim 的 bucket 的锁，更新 victim，否则如果旧 victim 和新 victim 位于同一个 bucket 中，那么只更新 victim，不释放锁。 这样操作后，在寻找 victim 和将 victim 从其原本所在的 bucket 中删除之前，进程会始终持有 victim 所在 bucket 的锁。然后申请 key 对应的 bucket 的锁，将 victim 插入到此 bucket 中。 综上， bget 的实现如下，从实现可以看出，其实没有 bcache.lock 的参与就能完成。 c static struct buf *bget(uint dev, uint blockno) { struct buf *b; int i; int key = ((dev + 1) * blockno) % NBUCKET; // acquire(\u0026bcache.lock); acquire(\u0026bcache.table[key].lock); for (b = bcache.table[key].head.next; b != \u0026bcache.table[key].head; b = b-\u003enext) { if (b-\u003edev == dev \u0026\u0026 b-\u003eblockno == blockno) { ++b-\u003erefcnt; release(\u0026bcache.table[key].lock); // release(\u0026bcache.lock); acquiresleep(\u0026b-\u003elock); return b; } } release(\u0026bcache.table[key].lock); // Not cached. uint stmp = kUintMax; int cur_key = 0; struct buf *victim; // acquire(\u0026bcache.lock); // bcache.table[i].lock 必须交错 release，即确保 victim 被更换之前，victim 对应的锁不能被释放 // 不如直接扫描 bcache 中的所有 buf for (i = 0; i \u003c NBUCKET; ++i) { acquire(\u0026bcache.table[i].lock); int find_flag = 0; for (b = bcache.table[i].head.next; b != \u0026bcache.table[i].head; b = b-\u003enext) { if (b-\u003erefcnt == 0 \u0026\u0026 b-\u003estamp \u003c stmp) { stmp = b-\u003estamp; if (cur_key != i \u0026\u0026 holding(\u0026bcache.table[cur_key].lock)) { release(\u0026bcache.table[cur_key].lock); } victim = b; cur_key = i; find_flag = 1; } } if (!find_flag) { release(\u0026bcache.table[i].lock); } } if (stmp != kUintMax \u0026\u0026 victim != 0) { // acquire(\u0026bcache.table[cur_key].lock); victim-\u003edev = dev; victim-\u003eblockno = blockno; victim-\u003evalid = 0; victim-\u003erefcnt = 1; victim-\u003ekey = key; // 可能需要移动当前 buf 到其他 bucket victim-\u003enext-\u003eprev = victim-\u003eprev; victim-\u003eprev-\u003enext = victim-\u003enext; // 从当前链表删除 release(\u0026bcache.table[cur_key].lock); // 插入到新的链表 acquire(\u0026bcache.table[key].lock); victim-\u003enext = bcache.table[key].head.next; victim-\u003eprev = \u0026bcache.table[key].head; bcache.table[key].head.next-\u003eprev = victim; bcache.table[key].head.next = victim; release(\u0026bcache.table[key].lock); // release(\u0026bcache.lock); acquiresleep(\u0026victim-\u003elock); return victim; } panic(\"bget: no buffers\"); } 注意，我们需要修改 struct buf，为其添加 uint stamp 和 int key 两个字段，前者一看便知，后者则是说，假如此 buf 在内存中存在 cache block，那么这个 cache block 位于索引为 key 的 bucket 中。 ","date":"2023-07-29","objectID":"/xv6-lab9.zh/:2:2","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab9: Locks","uri":"/xv6-lab9.zh/#bget"},{"categories":["notes"],"content":" 2.3 brelse、bpin、bunpin最麻烦的函数其实就是 bget 了，剩下这三个都很好处理。brelse 处理 lru 不再需要执行链表的插入删除，只需要递减 buf-\u003erefcnt 并将当前 ticks 赋值给 b-\u003estamp 即可，这里要申请 buf 所在 bucket 的锁，以及 tickslock。 c void brelse(struct buf *b) { if (!holdingsleep(\u0026b-\u003elock)) { // printf(\"panic, brelese\\n\"); panic(\"brelse\"); } releasesleep(\u0026b-\u003elock); acquire(\u0026bcache.table[b-\u003ekey].lock); b-\u003erefcnt--; acquire(\u0026tickslock); b-\u003estamp = ticks; release(\u0026tickslock); release(\u0026bcache.table[b-\u003ekey].lock); } 对于 bpin 和 bunpin，只需要修改持有和释放的锁即可，变成持有 buf 对应的 bucket 的锁。 c void bpin(struct buf *b) { acquire(\u0026bcache.table[b-\u003ekey].lock); b-\u003erefcnt++; release(\u0026bcache.table[b-\u003ekey].lock); } void bunpin(struct buf *b) { acquire(\u0026bcache.table[b-\u003ekey].lock); b-\u003erefcnt--; release(\u0026bcache.table[b-\u003ekey].lock); } ","date":"2023-07-29","objectID":"/xv6-lab9.zh/:2:3","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab9: Locks","uri":"/xv6-lab9.zh/#brelsebpinbunpin"},{"categories":["notes"],"content":" 3 总结第一个实验很简单，就不再重复了。第二个实验属实非常酸爽，各种死锁、panic，针对这种死锁的定位和调试，不知道各位有没有什么好办法。另外，个人感觉，在涉及锁的并行编程中，一个精心设计的数据结构能够让你在实现的时候少很多麻烦，例如这里使用带虚拟头结点的循环双向链表来作为 bucket 中的数据结构，而不是简单的双向链表（带虚拟头结点的虚拟尾结点的双向链表应该也可以），因为简单双向链表，边界条件处理起来很麻烦，本身并行编程为了防止 race condition 和 deadlock 就已经很麻烦了，两个麻烦叠加起来绝对是 $1 + 1 \u003e 2$。 另外一点，则是要考虑清楚，我使用锁，到底要保护一个什么样的 invariant，在这题中，我要保证 victim 始终是一个合法的 victim，它的 refcnt 一定不能中途被其他进程修改。 ","date":"2023-07-29","objectID":"/xv6-lab9.zh/:3:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab9: Locks","uri":"/xv6-lab9.zh/#总结"},{"categories":["notes"],"content":" 1 虚拟地址空间与物理地址空间地址空间（address space）是一个非负整数地址的有序集合： $$\\lbrace 0, 1, 2, \\cdots\\rbrace$$ 如果地址空间中的整数是连续的，那么我们说它是个线性地址空间（linear address space），为了简化讨论，我们总是假设我们使用的是线性地址空间。 地址空间的大小由表示最大地址所需的位数来决定，例如 $N - 1= 2^n - 1$，因此最大地址需要 $n$ 位数来表示，于是一个包含 $N = 2^n$ 个地址的地址空间就叫一个 $n$ 位地址空间。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:1:0","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#虚拟地址空间与物理地址空间"},{"categories":["notes"],"content":" 1.1 虚拟地址空间在一个带虚拟内存的系统中，CPU 由 $N=2^n$ 的地址空间中生成虚拟地址，这个虚拟地址的有序集合称为虚拟地址空间（virtual address space）： $$ \\lbrace 0, 1, 2, \\cdots N - 1\\rbrace$$ 这个地址空间是 $n$ 位的。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:1:1","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#虚拟地址空间"},{"categories":["notes"],"content":" 1.2 物理地址空间一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的 $M$ 个字节： $$\\lbrace0,1,2,\\cdots,M-1\\rbrace$$ $M$ 并不要求是 $2$ 的幂，例如可能是 $12GB$，但是为了简化讨论，我们假设 $M=2^m$，即地址空间是 $m$ 位的。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:1:2","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#物理地址空间"},{"categories":["notes"],"content":" 2 物理内存作为虚拟内存的缓存概念上而言，虚拟内存被组织为一个存放在磁盘上的由 $N=2^n$ 个连续字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，作为到数组的索引；对应的，计算机的主存（main memory，后面简称内存）被组织成一个由 $M=2^m$ 个连续的字节大小的单元组成的数组，每字节都有一个唯一的物理地址。 VM（Virtual Memory）系统通过将虚拟内存分割为称为虚拟页（Virtual Page，VP）的大小固定的块来处理这个问题，每个虚拟页的大小为 $P=2^p$ 字节。相应的，物理内存被分割为物理页（Physical Page，PP）来处理，大小也为 P 字节。这里的物理页就像是 SRAM cache 中的 block。 虚拟页有三种可能的状态（同一 VP 只会存在一种状态）： 未分配的：VM 系统还没有分配（或者创建）的页。未分配的 VP 没有任何数据与它关联，因此不占据任何磁盘空间； 缓存的：当前已缓存在物理内存中的已分配页； 未缓存的：未缓存在物理内存中的已分配页； 我们使用 DRAM cache 来表示 VM 系统的 cache，用 SRAM cache 来表示 CPU 和 内存之间的 L1、L2、L3 cache。DRAM cache 用于在主存中缓存虚拟页。 可以这样理解，VP 是存在于磁盘中的，VP 的 cache 即 PP 才存在于主存中。如果说主存中存在 VP，那么这个 VP 实际上是磁盘中的 VP 对应的 PP。并且，由于磁盘访问速度，比起内存来说都非常非常慢，因此缺页（page fault）（即 DRAM cache miss）的代价比 SRAM cache miss 的代价要昂贵得多得多。因此 VP 和 PP （即 dram cache block）往往很大（$4KB$），并且 DRAM cache 是全相联的，即任何 VP 都可以放置在任何 PP 中。 DRAM cache 总是采用 write back 而不是 write through。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:2:0","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#物理内存作为虚拟内存的缓存"},{"categories":["notes"],"content":" 3 页表（page table）页表是一种存放在物理内存中的数据结构，用来确定主存中是否存在与磁盘上的 VP 对应的 PP，如果存在，就能通过页表找到这个 PP。页表负责将 VP 映射到 PP。 页表其实就是一个 Page Table Entry（PTE）的数组，每个 PTE 是由一个有效位（valid bit）和一个 $k$ 位地址字段组成的。有效位表明了该 VP 是否被缓存在 DRAM 中。如果有效位为 $1$，$k$ 位地址字段就表示 DRAM 中相应的物理页的起始地址，结合页内偏移（page offset）就能得到虚拟地址（VA）对应的物理地址（PA）。 页表可以包含很多个页表项，我们先讨论只有一级页表的情况，假设一个虚拟地址空间是 $32$ 位的，一个页的大小是 $4KB$，那么一共需要 $\\frac{2^{32}}{2^2*2^{10}}$ 个 PTE，即 $1M$ 个（$M$ 指兆）。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:3:0","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#页表page-table"},{"categories":["notes"],"content":" 3.1 一级页表的页命中如下图，假设 CPU 要读取 VA 中的一个字，VA 对应的 VP 是 VP 2，假设 VP 2 被缓存在 DRAM 中，那么 MMU 会将 VA 作为一个索引来定位 PTE 2，使用 PTE 中的物理内存地址（指向 VP 2 对应的 cache —— PP 1）的起始地址，结合页内偏移即可构造出虚拟地址对应的物理地址。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:3:1","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#一级页表的页命中"},{"categories":["notes"],"content":" 3.2 一级页表下的缺页在虚拟内存的说法中，DRAM cache miss 被称为缺页（page fault）。由下图，假设 CPU 要读取 VA 中的一个字，VA 对应的 VP 是 VP 3，VP 3 可以由对应 PTE 3 的有效位确定它没有被缓存在主存中，然后就会触发一个缺页异常。 发生缺页异常后，事件流程如下： 缺页异常调用内核中的缺页异常处理程序，该程序选择一个牺牲页（victim page），此例中我们指定为 PP3 中的 VP4，如果 PP3 中的 VP4 是 dirty 的，那么内核将 VP4 复制回磁盘，修改 VP4 的 PTE，说明 VP4 不再缓存在 DRAM 中；然后内核从磁盘复制 VP3 到内存中的 PP 3，更新 PTE3，然后内核返回。 当异常处理程序返回时，会重新启动导致缺页的指令（即读取 VP3 中的字），这时就可以不发生缺页异常而正常读取了。如下图： ","date":"2023-07-28","objectID":"/virtual_memory.zh/:3:2","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#一级页表下的缺页"},{"categories":["notes"],"content":" 3.3 虚拟内存与 SRAM cache我们可以发现，虚拟内存系统与 SRAM cache 在概念和设计上有许多相似的地方，SRAM cache 中的 block 在 VM 系统中被称为页（page），磁盘和内存之间传送页的活动叫做交换（swapping）或者页面调度（paging）。直到发生缺页才进行页面换入内存（swap in）的策略称为按需页面调度（demand paging）。 局部性（locality）保证了此种机制下的 VM 系统的工作效率。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:3:3","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#虚拟内存与-sram-cache"},{"categories":["notes"],"content":" 4 虚拟内存的意义 简化链接：每个进程的虚拟内存结构都使用相同的基本格式，代码段总是从虚拟地址 $0x400000$ 开始，链接器在设计和实现时无需考虑代码和数据实际会存放在物理内存的何处，大大简化了链接器的设计和实现。同时避免了同一个物理地址被不同虚拟地址映射到时的冲突现象。 简化加载：每个页被初次引用时，VM 系统会自动按照需要调用数据页。TODO(zwyyy) 简化共享：操作系统通过将不同进程的中适当的 VP 映射到相同的 PP（例如 C 标准库的程序对应的 VP，又或者内核对应的 VP），从而使得多个进程共享这个标准库的同一个副本，而不是每个进程都包含一个单独的副本 简化内存分配：例如创建数组需要分配一段连续的内存空间，我们只需要分配一段连续的 VM 即可，而不需要分配连续的 PM，即这些分配的连续的 VM 对应的 PM 很可能是不连续的。 实现内存保护：通过在 PTE 上添加一些额外项，可以实现对一个 VP 的内容的访问权限控制。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:4:0","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#虚拟内存的意义"},{"categories":["notes"],"content":" 5 地址翻译形式上说，地址翻译是一个 N=2^n 元素的虚拟地址空间（VAS）到 M=2^m 元素的物理地址空间（PAS）中元素之间的映射： $$MAP:VAS \\rightarrow PAS \\cup \\emptyset$$ $$ MAP(A)=\\left\\lbrace \\begin{array}{l} \\emptyset\\ \\ 如果虚拟地址\\ A\\ 的数据不在物理内存中 \\newline A'\\ \\ 如果虚拟地址\\ A\\ 处的数据在\\ PAS\\ 的物理地址\\ A'\\ 中\\end{array}\\right. $$ 下图表示了 MMU 如何利用页表实现这一映射：CPU 中有一个 control register，又称页表基址寄存器（Page Table Base Register，PTBR）指向当前页表，注意不是 PTE，PTE 要由 VPN 才能确定！ n 位的虚拟地址包含两个部分: 一个 p 位的虚拟页面偏移（Virtual Page Offset，VPO）； 一个（n-p）位的虚拟页号（Virtual Page Number, VPN）。 MMU 利用 VPN 来选择适当的 PTE ，例如 VPN 为 0 选择 PTE 0，VPN 为 1选择 PTE 1 ，以此类推（实际上不一定是这样，为了表达意思这样说）。将页表条目中的物理页号（Physical Page Number, PPN）和虚拟地址中的 VPO 串联起来，就得到了物理地址。 由于这里 PP 和 VP 大小相同，都是 $P = 2^p$，因此 VPO 和 PPO 都是一样的。 页面命中时，CPU 硬件执行的步骤如下： 处理器生成或者说要访问一个虚拟地址（VA），并把它传递给 MMU； MMU 计算得到 PTE 地址（简单位运算即可），从 DRAM 或者 DRAM 的 cache（SRAM）中读取到这个 PTE； DRAM 或者 SRAM 向 MMU 返回 PTE； MMU 由 PTE 构造得到物理地址，并把它传送给 DRAM 或者 SRAM； DRAM 或者 SRAM 将所请求的字返回给处理器。 发生 page fault 时，相比页面命中多了缺页异常的发生与处理步骤。注意，当缺页异常完成处理后，CPU 会再次执行导致缺页的指令，即读取那个 PTE，此时会正常发生页面命中了。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:5:0","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#地址翻译"},{"categories":["notes"],"content":" 6 多级页表使用多级页表，相比只使用一级页表，能大大减少页表本身需要占据的物理内存中（这是因为未分配的页不会创建对应的 PTE）。 讲完多级页表的结构之后，就能理解为什么多级页表能减少页表本身的物理内存占用了。 下图描述了使用 $k$ 级页表层次结构的地址翻译： 考虑一个使用 $k$ 级页表结构层次的地址翻译，虚拟地址被划分为 $k$ 个 VPN 和一个 VPO，每个 VPN i 都是到 $i$ 级页表的页表项的索引，其中 $1 \\leq i \\leq k$； 对 $1 \\leq j \\leq k - 1 的每个 j$，第 $j$ 级页表中的每个 PTE 都指向第 $j + 1$ 级的某个页表的基址，相当于 PTE 中是基地址，VPN i 是相对于基址的偏移。 如果一级页表中的一个 PTE 是空的，那么相应的二级页表根本不会存在，也不会占用物理内存。而对于一个典型的程序，$4GB$ 的虚拟地址空间的大部分都是未分配的，因此可以大大节省物理内存占用。 例如：假设只有一级页表，那么对于 $4GB$ 的虚拟地址空间，每个进程需要 $\\frac{2^32}{4 * 2^{10}} * 4B = 2^{20} * 4B = 4 MB$ 的空间（$B$ 表示字节，Byte），无论虚拟地址空间实际上使用了多少。一级页表有 $2^{10}$ 个页表项，二级页表也是 $2^{10}$ 个页表项，假设虚拟地址空间使用了 $20$%，那么实际上占用的物理内存为 $2^{10} * 4B + \\frac{1}{5} * 2 ^{20} * 4B \\approx 0.804 MB$，大大节省了内存空间，而四级页表会节省得更多。 $64$ 为虚拟地址空间的思考方式同理，注意 $64$ 位虚拟地址空间的情况下，单个 PTE 占据 $8B$；而 $32$ 位是 $4B$。 在这里可以给出简单描述虚拟地址的结构体： cpp typedef union { uint64_t address_value; struct { uint64_t co : SRAM_CACHE_OFFSET_LENGTH; // 12 uint64_t ci : SRAM_CACHE_TAG_LENGTH; // 4 uint64_t ct : SRAM_CACHE_INDEX_LENGTH; // 32 }; // physical address: 16 bits struct { /* data */ union { uint64_t paddr_value : PHYSICAL_ADDRESS_LENGTH; // 16 struct { uint64_t ppo : PHYSICAL_PAGE_OFFSET_LENGTH; // 12 uint64_t ppn : PHYSICAL_PAGE_NUMBER_LENGTH; // 4 }; }; }; // virtual address: 48b bits struct { /* data */ union { uint64_t vaddr_value : VIRTUAL_ADDRESS_LENGTH; // 48 struct { uint64_t vpo : VIRTUAL_PAGE_OFFSET_LENGTH; // vpo 与 ppo 是一致的, 12 bits uint64_t vpn4 : VIRTUAL_PAGE_NUMBER_LENGTH; // 9 bits uint64_t vpn3 : VIRTUAL_PAGE_NUMBER_LENGTH; // 9 bits uint64_t vpn2 : VIRTUAL_PAGE_NUMBER_LENGTH; // 9 bits uint64_t vpn1 : VIRTUAL_PAGE_NUMBER_LENGTH; // 9 bits }; }; }; struct { uint64_t tlbo : TLB_CACHE_OFFSET_LENGTH; // virtual page offset, 12 bits uint64_t tlbi : TLB_CACHE_INDEX_LENGTH; // tlb set index, 4 bits uint64_t tlbt : TLB_CACHE_TAG_LENGTH; // TLB line tag, 32 bits }; } address_t; 这里利用 C 语言中的 union 这一类型，正好可以表达我们如何看待给出的一个 $64$ 位地址 addr_val（即 $64$ 位的 uint64_t 类型的数）。 当我们把 addr_val 解释为一个虚拟地址时，我们使用的真正的虚拟地址，其实只有它的低 $48$ 位，（由 AMD 设计 CPU 架构的时候规定，其实 $48$ 位也完全够用了），后 $16$ 位的值会与 addr_val 的第 $47$ 位保持一致（全 $0$ 或者全 $1$），全 $0$ 表示该虚拟地址处于当前虚拟地址空间的用户态部分，全 $1$ 表示处于内核态部分。 对 addr_val 来说，最低的 $12$ 位表示 Virtual Page Offset（VPO），它与对应的物理地址的 Physical Page Offset（PPO）是完全相等的。高 $39\\sim 47$ 这 $9$ 位的 vpn1 代表 Page Global Directory（PGD）的 PTE 的索引，从而可以知道这个 addr_val 对应着 PGD 中的哪个 PTE，PGD 中的 PTE 存放的是 Page Upper Directory（PUD）的基地址；$30\\sim 38$ 位的 vpn2 表示 PUD 的 PTE 的索引，PUD 中的 PTE 存放着 Page Middle Directory（PMD）的基地址；$21\\sim 29$ 位的 vpn3 表示 PMD 的 PTE 的索引，PMD 的 PTE 中存放着到 Page Table（PT）的基地址；$12\\sim 20$ 位的 vpn4 表示 PT 的 PTE 的索引，而 PT 的 PTE 中存放着 addr_val 对应的 PP 的页号，即 PPN，由 PPN 和 PPO（$PPO=VPO$） 即可拼接成物理地址 paddr。这个 page_walk 的流程如下图： 对每个进程来说，其 PGD 的起始地址由 CPU 的 CR3 Control Register 给出，CR3 指向 PGD 的起始位置，CR3 的值是每个进程上下文的一部分，每次上下文切换时，CR3 的值都会恢复。从 PGD 的最高位就能看出来是对应的虚拟地址是属于 user 还是 kernel 的。 这也就解答了为什么不同进程的同一个 vaddr 会映射到不同的 paddr，因为它们最一开始指向的 PGD 就不一样了！ ","date":"2023-07-28","objectID":"/virtual_memory.zh/:6:0","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#多级页表"},{"categories":["notes"],"content":" 7 PTE 格式PGD、PUD、PMD 的 PTE 格式如下： 地址段包含一个 $40$ 位的物理页号（PPN），$40$ 位的物理页号即要求物理页表 $4KB$ 对齐（$4k = 2^{12}$）。 PT 的 PTE 格式如下： R/W 位可以确定页的内容是可以读写的还是只读的，U/S 确定是否可以在用户模式访问该页；D 位称为 dirty bit（类似 cache 中的 dirty 状态）。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:7:0","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#pte-格式"},{"categories":["notes"],"content":" 8 TLBMMU 中存在一个关于 PTE 的小的缓存，称为 TLB，即拿到 vaddr 后，不需要一步步 page walk 得到最终的 PTE，可以直接从 TLB 中拿出 PT 的 PTE。 TLB 的结构与 SRAM cache 很像： cpp typedef struct { int valid; uint64_t tag; uint64_t ppn; } tlb_cacheline_t; typedef struct { tlb_cacheline_t lines[NUM_TLB_CACHE_LINE_PER_SET]; } tlb_cacheset_t; typedef struct { tlb_cacheset_t sets[1 \u003c\u003c TLB_CACHE_INDEX_LENGTH]; } tlb_cache_t; static tlb_cache_t mmu_tlb; static int read_tlb(uint64_t vaddr_value, uint64_t *paddr_value_ptr, int *free_tlb_line_index) { address_t addr; addr.address_value = vaddr_value; tlb_cacheset_t *set = \u0026mmu_tlb.sets[addr.tlbi]; // 获取 tlb 的 set 的 index for (int i = 0; i \u003c NUM_TLB_CACHE_LINE_PER_SET; ++i) { tlb_cacheline_t *line = \u0026set-\u003elines[i]; // cache line 一行行匹配 if (line-\u003evalid == 1) { // 这里为 1 表示 invalid *free_tlb_line_index = i; } if (line-\u003etag == addr.tlbt \u0026\u0026 line-\u003evalid != 1) { // 说明 TLB 中存在着 PTE 的 cache *paddr_value_ptr = line-\u003eppn; return 1; } } paddr_value_ptr = NULL; return 0; } ","date":"2023-07-28","objectID":"/virtual_memory.zh/:8:0","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#tlb"},{"categories":["notes"],"content":" 9 总结何为 page_walk？即由 CR3-\u003ePGD-\u003ePUD-\u003ePMD-\u003ePT-\u003ePTE，最后由 PTE 得到 PPN，再由 PPN 和 PPO（VPO）得到物理地址。 理解了 page_walk，我认为就可以说初步理解了这个虚拟内存系统。 ","date":"2023-07-28","objectID":"/virtual_memory.zh/:9:0","series":null,"tags":["csapp","linux"],"title":"虚拟内存","uri":"/virtual_memory.zh/#总结"},{"categories":["leetcode"],"content":" 1 Description2050. Parallel Courses III (Hard) You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course. You must find the minimum number of months needed to complete all the courses following these rules: You may start taking a course at any time if the prerequisites are met. Any number of courses can be taken at the same time. Return the minimum number of months needed to complete all the courses. Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).   Example 1: Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5] Output: 8 Explanation: The figure above represents the given graph and the time required to complete each course. We start course 1 and course 2 simultaneously at month 0. Course 1 takes 3 months and course 2 takes 2 months to complete respectively. Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months. Example 2: Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5] Output: 12 Explanation: The figure above represents the given graph and the time required to complete each course. You can start courses 1, 2, and 3 at month 0. You can complete them after 1, 2, and 3 months respectively. Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months. Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months. Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.   Constraints: 1 \u003c= n \u003c= 5 * 104 0 \u003c= relations.length \u003c= min(n * (n - 1) / 2, 5 * 104) relations[j].length == 2 1 \u003c= prevCoursej, nextCoursej \u003c= n prevCoursej != nextCoursej All the pairs [prevCoursej, nextCoursej] are unique. time.length == n 1 \u003c= time[i] \u003c= 104 The given graph is a directed acyclic graph. ","date":"2023-07-28","objectID":"/2050.parallel-courses-iii/:1:0","series":null,"tags":["topo sort"],"title":"2050. Parallel Courses III (Hard)","uri":"/2050.parallel-courses-iii/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe approach to this problem is quite evident, and it requires the utilization of topological sorting. During the process oftopological sorting, the longest required time should be calculated. ","date":"2023-07-28","objectID":"/2050.parallel-courses-iii/:2:0","series":null,"tags":["topo sort"],"title":"2050. Parallel Courses III (Hard)","uri":"/2050.parallel-courses-iii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minimumTime(int n, vector\u003cvector\u003cint\u003e\u003e \u0026relations, vector\u003cint\u003e \u0026time) { vector\u003cint\u003e cnt(n + 1); vector\u003cunordered_set\u003cint\u003e\u003e next(n + 1); for (auto \u0026vec : relations) { ++cnt[vec[1]]; next[vec[0]].insert(vec[1]); } queue\u003cint\u003e zero; // vector\u003cint\u003e res; vector\u003cint\u003e ans(n + 1); for (int i = 1; i \u003c= n; ++i) { if (cnt[i] == 0) { zero.push(i); ans[i] = time[i - 1]; } } int total = 0; while (!zero.empty()) { int idx = zero.front(); // res.push_back(idx); total = max(total, ans[idx]); zero.pop(); for (int course : next[idx]) { ans[course] = max(ans[course], ans[idx] + time[course - 1]); if (--cnt[course] == 0) { zero.push(course); } } } return total; } };``` ","date":"2023-07-28","objectID":"/2050.parallel-courses-iii/:3:0","series":null,"tags":["topo sort"],"title":"2050. Parallel Courses III (Hard)","uri":"/2050.parallel-courses-iii/#code"},{"categories":["leetcode"],"content":" 1 问题描述2050. 并行课程 III (Hard) 给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ， 其中 relations[j] = [prevCourseⱼ, nextCourseⱼ] ，表示课程 prevCourseⱼ 必须在课程 nextCourseⱼ * 之前* 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完 成第 (i+1) 门课程需要花费的 月份 数。 请你根据以下规则算出完成所有课程所需要的 最少 月份数： 如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。 你可以 同时 上 任意门课程 。 请你返回完成所有课程所需要的 最少 月份数。 注意： 测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。 示例 1: text 输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5] 输出：8 解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。 你可以在月份 0 同时开始课程 1 和 2 。 课程 1 花费 3 个月，课程 2 花费 2 个月。 所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。 示例 2： text 输入：n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5] 输出：12 解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。 你可以在月份 0 同时开始课程 1 ，2 和 3 。 在月份 1，2 和 3 分别完成这三门课程。 课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。 课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。 所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。 提示： 1 \u003c= n \u003c= 5 * 10⁴ 0 \u003c= relations.length \u003c= min(n * (n - 1) / 2, 5 * 10⁴) relations[j].length == 2 1 \u003c= prevCourseⱼ, nextCourseⱼ \u003c= n prevCourseⱼ != nextCourseⱼ 所有的先修课程对 [prevCourseⱼ, nextCourseⱼ] 都是 互不相同 的。 time.length == n 1 \u003c= time[i] \u003c= 10⁴ 先修课程图是一个有向无环图。 ","date":"2023-07-28","objectID":"/2050.parallel-courses-iii.zh/:1:0","series":null,"tags":["topo sort"],"title":"2050. 并行课程 III (Hard)","uri":"/2050.parallel-courses-iii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路这题的思路很明显，需要使用 拓扑排序。在拓扑排序的过程中，求出这个最长所需时间。 ","date":"2023-07-28","objectID":"/2050.parallel-courses-iii.zh/:2:0","series":null,"tags":["topo sort"],"title":"2050. 并行课程 III (Hard)","uri":"/2050.parallel-courses-iii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minimumTime(int n, vector\u003cvector\u003cint\u003e\u003e \u0026relations, vector\u003cint\u003e \u0026time) { // 先进行拓扑排序 // 统计每个课程的先修课程数量 vector\u003cint\u003e cnt(n + 1); vector\u003cunordered_set\u003cint\u003e\u003e next(n + 1); for (auto \u0026vec : relations) { ++cnt[vec[1]]; next[vec[0]].insert(vec[1]); } queue\u003cint\u003e zero; // vector\u003cint\u003e res; vector\u003cint\u003e ans(n + 1); for (int i = 1; i \u003c= n; ++i) { if (cnt[i] == 0) { zero.push(i); ans[i] = time[i - 1]; } } int total = 0; while (!zero.empty()) { int idx = zero.front(); // res.push_back(idx); total = max(total, ans[idx]); zero.pop(); for (int course : next[idx]) { ans[course] = max(ans[course], ans[idx] + time[course - 1]); if (--cnt[course] == 0) { zero.push(course); } } } return total; } };``` ","date":"2023-07-28","objectID":"/2050.parallel-courses-iii.zh/:3:0","series":null,"tags":["topo sort"],"title":"2050. 并行课程 III (Hard)","uri":"/2050.parallel-courses-iii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description335. Self Crossing (Hard) You are given an array of integers distance. You start at the point (0, 0) on an X-Y plane, and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise. Return true if your path crosses itself or false if it does not.   Example 1: Input: distance = [2,1,1,2] Output: true Explanation: The path crosses itself at the point (0, 1). Example 2: Input: distance = [1,2,3,4] Output: false Explanation: The path does not cross itself at any point. Example 3: Input: distance = [1,1,1,2,1] Output: true Explanation: The path crosses itself at the point (0, 0).   Constraints: 1 \u003c= distance.length \u003c= 105 1 \u003c= distance[i] \u003c= 105 ","date":"2023-07-28","objectID":"/335.self-crossing/:1:0","series":null,"tags":["analog"],"title":"335. Self Crossing (Hard)","uri":"/335.self-crossing/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can simulate the movement of the robot and consider the possible collisions with other tracks. For example, when moving north, the robot may intersect with tracks moving west, east, or north. Similarly, when moving west, the robot may collide with tracks moving north, south, or west. We can continue this process for other directions as well. For instance, when moving west, we can consider the conditions for collisions with tracks moving north, south, or west. ","date":"2023-07-28","objectID":"/335.self-crossing/:2:0","series":null,"tags":["analog"],"title":"335. Self Crossing (Hard)","uri":"/335.self-crossing/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool isSelfCrossing(vector\u003cint\u003e \u0026distance) { int n = distance.size(); if (n \u003c= 3) { return 0; } for (int i = 3; i \u003c n; ++i) { cout \u003c\u003c i \u003c\u003c endl; if (i == 3) { if (distance[2] \u003c= distance[0] \u0026\u0026 distance[3] \u003e= distance[1]) { return true; } } else if (i == 4) { if ((distance[i - 1] == distance[i - 3] \u0026\u0026 distance[i] + distance[i - 4] \u003e= distance[i - 2]) || (distance[i] \u003e= distance[i - 2] \u0026\u0026 distance[i - 1] \u003c= distance[i - 3])) { return true; } } else { if ((distance[i - 1] \u003c= distance[i - 3] \u0026\u0026 distance[i] \u003e= distance[i - 2]) || (distance[i] + distance[i - 4] \u003e= distance[i - 2] \u0026\u0026 distance[i - 1] + distance[i - 5] \u003e= distance[i - 3] \u0026\u0026 distance[i - 3] \u003e distance[i - 5] \u0026\u0026 distance[i - 2] \u003e distance[i - 4] \u0026\u0026 distance[i - 1] \u003c= distance[i - 3]) || (distance[i - 1] == distance[i - 3] \u0026\u0026 distance[i] + distance[i - 4] \u003e= distance[i - 2])) { return true; } } } return false; } }; ","date":"2023-07-28","objectID":"/335.self-crossing/:3:0","series":null,"tags":["analog"],"title":"335. Self Crossing (Hard)","uri":"/335.self-crossing/#code"},{"categories":["leetcode"],"content":" 1 问题描述335. 路径交叉 (Hard) 给你一个整数数组 distance。 从 X-Y 平面上的点 (0,0) 开始，先向北移动 distance[0] 米，然后向西移动 distance[1] 米，向南 移动 distance[2] 米，向东移动 distance[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针 变化。 判断你所经过的路径是否相交。如果相交，返回 true ；否则，返回 false 。 示例 1： text 输入：distance = [2,1,1,2] 输出：true 示例 2： text 输入：distance = [1,2,3,4] 输出：false 示例 3： text 输入：distance = [1,1,1,1] 输出：true 提示： 1 \u003c= distance.length \u003c= 10⁵ 1 \u003c= distance[i] \u003c= 10⁵ ","date":"2023-07-28","objectID":"/335.self-crossing.zh/:1:0","series":null,"tags":["analog"],"title":"335. 路径交叉 (Hard)","uri":"/335.self-crossing.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路模拟，以向北为例，可能与向西、向东、或者向北的轨迹发生交叉；向西，则可能会与向北、向南、向西的方向发生碰撞；依次类推。 再以向西为例，分别考虑与向北、向南、向西轨迹发生碰撞时的条件。 ","date":"2023-07-28","objectID":"/335.self-crossing.zh/:2:0","series":null,"tags":["analog"],"title":"335. 路径交叉 (Hard)","uri":"/335.self-crossing.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool isSelfCrossing(vector\u003cint\u003e \u0026distance) { int n = distance.size(); if (n \u003c= 3) { return 0; } for (int i = 3; i \u003c n; ++i) { cout \u003c\u003c i \u003c\u003c endl; if (i == 3) { if (distance[2] \u003c= distance[0] \u0026\u0026 distance[3] \u003e= distance[1]) { return true; } } else if (i == 4) { if ((distance[i - 1] == distance[i - 3] \u0026\u0026 distance[i] + distance[i - 4] \u003e= distance[i - 2]) || (distance[i] \u003e= distance[i - 2] \u0026\u0026 distance[i - 1] \u003c= distance[i - 3])) { return true; } } else { if ((distance[i - 1] \u003c= distance[i - 3] \u0026\u0026 distance[i] \u003e= distance[i - 2]) || (distance[i] + distance[i - 4] \u003e= distance[i - 2] \u0026\u0026 distance[i - 1] + distance[i - 5] \u003e= distance[i - 3] \u0026\u0026 distance[i - 3] \u003e distance[i - 5] \u0026\u0026 distance[i - 2] \u003e distance[i - 4] \u0026\u0026 distance[i - 1] \u003c= distance[i - 3]) || (distance[i - 1] == distance[i - 3] \u0026\u0026 distance[i] + distance[i - 4] \u003e= distance[i - 2])) { return true; } } } return false; } }; ","date":"2023-07-28","objectID":"/335.self-crossing.zh/:3:0","series":null,"tags":["analog"],"title":"335. 路径交叉 (Hard)","uri":"/335.self-crossing.zh/#代码"},{"categories":["notes"],"content":" 1 引入当我们针对文件系统讨论 logging 或者 journal 时，其实是在讨论同一件事，二者是同义词。 这一部分主要是讨论 Linux 的 ext3 文件系统，它相比 ext2，可以就说就是加了一层 logging，其他基本没有改变。我们要关注 ext3 与 xv6 的文件系统的不同之处，重点放在 ext3 是如何在保证 logging 的同时尽可能提升性能的。 ","date":"2023-07-27","objectID":"/mit6.s081-lec16.zh/:1:0","series":null,"tags":["linux","mit","os","xv6"],"title":"MIT 6.S081 File system performance and fast crash recovery","uri":"/mit6.s081-lec16.zh/#引入"},{"categories":["notes"],"content":" 2 ext3 file system log formatext3 数据结构与 xv6 相似，在内存中存在 block cache，它们是 write-back 的（即改动不会马上写回到磁盘）。 logging 系统有两个非常重要的准则： write-adead rule：必须现在 log 中记录好所有这些写操作，才能将这些写操作应用到磁盘； freeing rule：即我们不能覆盖或者重用 log。 ext3 还维护了一些 transaction 的信息，transaction_t 中包含： 一个序列号； 一系列该 transaction 修改的 block 的编号，这些 block 编号指向 cache 中的 blcok； 一系列的 handle，handle 对应属于transaction 的系统调用，它们会读写 cache 中的 block； ext3 的磁盘组织与 xv6 类似，存在一个文件系统树，包含 inode、目录、file 等，存在 bimtap lock 来标识每个 data block 是被分配还是空闲的，在磁盘的一个指定区域保存 log。 ext3 的 log 与 xv6 不太一样，在 ext3 的 log 中，也存在着一个 super block（注意这是 log 的 blcok，而不是文件系统的 block），log 的 superblock 包含了 log 中第一个有效的 transaction 的起始位置和序列号。在 log 中，除了 super block 以外的 block 存储了 transaction，每个 transaction 在 log 中包含了： 一个 description block，其中包含了 log 中的数据对应的实际 block 编号，有点像 xv6 中的 log 的 header block； 针对上面每一个 block 编号的更新数据； 当一个 transaction 完成并 commit 了，会有一个 commit block； log 中可能存在多个 transaction 的 block，如下图所示： log 的 superblock 中的起始位置和序列号属于最早的、排名最靠前，也是最有效的 transaction。 在 crash 之后恢复过程中会扫描 log，为了将 descriptor block 和 commit block 以及 data block 区分开来，descriptor block 和 commit block 会以一个 $32$ bit 的 magic nubmer 为起始，有点像 elf 文件，用于帮助软件区分不同的 block。 log 中可能有多个 transaction，但同一时间只有一个正在进行的 transaction，这个 transaction 对应的系统调用只会更新 cache 中的 block；当 ext3 决定结束当前正在进行的 transaction，它会做两件事： 开始一个新的 transaction 作为当前 transaction 的下一个 transaction； 将当前刚刚完成的 transaction 写入到磁盘，完成 commit，此时磁盘的 log 中存放了对磁盘 data blocks 的更新的记录，但是还没有讲更新应用到磁盘上，磁盘 log 分区上可能存在一系列这样的 transaction，然后内存中有一个正在进行，还没有 commit 的 transaction。 log 是一个循环数据结构，如果用到了 log 分区的最后，logging 系统会从 log 的最开始位置开始使用。 ","date":"2023-07-27","objectID":"/mit6.s081-lec16.zh/:2:0","series":null,"tags":["linux","mit","os","xv6"],"title":"MIT 6.S081 File system performance and fast crash recovery","uri":"/mit6.s081-lec16.zh/#ext3-file-system-log-format"},{"categories":["notes"],"content":" 3 ext3 如何提升性能ext3 主要通过三个方面提升性能： asynchronous：它提供异步（asynchronous）系统调用，系统调用写入到磁盘之前就返回了，系统调用只会更新缓存在内存中的 block，不用等待写磁盘操作，但它可能会等待读磁盘； batching：它提供了批处理（batching）的能力，可以将多个系统调用打包成一个 transaction； concurrency。 xv6 也提供了有限能力的 batching。 ","date":"2023-07-27","objectID":"/mit6.s081-lec16.zh/:3:0","series":null,"tags":["linux","mit","os","xv6"],"title":"MIT 6.S081 File system performance and fast crash recovery","uri":"/mit6.s081-lec16.zh/#ext3-如何提升性能"},{"categories":["notes"],"content":" 3.1 异步系统调用异步系统调用说明系统调用修改了 cache block 就立即返回，而不会触发写磁盘，因此系统调用可以快速返回，此时应用程序可以继续进行计算，而文件系统在后台完成之前系统调用所需的写磁盘操作，这被称为 I/O concurrency。同步系统调用中，应用程序需要等磁盘写入完成之后，才能从系统调用中返回。 异步系统调用还使得 batching 变得容易实现； 这个大概就像 xv6 中一样，执行系统调用，写入 cache block 之后就返回了，之后文件系统会批量将这些系统调用影响的 cache block 写回磁盘； 异步系统调用也有一个缺点，即系统调用的返回，并不能表示其工作真的完成了。例如，我创建一个文件，像文件写数据，然后关闭文件，并在终端输出 done。在终端看到了 done，并不意味着文件的数据就已经都写入到磁盘了，例如这个流程需要 open、write、close 系统调用，这三个系统调用写入了 cache block 之后就返回了，然后终端输出 done，文件系统在后台写入 log，再 commit 并 install trans，在输出 done 时，文件系统很可能还没有完成工作（还没有完成 commit，将修改记录到 log），如果此时断电了，那么尽管程序显示已经完成了创建和写入，但可能我们重启之后在磁盘中找不到这个文件。 文件系统对类似数据库或者文件编辑器之类的程序，提供了一个名为 fsync 的系统调用，来确保 crash 之后会有一个预期的结果。这个系统调用接受一个文件描述符作为参数，它会告诉文件系统去完成所有与该文件相关的写磁盘操作，在所有数据都写入到磁盘之后，fsync 才会返回。TODO(zwyyy) ","date":"2023-07-27","objectID":"/mit6.s081-lec16.zh/:3:1","series":null,"tags":["linux","mit","os","xv6"],"title":"MIT 6.S081 File system performance and fast crash recovery","uri":"/mit6.s081-lec16.zh/#异步系统调用"},{"categories":["notes"],"content":" 3.2 batching在任何时候，ext3 只会有一个存在于内存的 transaction，一个 transaction 可能包含多个不同的系统调用，ext3 的工作方式类似下面的描述： ext3 首先宣告要开始一个新的 transaction，接下来一段时间（例如 $5$ 秒）内所有的文件系统调用都是这个 transaction 的一部分，这些系统调用打包在一个 transaction 中，在 $5$ 秒钟结束的时候，ext3 会 commit 这个包含了可能有数百个更新的大 transaction。 batching 的优势可以分为以下三点： 它将一次 transaction 的固有的开销平摊给了多次系统调用，固有开销涉及写 transaction 的 descriptor block 和 commit block，在机械硬盘中，这需要查找 log 的位置，旋转磁头，这个成本是很高的（固态硬盘会好一些），batching 使得我们只需要对一批系统调用执行一次，而不用对每个系统调用都执行一次； 更容易触发 write absorption，即多次系统调用，但只用向对应的 data block 或者 bitmap block 写一次（向 block cache 可能写入多次）。例如创建一堆很小的文件（几 kB 或者几十 kB），这些 inode 的 data block 可能在几个连续的甚至同一个 data block；而如果创建 inode 时分配的是相邻的 data block，那我写 bitmap block 的时候，只需要修改一个 bitmap block 的很多 bit 位就好了。 最后是 disk scheduling，首先，向磁盘写入连续的 1000 个 block，比分 1000 次每次写连续位置的 disk block 要快得多（机械硬盘尤其如此），写 log 就是一次向磁盘连续位置写入 block。 当我们向文件系统分区写入包含在一个大的transaction中的多个更新时，如果我们能将大量的写请求同时发送到驱动，即使它们位于磁盘的不同位置，我们也使得磁盘可以调度这些写请求，并以特定的顺序执行这些写请求，驱动可以对这些写请求按照轨道号排序，提升写入性能，对固态硬盘来说，这个操作也有一点用处。 ","date":"2023-07-27","objectID":"/mit6.s081-lec16.zh/:3:2","series":null,"tags":["linux","mit","os","xv6"],"title":"MIT 6.S081 File system performance and fast crash recovery","uri":"/mit6.s081-lec16.zh/#batching"},{"categories":["notes"],"content":" 4 concurrency除前面异步系统调用提到的 I/O concurrency 之外，还有两种 concurrency： ext3 允许多个系统调用同时执行，这里 xv6 也可以说允许，但 xv6 的并发中，如果 transaction 处于 commiting 状态，即正在提交，那么其他系统调用会直接在 begin_op 处 sleep。 这里还是不太好理解，ext3 的并行相比 xv6 的优势？是说 ext3 处于 commiting 状态的时候，也能处理新的系统调用嘛？TODO(zwyyy) 可以有多个不同状态的 transaction 同时存在，但是只有一个内存中的 open transaction 可以接收系统调用，但是其他之前的 transaction 可以并行地写磁盘。这里并行存在的不同 transaction 状态包括： 一个 open transaction； 若干个正在 commit 到 log 的transaction，我们不需要等这些 transaction 结束，若之前的 transaction 还没有 commit 完成，还在写 log，新的系统调用仍然可以在当前 open transaction 中执行； 若干个正在从 cache 中向文件系统 block 写数据的 transaction； 若干个正在被释放的 transaction； xv6 中新的系统调用需要等待前一个 transaction 完全完成才能开始。 假设一个 block cache 正在被更新，而这个 block 又在被写入到磁盘，为了保证 transaction 写入到 log 的内容只包含本次 transaction 的更新，那么当它决定结束当前 open transaction，开启一个新的 transaction 时，它会在内存中拷贝所有相关的 block，之后 transaction 的 commit 是基于这些 block 的拷贝进行的，操作系统会使用 copy-on-write 来避免不必要的拷贝，即新 transaction 对这个 block cache 发生写入时，才真正拷贝这个 block cache（可以说之前只是添加了一份引用。 concurrency 之所以能帮助提升性能，正是因为它帮助我们并行地运行系统调用。 ","date":"2023-07-27","objectID":"/mit6.s081-lec16.zh/:4:0","series":null,"tags":["linux","mit","os","xv6"],"title":"MIT 6.S081 File system performance and fast crash recovery","uri":"/mit6.s081-lec16.zh/#concurrency"},{"categories":["leetcode"],"content":" 1 Description828. Count Unique Characters of All Substrings of a Given String (Hard) Let's define a function countUniqueChars(s) that returns the number of unique characters on s. For example, calling countUniqueChars(s) if s = \"LEETCODE\" then \"L\", \"T\", \"C\", \"O\", \"D\" are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5. Given a string s, return the sum of countUniqueChars(t) where t is a substring of s. The test cases are generated such that the answer fits in a 32-bit integer. Notice that some substrings can be repeated so in this case you have to count the repeated ones too.   Example 1: Input: s = \"ABC\" Output: 10 Explanation: All possible substrings are: \"A\",\"B\",\"C\",\"AB\",\"BC\" and \"ABC\". Every substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2: Input: s = \"ABA\" Output: 8 Explanation: The same as example 1, except countUniqueChars(\"ABA\") = 1. Example 3: Input: s = \"LEETCODE\" Output: 92   Constraints: 1 \u003c= s.length \u003c= 105 s consists of uppercase English letters only. ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string/:1:0","series":null,"tags":["dynamic programming"],"title":"828. Count Unique Characters of All Substrings of a Given String (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string/:2:0","series":null,"tags":["dynamic programming"],"title":"828. Count Unique Characters of All Substrings of a Given String (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string/#solution"},{"categories":["leetcode"],"content":" 2.1 DPThis problem can be easily solved using dynamic programming. Let’s define $dp[i]$ as the sum of countUniqueChar(t) values for substrings $t$ ending at $s[i]$. The next step is to find the recurrence relation: Suppose the character corresponding to $s[i]$ is $c$. For substrings ending at $s[i-1]$, if the substring does not contain $c$, then the countUniqueChar value for the substring ending at $s[i]$ is equal to the value for the substring ending at $s[i-1]$ (i.e., without $c$) plus $1$. If the substring contains one $c$, then the countUniqueChar value for the substring ending at $s[i]$ is equal to the value for the substring ending at $s[i-1]$ minus $1$. If the substring contains two $c$, then the countUniqueChar values for the substrings ending at $s[i]$ and $s[i-1]$ are equal. We maintain a vector\u003cpair\u003cint, int\u003e\u003e left_same, where left_same[i].second represents the largest index less than $i$ that contains the same character as $s[i]$ and left_same[i].first$ represents the second largest index. Note that the pair` needs to be initialized as $\\lbrace -1, -1\\rbrace$. ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string/:2:1","series":null,"tags":["dynamic programming"],"title":"828. Count Unique Characters of All Substrings of a Given String (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string/#dp"},{"categories":["leetcode"],"content":" 2.2 Contribution methodWe can also use the contribution method to calculate the number of substrings that include $s[i]$ in their countUniqueChar value. ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string/:2:2","series":null,"tags":["dynamic programming"],"title":"828. Count Unique Characters of All Substrings of a Given String (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string/#contribution-method"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string/:3:0","series":null,"tags":["dynamic programming"],"title":"828. Count Unique Characters of All Substrings of a Given String (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string/#code"},{"categories":["leetcode"],"content":" 3.1 DP cpp class Solution { public: int uniqueLetterString(string s) { int n = s.size(); vector\u003cint\u003e arr(26, -1); vector\u003cpair\u003cint, int\u003e\u003e left_same(n, {-1, -1}); for (int i = 0; i \u003c n; ++i) { if (arr[s[i] - 'A'] != -1) { left_same[i].first = left_same[arr[s[i] - 'A']].second; left_same[i].second = arr[s[i] - 'A']; } arr[s[i] - 'A'] = i; } vector\u003cint\u003e dp(n); dp[0] = 1; int sum = 1; for (int i = 1; i \u003c n; ++i) { dp[i] = dp[i - 1] + i - left_same[i].second - (left_same[i].second - left_same[i].first); sum += dp[i]; } return sum; } }; ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string/:3:1","series":null,"tags":["dynamic programming"],"title":"828. Count Unique Characters of All Substrings of a Given String (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string/#dp-1"},{"categories":["leetcode"],"content":" 3.2 Contribution method cpp class Solution { public: int uniqueLetterString(string s) { vector\u003cvector\u003cint\u003e\u003e same(26); int n = s.size(); for (int i = 0; i \u003c n; ++i) { int idx = s[i] - 'A'; same[idx].push_back(i); } int res = 0; for (int i = 0; i \u003c 26; ++i) { for (int j = 0; j \u003c same[i].size(); ++j) { int left = 0, right = 0; if (j == 0) { left = same[i][j] + 1; } else { left = same[i][j] - same[i][j - 1]; } if (j == same[i].size() - 1) { right = n - same[i][j]; } else { right = same[i][j + 1] - same[i][j]; } res += left * right; } } return res; } }; ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string/:3:2","series":null,"tags":["dynamic programming"],"title":"828. Count Unique Characters of All Substrings of a Given String (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string/#contribution-method-1"},{"categories":["leetcode"],"content":" 1 问题描述828. 统计子串中的唯一字符 (Hard) 我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。 例如： s = \"LEETCODE\" ，则其中 \"L\", \"T\", \"C\", \"O\", \"D\" 都是唯一字符，因为它们只出现一次 ，所以 countUniqueChars(s) = 5 。 本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。 输入用例保证返回值为 32 位整数。 注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的 所有子字符串中的唯一字符）。 示例 1： text 输入: s = \"ABC\" 输出: 10 解释: 所有可能的子串为：\"A\",\"B\",\"C\",\"AB\",\"BC\" 和 \"ABC\"。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2： text 输入: s = \"ABA\" 输出: 8 解释: 除了 countUniqueChars(\"ABA\") = 1 之外，其余与示例 1 相同。 示例 3： text 输入：s = \"LEETCODE\" 输出：92 提示： 1 \u003c= s.length \u003c= 10^5 s 只包含大写英文字符 ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/:1:0","series":null,"tags":["dynamic programming"],"title":"[828. 统计子串中的唯一字符] (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/:2:0","series":null,"tags":["dynamic programming"],"title":"[828. 统计子串中的唯一字符] (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 动态规划这题很容易想到可以用动态规划来解决。我们令 $dp[i]$ 表示以 $s[i]$ 结尾的子串 $t$ 的 countUniqueChar(t) 值之和。下一步就是寻找递推关系： 假设当前 $s[i]$ 对应的字符是 $c$，那么对以 $s[i - 1]$ 结尾的子串来说，如果子串不包含 $c$，那么以 $s[i]$ 结尾，其 countUniqueChar 的值相当于对应以 $s[i - 1]$ 结尾的子串（即去掉 $c$）值 $+1$，假设字串包含一个 $c$，那么以 $s[i]$ 结尾，其 countUniqueChar 的值相当于以 $s[i - 1]$ 结尾的字串值 $-1$，假设包含两个 $c$，那么以 $s[i]$ 结尾的子串和对应以 $s[i - 1]$ 结尾的字串的 countUniqueChar 的值相等。 我们维护一个 vector\u003cpair\u003cint, int\u003e\u003e left_same，left_same[i].second 表示与 $s[i]$ 相等的字符的小于 $i$ 的最大坐标，left_same[i].first 表示次大坐标，注意 pair 需要被初始化为 $\\lbrace -1, -1\\rbrace$。 ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/:2:1","series":null,"tags":["dynamic programming"],"title":"[828. 统计子串中的唯一字符] (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/#动态规划"},{"categories":["leetcode"],"content":" 2.2 贡献值法即求对每个 s[i]，有多少个子串在统计唯一字符时，会将 s[i] 统计进去。 ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/:2:2","series":null,"tags":["dynamic programming"],"title":"[828. 统计子串中的唯一字符] (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/#贡献值法"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/:3:0","series":null,"tags":["dynamic programming"],"title":"[828. 统计子串中的唯一字符] (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 动态规划 cpp class Solution { public: int uniqueLetterString(string s) { // 维护每个字符左侧相同字符的最大坐标 int n = s.size(); vector\u003cint\u003e arr(26, -1); vector\u003cpair\u003cint, int\u003e\u003e left_same(n, {-1, -1}); for (int i = 0; i \u003c n; ++i) { if (arr[s[i] - 'A'] != -1) { left_same[i].first = left_same[arr[s[i] - 'A']].second; left_same[i].second = arr[s[i] - 'A']; } arr[s[i] - 'A'] = i; } vector\u003cint\u003e dp(n); dp[0] = 1; int sum = 1; for (int i = 1; i \u003c n; ++i) { dp[i] = dp[i - 1] + i - left_same[i].second - (left_same[i].second - left_same[i].first); sum += dp[i]; } return sum; } }; ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/:3:1","series":null,"tags":["dynamic programming"],"title":"[828. 统计子串中的唯一字符] (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/#动态规划-1"},{"categories":["leetcode"],"content":" 3.2 贡献值法 cpp class Solution { public: int uniqueLetterString(string s) { vector\u003cvector\u003cint\u003e\u003e same(26); int n = s.size(); for (int i = 0; i \u003c n; ++i) { int idx = s[i] - 'A'; same[idx].push_back(i); } int res = 0; for (int i = 0; i \u003c 26; ++i) { for (int j = 0; j \u003c same[i].size(); ++j) { int left = 0, right = 0; if (j == 0) { left = same[i][j] + 1; } else { left = same[i][j] - same[i][j - 1]; } if (j == same[i].size() - 1) { right = n - same[i][j]; } else { right = same[i][j + 1] - same[i][j]; } res += left * right; } } return res; } }; ","date":"2023-07-27","objectID":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/:3:2","series":null,"tags":["dynamic programming"],"title":"[828. 统计子串中的唯一字符] (Hard)","uri":"/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/#贡献值法-1"},{"categories":["notes"],"content":" 1 Logging layerfile system 设计的一大重要问题就是 crash recovery。这是因为文件系统操作往往涉及向磁盘多次写入，而几次写入之后的 crash 可能导致磁盘上的文件系统处于一个不一致的状态。 For example, suppose a crash occurs during file truncation (setting the length of a file to zero and freeing its content blocks). Depending on the order of the disk writes, the crash may either leave an inode with a reference to a content block that is marked free, or it may leave an allocated but unreferenced content block. 前者当系统重启之后,可能导致一个磁盘 block 被两个文件所对应，这是一个很严重的问题。 xv6 的解决方法是使用 logging（日志）。xv6 的系统调用不会直接向 on-disk file system data structure（例如 buffer 以及磁盘 block？）写入，而是将它所有希望执行的磁盘写入的描述放在磁盘的某个 log 中，once the system call has logged all of its writes, it writes a special commit record to the disk indicating that the log contains a complete operation（这里不知道怎么翻译好了）。此时，系统调用才将 disk write 应用到 on-disk file system data structure。当所有的写入操作完成后，系统调用会清除磁盘上的 log。 如果系统崩溃重启，那么 file-system 代码会在运行进程之前，先检查磁盘上的 log。如果 log 被标记为包含完整的操作，那么 file-system recovery code 会将 log 中的写操作应用到对应的 on-disk file system；否则 file-system recovery code 会直接清除 log，不执行写入操作。 如果 file system 恢复时看到 log 被标记为不包含完整操作，那么说明 log 中的写入操作都还没有应用到磁盘上，即磁盘没有发生真正的写入，因此直接清除 log 即可，不需要执行任何写入操作。 log 使得这些写入操作对 crash 来说是原子的，要么都没写入，要么全都写入到磁盘了。 ","date":"2023-07-25","objectID":"/mit6.s081-lec15.zh/:1:0","series":null,"tags":["xv6","mit","os"],"title":"Mit6.s081 Lec15: xv6 的 logging system","uri":"/mit6.s081-lec15.zh/#logging-layer"},{"categories":["notes"],"content":" 2 Log designlog 存在于磁盘的 superblock 中，它由一个 header block 和后面的一系列 updated block copies（更新块的副本，又称 logged blocks） 组成。header block 包含一个扇区号（sector index）的数组，每个 sector index 对应一个 logged block，还包含着 log blocks 的数量。header block 中的计数要么为 $0$，说明 log 中不存在 transaction，要么不为 $0$，说明 log 包含一个完整的已、已提交的 transaction，并包含指定数量的 logged blocks。 xv6 在 transaction 提交时，向 header block 写入数据，在将 logged blocks 复制到 file system 之后，将 header block 的计数置为 $0$。 为了允许 file system 的操作被不同进程并发执行，日志系统（logging system）会将多个系统调用的写操作合并成一个 transaction。因此，单次的 commit 可能涉及多个完整的系统调用的写操作，为了避免一次系统调用被划分成两次 transaction，日志系统只会在没有 file-system 系统调用的时候进行 commit。 一次一起 commit 多个 transaction 的方法被称为 group commit，group commit 能通过平摊一次提交的开销到多次操作上来降低所需的磁盘操作数。 xv6 在磁盘上标识出了一段固定大小的空间用来存放 log。因此，系统调用要写入的 blocks 必须能被这块空间容纳。对 write 和 unlink 系统调用来说，这个限制可能会导致两个问题： 假设 write 要写一个大文件，那么可能要写入许多 data blocks、bitmap blocks 和 inode blocks，unlink 一个大文件可能要写入许多 bitmap blocks 和 inode blocks。为了解决这一问题，xv6 的 write 会将一次大的写入划分成多个更小的适合 log 的写入操作，由于 xv6 只使用一个 bitmap lock，因此 unlink 不会造成问题； 除非能确定系统调用的写入能容纳于 log 的剩余空间中，否则系统不会允许系统调用执行； ","date":"2023-07-25","objectID":"/mit6.s081-lec15.zh/:2:0","series":null,"tags":["xv6","mit","os"],"title":"Mit6.s081 Lec15: xv6 的 logging system","uri":"/mit6.s081-lec15.zh/#log-design"},{"categories":["notes"],"content":" 3 Code: logging系统调用中的 log 的使用一般如下图所示： begin_op wait until the logging system is not currently commiting, and until there is enough unreserved log space to hold the writes from this call. log.outstanding 会统计预订了 log space 的系统调用的数量，被预订的总空间就是 log.outstanding 乘上 MAXOPBLOCKS。递增 log.outstanding 会预订 log space，并且防止在此系统调用期间发生 commit。 xv6 保守地预计每个系统调用都会写入 MAXOPBLOCKS 个不同的 block。 事实上 等 end_op 完成 commit() 之后，begin_op 才会被唤醒，此时不仅是 log 被提交，更新也已经被应用到了磁盘。 log_write 表现得就像是 bwrite 的代理那样。它将 block 的 sector number 记录在内存中，在 disk 的 log 部分给这个 block 预留了一个槽位，并调用了 bpin(b) 来保证 buffer b 一定不会被 evict。 调用 log_write 时，调用者已经完成了对 buffer 的数据的修改； file system 中，bwrite 只会出现于 end_op 中； 调用 bpin(b) 之后，哪怕 buffer 缓存不足时，buffer b 也不会被换出，它修改了 buffer b 的 refcnt，之所以要这样设置，是因为假设 buffer b 中途被换出到磁盘，就违背了“必须 commit 之后再将写入应用到磁盘”的设定了，也就破坏了磁盘写入相对于 crash 的原子性。 c void log_write(struct buf *b) { int i; acquire(\u0026log.lock); if (log.lh.n \u003e= LOGSIZE || log.lh.n \u003e= log.size - 1) panic(\"too big a transaction\"); if (log.outstanding \u003c 1) panic(\"log_write outside of trans\"); for (i = 0; i \u003c log.lh.n; i++) { if (log.lh.block[i] == b-\u003eblockno) // log absorption break; } log.lh.block[i] = b-\u003eblockno; if (i == log.lh.n) { // Add new block to log? bpin(b); log.lh.n++; } release(\u0026log.lock); } 在 commit 之前，block 必须要缓存在 buffer 上， 这是因为 buffer 唯一地记录着我们对这个 block 的修改；只有在 commit 之后，才可以将 buffer 写入磁盘上的位置；同一 transaction 的假设要读取这个 block，那么它必须能看到对这个 buffer 的修改。log_write 会注意到一个 transaction 中，多次写入同一个 block 的情况，如果是写入同一个 block，那么就不会添加新 block 到 log 中，而是在 log 中为该 block 分配相同的槽位。这种优化通常被称为 absorption（合并），这样的话，从 buffer 写入到 log 的槽位只会发生一次，即使写入 buffer 发生了很多次。 end_op 首先会减少未完成的系统调用的计数（说明有系统调用完成了），如果计数被递减到了 $0$，它就会通过调用 commit() 来提交当前的 transaction。这个过程分为四个阶段： write_log 将每个在 transaction 被修改的 block 的 buffer 复制到 log 对应的槽位中（先复制到了 log 的 buffer 的对应的槽位中，然后将这个 log 的 buffer 写入到磁盘） write_head 将 header block 从 buffer 写到磁盘中，而这就是 commit 的关键节点： 当完成 header block 的从 buffer 写入到磁盘后，如果发生了 crash，那么恢复程序会从 log 中执行该次事务的写操作，将数据从 log 的 buffer 写入到磁盘；TODO(zwyyy)，如果 write_head 的 bwrite(buf) 发生了一半呢？ install_trans 会从 log 的 buffer 中读取每个 block 的 buffer，然后写入到文件系统（磁盘）； end_op 将 log header 的计数重置为 $0$（说明 log 中不存在 transaction），这会在下一个 transaction 要写入 logged blocks 之前完成，这保证了 crash 恢复时，不会将前一个 transaction 的 header 与下一个 transaction 的 logged blocks 混在一起恢复，即保证了一次恢复不会涉及两个 transaction。 recover_from_log 会被 inilog 调用，而 initlog 会被 fsinit 调用，这个调用的时间点在第一个用户进程运行之前，即第一个用户进程运行之间，文件系统会进行自检。它会读取 log header，如果 log 包含一次已提交的 transaction，那么它会模拟 end_op 的操作。 使用 log 的例子可以参照 kernel/file.c 中的 filewrite，注意 writei 会调用 write_log： c begin_op(); ilock(f-\u003eip); if ((r = writei(f-\u003eip, 1, addr + i, f-\u003eoff, n1)) \u003e 0) f-\u003eoff += r; iunlock(f-\u003eip); end_op(); ","date":"2023-07-25","objectID":"/mit6.s081-lec15.zh/:3:0","series":null,"tags":["xv6","mit","os"],"title":"Mit6.s081 Lec15: xv6 的 logging system","uri":"/mit6.s081-lec15.zh/#code-logging"},{"categories":["notes"],"content":" 4 同一个 transaction 中的并发系统调用在 xv6 中，不同地系统调用来临时，如果 transaction 没有处于 committing，那么是可以有新的系统调用参与的，它们的执行顺序可以如下图： 这里，可以参与的系统调用数受到了一个限制：log.lh.n + (log.outstanding + 1) * MAXOPBLOCKS \u003e LOGSIZE)，其中 log.lh.n 在 log_write 中是会增加的，由于 log space 在 commit 之前是不会被释放的，log.outstanding 只统计了未完成的系统调用数，end_op 递减 outstanding 不会释放对应的 log space，配合 log.lh.n 的限制，才真正避免了 log space 被撑爆。 如上图的调用顺序，在 begin_op 中可能不会发生 sleep（假设 log space 够用），因此 end_op 唤醒时，可能发现没有进程可以唤醒，但是无伤大雅。 ","date":"2023-07-25","objectID":"/mit6.s081-lec15.zh/:4:0","series":null,"tags":["xv6","mit","os"],"title":"Mit6.s081 Lec15: xv6 的 logging system","uri":"/mit6.s081-lec15.zh/#同一个-transaction-中的并发系统调用"},{"categories":["notes"],"content":" 1 Overview文件系统的设计目标就是组织和存储数据，文件系统一个比较重要功能是持久化，即重启之后，数据不会丢失。xv6 通过把数据存储在 virtio disk 上来实现持久化。 文件系统设计的几大挑战： The file system needs on-disk data structures to represent the tree of named directories and files, to record the identities of the blocks that hold each file’s content, and to record which areas of the disk are free. 由于文件系统需要实现持久化，因此必须要实现 crash recovery，即如果发生意外的 crash（例如断电），文件系统在计算机重启之后要能依旧正常工作； 可能有多个进程同时操作文件系统； 由于访问磁盘比访问内存要慢得多得多，因此文件系统需要能支持将部分 popluar 的 blocks 缓存在内存中； xv6 的文件系统可以说组织为七层，如下图所示： disk layer 负责读写 virtio hard drive 上的 blocks，buffer cache layer 是 blocks 的 cache，并且保证同一时间，只有一个内核进程可以修改存储在特定块上的数据；logging layer 将对几个特定 block 的更新打包为一次 transaction（就是数据库常说的事务？），从而确保这些 blocks 都是被原子化地更新，即要么一次都更新，要么一次都不更新；inode layer 则是用来表示单独的文件，每个文件都是以具有不重复的 index 的 inode 和保存了这个文件的数据的一些 blocks 来表示；而在 directory layer，每个 directory 都是一种特殊的 inode，包含一系列 direcotry entry，directory entry 则是包含了文件名和 index（对应 indode layer 所说的 index）；pathname layer 提供了层级化的路径名，利用递归查找来解析它们； disk hardware 一般将磁盘划分为 $512$ bytes 的 block 的序列（这个 $512$ bytes 的 block 又称为 sector（扇区））。xv6 使用的 block 的大小一般是 sector 大小的整数倍。 xv6 将磁盘划分为几个功能部分，如下图所示： ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:1:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#overview"},{"categories":["notes"],"content":" 2 Buffer cache layerbuffer cache 的实现代码在 kernel/bio.c， 它主要有两个任务： 同步进程对磁盘的访问，内存中只有一份磁盘的 block 的拷贝，并且同一时间内只有一个进程可以使用这份拷贝（同时读呢，是否可行？）； 缓存 popluar blocks 到内存中，从而可以直接从内存访问磁盘的 popular blocks，避免再从速度极其慢的磁盘中读取； 这里记 struct buf 的一个实例为 buffer buffer cache 的主要接口是 bread 和 bwrite， bread 返回一个存储于内存中的 buffer（会被加锁），我们可以读取或者修改这个 buffer，bwrite 负责将一个修改过的 buffer 写回到磁盘中合适的 block 去，当完成 bwrite 时，内核线程需要调用 brelse 来释放 buffer 的锁（是一个 sleep-lock，可以理解为与自旋锁相对？） bread 会返回带锁的 buf，因为 bread 调用 bget，而 bget 会加锁，加的是 sleep-lock，相当于 pthread 中的互斥锁（与自旋锁 spin-lock 相对）； 使用 sleep-lock 是因为磁盘相关的操作，可能会消耗比较长的时间； 那些 poplular 的 blocks 其实被缓存在一个 buffer 的双向链表里面（这个双向链表是首尾相接的），双向链表的长度是有限的，这就意味着需要有缓存淘汰机制，xv6 中，这里使用了 LRU，head-\u003eprev 应该是 least recently used，而 head-\u003enext 则是 most recently。这里的头结点 head 应该是虚拟头结点？TODO(zwyyy) ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:2:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#buffer-cache-layer"},{"categories":["notes"],"content":" 3 Code: Buffer cachebuffer cache 实际上是 buffer 的双向链表，kernel/main.c 的 main 函数调用 binit，使用静态数组 buf 中的 NBUF 个 struct buf 来初始化这个链表，数组只用来初始化，之后访问 buffer 都是通过双向链表都是通过 bcache.head，也就是说这个数组只用来初始化链表！ buffer 中含有两个状态字段，valid 说明这个 buffer 含有磁盘的 block 的拷贝，因此是有效的，disk 字段为 $1$ 说明 buffer 已经写回了 disk。 bread 可以读取指定 block 对应的 buffer，如果返回的 buffer 的 valid 字段为 $0$，说明 get 是利用 lru 机制选择了一个 victim buffer，因此我们需要调用 virtio_disk_rw(b, 0) 将磁盘的对应 block 读入这个 buffer。 bget 遍历 buffer 链表寻找与 dev 和 blockno 对应的 buffer，并为这个 buffer 申请 sleep-lock，返回未解锁的 buffer；如果找不到对应的 buffer，bget 会从 head 开始，反向遍历双向链表，找一个 refcnt 为 $0$ 的 buffer，将这个 buffer 的 valid 字段标记为 $0$，即说明我们要重新从磁盘对应的 sector 读取数据到 buffer。 bget 持有 bache.lock 保证了“寻找对应的 buffer 以及如果不存在，为 block 分配对应的 buffer” 这个过程是原子的。 b-\u003erefcnt = 1 保证了这个 buffer 不会被其他进程拿来作为 victim buffer 去存放其他 block 的数据，因此可以先释放 bcache.lock 再申请 b-\u003elock。 The sleep-lock protects reads and writes of the block’s buffered content, while the bcache.lock protects information about which blocks are cached. 如果 bread 的调用者通过 bread 拿到了这个 buffer，那么通过 b-\u003elock，它享有了对这个 buffer 的独占权，如果它修改了这个 buffer 的内容，那么再释放 b-\u003elock 之前，它必须调用 bwrite 将 buffer 的被修改的内容写回到 disk。 调用者完成对 buffer 的处理之后，必须调用 brelse 将 b-\u003elock 释放。 ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:3:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#code-buffer-cache"},{"categories":["notes"],"content":" 4 Code: Block allocator文件和目录的内容都是存放在 disk blocks 里的，我们必须从未分配的那些 blocks pool 中，为这些数据分配对应的块（就像为程序分配物理内存）。 xv6 的 block allocator 在磁盘上维护了一个 free bitmap，每个 block 对应一个 bit。bit 为 $0$ 表示这个 bit 对应的 block 是空闲的，bit 为 $1$ 表示这个 block 正在被使用。程序 mkfs 将这些 bits 与 boot sector、superblock、log blocks、inode blocks、bitmap blocks 对应起来。 balloc 的实现代码如下： c static uint balloc(uint dev) { int b, bi, m; struct buf *bp; bp = 0; for (b = 0; b \u003c sb.size; b += BPB) { bp = bread(dev, BBLOCK(b, sb)); for (bi = 0; bi \u003c BPB \u0026\u0026 b + bi \u003c sb.size; bi++) { m = 1 \u003c\u003c (bi % 8); if ((bp-\u003edata[bi / 8] \u0026 m) == 0) { // Is block free? bp-\u003edata[bi / 8] |= m; // Mark block in use. log_write(bp); brelse(bp); bzero(dev, b + bi); return b + bi; } } brelse(bp); } panic(\"balloc: out of blocks\"); } balloc 遍历所有的 block，sb.size 表示的就是当前文件系统的总的 block 的数量，balloc 首先寻找当前 block 对应的 bitmap block，一个 block 占据 $1024$ 个字节，因此，一个 bitmap block 可以表示 $8\\times 1024$ 个 block 是否被占用，即 BPB 个 block，因此外层循环每次递增 BPB，读取这 BPB 个 block 对应哪个 bitmap block，然后在内层循环检查每个 block 是否被使用，如果未被使用，将其标记为正在被使用，然后返回。 由于 buffer cache 保证了 bitmap block 的 buffer 同一时间只能有一个进程使用，因此避免了 race condtion。 bfree 则会直接清除要 free 的 block 在 bitmap block 中的对应 bit。bread 和 brelse 隐含的独占使用避免了争用的情况。 balloc 和 bfree 只能在 transaction 内部被调用，后面会提到的多数函数也是这样。 ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:4:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#code-block-allocator"},{"categories":["notes"],"content":" 5 Inode layer术语 inode 可能包含两种含义： 一种包含“文件的大小、以及该文件占据的 data blocks 的索引的数组”的 on-disk data structure； 指上述的 inode 在内存中的副本以及内核所需要的额外信息； on-disk inodes 被打包到了磁盘中的 inode blocks 区域，这个区域是连续的，每个 inode 都是相同的固定大小，因此我们可以通过 inode 的索引 $n$ 来找到磁盘上的这个 inode。 inode 的索引被称为 inode number，又称 i-number。 同一个文件可能有多个文件名（通过 link 系统调用实现） 内核会将有指针指向的 inode 保存在内存中的 itable 中，如果指向该 inode 的指针数量降低为 $0$，那么内核会从内存中丢弃该 inode。itable 的 ref 字段统计了指向该 inode 的指针数量。 指向 inode 的指针可能是来自于文件描述符、当前工作目录、以及 exec 等内核的 transient code。 在 xv6 的 inode 相关的代码中，锁或者类似锁的机制一共有四种。 itable.lock 保证 inode 在 inode table 中最多只会缓存一次，并且保证 ref 一定是指向该 inode 的内存中的指针数量； 每个 in-memory inode 都有一个 lock 字段（sleep-lock），确保以独占的方式访问 inode 的字段以及该 inode 对应的 content blocks； 如果 inode 的 ref 大于 $0$，系统会在 itable 中维护 inode 的缓存，并且不会重用该 table entry 为其他 inode 的缓存； nlink 大于 $0$ 时，这个 inode 不会被释放。在 on-disk 的 dinode 和 inode 中都有该字段。 在调用 iput 之前，iget 返回的指向 inode 的指针始终有效并始终指向该 inode，iget 是非独占的（不同于bread），即同时可能有多个指针指向该 inode。 iget 的机制既可以让指针长期指向该 inode，还可以避免死锁的情况下防止 race condition（因为都是只读？） in-memory inode 的主要功能是实现不同进程对 inode 访问的同步，cache 只是次要的，因为有 buffer 的存在。in-memory inode 缓存是直写的，修改了指向该 inode 的缓存，就必须马上调用 iupdate 写回磁盘。 iupdate 的直写策略不会破坏 crash 的一致性吗？TODO(zwyyy) 似乎还是修改的 inode 对应的 data block 的 buffer，然后调用 log_write 向 log 中做标记 ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:5:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#inode-layer"},{"categories":["notes"],"content":" 6 Code: Inode contenton-disk inode 定义于 kernel/fs.h 的结构体 dinode 中： dinode 的 type 字段标识出该 inode 是普通文件、目录还是设备（特殊文件）。type 为 $0$ 表示此 inode 是空闲的。 nlink 字段表示有多少文件名指向当前的 inode，用于确定何时释放这个 inode 对应的 data block。 size 字段说明了文件中的内容占据的字节数。 addrs 字段是一个长度为 NDIRECT + 1（即 $13$）的数组，前 $12$ 个元素记录了 data block 的编号，指向构成文件的前 $12$ 个 block，最后一个元素记录了一个特殊的 block 的编号，这个 block 里面存储的是 $256$ 个 data block 的编号，每个编号指向构成文件的后最多 $256$ 个 data block 的其中之一，每个编号占据 $4$ 个字节； 一个文件最多占 $(12 + 256) * 1024$ 字节大小； static uint bmap(struct inode *ip, uint bn) 返回 inode ip 的第 bn 个 block 在磁盘中的 block 编号，如果磁盘中的 block 不存在，那么 bmap 会调用 balloc 来分配。（ip-\u003eaddrs[i] 或者 ip-\u003eaddrs[NDIRECT] 对应的 entry 的值是 $0$，说明这个 block 没有被分配） c static uint bmap(struct inode *ip, uint bn) { uint addr, *a; struct buf *bp; if (bn \u003c NDIRECT) { if ((addr = ip-\u003eaddrs[bn]) == 0) ip-\u003eaddrs[bn] = addr = balloc(ip-\u003edev); return addr; } bn -= NDIRECT; if (bn \u003c NINDIRECT) { // Load indirect block, allocating if necessary. if ((addr = ip-\u003eaddrs[NDIRECT]) == 0) ip-\u003eaddrs[NDIRECT] = addr = balloc(ip-\u003edev); bp = bread(ip-\u003edev, addr); a = (uint *)bp-\u003edata; if ((addr = a[bn]) == 0) { a[bn] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); return addr; } panic(\"bmap: out of range\"); } ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:6:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#code-inode-content"},{"categories":["notes"],"content":" 6.1 writei 与 readireadi 首先会确保文件的 offset 以及 offset 加上要读取的字节数不会超过文件的 size，否则返回 error（return 0;），此时返回的读取的字节数小于预期要读取的字节数；没有异常，则住循环遍历文件的所有 block，从 buffer 中把数据复制到 dst 中。 writei 与 readi 类似，首先检查 offset 小于或等于文件的 size，同时保证写入文件不会导致文件超过最大文件大小的限制。 stati 将 inode 的 metadata 到 stat 结构体中，这是用户程序通过 stat 系统调用所需要获取的。 ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:6:1","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#writei-与-readi"},{"categories":["notes"],"content":" 7 Code：Inodesxv6 调用 ialloc 来分配新的 inode，它遍历所有的 inode 来找到一个空闲的 inode，找到之后将新的 type 写入到这个 inode 的 buffer 中，然后调用 log_write，最后调用 iget 返回一个内存中 inode（即将这个 inode 写入到 inode cache）中。 iget 查找 itable 来找到具有给定 dev 和 inode 的 active entry，如果找到了，就返回指向该 inode 的指针；如果不存在，它不会从磁盘中读，只是从 itable 中回收一个 entry 并返回该 entry，调用 ilock 的时候，才真正从磁盘中读取数据到 inode。 atcive 是指该 inode 有指针指向，即 ref \u003e 0。 ilock 对 inode 上锁，iunlock 解锁；可能有多个进程持有指向该 inode 的指针，但是只有一个进程能对该 inode 上锁。 c static struct inode * iget(uint dev, uint inum) { struct inode *ip, *empty; acquire(\u0026itable.lock); // Is the inode already in the table? empty = 0; for (ip = \u0026itable.inode[0]; ip \u003c \u0026itable.inode[NINODE]; ip++) { if (ip-\u003eref \u003e 0 \u0026\u0026 ip-\u003edev == dev \u0026\u0026 ip-\u003einum == inum) { ip-\u003eref++; release(\u0026itable.lock); return ip; } if (empty == 0 \u0026\u0026 ip-\u003eref == 0) // Remember empty slot. empty = ip; } // Recycle an inode entry. if (empty == 0) panic(\"iget: no inodes\"); ip = empty; ip-\u003edev = dev; ip-\u003einum = inum; ip-\u003eref = 1; ip-\u003evalid = 0; release(\u0026itable.lock); return ip; } void ilock(struct inode *ip) { struct buf *bp; struct dinode *dip; if (ip == 0 || ip-\u003eref \u003c 1) panic(\"ilock\"); acquiresleep(\u0026ip-\u003elock); if (ip-\u003evalid == 0) { bp = bread(ip-\u003edev, IBLOCK(ip-\u003einum, sb)); dip = (struct dinode *)bp-\u003edata + ip-\u003einum % IPB; ip-\u003etype = dip-\u003etype; ip-\u003emajor = dip-\u003emajor; ip-\u003eminor = dip-\u003eminor; ip-\u003enlink = dip-\u003enlink; ip-\u003esize = dip-\u003esize; memmove(ip-\u003eaddrs, dip-\u003eaddrs, sizeof(ip-\u003eaddrs)); brelse(bp); ip-\u003evalid = 1; if (ip-\u003etype == 0) panic(\"ilock: no type\"); } } iput 会递减 ref 并释放一个指向该 inode 的指针，如果 ref 变为 $0$，那么 itable 中原本属于该 inode 的位置就能用来存放另外的 inode 缓存。如果 iput 发现即没有指针指向该 inode，又没有文件名或者目录指向该 inode，那么该 inode 和他的 data blocks 会被释放，iput 会调用 itrunc 将文件大小缩短至 $0$，释放对应的 data blocks，然后 iput 将 inode type 置为 $0$，将该 inode 写回磁盘。 在 inode-\u003eref 是 $1$ 的时候，系统调用无法获取这个 in-memory inode 的指针，这个 inode-\u003eref 为 $1$ 的计数是调用 iput 的进程持有的。 iput 会向磁盘写入，这意味着任何 file system call 都可能向磁盘写入（因为系统调用可能是最后一个引用该 inode 的系统调用），哪怕它看起来只是读取磁盘，因此，所有 file system call 都应该打包成 transaction 来处理。 ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:7:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#codeinodes"},{"categories":["notes"],"content":" 8 Code：directory layer目录其内部实现其实很像一个文件，只不过它的 inode type 是 T_DIR，这个 inode 的 data blocks 里面的数据是一系列的 directory entry，每个 entry 都是一个 dirent 结构体。inode 为 $0$ 的 directory entry 是空闲的。 c struct dirent { ushort inum; char name[DIRSIZ]; }; dirlookup 会在给定目录 dp 中，查找给定“路径名”对应的 target inode，并将 poff 设定为 target inode 在 dp 中的 offset，然后返回 target inode 的指针（通过 iget）。 dirlookup 是 iget 不能返回上锁的 inode 的原因之一，dirlookup 的调用者会对 dp 上锁，假设要查询的目录就是 .，即当前目录，那么调用者对 dp 上锁，iget 也会对 dp 上锁，就发生了死锁，因此 iget 不能返回上锁的 inode（iget 只对 itable 上锁，返回时会解锁）。dirlookup 的调用者可以先解锁 dp，再锁定 ip。 c struct inode *dirlookup(struct inode *dp, char *name, uint *poff) { uint off, inum; struct dirent de; if (dp-\u003etype != T_DIR) panic(\"dirlookup not DIR\"); for (off = 0; off \u003c dp-\u003esize; off += sizeof(de)) { if (readi(dp, 0, (uint64)\u0026de, off, sizeof(de)) != sizeof(de)) panic(\"dirlookup read\"); if (de.inum == 0) continue; if (namecmp(name, de.name) == 0) { // entry matches path element if (poff) *poff = off; inum = de.inum; return iget(dp-\u003edev, inum); } } return 0; } dirlink 会向给定目录的 inode 写入一个具有指定路径名的新 directory entry，如果这个名字已经存在了，那么 dirlink 会 return error。之后，dirlink 在主循环中寻找未分配的 directory entry，如果找到了，就向这个未分配的 entry 对应的 offset 来进行写入。 c // Write a new directory entry (name, inum) into the directory dp. int dirlink(struct inode *dp, char *name, uint inum) { int off; struct dirent de; struct inode *ip; // Check that name is not present. if ((ip = dirlookup(dp, name, 0)) != 0) { iput(ip); return -1; } // Look for an empty dirent. for (off = 0; off \u003c dp-\u003esize; off += sizeof(de)) { if (readi(dp, 0, (uint64)\u0026de, off, sizeof(de)) != sizeof(de)) panic(\"dirlink read\"); if (de.inum == 0) break; } strncpy(de.name, name, DIRSIZ); de.inum = inum; if (writei(dp, 0, (uint64)\u0026de, off, sizeof(de)) != sizeof(de)) panic(\"dirlink\"); return 0; } ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:8:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#codedirectory-layer"},{"categories":["notes"],"content":" 9 Code: Path names路径名的查找涉及一系列的 dirlookup，例如查找 /x/y/z，就要先查到根目录下的 x，再查找 x 目录下的 y/z，再查找 y 目录下的 z。namei 直接调用 namex 来查找路径名对应的 inode；nameiparent 则是返回要查询的路径的父文件夹对应的 inode 并将最后一个元素复制到 name（例如查询 y/x/z，返回 x 对应的 inode，name 设置为 z）。 注意 C 中空字符串是 \"\\0\"，因此 skipelem(\"a\", name) 的返回值不是 $0$！ namex 首先检查路径是相对路径还是绝对路径，如果路径以 ‘/’ 开头，那么从 root inode 开始查找，否则以当前目录对应的 inode 开始查找。然后使用 skipelem 来获取路径的每一级的目录名，例如 skipelem(\"x/y/z\", name) = y/z，而 name = x，每次循环中，都会更新 ip 为 dirlookup(ip, name, 0) 返回的 inode 的指针。 之所以要用 ilock 锁定 inode，是因为运行 ilock 前，不能确保一定从磁盘读取了 ip-\u003etype，有可能这个 inode 只是被分配了，数据还没有从磁盘或者 buffer 更新。 c static struct inode *namex(char *path, int nameiparent, char *name) { struct inode *ip, *next; if (*path == '/') ip = iget(ROOTDEV, ROOTINO); else ip = idup(myproc()-\u003ecwd); while ((path = skipelem(path, name)) != 0) { ilock(ip); if (ip-\u003etype != T_DIR) { iunlockput(ip); return 0; } if (nameiparent \u0026\u0026 *path == '\\0') { // Stop one level early. iunlock(ip); return ip; } if ((next = dirlookup(ip, name, 0)) == 0) { iunlockput(ip); return 0; } iunlockput(ip); ip = next; } if (nameiparent) { iput(ip); return 0; } return ip; } namex 可能需要花费很长的时间，xv6 通过精心设计，确保当 namex 的一次调用被磁盘 I/O 阻塞时，另一个查找不同路径的内核进程可以并发执行。namex 对路径中的每层目录会单独上锁，所以查找不同目录的进程可以并行执行。 在 namex 执行 dirlookup 的时候，namex 持有当前目录 inode 的锁，而 dirlookup 返回的时候会调用 iget，iget 会递增当前 inode 的引用计数（接下来是个人理解），只有在 dirlookup 返回了 next 之后，才会调用 iunlockput 来解除对 ip 的锁并且递减 ip 的引用计数，此时已经可以释放并删除 ip 对应的 inode 了，而即使此刻我们 unlink next 对应的 inode，xv6 也不会删除这个 inode，因此 next 的引用计数被 iget 递增了。 这样就避免了，在执行 dirlookup 的时候，正在查找的 inode（与 target inode 相对），已经被另一个内核进程删除且 inode 的 block 已经被用作他途了。 查找 . 时，返回的 next 与当前 ip 相等，而 iget 不会对当前 inode（即 ip 上锁），namex 在获得下一个目录的锁之前会释放锁，于是就避免了死锁。 ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:9:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#code-path-names"},{"categories":["notes"],"content":" 10 File descriptor layer每个进程会维护自己打开的文件描述符的 table，每个文件由 struct file 表示（位于 kernel/file.h），文件的类型要么是 pipe，要么是 inode（需要配合 offset）。进程每次调用 open 都会创建一个新的文件描述符，和一个新的 struct file，如果多个进程独立地打开同一个文件，那么它们的文件描述符和 struct file 是不同的，但是 file 中的 inode 指针是相同的，而 offset 也自然会因为进程对文件的操作而不同。而相同的 struct file 也可能出现在不同的进程中，这可能通过调用 dup 或者 fork 来实现（此时 file 中的 ref 字段会递增）。 系统中所有打开的文件都保存在一个全局的 ftable 中（定义于 kernel/file.c），其中还有 filealloc、filedup、fileclose，这三者调用的时候都会请求 ftable.lock。这三者看一下源码，很容易就能理解它们在干什么。调用 fileclose 时，如果发现 file 的 ref 被递减到了 $0$，那么 fileclose 会调用 iput 来递减 inode 的 ref，这个过程被打包成了 transaction。 注意，iput 会调用 iupdate，而 iupdate 在完成对 inode 的更新后，会调用 log_write。 filestat 只允许对 inode 类型的 file 操作，调用 stati 来实现。fileread 和 filewrite 会检查读或者写操作是否在 sys_open 时被允许，然后调用 pipe 或者 inode 的对应实现。对 inode 的操作会调用 ilock 上锁，因此多个进程写不可能同时写同一个文件，只能依次写，但由于多个进程的 offset 不一致，最终表现出来文件的内容可能还是交错的。 ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:10:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#file-descriptor-layer"},{"categories":["notes"],"content":" 11 Code: System calls通过使用 lower layers 提供的函数，大多数 file-system call 的实现都不难，但是我们还是得关注几个系统调用。 ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:11:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#code-system-calls"},{"categories":["notes"],"content":" 11.1 sys_link 与 sys_unlink这两个函数都是 transaction 的很好的例子。sys_link 通过 argaddr 获取 old 和 new 两个路径名参数，先对 old 作检查（包括是否有对应 inode，inode 是否是目录类型），然后递增该 inode 的 nlink，然后查找 new 目录的父目录，利用 dirlink 在这个父目录下创建一个 directory entry，指向 inode，实现 new 与 inode 的绑定。 注意其中的 begin_op 和 end_op。 这个过程涉及对多个 disk blocks 的更新，但是借助 transaction，我们不需要关注更新的顺序，因为我们要么全都成功更新，要么全没有更新。 sys_link 的功能其实就是为已存在的 inode 创建一个新的别名（可能位于另外的目录下）， 函数 create 为一个新的名字创建一个新的 inode，它是 sys_open、sys_mkdir、sys_mkdev 的泛化，后三者的实现都需要调用 create。create 的实现根据源码来看，不难理解。值的注意的是，create 会同时持有 ip 和 ip 的父目录对应的 inode dp 的锁，但这不会造成死锁，因为 ip 是新分配的，不会有进程持有这个 ip 的锁然后来试图持有 dp 的锁。 sys_open 根据传入的 flag 的不同，会有不同的行为。flag 是 O_CREATE 时，会调用 create 来创建，它会返回上锁的 ip，而 namei 则返回无锁的 ip（因此必须要 sys_open 自身来锁定）。sys_open 会创建一个 file，分配一个 fd 与这个 file 对应，返回该 fd。 其他进程无法访问部分初始化的 file，因为它仅位于当前进程的表中。 ","date":"2023-07-22","objectID":"/mit6.s081-lec14.zh/:11:1","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Lec14: File system","uri":"/mit6.s081-lec14.zh/#sys_link-与-sys_unlink"},{"categories":["notes"],"content":" 1 Uthread: switching between threads这个题还是对的起它 moderate 的难度了，如果认真看了 book-riscv-rev2.pdf 的 Scheduling 章节，以及看了这个 课程翻译，那么这题可以很快做出来，个人觉得 pdf 讲得更加清楚一些。 这个题甚至帮你把需要添加代码的地方都标注出来了，参照题目说明，主要有三步： 修改 thread_create 来保证当 thread_schedule 第一次运行 thread_create 创建出来的线程时，该线程就会在自己的 stack 上执行传递给 thread_create 的函数，这里我们可以参照 allocproc 的实现，在 thread_create 标记出来的要我们添加代码的地方添加如下三行： c memset(\u0026t-\u003econtext, 0, sizeof(t-\u003econtext)); t-\u003econtext.ra = (uint64)func; t-\u003econtext.sp = (uint64)t-\u003estack + STACK_SIZE; 保证 thread_switch 会切换并保存寄存器，这里参照 scheduler 的实现即可，在注释标记的地方添加以下语句，并且在 uthread_switch.S 中实现 thread_switch 函数（照抄 swtch 即可）： c thread_switch((uint64)\u0026t-\u003econtext, (uint64)\u0026current_thread-\u003econtext); asm thread_switch: /* YOUR CODE HERE */ sd ra, 0(a0) sd sp, 8(a0) sd s0, 16(a0) sd s1, 24(a0) sd s2, 32(a0) sd s3, 40(a0) sd s4, 48(a0) sd s5, 56(a0) sd s6, 64(a0) sd s7, 72(a0) sd s8, 80(a0) sd s9, 88(a0) sd s10, 96(a0) sd s11, 104(a0) ld ra, 0(a1) ld sp, 8(a1) ld s0, 16(a1) ld s1, 24(a1) ld s2, 32(a1) ld s3, 40(a1) ld s4, 48(a1) ld s5, 56(a1) ld s6, 64(a1) ld s7, 72(a1) ld s8, 80(a1) ld s9, 88(a1) ld s10, 96(a1) ld s11, 104(a1) ret /* return to ra */ 修改 strcut thread 来存储 thread_switch 时需要保存的寄存器，还是参照 struct proc 即可： c struct t_context { uint64 ra; uint64 sp; // callee saved uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11; }; struct thread { char stack[STACK_SIZE]; /* the thread's stack */ int state; /* FREE, RUNNING, RUNNABLE */ struct t_context context; }; 这样修改之后就能通过 uthread 了。 ","date":"2023-07-22","objectID":"/xv6-lab7.zh/:1:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab7: Multithreading","uri":"/xv6-lab7.zh/#uthread-switching-between-threads"},{"categories":["notes"],"content":" 2 Using threads首先，注意 include \u003cpthread.h\u003e 应该在文件内容的最前面，否则 make ph 时容易出现意料之外的问题。 在多线程执行 ph 时，之所以会出现 xxx keys missing，是因为写的时候，假设有两个 put 进程，keys 的数量一共为 $100$，那么进程 $1$ 会负责写 $0\\sim 49$，进程 $2$ 会负责写 $50\\sim 99$，NBUCKET = 5，那么两个进程会往同一个 bucket 中写入 entry，这就是出现问题的原因。 假设进程 $1$ 执行 insert(1, 3, \u0026table[1], table[1]);，进程 $2$ 执行 insert(6, 2, \u0026table[1], table[1])，就会出现类似 kalloc 的 freelist 中，两个进程同时往链表插入头结点的情况。 解决方案很简单，针对要访问的 table[i] 加上互斥锁来保护即可，因此，我们需要一个互斥锁的数组 mutex，数组大小为 NBUCKET，需要访问 table[i]，就申请持有 mutex[i] 。 读取的时候不需要上锁，记得要先在 main 函数中初始化互斥锁。 ","date":"2023-07-22","objectID":"/xv6-lab7.zh/:2:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab7: Multithreading","uri":"/xv6-lab7.zh/#using-threads"},{"categories":["notes"],"content":" 3 Barrier这个其实不难，只不过之前的 lab 让我有点害怕 moderate。。。 主要是要防止第二次 round 不会影响上一次的 round。我们保证每次，所有的线程都到达 barrier 之后才会增加一次 bstate.round。 c static void barrier() { // YOUR CODE HERE // // Block until all threads have called barrier() and // then increment bstate.round. // // nthread 就是我们输入的第二个参数 pthread_mutex_lock(\u0026bstate.barrier_mutex); ++bstate.nthread; if (bstate.nthread == nthread) { bstate.round += 1; bstate.nthread = 0; pthread_cond_broadcast(\u0026bstate.barrier_cond); } else { pthread_cond_wait(\u0026bstate.barrier_cond, \u0026bstate.barrier_mutex); } pthread_mutex_unlock(\u0026bstate.barrier_mutex); } 其实一开始因为想着条件变量总会配合 while 循环，因此写了两个 while 循环，两个条件变量来实现，但是按上面的单纯 if 就可以实现了。 ","date":"2023-07-22","objectID":"/xv6-lab7.zh/:3:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab7: Multithreading","uri":"/xv6-lab7.zh/#barrier"},{"categories":[""],"content":" 1 nfs首先执行 sudo apt install nfs-kernel-server 安装 nfs，然后执行 sudo nvim /etc/exports 编辑 /etc/exports 文件，添加以下内容 sh # share documents /home/zwyyy/Documents 192.168.6.0/24(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000) # share downloads /home/zwyyy/Downloads 192.168.6.0/24(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000) # external disk /home/zwyyy/mnt/ext 192.168.6.0/24(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000) 最前面是路径，根据自己需求来写。 192.168.6.0/24 是为了保证同一局域网下都能连接，all_squash,anonuid,anongid 保证客户端连接到 nfs 服务端的时候，都是以 uid=1000,gid=1000 用户和用户组连接的，这样就解决了 mac 连接上 nfs 之后无法写入的问题。 然后 debian 执行以下命令 sh sudo exportfs -ra sudo systemctl start nfs-server sudo systemctl enable nfs-server 然后 mac 执行 sudo mount -t nfs -o resvport 192.168.6.155:/home/zwyyy/Documents ~/Downloads/deb-doc 将 nfs 服务端的路径挂载到本地，具体路径根据自己需求来写。 注意确保执行挂载命令前，mac 的对应目录已经存在。 Windows 不建议通过 nfs 方式连接到 nas。 ","date":"2023-07-21","objectID":"/debian-file-share-pt.zh/:1:0","series":null,"tags":[""],"title":"debian 配置文件共享（samba、nfs）与 pt","uri":"/debian-file-share-pt.zh/#nfs"},{"categories":[""],"content":" 2 samba首先执行 sudo apt install samba 安装 samba 服务，执行 sudo nvim /etc/samba/smb.conf，编辑 Share Definitions 部分： txt [homes] comment = Home Directories path = /home/zwyyy browseable = yes read only = no writable = yes # 当 Windows 通过 samba 连接到 Debian 时，windows 通过 samba 在 Debian 创建文件时的文件权限为 0764 create mask = 0764 directory mask = 0764 valid users = %s path 修改为要共享的路径。 然后执行 sudo smbpasswd -a zwyyy 创建对应的 samba 用户 zwyyy，这个过程会需要你输入密码，之后便可以通过这个用户连接到 samba 了，注意创建的 samba 用户名必须是 Debian 系统中已经存在的用户名。 然后执行 sudo systemctl restart smbd，之后就能在 Windows 上通过 samba 连接到 Debian 了。 打开 Windows 的文件管理，右键点击 此电脑，点击 映射网络驱动器，盘符随便选，网址为 \\\\192.168.6.181\\homes，注意 ip 改为自己要连接的设备的 ip，homes 改为与上面 Share Definitions 中方括号包裹的内容，如下图所示： ","date":"2023-07-21","objectID":"/debian-file-share-pt.zh/:2:0","series":null,"tags":[""],"title":"debian 配置文件共享（samba、nfs）与 pt","uri":"/debian-file-share-pt.zh/#samba"},{"categories":["notes"],"content":" 1 Sleep and wakeupSleep 允许一个内核线程等待某个特定事件的发生，另一个线程可以调用 wakeup 来表示这个正在等待时间发生的线程应该恢复了。 Sleep and wakeup are often called sequence cooridination or conditional synchronization mechanisms. xv6 中利用 sleep 和 wakeup 实现了一种 high-level 的同步机制，被称为信号量（semaphore），用于协调生产者和消费者（xv6 中并未使用信号量）。 A semaphore maintains a count and provides two operations. The “V” operation (for the producer) increments the count. The “P” operation (for the consumer) waits until the count is non-zero, and then decrements it and returns. c struct semaphore { struct spinlock lock; int count; }; void V(struct semaphore *s) { acquire(\u0026s-\u003elock); s-\u003ecount += 1; // wakeup(s); release(\u0026s-\u003elock); } void P(struct *s) { while (s-\u003ecount == 0) //sleep(s); ; acquire(\u0026s-\u003elock); s-\u003ecount -= 1; release(\u0026s-\u003ecount); } 上述代码给出了一个非常简单但是性能不优秀的 “生产者-消费者” 模型实现，如果生产者很少工作，那么消费者会花费大量时间在 while 循环中。为了避免这一点，消费者应该要有办法主动让出 cpu，并且只在 V 递增 s-\u003ecount 之后才恢复执行。 注释中给出了一种简单的实现办法。然而，仅仅是这样并不够，因为存在一个 lost wake-up 问题。 （先考虑一个 P 和一个 V 的情况）假设 P 执行完 while (s-\u003ecount == 0)，正准备执行 sleep(s)，这时候 V 递增了 s-\u003ecount，然后准备唤醒一个线程，然而由于这时 P 还没有 sleep，因此没有线程可以被 V 唤醒，那么即使 s-\u003ecount 已经不为 $0$ 了，P 还是执行了 sleep(s)，然而，除非 V 再次递增 s-\u003ecount，否则 P 永远不会被唤醒。这就是 lost wake-up，即有一次 wake-up 丢失了，本该唤醒进程却没有，而 P 一直在等待这个已经发生了的唤醒。 如果简单的把 acquire(\u0026s-\u003elock) 移动到 P 的最开始，看起来可以解决问题，但是会造成更严重的死锁问题，P 持有锁，然后 sleep，因此 P 在被唤醒之前不会主动释放锁，而 V 需要持有锁才能唤醒 P。 为了解决 lost wake-up 问题，同时避免死锁，我们需要修改一下 sleep 的接口， c void P(struct semaphore *s) { acquire(\u0026s-\u003elock); while(s-\u003ecount == 0) sleep(s, \u0026s-\u003elock) s-\u003ecount -= 1; release(\u0026s-\u003elock); } 在 sleep 中，我们会在 proc 已经被标记成 asleep 之后再释放 s-\u003elock，这就保证了 V 直到 P 让自己完成睡眠之后才能尝试递增计数和唤醒进程。我们这里可以将 s-\u003elock 称为 condtion lock。 ","date":"2023-07-20","objectID":"/mit6.s081-lec13.zh/:1:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Sleep \u0026 Wake up","uri":"/mit6.s081-lec13.zh/#sleep-and-wakeup"},{"categories":["notes"],"content":" 2 Code: Sleep and wakeupxv6 的 sleep 和 wakeup 的实现机制与使用规则避免了 lost wake-up。 xv6 的 sleep 的基础机制就是 sleep 将当前进程标记为 SLEEPING，并调用 sched 来让出 cpu；而 wakeup 寻找等待队列中一个 sleeping 的进程，然后将它标记为 RUNNABLE。xv6 一般使用涉及 wait 的内核数据结构的地址作为 channel。 c void sleep(void *chan, struct spinlock *lk) { struct proc *p = myproc(); acquire(\u0026p-\u003elock); // DOC: sleeplock1 release(lk); // Go to sleep. p-\u003echan = chan; p-\u003estate = SLEEPING; sched(); // Tidy up. p-\u003echan = 0; // Reacquire original lock. release(\u0026p-\u003elock); acquire(lk); } 当要 sleep 的进程持有了 \u0026p-\u003elock 之后，就可以释放 s-\u003elock（即 lk 了），持有 lk 是为了避免在进程进入睡眠之前，就有 V 来唤醒它，造成 lost wake-up，当持有 \u0026p-\u003elock 之后，由于 wakeup 进程需要持有该进程的锁，因此持有 \u0026p-\u003elock 就能避免该进程在进入睡眠之前就被唤醒了，于是我们可以释放 lk 了。而 \u0026p-\u003elock 会在完成睡眠，调用 sched 之后，由 scheduler 线程释放，这里跟定时器中断导致的进程切换是一致的。 理解了 sleep，再看 wakeup 其实就不难理解了。 c void wakeup(void *chan) { struct proc *p; for (p = proc; p \u003c \u0026proc[NPROC]; p++) { if (p != myproc()) { acquire(\u0026p-\u003elock); if (p-\u003estate == SLEEPING \u0026\u0026 p-\u003echan == chan) { p-\u003estate = RUNNABLE; } release(\u0026p-\u003elock); } } } 虚假唤醒：有时候可能会出现多个进程睡眠在同一个 channel 上的情况，例如多个进程从同一个 pipe 中读取数据，一次 wakeup 调用会唤醒所有的这些进程，但是当一个进程被 scheduler 线程选择，将数据读取完之后，递减计数，于是其他睡眠的进程会发现，自己虽然被唤醒了，但是 s-\u003ecount 依旧是 $0$，这种情况我们被称为虚假唤醒，由于 sleep 处于 while(s-\u003ecount == 0) 的循环中，因此会被困在循环中，再次睡眠，因此虚假唤醒这个问题是可以接受的。 这里 sleep 最后的 acquire 保证了，即使一次有多个睡眠进程被标记为 RUNNABLE，也只有一个进程能够获取到 lk，执行生产者的操作并递减 s-\u003ecount。 sleep 与 wakeup 的吸引力在于它们都非常轻量，不需要创建特定数据结构来充当 sleep 的 channel，并且提供了一层间接性，调用者不需要知道具体与哪个进程交互。 ","date":"2023-07-20","objectID":"/mit6.s081-lec13.zh/:2:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Sleep \u0026 Wake up","uri":"/mit6.s081-lec13.zh/#code-sleep-and-wakeup"},{"categories":["notes"],"content":" 3 Code: Pipes这里要主要是理解 piperead 和 pipewrite，这要求我们注意两点：一是 sleep 会申请进程锁再释放 pi-\u003elock，scheduler 线程切换回 sleep 之后，会释放进程锁再申请 pi-\u003elock。而 wakeup 只会申请与释放进程锁。 piperead 中 pi-\u003enread == pi-\u003enwrite 就起到了 s-\u003ecount == 0 的作用，在 pipewrite 中则是 pipewrite == piperead + PIPESIZE，pipewrite 是生产者， piperead 是消费者。 pipe 的实现针对 reader 和 writer 使用了不同的 channel（\u0026pi-\u003enread 与 \u0026pi-\u003enwrite）。 c int pipewrite(struct pipe *pi, uint64 addr, int n) { int i = 0; struct proc *pr = myproc(); acquire(\u0026pi-\u003elock); while (i \u003c n) { if (pi-\u003ereadopen == 0 || pr-\u003ekilled) { release(\u0026pi-\u003elock); return -1; } if (pi-\u003enwrite == pi-\u003enread + PIPESIZE) { // DOC: pipewrite-full wakeup(\u0026pi-\u003enread); sleep(\u0026pi-\u003enwrite, \u0026pi-\u003elock); } else { char ch; if (copyin(pr-\u003epagetable, \u0026ch, addr + i, 1) == -1) break; pi-\u003edata[pi-\u003enwrite++ % PIPESIZE] = ch; i++; } } wakeup(\u0026pi-\u003enread); release(\u0026pi-\u003elock); return i; } int piperead(struct pipe *pi, uint64 addr, int n) { int i; struct proc *pr = myproc(); char ch; acquire(\u0026pi-\u003elock); while (pi-\u003enread == pi-\u003enwrite \u0026\u0026 pi-\u003ewriteopen) { // DOC: pipe-empty if (pr-\u003ekilled) { release(\u0026pi-\u003elock); return -1; } sleep(\u0026pi-\u003enread, \u0026pi-\u003elock); // DOC: piperead-sleep } for (i = 0; i \u003c n; i++) { // DOC: piperead-copy if (pi-\u003enread == pi-\u003enwrite) break; ch = pi-\u003edata[pi-\u003enread++ % PIPESIZE]; if (copyout(pr-\u003epagetable, addr + i, \u0026ch, 1) == -1) break; } wakeup(\u0026pi-\u003enwrite); // DOC: piperead-wakeup release(\u0026pi-\u003elock); return i; } ","date":"2023-07-20","objectID":"/mit6.s081-lec13.zh/:3:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Sleep \u0026 Wake up","uri":"/mit6.s081-lec13.zh/#code-pipes"},{"categories":["notes"],"content":" 4 Code: wait, exit and killwait 首先会申请 condtion lock，即 wait_lock，保证 wait 不会错过 exit 的 wakeup，然后寻找子进程中的 ZOMBIE 进程，释放其资源和 proc 结构体，拷贝子进程的 exit status，释放锁，并返回子进程的 pid。如果 wait 发现没有子进程退出，就会调用 sleep 来等待子进程退出。被退出的子进程调用 wakeup 唤醒并由 scheduler 线程返回到 sleep 的下一条语句之后，它会继续执行查找 ZOMBIE 子进程并释放其资源的任务。 假设进程 a 调用 exit，那么exit 记录了 exit status，释放进程 a 的一些资源，调用 reparent 把 a 的子进程的转让给 init 进程，即进程 a 的子进程的父进程，会变成 init 进程。exit 还会将进程 a 的状态标记为 ZOMBIE，永远让出 cpu（毕竟 scheduler 线程只会选择 RUNNABLE 进程）。exit 会持有 wait_lock 和 p-\u003elock，wait_lock 是生产者 exit 和消费者 wait 的 condtion lock，而持有 \u0026p-\u003elock 是为了防止 wait 在 exit 调用 swtch 之前就观察到该进程是 ZOMBIE 的了。为了防止死锁，exit 与 wait 申请锁的顺序是相同的。 kill 则只是将进程 p-\u003ekilled 标记为 $1$，将进程状态从 SLEEPING 修改为 RUNNABLE，从而让进程能被唤醒，然后回到 usertrap.c 调用 exit 自杀，如果 victim 进程本身是在 user space 中运行的，那么它很快会因为定时器中断进入 usertrap 然后调用 exit。 kill 的将状态从 SLEEPING 修改为 RUNNABLE 可能带来隐患，睡眠中的进程可能没等到它需要的条件就被唤醒了，因此 while 循环中还需要判断 p-\u003ekilled 的状态，如果被设置了，那么就放弃当前的活动，例如 pipe。 也有一些 xv6 的 sleep 所处的 while 循环不检查 p-\u003ekilled，因为代码应该是原子操作的多步系统调用的中间，例如 virtio 驱动程序，它不检查 p-\u003ekilled，等待磁盘 I/O 时被杀死的进程将不会退出，直到它完成当前系统调用并且 usertrap 看到了 p-\u003ekilled 标志。 ","date":"2023-07-20","objectID":"/mit6.s081-lec13.zh/:4:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Sleep \u0026 Wake up","uri":"/mit6.s081-lec13.zh/#code-wait-exit-and-kill"},{"categories":["notes"],"content":" 5 Process Locking进程的锁（p-\u003elock）应该是 xv6 中最复杂的锁了。在进程要读写 struct proc 的 p-\u003estate, p-\u003echan, p-\u003ekilled, p-\u003exstate, p-\u003epid 等字段时，都必须持有 p-\u003elock，因为这些字段可能被其他进程，或者其他 cpu 上的调度器线程访问。 p-\u003elock 做了以下事情： 与 p-\u003estate 一起，避免从 proc[] 数组创建新线程时的 race condition； 当进程被创建或者销毁时，避免它被别的进程看到； 避免父进程在 wait 循环中看到一个状态为 ZOMBIE 但是还没有让出 cpu 的子进程； 防止其他 cpu 的 scheduler 线程去运行一个马上要让出 cpu，已经将状态设置为 RUNNABLE 但是还没有结束 swtch 调用的进程； 保证一个 RUNNABLE 的进程只会被一个 scheduler 线程运行； 防止进程在调用 swtch 中时，被定时器中断再驱使着去执行 yield； 防止 wakeup 进程看到有状态处于 SLEEP 但是还没有完成让出 cpu 的动作的进程； 使得 kill 的检查 p-\u003epid 和设置 p-\u003ekilled 原子化； It prevents the victim process of kill from exiting and perhaps being re-allocated between kill’s check of p-\u003epid and setting p-\u003ekilled. 假设没有这个 p-\u003elock 的话，它可能检查完 p-\u003epid 之后，这个调用 killed 的进程就被暂停了，然后让出了 cpu，这时一个新进程被分配，并且二者具有相同的 pid，因此导致新进程受到影响，而不是影响原来的目标进程。 ","date":"2023-07-20","objectID":"/mit6.s081-lec13.zh/:5:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Sleep \u0026 Wake up","uri":"/mit6.s081-lec13.zh/#process-locking"},{"categories":["leetcode"],"content":" 1 Description918. Maximum Sum Circular Subarray (Medium) Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums. A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n]. A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i \u003c= k1, k2 \u003c= j with k1 % n == k2 % n.   Example 1: Input: nums = [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3. Example 2: Input: nums = [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10. Example 3: Input: nums = [-3,-2,-3] Output: -2 Explanation: Subarray [-2] has maximum sum -2.   Constraints: n == nums.length 1 \u003c= n \u003c= 3 * 104 -3 * 104 \u003c= nums[i] \u003c= 3 * 104 ","date":"2023-07-20","objectID":"/918.maximum-sum-circular-subarray/:1:0","series":null,"tags":["dynamic programming"],"title":"918. Maximum Sum Circular Subarray (Medium)","uri":"/918.maximum-sum-circular-subarray/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe define $dp[i]$ to represent the maximum sum of subarrays that end at $nums[i]$. Then, we can discuss two cases: The subarray is a continuous segment, i.e., $tail \\geq head$. The subarray is divided into two segments, i.e., $tail \u003c head$. In each case, we can update the $dp[i]$ value accordingly to find the maximum sum of subarrays that end at each element $nums[i]$. ","date":"2023-07-20","objectID":"/918.maximum-sum-circular-subarray/:2:0","series":null,"tags":["dynamic programming"],"title":"918. Maximum Sum Circular Subarray (Medium)","uri":"/918.maximum-sum-circular-subarray/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maxSubarraySumCircular(vector\u003cint\u003e \u0026nums) { int n = nums.size(); if (n == 1) { return nums[0]; } vector\u003cint\u003e dp(n, INT_MIN); int sum = accumulate(nums.begin(), nums.end(), 0); vector\u003cint\u003e normal(n, INT_MIN); dp[0] = nums[0]; for (int i = 1; i \u003c n; ++i) { dp[i] = max(nums[i], nums[i] + dp[i - 1]); } vector\u003cint\u003e min_sum(n, 0); min_sum[n - 1] = nums[n - 1]; for (int i = n - 2; i \u003e= 0; --i) { min_sum[i] = min(min_sum[i + 1] + nums[i], nums[i]); } int res = INT_MIN; for (int i = 0; i \u003c n - 1; ++i) { dp[i] = max(dp[i], sum - min_sum[i + 1]); res = max(res, dp[i]); } return max(res, dp[n - 1]); } }; ","date":"2023-07-20","objectID":"/918.maximum-sum-circular-subarray/:3:0","series":null,"tags":["dynamic programming"],"title":"918. Maximum Sum Circular Subarray (Medium)","uri":"/918.maximum-sum-circular-subarray/#code"},{"categories":["leetcode"],"content":" 1 问题描述918. 环形子数组的最大和 (Medium) 给定一个长度为 n 的 环形整数数组 nums ，返回nums 的非空 子数组 的最大可能和 。 环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。 子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i \u003c= k1, k2 \u003c= j 其中 k1 % n == k2 % n 。 示例 1： text 输入：nums = [1,-2,3,-2] 输出：3 解释：从子数组 [3] 得到最大和 3 示例 2： text 输入：nums = [5,-3,5] 输出：10 解释：从子数组 [5,5] 得到最大和 5 + 5 = 10 示例 3： text 输入：nums = [3,-2,2,-3] 输出：3 解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3 提示： n == nums.length 1 \u003c= n \u003c= 3 * 10⁴ -3 * 10⁴ \u003c= nums[i] \u003c= 3 * 10⁴ ","date":"2023-07-20","objectID":"/918.maximum-sum-circular-subarray.zh/:1:0","series":null,"tags":["dynamic programming"],"title":"918. 环形子数组的最大和 (Medium)","uri":"/918.maximum-sum-circular-subarray.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路我们令 $dp[i]$ 表示以 $nums[i]$ 结尾的子数组的最大和，那么我们分两种情况讨论即可： 子数组是连续的一段，即 $tail \u003e= head$； 子数组被分成了两段，即 $tail \u003c head$； ","date":"2023-07-20","objectID":"/918.maximum-sum-circular-subarray.zh/:2:0","series":null,"tags":["dynamic programming"],"title":"918. 环形子数组的最大和 (Medium)","uri":"/918.maximum-sum-circular-subarray.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxSubarraySumCircular(vector\u003cint\u003e \u0026nums) { int n = nums.size(); if (n == 1) { return nums[0]; } vector\u003cint\u003e dp(n, INT_MIN); // 先求 dp[0]; // 分情况讨论，先统计正常的情况，再统计被分成两段的情况 int sum = accumulate(nums.begin(), nums.end(), 0); vector\u003cint\u003e normal(n, INT_MIN); dp[0] = nums[0]; for (int i = 1; i \u003c n; ++i) { dp[i] = max(nums[i], nums[i] + dp[i - 1]); } // 寻找以 head 为起点的最小值 vector\u003cint\u003e min_sum(n, 0); min_sum[n - 1] = nums[n - 1]; for (int i = n - 2; i \u003e= 0; --i) { min_sum[i] = min(min_sum[i + 1] + nums[i], nums[i]); } int res = INT_MIN; for (int i = 0; i \u003c n - 1; ++i) { dp[i] = max(dp[i], sum - min_sum[i + 1]); res = max(res, dp[i]); } return max(res, dp[n - 1]); } }; ","date":"2023-07-20","objectID":"/918.maximum-sum-circular-subarray.zh/:3:0","series":null,"tags":["dynamic programming"],"title":"918. 环形子数组的最大和 (Medium)","uri":"/918.maximum-sum-circular-subarray.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description950. Reveal Cards In Increasing Order (Medium) You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i]. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. You will do the following steps repeatedly until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck then put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return an ordering of the deck that would reveal the cards in increasing order. Note that the first entry in the answer is considered to be the top of the deck.   Example 1: Input: deck = [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom. The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom. The deck is now [13,17]. We reveal 13, and move 17 to the bottom. The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. Example 2: Input: deck = [1,1000] Output: [1,1000]   Constraints: 1 \u003c= deck.length \u003c= 1000 1 \u003c= deck[i] \u003c= 106 All the values of deck are unique. ","date":"2023-07-20","objectID":"/950.reveal-cards-in-increasing-order/:1:0","series":null,"tags":["analog","data structure and algorithms"],"title":"950. Reveal Cards In Increasing Order (Medium)","uri":"/950.reveal-cards-in-increasing-order/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem can be solved through direct simulation according to the given instructions. The use of recursion is not necessary. Since the problem involves popping the first element, a double-ended queue (deque) is a suitable data structure to use. The deque will store the indices of elements, and we can proceed with the simulation accordingly. ","date":"2023-07-20","objectID":"/950.reveal-cards-in-increasing-order/:2:0","series":null,"tags":["analog","data structure and algorithms"],"title":"950. Reveal Cards In Increasing Order (Medium)","uri":"/950.reveal-cards-in-increasing-order/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e deckRevealedIncreasing(vector\u003cint\u003e\u0026 deck) { sort(deck.begin(), deck.end()); int n = deck.size(); vector\u003cint\u003e res(n); deque\u003cint\u003e dq; for (int i = 0; i \u003c n; ++i) { dq.push_back(i); } int cnt = 0; for (int card : deck) { res[dq.front()] = card; dq.pop_front(); if (!dq.empty()) { dq.push_back(dq.front()); dq.pop_front(); } } return res; } }; ","date":"2023-07-20","objectID":"/950.reveal-cards-in-increasing-order/:3:0","series":null,"tags":["analog","data structure and algorithms"],"title":"950. Reveal Cards In Increasing Order (Medium)","uri":"/950.reveal-cards-in-increasing-order/#code"},{"categories":["leetcode"],"content":" 1 问题描述950. 按递增顺序显示卡牌 (Medium) 牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。 最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。 现在，重复执行以下步骤，直到显示所有卡牌为止： 从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。 如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。 如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。 返回能以 递增顺序 显示卡牌的牌组顺序。 答案中的第一张牌被认为处于牌堆顶部。 示例： text 输入：[17,13,11,2,3,5,7] 输出：[2,13,3,11,5,17,7] 解释： 我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。 重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。 我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。 我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。 我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。 我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。 我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。 我们展示 13，然后将 17 移到底部。牌组现在是 [17]。 我们显示 17。 由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。 提示： 1 \u003c= A.length \u003c= 1000 1 \u003c= A[i] \u003c= 10^6 对于所有的 i != j， A[i] != A[j] ","date":"2023-07-20","objectID":"/950.reveal-cards-in-increasing-order.zh/:1:0","series":null,"tags":["analog","data structure and algorithms"],"title":"950. 按递增顺序显示卡牌 (Medium)","uri":"/950.reveal-cards-in-increasing-order.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路这题其实不需要使用递归啥的，直接按照题目意思模拟即可，由于涉及弹出首元素，因此我们可以使用双端队列 deque 来实现，deque 中存放着元素的索引。 ","date":"2023-07-20","objectID":"/950.reveal-cards-in-increasing-order.zh/:2:0","series":null,"tags":["analog","data structure and algorithms"],"title":"950. 按递增顺序显示卡牌 (Medium)","uri":"/950.reveal-cards-in-increasing-order.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e deckRevealedIncreasing(vector\u003cint\u003e\u0026 deck) { sort(deck.begin(), deck.end()); // 用双端队列就可以了 int n = deck.size(); vector\u003cint\u003e res(n); deque\u003cint\u003e dq; for (int i = 0; i \u003c n; ++i) { dq.push_back(i); } int cnt = 0; for (int card : deck) { res[dq.front()] = card; dq.pop_front(); if (!dq.empty()) { dq.push_back(dq.front()); dq.pop_front(); } } return res; } }; ","date":"2023-07-20","objectID":"/950.reveal-cards-in-increasing-order.zh/:3:0","series":null,"tags":["analog","data structure and algorithms"],"title":"950. 按递增顺序显示卡牌 (Medium)","uri":"/950.reveal-cards-in-increasing-order.zh/#代码"},{"categories":["notes"],"content":" 1 Multiplexingxv6 通过将 cpu 从一个进程切换到另一个进程来实现 multiplex（多路复用），进程的切换会在两种情形下发生： xv6 的 sleep 与 wakeup 机制在进程等待 IO 完成或者等待子进程退出又或者在 sleep 系统调用中等待的时候切换进程。 xv6 会周期性地强制切换进程，从而应对那些长时间切换而未 sleep 的进程。 这个 multiplex 机制会让进程产生一种自己完全拥有 cpu 的错觉，就像 xv6 用虚拟内存和 page table 机制让进程觉得自己拥有完整的内存空间一样。 xv6 使用硬件定时器中断来保证 context switch（上下文切换）。 ","date":"2023-07-19","objectID":"/mit6.s081-lec11.zh/:1:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Thread switching","uri":"/mit6.s081-lec11.zh/#multiplexing"},{"categories":["notes"],"content":" 2 Code: Context switching用户进程之间的切换步骤如下图所示： 用户进程之间的切换其实会经过两次 context switch，以上图为例，第一次是从 shell 用户进程的 kernel thread 切换到 cpu 的 scheduler thread；第二次从 cpu 的 scheduler thread 切换到新用户进程（例如 cat）的 kernel thread。 在 xv6 中，我们可以认为每个用户进程，包含一个内核线程与一个用户线程，然后每个 cpu 包含一个 scheduler thread，schedular thread 工作在内核中，有只属于它的 kernel stack。 swtch 执行为内核线程切换的保存和恢复工作。swtch 的主要工作就是保存和恢复 riscv 的寄存器，又被称为上下文。 当一个进程要让出 cpu 时，该进程的内核线程会调用 swtch 来把该进程的 context 保存起来，并返回到 scheduler 线程的 context，每个 context 都包含于 strcut context。 context 结构体可能是 struct proc 的成员或者 struct cpu 的成员（ scheduler 线程）。 c struct context { uint64 ra; uint64 sp; // callee-saved uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11; }; swtch 函数实际上是利用汇编实现的，它接受两个参数 struct context *old 和 struct context *new，将当前寄存器保存在 old，中然后从 new 中加载内容到当前寄存器，然后 return。 用户进程要让出 cpu，切换到 scheduler 线程，会经历 usertrap =\u003e yield =\u003e sched =\u003e swtch 的过程，swtch 把当前进程的上下文保存在 p-\u003econtext 中，从 cpu-\u003econtext 加载当前 cpu 的 scheduler 线程的 context。 swtch 只会保存 callee-saved 寄存器（这里 sched 是 caller， swtch 是 callee）。swtch 不保存 pc，而是保存 ra 寄存器（ra 寄存器存放了 swtch 调用结束后应该返回到的地址，可以理解为 swtch 语句的下一条语句）。 scheduler 的 context 是在 scheduler 线程调用 swtch 的时候被保存在 cpu-\u003econtext 的。 进程切换的流程可以这么理解，进程 a 调用 swtch，将进程 a 的 context 保存在 proca-\u003econtext（包括进程 a 的 ra 寄存器），从 cpu-\u003econtext 中加载 context，由于 context 中包含了 ra 寄存器，而 swtch 函数的最后一条指令就是 ret，因此会跳转到 ra 寄存器的地址处继续执行，这里应该就是执行 scheduler 函数中的 c-\u003eproc = 0，由于 scheduler 本身是个死循环，c-\u003eproc = 0 的下一个语句就是一个新的 for 循环，就又会执行到 swtch，将 scheduler 线程的 context 保存在 cpu-\u003econtext 中，然后从 procb-\u003econtext 中加载 context（包括进程 b 的 ra 寄存器），然后跳转到进程 b 的 ra 寄存器的地址处继续执行（这里类比进程 a，就是进程 b 调用的 swtch 语句的下一条语句），这里从结果来看，就是让进程 b 会从系统调用或者中断响应中退出，继续执行它的本职工作。 ","date":"2023-07-19","objectID":"/mit6.s081-lec11.zh/:2:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Thread switching","uri":"/mit6.s081-lec11.zh/#code-context-switching"},{"categories":["notes"],"content":" 3 Code: Schedulingscheduler 的实现如下： c void scheduler(void) { struct proc *p; struct cpu *c = mycpu(); c-\u003eproc = 0; for (;;) { // Avoid deadlock by ensuring that devices can interrupt. intr_on(); for (p = proc; p \u003c \u0026proc[NPROC]; p++) { acquire(\u0026p-\u003elock); if (p-\u003estate == RUNNABLE) { // Switch to chosen process. It is the process's job // to release its lock and then reacquire it // before jumping back to us. p-\u003estate = RUNNING; c-\u003eproc = p; swtch(\u0026c-\u003econtext, \u0026p-\u003econtext); // Process is done running for now. // It should have changed its p-\u003estate before coming back. c-\u003eproc = 0; } release(\u0026p-\u003elock); } } } 我们可以发现，在调用 swtch 时，xv6 持有 \u0026p-\u003elock，但是这个锁，会在 scheduler 线程中马上被解锁。 我们考虑一个进程 a 切换到进程 b 在切换到进程 c 的过程，就能弄明白这个过程： 进程 a 调用 yield，此时 pa-\u003econtext 保存的 ra 就是 release(\u0026pa-\u003elock)，然后进入到 scheduler 线程，由于 cpu-\u003econtext 保存的 ra 就是 c-\u003eproc = 0; release(\u0026px-\u003elock);（这个 x 到底是哪个进程，也许现在还想不明白，但是很快就能意识到，x 其实就是 a），所以马上执行 c-\u003eproc = 0; release(\u0026px-\u003elock);，然后选择了进程 b，于是我们给 b 加锁，然后执行 swtch，这里就知道，cpu-\u003econtext 的 ra 中会保存 c-\u003eproc = 0; release(\u0026pb-\u003elock);；然后，就执行到 pb-\u003econtext 的 ra 对应的指令了。当进程 b 因为定时器中断，要让出 cpu 时，进程 b 调用 yield，然后切换到 scheduler 线程时，我们就知道此时的 ra 寄存器，即 cpu-\u003econtext 的 ra，就是 c-\u003eproc = 0; release(\u0026pb-\u003elock)，即我们会马上释放进程 b 的锁。 其实就是要意识到一点，进程 a 让出 cpu 之前，必然是被另一个进程 x 切换到了进程 a，因此从进程 a 切换到 scheduler 线程，会马上释放进程 a 的锁！ 从考虑上面的进程 a 切换到 进程 b 的过程，我们发现，回到进程 b 的 sched 语句的下一条语句，就是 release，但是这里释放的进程 b 的锁，其实应该是在 scheduler 线程中被申请的。 彼此之间有意识地通过线程传递 cpu 控制权的进程有时候也被称作协程（coroutines），sched 和 scheduler 就可以看作是彼此的协程。 只有一种情况，scheduler 调用 swtch 不会返回到要切换到的进程的 sched(); 语句的下一条指令处，那就是创建（子）进程的时候，allocproc 会将进程的 ra 设置为 forkret 函数，这样哪怕子进程之前没有调用过 swtch，也能够被切换到这个子进程，这样会先释放子进程的锁，再执行 usertrapret 返回到子进程的用户空间，否则可能子进程会直接返回到 usertrapret 再返回用户空间，子进程的锁不会被释放。 ","date":"2023-07-19","objectID":"/mit6.s081-lec11.zh/:3:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Thread switching","uri":"/mit6.s081-lec11.zh/#code-scheduling"},{"categories":["leetcode"],"content":" 1 Description2069. Walking Robot Simulation II (Medium) A width x height grid is on an XY-plane with the bottom-left cell at (0, 0) and the top-right cell at (width - 1, height - 1). The grid is aligned with the four cardinal directions (\"North\", \"East\", \"South\", and \"West\"). A robot is initially at cell (0, 0) facing direction \"East\". The robot can be instructed to move for a specific number of steps. For each step, it does the following. Attempts to move forward one cell in the direction it is facing. If the cell the robot is moving to is out of bounds, the robot instead turns 90 degrees counterclockwise and retries the step. After the robot finishes moving the number of steps required, it stops and awaits the next instruction. Implement the Robot class: Robot(int width, int height) Initializes the width x height grid with the robot at (0, 0) facing \"East\". void step(int num) Instructs the robot to move forward num steps. int[] getPos() Returns the current cell the robot is at, as an array of length 2, [x, y]. String getDir() Returns the current direction of the robot, \"North\", \"East\", \"South\", or \"West\".   Example 1: Input [\"Robot\", \"step\", \"step\", \"getPos\", \"getDir\", \"step\", \"step\", \"step\", \"getPos\", \"getDir\"] [[6, 3], [2], [2], [], [], [2], [1], [4], [], []] Output [null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"] Explanation Robot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East. robot.step(2); // It moves two steps East to (2, 0), and faces East. robot.step(2); // It moves two steps East to (4, 0), and faces East. robot.getPos(); // return [4, 0] robot.getDir(); // return \"East\" robot.step(2); // It moves one step East to (5, 0), and faces East. // Moving the next step East would be out of bounds, so it turns and faces North. // Then, it moves one step North to (5, 1), and faces North. robot.step(1); // It moves one step North to (5, 2), and faces North (not West). robot.step(4); // Moving the next step North would be out of bounds, so it turns and faces West. // Then, it moves four steps West to (1, 2), and faces West. robot.getPos(); // return [1, 2] robot.getDir(); // return \"West\"   Constraints: 2 \u003c= width, height \u003c= 100 1 \u003c= num \u003c= 105 At most 104 calls in total will be made to step, getPos, and getDir. ","date":"2023-07-19","objectID":"/2069.walking-robot-simulation-ii/:1:0","series":null,"tags":["analog"],"title":"2069. Walking Robot Simulation II (Medium)","uri":"/2069.walking-robot-simulation-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis is a somewhat tricky simulation problem, but it becomes straightforward when you notice two points: The robot will only be positioned on the outermost layer of the grid. We can keep track of the total number of steps the robot has moved. This way, we can calculate the paths starting from $(0, 0)$ without needing to use the robot’s previous position. ","date":"2023-07-19","objectID":"/2069.walking-robot-simulation-ii/:2:0","series":null,"tags":["analog"],"title":"2069. Walking Robot Simulation II (Medium)","uri":"/2069.walking-robot-simulation-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Robot { public: Robot(int width, int height) { wid_ = width; hei_ = height; } void step(int num) { total += num; if (total == 0) { return; } int realmove = total % (wid_ - 1 + hei_ - 1 + wid_ - 1 + hei_ - 1); if (realmove == 0) { direct = 3; posx = 0; posy = 0; } else if (realmove \u003e 0 \u0026\u0026 realmove \u003c= wid_ - 1) { direct = 0; posx = realmove; posy = 0; } else if (realmove \u003e wid_ - 1 \u0026\u0026 realmove \u003c= wid_ - 1 + hei_ - 1) { posx = wid_ - 1; posy = realmove - (wid_ - 1); direct = 1; } else if (realmove \u003e wid_ - 1 + hei_ - 1 \u0026\u0026 realmove \u003c= wid_ - 1 + hei_ - 1 + wid_ - 1) { posy = hei_ - 1; posx = wid_ - 1 - (realmove - (wid_ - 1 + hei_ - 1)); direct = 2; } else { posx = 0; posy = hei_ - 1 - (realmove - (wid_ - 1 + hei_ - 1 + wid_ - 1)); direct = 3; } } vector\u003cint\u003e getPos() { return {posx, posy}; } string getDir() { switch (direct % 4) { case 0: return \"East\"; case 1: return \"North\"; case 2: return \"West\"; case 3: return \"South\"; } return \"\"; } private: int posx = 0; int posy = 0; int direct = 0; int wid_; int hei_; int total = 0; }; ","date":"2023-07-19","objectID":"/2069.walking-robot-simulation-ii/:3:0","series":null,"tags":["analog"],"title":"2069. Walking Robot Simulation II (Medium)","uri":"/2069.walking-robot-simulation-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述2069. 模拟行走机器人 II (Medium) 给你一个在 XY 平面上的 width x height 的网格图， 左下角 的格子为 (0, 0) ， 右上角 的格子 为 (width - 1, height - 1) 。网格图中相邻格子为四个基本方向之一（ \"North\"， \"East\"， \"South\" 和 \"West\"）。一个机器人 初始 在格子 (0, 0) ，方向为 \"East\" 。 机器人可以根据指令移动指定的 步数 。每一步，它可以执行以下操作。 沿着当前方向尝试 往前一步 。 如果机器人下一步将到达的格子 超出了边界 ，机器人会 逆时针 转 90 度，然后再尝试往前一步。 如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。 请你实现 Robot 类： Robot(int width, int height) 初始化一个 width x height 的网格图，机器人初始在 (0, 0) ，方向 朝 \"East\" 。 void step(int num) 给机器人下达前进 num 步的指令。 int[] getPos() 返回机器人当前所处的格子位置，用一个长度为 2 的数组 [x, y] 表示。 String getDir() 返回当前机器人的朝向，为 \"North\" ， \"East\" ， \"South\" 或者 \"West\" 。 示例 1： text 输入： [\"Robot\", \"step\", \"step\", \"getPos\", \"getDir\", \"step\", \"step\", \"step\", \"getPos\", \"getDir\"] [[6, 3], [2], [2], [], [], [2], [1], [4], [], []] 输出： [null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"] 解释： Robot robot = new Robot(6, 3); // 初始化网格图，机器人在 (0, 0) ，朝东。 robot.step(2); // 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。 robot.step(2); // 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。 robot.getPos(); // 返回 [4, 0] robot.getDir(); // 返回 \"East\" robot.step(2); // 朝东移动 1 步到达 (5, 0) ，并朝东。 // 下一步继续往东移动将出界，所以逆时针转变方向朝北。 // 然后，往北移动 1 步到达 (5, 1) ，并朝北。 robot.step(1); // 朝北移动 1 步到达 (5, 2) ，并朝 北 （不是朝西）。 robot.step(4); // 下一步继续往北移动将出界，所以逆时针转变方向朝西。 // 然后，移动 4 步到 (1, 2) ，并朝西。 robot.getPos(); // 返回 [1, 2] robot.getDir(); // 返回 \"West\" 提示： 2 \u003c= width, height \u003c= 100 1 \u003c= num \u003c= 10⁵ step ， getPos 和 getDir 总共 调用次数不超过 10⁴ 次。 ","date":"2023-07-19","objectID":"/2069.walking-robot-simulation-ii.zh/:1:0","series":null,"tags":["analog"],"title":"2069. 模拟行走机器人 II (Medium)","uri":"/2069.walking-robot-simulation-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路这是一道有点麻烦的模拟题，但其实注意到两点就不难了： 机器人只会位于网格最外层的这一圈上； 我们可以记录机器人总共移动了多少步，这样就可以以 $(0, 0)$ 为起点进行计算，而不需要使用机器人的上一个位置； ","date":"2023-07-19","objectID":"/2069.walking-robot-simulation-ii.zh/:2:0","series":null,"tags":["analog"],"title":"2069. 模拟行走机器人 II (Medium)","uri":"/2069.walking-robot-simulation-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Robot { public: Robot(int width, int height) { wid_ = width; hei_ = height; } void step(int num) { total += num; if (total == 0) { return; } int realmove = total % (wid_ - 1 + hei_ - 1 + wid_ - 1 + hei_ - 1); if (realmove == 0) { direct = 3; posx = 0; posy = 0; } else if (realmove \u003e 0 \u0026\u0026 realmove \u003c= wid_ - 1) { direct = 0; posx = realmove; posy = 0; } else if (realmove \u003e wid_ - 1 \u0026\u0026 realmove \u003c= wid_ - 1 + hei_ - 1) { posx = wid_ - 1; posy = realmove - (wid_ - 1); direct = 1; } else if (realmove \u003e wid_ - 1 + hei_ - 1 \u0026\u0026 realmove \u003c= wid_ - 1 + hei_ - 1 + wid_ - 1) { posy = hei_ - 1; posx = wid_ - 1 - (realmove - (wid_ - 1 + hei_ - 1)); direct = 2; } else { posx = 0; posy = hei_ - 1 - (realmove - (wid_ - 1 + hei_ - 1 + wid_ - 1)); direct = 3; } } vector\u003cint\u003e getPos() { return {posx, posy}; } string getDir() { switch (direct % 4) { case 0: return \"East\"; case 1: return \"North\"; case 2: return \"West\"; case 3: return \"South\"; } return \"\"; } private: int posx = 0; int posy = 0; int direct = 0; int wid_; int hei_; int total = 0; }; ","date":"2023-07-19","objectID":"/2069.walking-robot-simulation-ii.zh/:3:0","series":null,"tags":["analog"],"title":"2069. 模拟行走机器人 II (Medium)","uri":"/2069.walking-robot-simulation-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1851. Minimum Interval to Include Each Query (Hard) You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1. You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti \u003c= queries[j] \u003c= righti. If no such interval exists, the answer is -1. Return an array containing the answers to the queries.   Example 1: Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] Output: [3,3,1,4] Explanation: The queries are processed as follows: - Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3. - Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3. - Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1. - Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4. Example 2: Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22] Output: [2,-1,4,6] Explanation: The queries are processed as follows: - Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2. - Query = 19: None of the intervals contain 19. The answer is -1. - Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4. - Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.   Constraints: 1 \u003c= intervals.length \u003c= 105 1 \u003c= queries.length \u003c= 105 intervals[i].length == 2 1 \u003c= lefti \u003c= righti \u003c= 107 1 \u003c= queries[j] \u003c= 107 ","date":"2023-07-18","objectID":"/1851.minimum-interval-to-include-each-query/:1:0","series":null,"tags":["priority queue"],"title":"1851. Minimum Interval to Include Each Query (Hard)","uri":"/1851.minimum-interval-to-include-each-query/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirst, it should be noted that sorting the intervals array will not affect the result. Secondly, sorting the queries array will not have a significant impact on the answer. It merely changes the order of the answers. We just need to associate the result of each query with its corresponding index in the original queries array. For convenience, let’s convert the queries array into a vector\u003cpair\u003cint, int\u003e\u003e qrs; where the first element represents the value to be queried, and the second element represents its index in the queries array. Then, we sort the qrs vector in ascending order based on the first element. Next, we prepare to iterate through the qrs vector. Since the intervals array is already sorted in ascending order based on the left endpoint, we compare the current query with intervals[idx][0]. If intervals[idx][0] \u003c= query, we enqueue the intervals (fulfilling half of the required conditions), and increment idx to indicate that we have considered this interval. We continue this process until idx \u003e= queries.size() or intervals[idx][0] \u003e query. Next, we compare the current query with the right endpoint of the top interval in the heap (where the top interval has the smallest length). If the right endpoint is smaller than query, we pop the interval out of the heap until the heap is empty or the right endpoint of the top interval is \u003e= query. Finally, we can update the minimum interval length corresponding to the query. ","date":"2023-07-18","objectID":"/1851.minimum-interval-to-include-each-query/:2:0","series":null,"tags":["priority queue"],"title":"1851. Minimum Interval to Include Each Query (Hard)","uri":"/1851.minimum-interval-to-include-each-query/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e minInterval(vector\u003cvector\u003cint\u003e\u003e \u0026intervals, vector\u003cint\u003e \u0026queries) { sort(intervals.begin(), intervals.end()); using pii = pair\u003cint, int\u003e; vector\u003cpii\u003e qrs; int m = intervals.size(), n = queries.size(); for (int i = 0; i \u003c n; ++i) { qrs.emplace_back(queries[i], i); } std::sort(qrs.begin(), qrs.end()); vector\u003cint\u003e ans(n, -1); priority_queue\u003cpii, vector\u003cpii\u003e, greater\u003cpii\u003e\u003e pq; // pair.first =\u003e right - left + 1，pair.second =\u003e right int idx = 0; for (int i = 0; i \u003c n; ++i) { while (idx \u003c m \u0026\u0026 intervals[idx][0] \u003c= qrs[i].first) { pq.push({intervals[idx][1] - intervals[idx][0] + 1, intervals[idx][1]}); ++idx; } while (!pq.empty() \u0026\u0026 pq.top().second \u003c qrs[i].first) { pq.pop(); } if (!pq.empty()) { ans[qrs[i].second] = pq.top().first; } } return ans; } }; ","date":"2023-07-18","objectID":"/1851.minimum-interval-to-include-each-query/:3:0","series":null,"tags":["priority queue"],"title":"1851. Minimum Interval to Include Each Query (Hard)","uri":"/1851.minimum-interval-to-include-each-query/#code"},{"categories":["leetcode"],"content":" 1 问题描述[1851. 包含每个查询的最小区间] (Hard) 给你一个二维整数数组 intervals ，其中 intervals[i] = [leftᵢ, rightᵢ] 表示第 i 个区间开始于 le ftᵢ 、结束于 rightᵢ（包含两侧取值， 闭区间）。区间的 长度 定义为区间中包含的整数数目，更 正式地表达是 rightᵢ - leftᵢ + 1 。 再给你一个整数数组 queries 。第 j 个查询的答案是满足 leftᵢ \u003c= queries[j] \u003c= rightᵢ 的 长度最 小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。 以数组形式返回对应查询的所有答案。 示例 1： text 输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] 输出：[3,3,1,4] 解释：查询处理如下： - Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。 - Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。 示例 2： text 输入：intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22] 输出：[2,-1,4,6] 解释：查询处理如下： - Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。 - Query = 19：不存在包含 19 的区间，答案为 -1 。 - Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。 - Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。 提示： 1 \u003c= intervals.length \u003c= 10⁵ 1 \u003c= queries.length \u003c= 10⁵ intervals[i].length == 2 1 \u003c= leftᵢ \u003c= rightᵢ \u003c= 10⁷ 1 \u003c= queries[j] \u003c= 10⁷ ","date":"2023-07-18","objectID":"/1851.minimum-interval-to-include-each-query.zh/:1:0","series":null,"tags":["priority queue"],"title":"1851. 包含每个查询的最小区间 (Hard)","uri":"/1851.minimum-interval-to-include-each-query.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，应该注意到，对 intevals 数组排序对结果不会有任何影响，其次，对 queries 排序也不会对答案产生本质影响，只是改变了答案的顺序罢了，只要把 $query$ 的结果和 $query$ 在原先的 queries 数组的索引对应起来就好了。 为了方便，把 queries 转化为 vector\u003cpair\u003cint, int\u003e\u003e qrs;，first 是要查询的值，second 是这个值在 queries 数组中的索引，然后对 qrs 按 first 从小到大排序。 然后准备遍历 qrs 数组，由于 intervals 已经按照从左端点元素从小到大的顺序排好序了，因此我们比较当前 query 与 intervals[idx][0] 的大小，如果 intervals[idx][0] \u003c= query，就将 intervals 入队（队中元素满足了题目要求的一半条件），并递增 idx，表示这个区间我们已经考虑了，直到 idx \u003e= queries.size() || intervals[idx][0] \u003e query。 接着，我们比较当前 query 与堆顶区间的右端点大小（堆顶是区间长度最小的区间），如果右端点小于 query，将该区间弹出，直到堆为空或者堆顶区间的右端点 \u003e= query。 最后，可以更新 query 对应的最小区间长度了。 ","date":"2023-07-18","objectID":"/1851.minimum-interval-to-include-each-query.zh/:2:0","series":null,"tags":["priority queue"],"title":"1851. 包含每个查询的最小区间 (Hard)","uri":"/1851.minimum-interval-to-include-each-query.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e minInterval(vector\u003cvector\u003cint\u003e\u003e \u0026intervals, vector\u003cint\u003e \u0026queries) { sort(intervals.begin(), intervals.end()); using pii = pair\u003cint, int\u003e; vector\u003cpii\u003e qrs; int m = intervals.size(), n = queries.size(); for (int i = 0; i \u003c n; ++i) { qrs.emplace_back(queries[i], i); } std::sort(qrs.begin(), qrs.end()); vector\u003cint\u003e ans(n, -1); priority_queue\u003cpii, vector\u003cpii\u003e, greater\u003cpii\u003e\u003e pq; // pair.first =\u003e right - left + 1，pair.second =\u003e right int idx = 0; for (int i = 0; i \u003c n; ++i) { while (idx \u003c m \u0026\u0026 intervals[idx][0] \u003c= qrs[i].first) { pq.push({intervals[idx][1] - intervals[idx][0] + 1, intervals[idx][1]}); ++idx; } while (!pq.empty() \u0026\u0026 pq.top().second \u003c qrs[i].first) { pq.pop(); } if (!pq.empty()) { ans[qrs[i].second] = pq.top().first; } } return ans; } }; ","date":"2023-07-18","objectID":"/1851.minimum-interval-to-include-each-query.zh/:3:0","series":null,"tags":["priority queue"],"title":"1851. 包含每个查询的最小区间 (Hard)","uri":"/1851.minimum-interval-to-include-each-query.zh/#代码"},{"categories":["notes"],"content":" 1 why lock防止多核并行运行下的 race condition 导致的错误。 内核中的数据是典型的 concurrently-accessed 的数据。 ","date":"2023-07-18","objectID":"/mit6.s081-lec10.zh/:1:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Multiprocessors and locking","uri":"/mit6.s081-lec10.zh/#why-lock"},{"categories":["notes"],"content":" 2 race condition and how the lock avoid itA race condition is a situation in which a memory location is accessed concurrently, and at least one access is a write. Locks ensure mutual exclusion. 锁的持有与释放之间的语句会被原子化，在 xv6 中，就是 acquire 和 release 之间的多条语句，只能被一个进程（CPU）全部执行完了之后，才可能被其他的进程（CPU）执行，这样就避免了 race condition。 acquire 和 release 之间的多条指令通常被称为 critical section。 lock 在某种意义上是在维护 critical section 中一些数据的不变量（some collection of invariants），这个不变量在 critical section 中可能会被暂时破坏，但是当 critical section 的最开始，以及结束的时候，这个 invariants 一定成立！ 例如 kfree 中的 lock，就是在维护 kmem.freelist 一定指向 freelist 的头结点这一不变量。 内核设计的一大主要挑战就是避免锁争用（lock contention）。 ","date":"2023-07-18","objectID":"/mit6.s081-lec10.zh/:2:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Multiprocessors and locking","uri":"/mit6.s081-lec10.zh/#race-condition-and-how-the-lock-avoid-it"},{"categories":["notes"],"content":" 3 Code: Locksxv6 有 spinlocks（自旋锁）和 sleep-locks 两种 spinlock 的实现如下： c // Mutual exclusion lock. struct spinlock { uint locked; // Is the lock held? // For debugging: char *name; // Name of lock. struct cpu *cpu; // The cpu holding the lock. }; spinlock 的关键部分在于 locked 字段，locked = 1 时，说明 lock 已经被持有了，locked = 0 时，则说明 lock 未被持有，即 cpu 可以申请持有该锁。 acquire 一个简单但是错误的实现如下： c void acquire(struct spinlock *lk) { for (;;) { if (lk-\u003elocked == 0) { lk-\u003elocked = 1; break; } } } 这个实现的问题在与，假设有 cpu1 和 cpu2，cpu1 先观察到 lk-\u003elocked == 0 了，正准备执行 lk-\u003elocked = 1 时，cpu2 也观察到了 lk-\u003elocked == 0，那么就存在两个 cpu 同时拿到锁的情况了。因此，我们必须保证 if (lk-\u003elocked == 0) 和 lk-\u003elocked = 1 这两条语句被原子（atomic）地执行。即不存在 cpu1 执行完语句 $1$，还没执行语句 $2$ 时就被 cpu1 执行语句 $1$ 的情况。 多核处理器一般会提供原子指令保证这两条语句原子化地执行，在 riscv 中，有 amoswap r, a。该指令读取地址 a 处的值，记为 tmp，然后将寄存器 r 中的值写入 a，再将 tmp 的值写入寄存器 r。该指令实际上就是原子地执行交换地址 a 和寄存器 r 处的值。 所以，acquire 的实现要想不出错，就应该执行原子地交换 val（值为 $1$） 与 l-\u003elocked 的值，然后检查 val 的值，如果是 $0$，就说明获取到了锁，否则说明没有获取到，并且执行交换后，l-\u003elocked 一定是 $1$。由于执行原子交换，也不可能存在两个 cpu 同时检查到 val 为 $0$ 的情况。 It performs this sequence atomically, using special hardware to prevent any other CPU from using the memory address between the read and the write. xv6 的 acquire 函数调用了 portable C library 的 __sync_lock_test_and_set 函数，本质上就是上面提到的 amoswap 函数。 xv6 的 release 函数调用 __sync_lock_release(\u0026lk-\u003elock)，该函数执行原子地将 lk 的 locked 字段写为 $0$。 为什么不能使用一个普通的写入语句将 lk-\u003elocked 的值写为 $0$ 呢？这是因为：普通的赋值语句，riscv 中对应的汇编语句是 store，而 store 本身并不是原子的（可能导致缓存一致性失效？，这里不使用原子指令的副作用感觉不是很清晰 TODO(zwyyy)）。 由于每个 cpu 都有自己的 cache，将内存中的某个值写为 $0$，可能要经过先将 $cache$ 中的对应值写为 $0$，再写回内存的过程， 因此 store 指令不是原子的。 编译器在编译代码时，可能会重排指令以获取更好的性能，例如： c acquire(\u0026lock); ++i; release(\u0026lock); 编译器可能重排指令导致 ++i 语句优先于 acquire 指令，这就违背了我们的初衷。 xv6 的源码中的 acquire 函数的实现如下： c void acquire(struct spinlock *lk) { push_off(); // disable interrupts to avoid deadlock. if (holding(lk)) panic(\"acquire\"); // On RISC-V, sync_lock_test_and_set turns into an atomic swap: // a5 = 1 // s1 = \u0026lk-\u003elocked // amoswap.w.aq a5, a5, (s1) while (__sync_lock_test_and_set(\u0026lk-\u003elocked, 1) != 0) ; __sync_synchronize(); lk-\u003ecpu = mycpu(); } acquire 实现中有 __sync_sychronize(); 这么一条语句，它保证了 __sync_synchronize 之前的指令不会在编译器优化时，被重排到 __sync_synchronize 之后，即避免了 critaical section 中的指令被重排到 acquire 之前。 在 release 的实现中同样有 __sync_synchronzie 语句，它又被称作 memory barrier，它基于硬件上的 memroy fence 实现。 ","date":"2023-07-18","objectID":"/mit6.s081-lec10.zh/:3:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Multiprocessors and locking","uri":"/mit6.s081-lec10.zh/#code-locks"},{"categories":["notes"],"content":" 4 Using locks什么时候需要使用锁？一般来说，当多个 CPU（线程）需要访问同一块内存，并且 CPU（线程）对内存的操作涉及写入（而不仅仅是读取）时，就需要使用锁来保护这块内存上存储的数据，防止 race condition。 不涉及访问同一块内存，就不需要使用锁了吗？答案也是否定的，考虑在 printf 时，我们往往希望一个字符串能够被完整地输出而不与其他进程的 printf 交织。 ","date":"2023-07-18","objectID":"/mit6.s081-lec10.zh/:4:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Multiprocessors and locking","uri":"/mit6.s081-lec10.zh/#using-locks"},{"categories":["notes"],"content":" 5 Deadlock and lock ordering死锁个人认为就是指锁一直被持有，无法被释放。 最简单的死锁场景就是，一个进程重复申请持有同一个锁，例如： c acquire(lk); acquire(lk); ++i; release(lk); 第二个 acquire 必须等第一个 acquire 状态被 release 了才能执行，但是不继续执行又无法走到第一个 release，就产生了死锁。xv6 会检查这种简单的死锁，触发 panic。 再考虑另一种死锁的情况，相比上一种情况更隐蔽，更难探测出来： c // 进程 1 acquire(lk1); acquire(lk2); ++i; release(lk2); release(lk1); // 进程 2 acquire(lk2); acquire(lk1); ++i; release(lk1); release(lk2); 那么就可能出现这样一种情况，proc1 持有了 lk1，然后 proc2 马上持有了 lk2，接着 proc1 申请持有 lk2，但是 lk2 已经被 proc2 持有了，只能等待 proc2 release(lk2)，然后 proc2 申请持有 lk1，同样的， lk1 被 proc1 持有了，因此必须等待 proc1 release(lk1)，然而，两个进程都卡在第二个 acquire 这一步，无法执行 release，因此两个进程就只能一直等到地老天荒，这就发生了死锁。 为了避免出现这一问题，我们需要确定不同进程之间，锁对象有一个相同的申请顺序，即都先申请 lk1，再申请 lk2。 If a code path through the kernel must hold several locks at the same time, it is important that all code paths acquire those locks in the same order. ","date":"2023-07-18","objectID":"/mit6.s081-lec10.zh/:5:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Multiprocessors and locking","uri":"/mit6.s081-lec10.zh/#deadlock-and-lock-ordering"},{"categories":["notes"],"content":" 6 Re-entrant locksre-entrant locks 允许锁被同一个进程重复持有，又称为 recursive locks，使用 re-entrant locks 可以一定程度上避免死锁，然而，一般不推荐使用 re-entrant locks，因为这会让 debug 变得非常困难，产生意料之外的问题。 ","date":"2023-07-18","objectID":"/mit6.s081-lec10.zh/:6:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Multiprocessors and locking","uri":"/mit6.s081-lec10.zh/#re-entrant-locks"},{"categories":["notes"],"content":" 7 Locks and interrupt handlersspinlock 与 interrupt 的相互作用可能是非常危险的。假设 sys_sleep 持有了 tickslock，然后 cpu 被计时器中断打断，clockintr 会尝试获取 tickslock，然而由于 tickslock 已经被 sys_sleep 持有，那么 clockintr 会一直等待 sys_spleep 释放锁，然而在 clockintr return 之前，sys_sleep 是不会继续执行的，这就导致了死锁。 为了避免这一情况，如果 interrupt handler 需要使用 spinlock，那么当中断 enable 的时候，该 spinlock 绝不能被 cpu 持有。而 xv6更保守，在申请持有锁的时候，会 disable interrupt on that CPU。（注意这里只关闭同一个 cpu 的中断） ","date":"2023-07-18","objectID":"/mit6.s081-lec10.zh/:7:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Multiprocessors and locking","uri":"/mit6.s081-lec10.zh/#locks-and-interrupt-handlers"},{"categories":["notes"],"content":" 8 Sleep lockssleep locks 一般适用于线程需要长期持有锁的情况。例如 file system 需要向磁盘中写入文件，往往需要十多毫秒，如果使用 spin lock，意味着其他请求 spin lock 的线程会自旋等待十多毫秒且不会让出 cpu。 spin lock 的另一个缺点是持有 spin lock 的线程无法让出 cpu。因为 acquire 的时候会关闭 cpu 中断。 因此我们需要一种在线程 acquire 这个锁的时候，会让出 cpu 的锁，并且在持有锁的时候允许让出 cpu 以及中断响应。xv6 提供了这样一种锁，被称为 sleep lock。sleep lock 的具体实现细节见 lec11 \u0026 lec13。 ","date":"2023-07-18","objectID":"/mit6.s081-lec10.zh/:8:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Multiprocessors and locking","uri":"/mit6.s081-lec10.zh/#sleep-locks"},{"categories":["leetcode"],"content":" 1 Description834. Sum of Distances in Tree (Hard) There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges. You are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. Return an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes.   Example 1: Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] Output: [8,12,6,10,10,10] Explanation: The tree is shown above. We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) equals 1 + 1 + 2 + 2 + 2 = 8. Hence, answer[0] = 8, and so on. Example 2: Input: n = 1, edges = [] Output: [0] Example 3: Input: n = 2, edges = [[1,0]] Output: [1,1]   Constraints: 1 \u003c= n \u003c= 3 * 104 edges.length == n - 1 edges[i].length == 2 0 \u003c= ai, bi \u003c n ai != bi The given input represents a valid tree. ","date":"2023-07-18","objectID":"/834.sum-of-distances-in-tree/:1:0","series":null,"tags":["dynamic programming","tree","graph"],"title":"834. Sum of Distances in Tree (Hard)","uri":"/834.sum-of-distances-in-tree/#description"},{"categories":["leetcode"],"content":" 2 SolutionTo find the sum of distances to a single node (e.g., $0$) denoted as $dp[0]$, we can easily use DFS to compute it with a time complexity of $O(n)$. However, finding the sum of distances for all $n$ nodes would take $O(n^2)$ time, which would obviously result in a timeout for large graphs. However, we notice that there exists a recurrence relationship between the parent node $j$’s $dp[j]$ and the child node $i$’s $dp[i]$. Specifically, $dp[i] = dp[j] - cnt[i] + n - cnt[i]$ (since nodes $i$ and $j$ are directly connected). So, the remaining problem is how to calculate cnt[i], which represents the number of nodes in the subtree rooted at the current node in the tree represented as an undirected graph. Please refer to the Tree Organized as an Undirected Graph for more details. ","date":"2023-07-18","objectID":"/834.sum-of-distances-in-tree/:2:0","series":null,"tags":["dynamic programming","tree","graph"],"title":"834. Sum of Distances in Tree (Hard)","uri":"/834.sum-of-distances-in-tree/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int count(vector\u003cvector\u003cint\u003e\u003e \u0026tree, vector\u003cint\u003e \u0026dis, vector\u003cint\u003e \u0026cnt, int pa, int grandpa) { int res = 1; for (int child : tree[pa]) { if (child == grandpa) { // prevent repeated traversal continue; } dis[child] = dis[pa] + 1; res += count(tree, dis, cnt, child, pa); } cnt[pa] = res; return res; } vector\u003cint\u003e sumOfDistancesInTree(int n, vector\u003cvector\u003cint\u003e\u003e \u0026edges) { vector\u003cvector\u003cint\u003e\u003e tree(n); for (auto \u0026vec : edges) { tree[vec[0]].push_back(vec[1]); tree[vec[1]].push_back(vec[0]); // push_back twice to build undirected graph } vector\u003cint\u003e cnt(n); vector\u003cint\u003e dp(n); vector\u003cint\u003e dis(n); count(tree, dis, cnt, 0, -1); for (int i = 0; i \u003c n; ++i) { dp[0] += dis[i]; } queue\u003cpair\u003cint, int\u003e\u003e q; q.push({0, -1}); // pa, grandpa while (!q.empty()) { auto [pa, grandpa] = q.front(); q.pop(); for (int child : tree[pa]) { if (child == grandpa) { // prevent repeated bfs continue; } dp[child] = dp[pa] + n - 2 * cnt[child]; q.push({child, pa}); } } return dp; } }; ","date":"2023-07-18","objectID":"/834.sum-of-distances-in-tree/:3:0","series":null,"tags":["dynamic programming","tree","graph"],"title":"834. Sum of Distances in Tree (Hard)","uri":"/834.sum-of-distances-in-tree/#code"},{"categories":["leetcode"],"content":" 1 问题描述834. 树中距离之和 (Hard) 给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。 给定整数 n 和数组 edges ， edges[i] = [aᵢ, bᵢ] 表示树中的节点 aᵢ 和 bᵢ 之间有一条边。 返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。 示例 1: text 输入: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] 输出: [8,12,6,10,10,10] 解释: 树如图所示。 我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。 示例 2: text 输入: n = 1, edges = [] 输出: [0] 示例 3: text 输入: n = 2, edges = [[1,0]] 输出: [1,1] 提示: 1 \u003c= n \u003c= 3 * 10⁴ edges.length == n - 1 edges[i].length == 2 0 \u003c= aᵢ, bᵢ \u003c n aᵢ != bᵢ 给定的输入保证为有效的树 ","date":"2023-07-18","objectID":"/834.sum-of-distances-in-tree.zh/:1:0","series":null,"tags":["dynamic programming","tree","graph"],"title":"834. 树中距离之和 (Hard)","uri":"/834.sum-of-distances-in-tree.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路求单个结点（例如 $0$）的距离之和 $dp[0]$，我们可以很容易利用 dfs 以 $O(n)$ 的时间复杂度求出，求 $n$ 个点就是 $O(n^2)$，明显会超时。 但是，不难看出，父结点 $j$ 的 $dp[j]$ 和子结点 $i$ 的 $dp[i]$ 之间存在某种递推关系，即 $dp[i] = dp[j] - cnt[i] + n - cnt[i]$（因为 $i, j$ 直接相连）。 那么，问题就只剩下如何求 cnt[i] 了，即在无向图表示的树中，如何求以当前结点为根结点的子树的结点数，参见 无向图形式组织的树。 ","date":"2023-07-18","objectID":"/834.sum-of-distances-in-tree.zh/:2:0","series":null,"tags":["dynamic programming","tree","graph"],"title":"834. 树中距离之和 (Hard)","uri":"/834.sum-of-distances-in-tree.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int count(vector\u003cvector\u003cint\u003e\u003e \u0026tree, vector\u003cint\u003e \u0026dis, vector\u003cint\u003e \u0026cnt, int pa, int grandpa) { int res = 1; for (int child : tree[pa]) { if (child == grandpa) { // 防止重复遍历，保证 dfs 遍历时的单向性 continue; } dis[child] = dis[pa] + 1; res += count(tree, dis, cnt, child, pa); } cnt[pa] = res; return res; } vector\u003cint\u003e sumOfDistancesInTree(int n, vector\u003cvector\u003cint\u003e\u003e \u0026edges) { vector\u003cvector\u003cint\u003e\u003e tree(n); for (auto \u0026vec : edges) { tree[vec[0]].push_back(vec[1]); tree[vec[1]].push_back(vec[0]); // 注意，建立无向图要 push_back 两次！ } vector\u003cint\u003e cnt(n); vector\u003cint\u003e dp(n); vector\u003cint\u003e dis(n); // 表示结点 0 到其他结点的最短距离 count(tree, dis, cnt, 0, -1); for (int i = 0; i \u003c n; ++i) { dp[0] += dis[i]; } queue\u003cpair\u003cint, int\u003e\u003e q; q.push({0, -1}); // pa, grandpa while (!q.empty()) { auto [pa, grandpa] = q.front(); q.pop(); for (int child : tree[pa]) { if (child == grandpa) { // 保证 bfs 遍历时的单向性 continue; } dp[child] = dp[pa] + n - 2 * cnt[child]; q.push({child, pa}); } } return dp; } }; ","date":"2023-07-18","objectID":"/834.sum-of-distances-in-tree.zh/:3:0","series":null,"tags":["dynamic programming","tree","graph"],"title":"834. 树中距离之和 (Hard)","uri":"/834.sum-of-distances-in-tree.zh/#代码"},{"categories":["notes"],"content":" 1 引入如 数组形式组织的树 中所说，树一般以链表结点的形式组织，定义如下： cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} }; 也可能以数组的形式组织，即使用 $parent$ 数组，$y = parent[x]$ 说明 $y$ 是 $x$ 的父结点，根结点的父结点为 $-1$，表示父结点不存在。 还可以使用无向图的形式来表示，例如 leetcode 的 834. 树中距离之和。 昨天做这个题的时候，整体思路挺好想的，但就是有个地方被困住了，那就是，在树的无向图的表示情况下，如何统计以当前结点为根结点的子树的数量？（没办法转化成有向图！） ","date":"2023-07-18","objectID":"/undirected-graph-tree.zh/:1:0","series":null,"tags":["tree","graph","data structure and algorithms"],"title":"无向图形式组织的树","uri":"/undirected-graph-tree.zh/#引入"},{"categories":["notes"],"content":" 2 统计以当前结点为根结点的子树的结点数统计方法还是深度优先搜索（dfs），只不过，相比一般的深度优先搜索，我们需要传入一个额外的参数，即上一次搜索的父结点，如下图所示： 相应的 dfs 代码为 cpp for (int child : tree[pa]) { if (child == ancestor) { continue; } // 对子结点进行 dfs ... } 这样就确定出了一个遍历方向，因此，整体思路就是，我们可以任意选择一个结点作为 dfs 的起点（这里就选择 $0$ 号结点），依次进行 dfs，利用递归的方法，统计以当前结点为根结点的子树的结点数。 因此，834. 树中距离之和 的完整解题代码如下： cpp class Solution { public: int count(vector\u003cvector\u003cint\u003e\u003e \u0026tree, vector\u003cint\u003e \u0026dis, vector\u003cint\u003e \u0026cnt, int pa, int grandpa) { int res = 1; for (int child : tree[pa]) { if (child == grandpa) { // 防止重复遍历，保证 dfs 遍历时的单向性 continue; } dis[child] = dis[pa] + 1; res += count(tree, dis, cnt, child, pa); } cnt[pa] = res; return res; } vector\u003cint\u003e sumOfDistancesInTree(int n, vector\u003cvector\u003cint\u003e\u003e \u0026edges) { vector\u003cvector\u003cint\u003e\u003e tree(n); for (auto \u0026vec : edges) { tree[vec[0]].push_back(vec[1]); tree[vec[1]].push_back(vec[0]); // 注意，建立无向图要 push_back 两次！ } vector\u003cint\u003e cnt(n); vector\u003cint\u003e dp(n); vector\u003cint\u003e dis(n); // 表示结点 0 到其他结点的最短距离 count(tree, dis, cnt, 0, -1); for (int i = 0; i \u003c n; ++i) { dp[0] += dis[i]; } queue\u003cpair\u003cint, int\u003e\u003e q; q.push({0, -1}); // pa, grandpa while (!q.empty()) { auto [pa, grandpa] = q.front(); q.pop(); for (int child : tree[pa]) { if (child == grandpa) { // 保证 bfs 遍历时的单向性 continue; } dp[child] = dp[pa] + n - 2 * cnt[child]; q.push({child, pa}); } } return dp; } }; ","date":"2023-07-18","objectID":"/undirected-graph-tree.zh/:2:0","series":null,"tags":["tree","graph","data structure and algorithms"],"title":"无向图形式组织的树","uri":"/undirected-graph-tree.zh/#统计以当前结点为根结点的子树的结点数"},{"categories":["notes"],"content":" 1 概述这一章主要聚焦于，我们利用 virtural memory 和 page fault 这两个机制，能够实现一些什么样的有意思的优化。 虚拟内存的有两大优势： Isolation，保证每个进程都有它自己的虚拟地址空间，写自己的虚拟地址处的数据不会破坏其他进程的数据； Levle of indirection，提供了一层抽象（这里不是很好理解），可以理解为提供了一层从虚拟地址到物理地址的映射关系，利用这个映射关系，我们可以实现很多有意思的优化。 利用 page fault，我们可以更新 page table，即更改虚拟地址和物理地址之间的映射关系（在之前的 xv6 中，可以说 va 和 pa 的映射关系，在进程启动之后，到进程结束之前，都是固定的）。 对于 page fault，也可以说是一种 trap，之前提到的 system call 是发生了系统调用之后的 trap，因此 trap 完成之后，我们会返回到产生系统调用的指令的下一条指令继续执行；而 page fault 则是异常（exception）导致的 trap，trap 结束之后，我们会返回导致 page fault 的指令，重新执行这一条指令； 正如 system call 导致的 trap 中，我们需要实现真正执行 systemcall 的函数；而 page fault 导致的 trap 中，我们也需要处理这一异常（一般是在 trap.c 的 usertrap 函数中）。 对于处理 page fautl 的思路，其实可以参照 system call，我们通过读取 scause 寄存器的值来判断导致 trap 的原因，如果是 $13$ 或者 $15$，则说明是 page fault。 然后，我们可以读取 stval 寄存器的值，找到发生 page fault 的虚拟地址 vaddr，而导致 page fault 的指令的地址，存放在 sepc 寄存器中。 通过 page fault，我们可以实现一些非常有意思的优化方案，例如 lazy page allocation、zero fill on demand、copy on write fork、demand paging、memory mapped files 等； ","date":"2023-07-17","objectID":"/mit6.s081-lec08.zh/:1:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Page faults","uri":"/mit6.s081-lec08.zh/#概述"},{"categories":["notes"],"content":" 2 Lazy page allocation调用 sbrk 时，如果参数 n \u003e 0，那么只是单纯增加有效的虚拟地址的范围，从 p-\u003esz 增加到 p-\u003esz + n（即新的 p-\u003esz），如果读取某个 heap 中的虚拟地址，发现该 va 没有映射到 pa 上，那么就会触发 page fault，分配物理页，让 va 映射到这个新的 PP 上。 具体细节可以参照这篇 实验笔记。 这里尤其要注意一点，在内核态下，访问 user pagetable 下的未映射到 PP 的 vaddr，不会触发 page fault，因此在 argaddr 中，我们需要进行检查。 ","date":"2023-07-17","objectID":"/mit6.s081-lec08.zh/:2:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Page faults","uri":"/mit6.s081-lec08.zh/#lazy-page-allocation"},{"categories":["notes"],"content":" 3 Copy-on-Write fork举个例子，当 shell 要执行一个命令时，shell 先 fork 一个子进程，fork 会为子进程创建一个父进程的拷贝，然后子进程或调用 exec 运行其他程序例如 echo，exec 要运行其他程序，要做的第一件事就是丢弃这个虚拟地址空间，转而使用一个包含了 echo 的新的地址空间。 因此，其中一个优化是，创建子进程时，不再“复制 PP，并将子进程的虚拟地址 map 到这个新的 PP”，而是将子进程的虚拟地址也 map 到父进程的这个 PP 上，即父子进程共享 PP。 为了防止子进程修改 VP 的内容时影响到父进程的 VP 的内容，或者父进程修改 VP 时影响到子进程的 VP 的内容（因为父子进程的 VP map 到了同一个 PP），我们需要将父进程和子进程的 VP 都设置为不可写的，并将 riscv 预留的 pte 标志位的第 $8$ 位标记为 $1$（PTE_C），当要写这个 VP 时，就触发 page fault，根据该虚拟地址是否映射了 PP 以及该虚拟地址的 PTE_W 位和 PTE_C 位，判断是否是写 COW page 导致的 page fault，至于如何处理，参照 lab6: Copy-on-Write Fork for xv6。 ","date":"2023-07-17","objectID":"/mit6.s081-lec08.zh/:3:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Page faults","uri":"/mit6.s081-lec08.zh/#copy-on-write-fork"},{"categories":["notes"],"content":" 4 Zero fill on demand在用户程序的地址空间中，除了 data、text 区域，还有一个 bss 区域，里面包含了未被初始化或者初始化为 $0$ 的全局或者静态变量，正常来说，程序执行的时候，是要为 bss 段的 VP，也都分配对应的物理页的，但是这其实并不必要。 例如，假设 bss 段有很多个 VP，并且基于 bss 段的定义，这里面的数据都是 $0$，那么我们不必为每一个 VP 都 map 单独的 PP，而是将 bss 段的所有的 VP 都 map 到一个值全为 $0$ 的 PP 上。 因此，我们需要将这些 VP 都设为不可写的，当要写其中一个 VP 时，策略与 Copy-on-Write fork 类似。 ","date":"2023-07-17","objectID":"/mit6.s081-lec08.zh/:4:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Page faults","uri":"/mit6.s081-lec08.zh/#zero-fill-on-demand"},{"categories":["notes"],"content":" 5 Demanding paging对于 exec，未修改的 xv6 中，os 会加载程序的 text、data 区域，并以 eager 的方式将这些区域加载进 page table（应该也可以说加载进物理内存），实际上我们可以采用 lazy 的方式，即为 text 和 data 分配好地址段，但是相应的 PTE 不对应任何 PP，即这些 PTE 的 valid bit 被设置为 $0$。 我们可以基于 accessed bit 实现 LRU 策略。 ","date":"2023-07-17","objectID":"/mit6.s081-lec08.zh/:5:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Page faults","uri":"/mit6.s081-lec08.zh/#demanding-paging"},{"categories":["notes"],"content":" 1 思路经过 lab5: lazy page allocation 之后，对 xv6 的 page fault 的处理，算是有所了解了。 今天这个 COW 实验，在 2020 年的课程视频中有对思路的讲解，可以先看看 课程翻译，厘清一下思路。 整体思路其实也不难，默认情况下，fork 会调用 uvmcopy，将父进程的 PP（物理页）复制一份，将这个 PP 的副本映射到子进程的 pagetable 的 VP（虚拟页）（子进程和父进程具有相同的虚拟地址，不同的 pagetable，不同的 PP，但是相同虚拟地址对应的 PP 的内容是一样的）。 我们这里讨论 vaddr、paddr 都是基于地址已经是 PGSIZE 对齐的情况来讨论的。 我们要做的修改就是，不再复制这个 PP，而是将 PP 的 paddr 同时映射到父进程的 vaddr 以及子进程的 vaddr。 在未修改 uvmcopy 之前，修改父进程的 vaddr 处的内容并不会影响子进程的 vaddr 处的内容，因为两个 vaddr 对应的是不同的 PP，只是 PP 的内容相同而已（在 pp 是 clean 的情况下）。 而修改了 uvmcopy 之后，写入父进程的 vaddr 会影响子进程的 vaddr 处的内容，这是我们不希望看到的，因此我们将这个 PP 对应的父进程的 pte 和子进程的 pte 的 PTE_W 位都清零，即标记为不可写，这样，当我们试图往这个 PP 中写入内容的时候，就会出现 page fault。 在出现 page fault 之后，我们需要在 usertrap 中处理这一情况，首先我们需要判断这个 page fault 是由于 Copy-on-Write Fork 这一机制导致的，而不是由于我们试图往一个真正的只读的页面写入内容，因此，我们需要用到 riscv 的 pte 的第 $8\\sim9$ 位，这是给 riscv 给操作系统的设计者预留的，这里，如果 pte 的第 $8$ 位为 $1$，说明这是对应一个 Copy-on-Write Fork page。 而我们在 usertrap 中的处理方法也很简单，申请一块物理内存（一个新的 PP），将 PP 的内容复制到这个新的 PP 中去，然后解除 PP 和导致 page fault 的 vaddr 的映射，将这个新的 PP 映射到 vaddr。 此外，还有一个非常重要的细节，目前 xv6 中，除了 trampoline page 之外，一个 PP 同时只会映射一个用户进程的 VP，而我们这样修改之后，一个 PP 可能同时映射到父进程和它的子进程的 VP，因此父进程或者某个子进程退出时，正常情况下该 PP 会被释放，但是由于其他用户进程可能还需要访问该 PP，因此不能直接被释放。 因此我们需要一个引用计数数组 ref_cnt，每个 PP 对应 ref_cnt 中的一个元素，每次调用 kfree 时，将这个 PP 对应的的引用计数 $-1$，如果这样引用计数变为 0 了，就释放该物理页；如果引用计数在减一之前就已经是 $0$，也要释放该 PP。 我昨天做的时候就是卡在这里了，光想着复制 PP，重新映射的时候要递减原 PP 的引用计数，而 kfree 写成了引用计数不为 $0$ 就什么也不做，正常应该是不为 $0$ 的时候就将引用计数减一。 ","date":"2023-07-17","objectID":"/xv6-lab6.zh/:1:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab6: Copy-on-Write Fork for xv6","uri":"/xv6-lab6.zh/#思路"},{"categories":["notes"],"content":" 2 实现首先，修改 kalloc.c，添加引用计数数组，这里我们参照 kalloc 中的 kmem，添加一个 kref_cnt 结构体： c struct { struct spinlock lock; struct ref_arr[PHYSTOP / PGSIZE]; } kref_cnt; 由于每个物理页都需要一个引用计数，因此引用计数数组的大小是 PHYSTOP / PGSIZE，同时，由于可能涉及多进程同时写入 ref_arr，因此我们需要一个 spinlock 自旋锁来保护 ref_arr 的数据不出错。 添加操作 ref_arr 的辅助函数，包括递增、设值、递减、读取，记得在 defs.h 中添加 prototype。 c uint8 get_ref(uint64 paddr) { return kref_cnt.ref_arr[paddr / PGSIZE]; } void dec_ref(uint64 paddr) { if (kref_cnt.ref_arr[paddr / PGSIZE] == 0) { return; } acquire(\u0026kref_cnt.lock); kref_cnt.ref_arr[paddr / PGSIZE] -= 1; release(\u0026kref_cnt.lock); } void inc_ref(uint64 paddr) { acquire(\u0026kref_cnt.lock); kref_cnt.ref_arr[paddr / PGSIZE] += 1; release(\u0026kref_cnt.lock); } void set_ref(uint64 paddr, uint8 val) { acquire(\u0026kref_cnt.lock); kref_cnt.ref_arr[paddr / PGSIZE] = val; release(\u0026kref_cnt.lock); } 下一步则是修改 kalloc 和 kfree 两个函数，对于 kalloc，每次分配物理内存之后，将物理地址对应的引用计数置为 $1$ 即可，kfree 的逻辑稍微复杂一点，首先判断物理地址的引用计数是否大于 $1$，如果大于 $1$，就递减引用计数然后直接 return，否则将引用计数置为 $0$，然后执行释放物理内存的操作。 c void kfree(void *pa) { if (((uint64)pa % PGSIZE) != 0 || (char *)pa \u003c end || (uint64)pa \u003e= PHYSTOP) panic(\"kfree\"); if (get_ref((uint64)pa) \u003e 1) { dec_ref((uint64)pa); return; } set_ref((uint64)pa, 0); struct run *r; // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run *)pa; acquire(\u0026kmem.lock); r-\u003enext = kmem.freelist; kmem.freelist = r; release(\u0026kmem.lock); } void *kalloc(void) { struct run *r; acquire(\u0026kmem.lock); r = kmem.freelist; if (r) kmem.freelist = r-\u003enext; release(\u0026kmem.lock); if (r) memset((char *)r, 5, PGSIZE); // fill with junk set_ref((uint64)r, 1); return (void *)r; } 再下一步是修改 uvmcopy 函数，修改思路前文已经给出了，同时要注意递增 paddr 对应的引用计数（因为子进程的 VP 也被这个 PP 映射了），同时注意标志位的设置和清除，PTE_C 需要自行定义在 riscv.h 中。 c int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { pte_t *pte; uint64 pa, i; uint flags; // char *mem; for (i = 0; i \u003c sz; i += PGSIZE) { if ((pte = walk(old, i, 0)) == 0) panic(\"uvmcopy: pte should exist\"); if ((*pte \u0026 PTE_V) == 0) panic(\"uvmcopy: page not present\"); *pte = *pte | PTE_C; *pte = *pte \u0026 (~PTE_W); // 设置 cow 标志位，PTE_W 清零 pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); // if ((mem = kalloc()) == 0) // goto err; // memmove(mem, (char *)pa, PGSIZE); if (mappages(new, i, PGSIZE, pa, flags) != 0) { kfree((char *)pa); goto err; } inc_ref(pa); // 递增引用计数 } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1; } 然后就是修改 usertrap 了，先判断是否是 page fault 引起的 trap，方法与 lab5 一致，然后通过 if ((*pte \u0026 PTE_W) == 0 \u0026\u0026 (*pte \u0026 PTE_C) == PTE_C) 判断发生 page fault 是不是“向 cow page 写入” 造成的。如果是，执行 remappage（定义在 vm.c 中）。 remappage 的主要内容就是解除原先的 PP 对 vaddr 的映射，将申请的新 PP 映射到 vaddr，同时注意处理引用计数。 c } else if (r_scause() == 13 || r_scause() == 15) { // copy on write uint64 vaddr = PGROUNDDOWN(r_stval()); uint64 paddr; pte_t *pte; if ((paddr = walkaddr(p-\u003epagetable, vaddr)) == 0) { // 判断该 vaddr 是否有效，并获取 vaddr 对应的 paddr p-\u003ekilled = 1; exit(-1); } // 检查 PTE_W 和 PTE_C pte = walk(p-\u003epagetable, vaddr, 0); if ((*pte \u0026 PTE_W) == 0 \u0026\u0026 (*pte \u0026 PTE_C) == PTE_C) { if (remappage(p-\u003epagetable, vaddr, paddr, pte) == 0) { p-\u003ekilled = 1; exit(-1); } } } c uint64 remappage(pagetable_t pagetable, uint64 vaddr, uint64 old_pa, pte_t *pte) { if (get_ref(old_pa) == 1) { // 说明只有一个进程在使用这个 PP 了，直接修改 pte 的 PTE_W 位即可 *pte = *pte | PTE_W; *pte = *pte \u0026 (~PTE_C); return old_pa; } char *mem; if ((mem = kalloc()) == 0) { return 0; } memmove(mem, (char *)old_pa, PGSIZE); // 记得先解除映射，否则会 \"panic, remap!\" uvmunmap(pagetable, vaddr, 1, 1); // uvmunmap 的时候就会调用 free，递减引用计数 // dec_ref(old_pa); if (mappages(pagetable, vaddr, PGSIZE, (uint64)mem, PTE_W | PTE_U | PTE_X | PTE_R) != 0) { kfree(mem); return 0; } return (uint64)mem; } 修改 copyout 的步骤与修改 usertrap 基本一致，只是要注意一点：在向 cow page 写入时，我们是重新申请了 PP，将原先的 PP 的内容复制到新的 PP，并执行了 remappage，那么最后向物理地址写入数据的时候，应该向我们新申请的 PP写入！ c int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) { uint64 n, va0, pa0; while (len \u003e 0) { va0 = PGROUNDDOWN(dstva); pa0 = walkaddr(pagetable, va0); // pa0 一定是 PGSIZE 对齐的 uint64 mem = pa0; if (pa0 == 0) { return -1; } ","date":"2023-07-17","objectID":"/xv6-lab6.zh/:2:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab6: Copy-on-Write Fork for xv6","uri":"/xv6-lab6.zh/#实现"},{"categories":["notes"],"content":" 3 总结这个实验与上一个 lazy allocation 的实验大同小异，都能很好加深对 page fault 异常的处理的理解。 ","date":"2023-07-17","objectID":"/xv6-lab6.zh/:3:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab6: Copy-on-Write Fork for xv6","uri":"/xv6-lab6.zh/#总结"},{"categories":["notes"],"content":" 1 前言这个实验只有 2020 年的才有，2021 年的课程中是没有的，但是感觉这个实验还是挺有意义的，因此用 docker 创建了一个 debian 12 的容器，在容器中搭建了 2020 的实验环境，实验环境的搭建过程可以参照 MIT 6.s081 实验环境搭建。 ","date":"2023-07-15","objectID":"/xv6-lab5.zh/:1:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab5: lazy page allocation","uri":"/xv6-lab5.zh/#前言"},{"categories":["notes"],"content":" 2 Eliminate allocation from sbrk()这个算是最简单的： c // kernel/sysproc.c uint64 sys_sbrk(void) { int addr; int n; if (argint(0, \u0026n) \u003c 0) { return -1; } addr = myproc-\u003esz; myproc()-\u003esz += n; // 添加的部分，修改 p-\u003esz，然后注释掉下面这三行 // if (growproc(n) \u003c 0) { // return -1; // } return addr; } ","date":"2023-07-15","objectID":"/xv6-lab5.zh/:2:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab5: lazy page allocation","uri":"/xv6-lab5.zh/#eliminate-allocation-from-sbrk"},{"categories":["notes"],"content":" 3 Lazy allocation在去掉了 sys_sbrk 的 growproc 部分之后，由于只是单纯增加了 p-\u003esz，而没有给对应的虚拟地址分配物理页，因此，在执行 echo hi 时，会访问到 heap 中的未分配物理页的虚拟地址，于是出现 page fault，默认的 Xv6 的代码中并没有给出对 page fault 的处理，而是会直接杀死进程，因此无法正常执行完 echo hi。 因此，我们需要修改 kernel/trap.c 中的 usertrap 函数，为它添加对 page fault 的处理函数，提示已经说的很清楚了，利用 r_scause() 函数读取 scause 寄存器，如果值为 $13$ 或者 $15$ 就说明是 page fault，然后执行相应的处理函数。 我们可以观察一下 growproc 在 n \u003e 0 的时候做了什么：调用 uvmalloc 并更新 p-\u003esz 为 sz + n，而 uvmalloc 函数其实就是调用 mappages 来为虚拟地址对应的 VP 分配对应的 PP。 因此，在 page fault 的处理部分，我们可以参照 uvmalloc 给虚拟地址对应的 VP 分配对应的 PP，同时要注意检查虚拟地址是不是一个有效的虚拟地址。 c // else if ((which_dev = devintr()) != 0) { // ok // } else if (r_scause() == 15 || r_scause() == 13) { uint64 wrong_addr = r_stval(); if (wrong_addr \u003e= p-\u003esz) { // va is not allocated by sbrk() p-\u003ekilled = 1; exit(-1); } if (wrong_addr \u003c PGROUNDUP(p-\u003etrapframe-\u003esp)) { // wrong_addr 必须在 heap，不能在 stack 中 printf(\"under stack!\\n\"); p-\u003ekilled = 1; exit(-1); } uint64 lb = PGROUNDDOWN(wrong_addr); char *mem = kalloc(); if (mem == 0) { // printf(\"there is not enough free space\\n\"); p-\u003ekilled = 1; } else { memset(mem, 0, PGSIZE); // printf(\"memset\\n\"); if (mappages(p-\u003epagetable, lb, PGSIZE, (uint64)mem, PTE_W | PTE_X | PTE_R | PTE_U) != 0) { kfree(mem); uvmdealloc(p-\u003epagetable, lb + PGSIZE, lb); p-\u003ekilled = 1; } } } 此外，我们还需要修改 uvmunmap，否则会出现 panic： Xv6 中，由于 sbrk 是以 eager 的形式扩充 heap 的，所有的虚拟地址都被映射到了物理地址上，因此，不应该存在 valid 标志位不为 $1$ 的情况，因此若出现该情况，直接 panic； 但是，当我们采取 lazy 的方式进行内存分配时，存在虚拟地址没有被物理地址映射是正常情况，因此 (pte = walk(pagetable, a, 0)) == 0 和 (*pte \u0026 PTE_V) == 0 都是正常现象： 前者可能虚拟地址对应的 L1, L0 页表都还不存在，又或者只有 L1 页表存在，L0 页表还未分配； 后者表示 L1, L0 页表都存在，但是虚拟地址还没有被物理地址映射，即 L0 页表的其他的 pte 对应的虚拟地址可能已经被物理地址映射了。 因此，碰到这两种情况，我们直接 continue; 即可： c void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) { uint64 a; pte_t *pte; if ((va % PGSIZE) != 0) panic(\"uvmunmap: not aligned\"); for (a = va; a \u003c va + npages * PGSIZE; a += PGSIZE) { if ((pte = walk(pagetable, a, 0)) == 0) { // 说明 pte 是无效的 continue; // 未分配的页无需释放 panic(\"uvmunmap: walk\"); } if ((*pte \u0026 PTE_V) == 0) // panic(\"uvmunmap: not mapped\"); // printf(\"may panic\\n\"); // 对未分配的页跳过 continue; if (PTE_FLAGS(*pte) == PTE_V) panic(\"uvmunmap: not a leaf\"); if (do_free) { uint64 pa = PTE2PA(*pte); kfree((void *)pa); } *pte = 0; } } ","date":"2023-07-15","objectID":"/xv6-lab5.zh/:3:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab5: lazy page allocation","uri":"/xv6-lab5.zh/#lazy-allocation"},{"categories":["notes"],"content":" 4 Layztests and Usertests这个实验还是有些难度的，关键是有个地方要能想到，我们先跟着实验的提示来： 处理 sbrk 的参数为负数的情况: 这个很好处理，负数的时候，调用 growproc 即可： c uint64 sys_sbrk(void) { int addr; int n; if (argint(0, \u0026n) \u003c 0) return -1; addr = myproc()-\u003esz; if (n \u003c 0) { if (growproc(n) \u003c 0) { return -1; } return addr; } myproc()-\u003esz += n; return addr; } 处理访问的虚拟地址没有被 sbrk 分配的情况： 这里其实是有一个要注意的细节的，我们的虚拟内存一般是从 $[0, 2^{n} - 1]$，或者说 $[0, 2^{n})$，因此，可以说虚拟内存空间一般是左闭右开的，而 heap，stack 等，假设它们都占据一个 PGSIZE 的大小，那么，可以说它们从低地址到高地址也是左闭右开的。因此，我们执行 sbrk 更新得到的地址 p-\u003esz 应该是不能被访问的，相当于是开区间的右端点（当然，由于我们一次至少分配 PGSIZE 的大小，除非 p-\u003esz 也是 PGSIZE 对齐的，不然实际上还是可以访问的） 处理虚拟地址位于 stack 的情况： 这里一开始我不知道怎么找到 stack 的虚拟地址，后面我查看了一下 usertests.c 的 stacktest 函数，里面是通过 r_sp() 获取 sp 寄存器的地址，来获取 stack 的栈顶的虚拟地址，而在发生 trap 时，sp 寄存器的值会被保存到 p-\u003etrapframe-\u003esp 中，因此，在内核中我们可以通过读取 p-\u003etrapframe-\u003esp 来获取当前栈顶指针的值（即栈顶的地址），我们再使用 PGROUNDUP 进行对齐，注意之前提到的，stack 也是低地址到高地址左闭右开，因此 PGROUNDUP(p-\u003etrapframe-\u003esp) 这个地址是属于 heap 的。 因此，我们的 usertrap 函数的 page fault 的处理部分应该是这样的： c } else if (r_scause() == 15 || r_scause() == 13) { uint64 wrong_addr = r_stval(); if (wrong_addr \u003e p-\u003esz) { // va is not allocated by sbrk() p-\u003ekilled = 1; exit(-1); } if (wrong_addr \u003c PGROUNDUP(p-\u003etrapframe-\u003esp)) { // va is in or below the stack printf(\"under stack!\\n\"); p-\u003ekilled = 1; exit(-1); } uint64 lb = PGROUNDDOWN(wrong_addr); // printf(\"try alloc\\n\"); char *mem = kalloc(); if (mem == 0) { // printf(\"there is not enough free space\\n\"); p-\u003ekilled = 1; } else { memset(mem, 0, PGSIZE); // printf(\"memset\\n\"); if (mappages(p-\u003epagetable, lb, PGSIZE, (uint64)mem, PTE_W | PTE_X | PTE_R | PTE_U) != 0) { kfree(mem); uvmdealloc(p-\u003epagetable, lb + PGSIZE, lb); p-\u003ekilled = 1; } } } 处理 out-of-memory 的情况: 上面的代码已经处理了。 处理 parent-to-child 在 fork 时的内存复制的情况: 这里我想了很久才想明白，其实参考一下 uvmunmap 的处理就知道该怎么修改 uvmcopy 了，不过我一开始还是想歪了，直接是当检查到虚拟地址没有被物理地址映射时，手动给虚拟地址分配物理页，这样是有问题的，相当于 fork 的时候没有进行 lazy allocate 了。其实处理方案跟 uvmunmap 一摸一样，直接 continue 就行了，只要保证分配了 PP 的 VP 被复制过去就好了，没有分配 PP 的 VP，等它的虚拟地址被访问时，由 page fault 来处理就好了： c int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { pte_t *pte; uint64 pa, i; uint flags; // char *memold; char *mem; for (i = 0; i \u003c sz; i += PGSIZE) { if ((pte = walk(old, i, 0)) == 0) { continue; panic(\"uvmcopy: pte should exist\"); } if ((*pte \u0026 PTE_V) == 0) { continue; panic(\"uvmcopy: page not present\"); } pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if ((mem = kalloc()) == 0) { printf(\"no enough space for mem\\n\"); goto err; } memmove(mem, (char *)pa, PGSIZE); if (mappages(new, i, PGSIZE, (uint64)mem, flags) != 0) { printf(\"can't mappages new\\n\"); kfree(mem); goto err; } } return 0; err: printf(\"uvmcopy err\\n\"); uvmunmap(new, 0, i / PGSIZE, 1); return -1; } 处理未分配 PP 的虚拟地址被直接作为系统调用的参数，在内核中被访问的情况： 这里当时理解错了实验提示的意思，另外就是，在内核中访问用户态的虚拟地址（通过 copyin 等函数），如果该虚拟地址没有被分配 PP，是不会触发 page fault 的！因此，需要我们在访问这个虚拟地址之前，就手动给虚拟地址分配 PP！ 最好的时机就是在 argaddr 处，因为内核中，真正承担系统调用功能的 sys_func 函数都需要通过 argaddr 才能获取被作为参数传入到系统调用的虚拟地址，因此，我们可以在修改 argaddr，让它在获取传入的作为参数的虚拟地址之后，不马上返回，而是检查该虚拟地址是否被分配了 PP，如果没有，就检查该虚拟地址的合法性，如果合法，那么就给虚拟地址分配 PP： c int argaddr(int n, uint64 *ip) { *ip = argraw(n); // ip 就是那个虚拟地址 struct proc *p = myproc(); if (walkaddr(p-\u003epagetable, *ip) == 0) { uint64 wrong_addr = *ip; if (wrong_addr \u003e= p-\u003esz) { // va is not allocated by sbrk() return -1; } if (wrong_addr \u003c PGROUNDUP(p-\u003etrapframe-\u003esp)) { // addr 在 stack 的下方 printf(\"under stack!\\n\"); return -1; } uint64 lb = PGROUNDDOWN(wrong_addr); char *mem = kalloc(); if (mem == 0) { printf(\"there is not enough free space\\n\"); return -1; } else { memset(mem, 0, PGSIZE); if (mappages(p-\u003epagetable, lb, PGSIZE, (uint64)mem, PTE_W | PTE_X | PTE_R | PTE_U) != 0) { kfree(mem); uvmdealloc(p-\u003epagetable, lb + PGSIZE, lb); return -1; } } } return 0; } ","date":"2023-07-15","objectID":"/xv6-lab5.zh/:4:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab5: lazy page allocation","uri":"/xv6-lab5.zh/#layztests-and-usertests"},{"categories":["notes"],"content":" 5 总结到此其实也算做了 $5$ 个 Lab 了，差不多一半了，本课程的 Lab 代码量都不大，然后会有一两个比较难以想到的点，如果想到了，那么很容易就能写出来，想不到就抓瞎了。 ","date":"2023-07-15","objectID":"/xv6-lab5.zh/:5:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab5: lazy page allocation","uri":"/xv6-lab5.zh/#总结"},{"categories":["notes"],"content":" 1 RISC-V assemblyWhich registers contain arguments to functions? For example, which register holds 13 in main’s call to printf? a2 寄存器，函数调用时，参数从左到右会依次保存在 a0, a1, a2, a3 寄存器，似乎是一直到寄存器 a7 的。 Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.) 这里的调用都被内联了 At what address is the function printf located? auipc（Add Upper Immediate PC）指令是将一个立即数左移 $12$ 位加上当前指令的地址（pc）中，得到一个绝对地址。 例如 auipc a0, 0x0 就是将 $\\text{0x0}$ 左移 $12$ 位加上当前指令的地址 (pc) 中（pc 的值我们一般认为是在指令执行完成时才发生递增，从而指向下一条指令，使得处理器能够按顺序顺利执行指令序列），因此，执行 auipc a0, 0x0 时，加的就是当前指令的地址，即 $\\text{0x28}$。 auipc 常常会与 jalr（Jump and Link Register） 指令组合在一起，在 jalr 1526(ra) 中，它把 pc 设置为寄存器 ra 的值加上 offset，然后把原先的 $pc + 4$ 的值写入寄存器 ra，即 ra 的值就是函数的返回值，即正常序列里，jalr 的下一条指令，这里 ra 的值应该是 $\\text{0x38}$, pc 的值则为 $\\text{0x626}$。 c unsigned int i = 0x00646c72; printf(\"H%x Wo%s\", 57616, \u0026i); 上面这段代码的输出结果为 He110 World。 ","date":"2023-07-13","objectID":"/xv6-lab4.zh/:1:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab4: Traps","uri":"/xv6-lab4.zh/#risc-v-assembly"},{"categories":["notes"],"content":" 2 Backtrace这里的关键在于弄懂 stack frame 的结构，参考这张图，其实基本原理与 x86 下 C 语言的 stack frame 是一致的，我们通过 uint64 fp = r_fp() 函数拿到的是栈基地址（联想 x86 中的 rbp），因此 fp + 8 就是 return address 的地址，因此 uint64 ra = *(uint64 *)(fp + 8);，注意 fp + 8 是地址的地址，不是我们要输出的 ra！ 我们需要遍历 stack frame，上一个 stack frame 的栈基地址就存放在 fp + 16 处，因此 fp = *(uint64 *)(fp + 16);。 循环的终止条件，可以先计算出 fp 的上下界 PGROUNDDOWN(fp) 和 PGROUNDUP(fp)（按照 PGSIZE 大小对齐），又或者当 PGROUNDUP(fp) != p-\u003ekstack + PGSIZE 时退出循环。 cpp void backtrace(void) { uint64 fp = r_fp(); printf(\"backtrace\\n\"); uint64 upb = PGROUNDUP(fp); uint64 db = PGROUNDDOWN(fp); // struct proc *p = myproc(); while (fp \u003c upb \u0026\u0026 fp \u003e db) { uint64 ra = *(uint64 *)(fp - 8); printf(\"%p\\n\", ra); fp = *(uint64 *)(fp - 16); } } ","date":"2023-07-13","objectID":"/xv6-lab4.zh/:2:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab4: Traps","uri":"/xv6-lab4.zh/#backtrace"},{"categories":["notes"],"content":" 3 Alarm这个实验在了解了 trap 机制的整个流程，如何陷入到内核代码，又如何返回用户代码之后，其实并不难，但是还是有两个地方比较难想： sigalarm 的调用其实只起到一个开关的作用，当开启 sigalarm 之后，还是要在 usertrap 的外部定时中断部分来执行定时响应函数，我们可以通过 argaddr 函数来获取 sigalarm 传入的作为函数地址的第二个参数，但是，我们并不能直接在 usertrap 中把函数地址强制类型转化为函数指针来调用函数，这是因为 kernel page table 与 user page table 是不一样的，我们需要把 p-\u003etrapframe-\u003eepc 修改为 periodic 的地址，在返回用户态时，pc 会被更新为 p-\u003etrapframe-\u003eepc 的值，这样返回到用户态时就会马上执行 periodic 函数； 经过上面的操作，我们返回时会直接执行 periodic 函数，但是执行完函数之后，机器就不知道接下来该执行哪一条指令来，因此提供了 sigreturn 函数，使得可以恢复到发生定时器中断时的状态，这里提到了需要保存很多寄存器的值，因此直接在 struct proc 中添加一个 struct trapframe *save_reg; 字段，在 usertrap 的定时中断响应中，利用 memmove 将 p-\u003etrapframe 复制到 p-\u003esave_reg，而在 sys_return 中将 p-\u003esave_reg 恢复到 p-\u003etrapframe。 几处关键的代码： trap.c 中： c void usertrap(void) { int which_dev = 0; if ((r_sstatus() \u0026 SSTATUS_SPP) != 0) panic(\"usertrap: not from user mode\"); // send interrupts and exceptions to kerneltrap(), // since we're now in the kernel. w_stvec((uint64)kernelvec); struct proc *p = myproc(); // save user program counter. p-\u003etrapframe-\u003eepc = r_sepc(); if (r_scause() == 8) { // system call if (p-\u003ekilled) exit(-1); // sepc points to the ecall instruction, // but we want to return to the next instruction. p-\u003etrapframe-\u003eepc += 4; // an interrupt will change sstatus \u0026c registers, // so don't enable until done with those registers. intr_on(); syscall(); } else if ((which_dev = devintr()) != 0) { // ok if (which_dev == 2 \u0026\u0026 p-\u003einterval != 0) { // 说明启用了 alarm ++p-\u003etick_num; if (p-\u003etick_num == p-\u003einterval) { if (p-\u003eflag == 0) { // typedef void (*Handler)(); // printf(\"p-\u003ehandler: %p\\n\", p-\u003ehandler); memmove(p-\u003esave_reg, p-\u003etrapframe, PGSIZE); p-\u003eflag = 1; p-\u003etrapframe-\u003eepc = p-\u003ehandler; } p-\u003etick_num = 0; } } } else { printf(\"usertrap(): unexpected scause %p pid=%d\\n\", r_scause(), p-\u003epid); printf(\" sepc=%p stval=%p\\n\", r_sepc(), r_stval()); p-\u003ekilled = 1; } if (p-\u003ekilled) exit(-1); // give up the CPU if this is a timer interrupt. if (which_dev == 2) { yield(); } usertrapret(); } sysproc.c 中： c uint64 sys_sigalarm() { struct proc *p = myproc(); int interval; if (argint(0, \u0026interval) \u003c 0) { return -1; } uint64 addr; if (argaddr(1, \u0026addr) \u003c 0) { return -1; } p-\u003einterval = interval; p-\u003ehandler = addr; return 0; } uint64 sys_sigreturn() { struct proc *p = myproc(); memmove(p-\u003etrapframe, p-\u003esave_reg, PGSIZE); p-\u003eflag = 0; return 0; } 同时注意在 proc.c 的 allocproc 中给 save_reg 分配空间，在 freeproc 中释放。 以及 kernel/param.h 中，FSSIZE 要修改为至少 $1088$，否则 alarmtest 能过，但是 usertests 过不了，会卡在 writebig 处，报错提示为 “test writebig: panic: balloc: out of blocks”，不知道有没有大佬能解惑。 另外，为什么一定要保存整个 trapframe 呢？ ","date":"2023-07-13","objectID":"/xv6-lab4.zh/:3:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab4: Traps","uri":"/xv6-lab4.zh/#alarm"},{"categories":["notes"],"content":" 1 Trap 机制程序运行往往需要完成用户空间和内核空间的切换，每当： 程序执行系统调用（system call）； 程序出现了 page fault 等错误； 一个设备触发了中断； 都会发生这样的切换。 这里用户空间切换到内核空间通常被称为 trap，因此有时候我们会说程序“陷入”到内核态。trap 机制需要尽可能的简单。 trap 的工作，可以说是让硬件从适合运行用户程序的状态，切换到适合运行内核代码的状态。 这里说的状态中，我们最关心的状态可能是 $32$ 个用户寄存器，我们尤其需要关注以下硬件寄存器的内容： 堆栈寄存器（stack register，又称 stack pointer）； 程序计数器（Program Counter Register）； 表明当前 mode 的标志位的寄存器，表明当前是 supervisor mode 还是 user mode； 控制 CPU 工作方式的寄存器，例如 SATP（Supervisor Address Translation and Protection）寄存器，它包含了指向 page table 的物理内存地址； STVEC（Supervisor Trap Vector Base Address Register）寄存器，它指向了内核中处理 trap 的指令的起始地址； SEPC（Supervisor Exception Program Counter）寄存器，在 trap 的过程中保存程序计数器的值； sscratch（Supervisor Scratch Register）寄存器； 在 trap 的最开始，CPU 所有的状态肯定还是在运行用户代码而不是内核代码，在 trap 处理的过程中，我们会逐渐更改状态，或者对状态做一些操作，我们可以设想一下我们需要做哪些操作： 保存 $32$ 个用户寄存器的状态，例如，当响应中断完成后，我们会希望能恢复用户程序的执行，而这些寄存器需要被内核代码所使用，因此，在 trap 之前，我们需要保存这 $32$ 个用户寄存器的内容； 保存 PC 的内容，原因类似于保存 $32$ 个用户寄存器； 将 mode 修改为 supervisor mode； 运行内核代码前，将 SATP 由指向 user page table 修改为指向 kernel page table； trap 机制不会依赖于 $32$ 个用户寄存器； supervisor mode 可以实现什么 user mode 不能实现的事情？（其实不多） 读写 SATP、STVEC、SEPC、sscratch 等寄存器； 使用 PTE_U 标志位为 0 的 PTE； supervisor mode 并不能读写任意物理地址，在 supervisor mode 中，也需要通过 page table 来访问内存，如果一个物理地址映射的虚拟地址并不在当前 SATP 指向的 page table 中，又或者 SATP 指向的 page table 中，PTE_U = 1，那么 supervisor mode 不能使用那个地址。 ","date":"2023-07-08","objectID":"/mit6.s081-lec06.zh/:1:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Isolation \u0026 System call entry/exit","uri":"/mit6.s081-lec06.zh/#trap-机制"},{"categories":["notes"],"content":" 2 ecall 指令2020 版的课程以 Xv6 的 sh.c 的 getcmd 中执行的 write 系统调用来说明这个例子（2021 版中，getcmd 转而使用了 fprintf），我这里其实是调试的 echo.c。 执行 make CPUS=1 qemu-gdb 以及 riscv64-unknown-elf-gdb（注意要配置好 .gdbinit），然后 gdb 中执行 file user/echo.o 以及 b main，将断点打在 user/echo.c 的 main 函数处，多执行几次 continue，直到 qemu 中的 shell 加载完成，可以执行命令了，输入 echo zwyyy，再在 gdb 的窗口中执行 layout split 以及 continue，函数将停在 main 函数处，从 echo.asm 中我们可以看到 write 系统调用对应的 ECALL 指令所在的地址，为 $\\text{0x31c}$，因此我们执行 b *0x31c，然后执行 continue： 然后我们打印 PC 的值，正好在 $\\text{0x31c}$ 处： a0，a1，a2 寄存器中的内容是 shell 传递给 write 系统调用的参数，a0 是文件描述符，a1 是 shell 想要写入的字符串的指针，a2 是想要写入的字符数： 在 QEMU 中输入 ctrl + a，再输入 c 可以进入到 QEMU 的 console 中，之后输入 info mem，QEMU 会打印完整的 page table 可以看到最后两个 pte 的 vaddr 非常大，接近虚拟地址的顶端，这两个 page 分别是 trapframe page 和 trampoline page。 然后我们输入 stepi 来执行 ecall 指令，此时输入print $pc，发现 pc 中的内容是一个很大的地址，它正是 trampoline page 的最开始，我们的指令正在内存的 trampline page 中。 ecall 指令的下一个指令是 csrrw a0, sscratch, a0，交换了寄存器 a0 和寄存器 sscratch 的内容。 我们现在正在 trampoline page 中，ecall 并不会切换 page table，因此，trap 处理代码必须存在于每个 user page table 中，因为 ecall 并不会切换 page table，因此，我们需要在 user page table 中的某处来执行最初的内核代码，而这个 trampoline page 由内核映射到每一个 user page table 中，使得我们仍在使用 user page table 时，内核能在一个地方执行 trap 机制的最开始的一些指令。 这里的指令从 ecall 跳转到 trampoline page 是通过 ecall 指令实现的： ECALL 指令其实只会做三件事： 将代码从 user mode 切换到 supervisor mode； 将 PC 的值保存在 SEPC 寄存器中； 跳转到 STVEC 寄存器指向的指令，STVEC 寄存器只能在 supervisor mode 下进行读写； 打印 sepc 寄存器的内容，我们可以看到这个寄存器的内容就是 ecall 指令在用户空间的地址。 ","date":"2023-07-08","objectID":"/mit6.s081-lec06.zh/:2:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Isolation \u0026 System call entry/exit","uri":"/mit6.s081-lec06.zh/#ecall-指令"},{"categories":["notes"],"content":" 3 ecall 指令执行完之后ecall 帮我们做了开头的工作，但离我们执行内核中的 C 代码还有很多工作要做： 我们需要保存 $32$ 个用户寄存器的内容，这样当我们需要恢复执行用户代码时，我们才能恢复这些寄存器的内容，从而让用户代码察觉到不到自己被暂停执行系统调用去了； 从 user page table 切换到 kernel page table 创建或者找到一个 kernel stack，将 stack pointer 寄存器的内容指向那个 kernel stack，这样内核中的 C 代码才有栈可以使用； 还需要跳转到内核中 C 代码某些合理的位置； ecall 指令之所以不完成上述的工作，是因为 RISC-V 的设计理念，即“ecall 只尽量完成少的必须要完成的工作，其他工作都交给软件完成，从而为软件与操作系统程序员提供最大的灵活性”。 ","date":"2023-07-08","objectID":"/mit6.s081-lec06.zh/:3:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Isolation \u0026 System call entry/exit","uri":"/mit6.s081-lec06.zh/#ecall-指令执行完之后"},{"categories":["notes"],"content":" 4 uservec 函数 与 trampoline pageXv6 为每个 user page table 映射了 trapframe page，在 trapfram page 中有 $32$ 个空槽位，用来保存 $32$ 个用户寄存器的内容。 trapframe page 在 user page table 中的虚拟地址总是 $\\text{0x3ffffffe000}$。 如果想要查看 Xv6 在 trapframe page 中存放了什么，可以查看 proc.h 中的 trapframe 结构体。 保存用户寄存器的方案分为两部分： 内核将 trapframe page 映射到了每个 user page table； 另一部分则在于 sscratch 寄存器； 在进入 user space 之前，内核会将 trapframe page 的地址保存在这个寄存器中，即 $\\text{0x3ffffffe000}$。 注意，我们只会在 user page table 下使用 trapframe page 的虚拟地址！后面可以看到，在 userret 时，我们是将 kernel page table 切换回 user page table 之后才使用的 trapframe page！ 我们可以看到，当执行完 csrrw 指令之后，a0 寄存器中的值就是 trapframe page 的虚拟地址，此后的一系列 sd 指令，就是将寄存器的内容保存在 trapframe page 的不同 offset 处，即 $offset + a0$ 处。 在内核上一次切换回用户空间时，sscratch 寄存器的内容会被设置为 $\\text{0x3ffffffe000}$。 Xv6 的启动流程参见 MIT 6.S081 操作系统组织架构，会经过一个从 machine mode 到 supervisor mode 再到 user mode 的过程，因此在 ecall 指令执行之前，sscratch 的内容就已经被设置好了。 在第一个 ld 指令之前，有 csrr t0, sscratch 和 sd t0, 112(a0) 这两条指令。这两条指令结合起来，就是将 sscratch 的值写入到了 trapframe 结构体中的 a0 字段处。 然后我们将停在第一个 ld 指令处，这条指令将 a0 中的内存地址（即 trapframe 的地址）往后数 $8$ 个字节处开始的数据加载到 Stack Pointer 寄存器中，由 trapframe 结构体我们可以知道，这里的数据就是内核的 Stack Pointer 的内容。 trapframe 中的 kernel_sp 是由 kernel 在进入用户空间之前就设置好的，它的值是这个进程的 kernel stack。所以这条指令的作用是初始化 Stack Pointer 指向这个进程的 kernel stack 的最顶端。指向完这条指令之后，我们打印一下当前的 Stack Pointer 寄存器。 下一条指令是将 trapframe 结构体中的 kernel_hartid 写到 tp 寄存器中，kernel_hartid 就是当前 CPU 核的编号。 再下一条指令是往 t0 寄存器中写入数据，这里写入的是将要执行的第一个 C 函数 —— usertrap 的指针。 再下一条指令是向 t1 中写入包含 kernel page table 地址的数据（相比真正的地址，进行了移位）。 再下一条交换 SATP 寄存器和 t1 寄存器，当这条指令完成后，当前程序会从 user page table 切换到 kernel page table，而 t1 寄存器中保存着 user page table 的地址。 我们已经切换了 page table，而程序计数器中保存的是虚拟地址，但我们还是能正确执行内容，同一个虚拟地址不会因为 page table 的切换而走到无关的 pp 中，这正是因为我们还在 trampoline page 中，而 trampoline page 在用户空间和内核空间都映射到了同一个虚拟地址。 只有 trampoline page 在 user page table 和 kernel page table 中都映射到了同一个虚拟地址！ 最后一条指令是 jr t0，执行了这条指令，我们就从 trampoline page 跳转到内核的 C 代码中去了。 ","date":"2023-07-08","objectID":"/mit6.s081-lec06.zh/:4:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Isolation \u0026 System call entry/exit","uri":"/mit6.s081-lec06.zh/#uservec-函数-与-trampoline-page"},{"categories":["notes"],"content":" 5 usertrap 函数usertrap 函数定义于 kernel/trap.c 中： 首先，我们执行 w_stvec，从而将kernelvec 变量的值写入到 STVEC 中，这是内核空间 trap 处理代码的位置，而不是用户空间 trap 处理代码的位置，从而保证 trap 来源于内核空间时，不会像来源于用户空间时那样执行很多不必要的操作。 然后，我们通过 myproc 函数获取当前进程编号，接下来我们将 SEPC 寄存器中的值保存到 p-\u003etrapframe-\u003eepc 中，防止中途切换到另一个要执行系统调用的进程中导致 SEPC 被覆盖。 接下来我们检查 SCAUSE 寄存器，如果内容为 $8$，说明是通过系统调用触发 trap 的，然后检查是否有其他进程杀掉了当前进程。 我们将 p-\u003etrapframe-\u003eepc += 4，是因为我们希望恢复到用户代码时，不是恢复到 ecall 然后再执行一遍 ecall，而是用户代码中 ecall 的下一条指令，即 ret。 XV6会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被RISC-V的trap硬件关闭，所以在这个时间点，我们需要执行 intr_on() 显式的打开中断。 之后，我们会调用 syscall 函数，syscall 从 a7 寄存器中获取系统调用编号，而之前系统调用 write 对应的汇编代码中，有一个 li a7, SYS_write，因此 syscall 就知道要去执行 sys_write() 函数了（syscall.c 中定义了一个索引表）。 write 的参数在 ecall 之前分别保存在 a0、a1、a2 处，在 trap 机制之后，它们分别位于 trapframe 结构体的 a0、a1、a2 字段处。 p-\u003etrapframe-\u003ea0 = syscalls[num](); 这里向 trapframe 中的 a0 赋值是因为：所有系统调用都会返回一个返回值，RISC-V 上的 C 代码习惯将函数返回值存储于寄存器 a0，而返回到用户空间时，trapframe 的 a0 槽位的数值会写回到实际的 a0 寄存器，shell 会认为 a0 寄存器的值就是 write 系统调用的返回值。 在 usertrap 函数中，执行完 syscall 之后，我们再次检查进程是否被杀掉（我们不希望恢复一个被杀掉的进程），然后执行 usertrapret。 ","date":"2023-07-08","objectID":"/mit6.s081-lec06.zh/:5:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Isolation \u0026 System call entry/exit","uri":"/mit6.s081-lec06.zh/#usertrap-函数"},{"categories":["notes"],"content":" 6 usertrapret 函数首先，它执行 intr_off 关闭了中断。 然后，执行 w_stvec(TRAMPOLINE + (uservec - trampoline)); 将 STVEC 寄存器中的内容修改为指向 user trampoline 的地址。 然后执行一系列操作将对应值填入到 trapframe 中，再之后设置 SSTATUS 寄存器，该寄存器的 SSP bit 为 $0$ 说明我们执行 sret 时应该返回 user mode 而不是 supervisor mode。 SPIE bit 为 $1$ 表明执行 sret 之后是否打开中断。 然后我们将 p-\u003etrapframe-\u003eepc 的值写入到 SEPC 寄存器中去。 uint64 fn = TRAMPOLINE + (userret - trampoline) 计算出我们要跳转到的汇编代码的地址，即 trampoline page 中的 userret 函数。 再将相应 user page table 地址写入到 satp，然后通过 fn 函数传递，satp 的值会出现在 a1 寄存器中，执行该 userret 函数。 ","date":"2023-07-08","objectID":"/mit6.s081-lec06.zh/:6:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Isolation \u0026 System call entry/exit","uri":"/mit6.s081-lec06.zh/#usertrapret-函数"},{"categories":["notes"],"content":" 7 userret 函数userret 函数位于 trampoline.S 中 第一步是将 page table 从 kernel page table 切换到 user page table 中，即将 a1 寄存器的值写入到 satp 寄存器中去，a1 寄存器的值就是 user page table 的地址。 然后我们执行 ld t0, 112(a0) 和 csrw sscratch, t0，将 p-\u003etrapframe-\u003ea0 的值写入到了 sscratch 寄存器中。 之后是将 trapframe 中的一系列值写回到寄存器中去。 此时 a0 寄存器仍然是 TRAPFRAME 的地址，而 sscratch 寄存器中则是系统调用的返回值，执行一次 csrrw a0, sscratch, a0，交换两个寄存器的值，sscratch 中就存储着 TRAPFRAME 的地址了，而 a0 寄存器中则是系统调用的返回值。 sret 是我们在 kernel 中的最后一条指令，执行它会产生以下三个效果： 程序切换回 user mode； SEPC 寄存器的数值被保存到 PC 寄存器，它指向 ecall 的下一条指令 ret； 重新打开中断； ","date":"2023-07-08","objectID":"/mit6.s081-lec06.zh/:7:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 Isolation \u0026 System call entry/exit","uri":"/mit6.s081-lec06.zh/#userret-函数"},{"categories":["tutorial"],"content":" 1 问题描述我主要用的 shell 就是 fish，主打一个开箱即用，虽然也配置过 zsh，但是感觉配置好的 zsh 在易用性上也就是 fish 的水平。 此前，一直以来默认的 shell 都是 bash，ssh 或者 vscode remote 远程连接上去之后，再输入 fish 来进行手动切换，后来嫌麻烦，就执行 chsh -s /usr/bin/fish 将默认 shell 切换到了 fish，然后 vscode remote 就连接不上了。 出现该问题的原因见该 issue 里的讨论 we still have a bug connecting to remotes with fish shells as their default shell. Using the remotePlatform setting we added a work around to make the connection work. It’s not ideal but it works. The bug specifically has to do with what seems that Fish shells don’t let us pipe in scripts after connection unless we connect with a command like ssh your_host bash. However, we want to avoid using “bash” since it prevents usage of RemoteCommand. For now it’s not clear what the best way to accommodate both RemoteCommands and Fish shells. The remotePlatform setting gives me a workaround where if I see you have that set I add “bash” to the connection command and disable RemoteCommand. ","date":"2023-07-08","objectID":"/fish-vscode-remote.zh/:1:0","series":null,"tags":["tips"],"title":"解决远程主机的默认 shell 为 fish 时，vscode remote 无法连接的问题","uri":"/fish-vscode-remote.zh/#问题描述"},{"categories":["tutorial"],"content":" 2 解决方案在上面提到的 issue 里面有给出解决方案，即打开设置，搜索 remote.SSH.remotePlatfrom，选择 add Item，添加键值对，key 是远程主机的名字，例如 deb-lenovo，value 则是平台，选择 linux，即可。 这样做其实还是有一个副作用，那就是 vscode remote 连接上去之后，new Terminal 的默认 shell 还是 bash，所以说这个解决方案并不优雅。 ","date":"2023-07-08","objectID":"/fish-vscode-remote.zh/:2:0","series":null,"tags":["tips"],"title":"解决远程主机的默认 shell 为 fish 时，vscode remote 无法连接的问题","uri":"/fish-vscode-remote.zh/#解决方案"},{"categories":["notes"],"content":" 1 Paging hardware总的来说，Xv6 的虚拟内存到物理内存的映射方式与 x64 是一致的，都是使用页表来进行映射。区别在于，Xv6 只使用了三级页表，而 x64 则是使用四级页表，另外，二者的页表层级的命名也有区别，对 Xv6 来说，最高级的页表是 L3（其地址存放于寄存器 satp 中）。 每个 page table 含有 512 个 page table entry，而每个 page table entry 的大小是 8KB，因此一个 page table 占据的大小正好是 4KB，即一个 VP 的大小！ 标志位可以说是顾名思义，除了这个 dirty？（留待之后处理） ","date":"2023-07-03","objectID":"/mit6.s081-page-table.zh/:1:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 页表","uri":"/mit6.s081-page-table.zh/#paging-hardware"},{"categories":["notes"],"content":" 2 Kernel address spaceXv6 中，每个进程都有属于自己的地址空间，以及一个全局唯一的描述内核地址空间的 page table，（kernel page table）。 内核内存布局： QEMU 模拟了一台带 RAM（物理内存）的电脑，该 RAM 的起始地址是 $\\text{0x80000000}$ ,结束地址至少是 $\\text{0x86400000}$（该地址在 Xv6 中被定义为 PHYSTOP），这里的地址说的都是物理地址。 QEMU 会将设备接口以内存映射的控制寄存器暴露给系统软件，这些寄存器地址映射的内存都是在 $\\text{0x80000000}$，即系统要访问这些设备，都是通过 $\\text{0x80000000}$ 以下的物理地址直接访问，但通过这样的物理地址访问设备就不会经过 RAM 了。 内核空间的虚拟地址是直接映射到物理地址的，例如 KERNBASE=0x80000000，虚拟地址和物理地址都是这个值，可以理解为虚拟地址等于物理地址。 但是有几个内核虚拟地址不是直接映射的，如下图所示： trampoline page（蹦床页面），它映射在虚拟地址空间的顶部，user page table 具有相同的映射，即不论 kernel page table 还是 user page table，trampoline page 的虚拟地址都是在虚拟地址空间的顶部； kernel stack page，每个进程都有自己的 kernel stack，会映射到虚拟地址空间中比较高的那个 kernel stack，这样可以利用到 kernel stack 下方的那个 guard page。Guard page is invalid!（PTE_V 没有设置）。因此，一旦 kernel stack 发生溢出，就会发生异常。 trampoline page 是 r-x 的，kernel stack 是 rw- 的。 从图上来看，其实只有 kernel data 和 kernel text 是直接映射的。 ","date":"2023-07-03","objectID":"/mit6.s081-page-table.zh/:2:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 页表","uri":"/mit6.s081-page-table.zh/#kernel-address-space"},{"categories":["notes"],"content":" 3 Code: creating an address space关于操作 page table 和地址空间的代码主要位于 kernel/vm.c 中。 通过函数 walk 找到虚拟地址对应的 PTE 以及最终的物理地址（相当于之前 csapp 的虚拟内存那一章提到的 page walk）。 ","date":"2023-07-03","objectID":"/mit6.s081-page-table.zh/:3:0","series":null,"tags":["xv6","mit","os"],"title":"MIT 6.S081 页表","uri":"/mit6.s081-page-table.zh/#code-creating-an-address-space"},{"categories":["notes"],"content":" 1 系统调用Lab1 主要是基于提供的系统调用接口来编写一些小工具程序，而 Lab2 则是要我们自己实现系统调用，并提供系统调用的接口。 以本次 Lab 要我们实现的 trace 调用为例，说明一下系统调用的流程： 在 user/trace.c 的第 $15$ 行，调用了属于 system call 的 trace 函数，当前执行 make qemu 是无法成功的，因为我们还没有给用户提供接口。因此，我们需要在 user/user.h 里面添加系统调用 trace 的函数声明（prototype）。 我们需要在 user/usys.pl 中追加 entry(\"trace\"); 这一行，从而添加一个 trap entry，从而实现调用 trace 时会发生 trap，从而会执行 ECALL 指令，并且会将系统调用的接口的参数（这里就是 trace 的参数）的存入寄存器 a0、a1 等（从左往右第一个参数的地址存入 a0，依次类推），此外，还会将 trace 对应的系统调用号存入寄存器 a7。 之后控制权来到 kernel 中的 syscall 函数，它从 a7 中取出系统调用号，并执行系统调用号对应的 sys_func。 这里的系统调用号可以理解为数组索引，在本次 Lab 中需要我们修改 kernel/syscall.c 和 kenel/syscall.h 从而添加 trace 对应的系统调用号，以及内核中 trace 对应的 sys_trace 的实现）。 ","date":"2023-07-01","objectID":"/xv6-lab2.zh/:1:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab2: System calls","uri":"/xv6-lab2.zh/#系统调用"},{"categories":["notes"],"content":" 2 System call tracing官网的提示其实是比较全面了，按提示处理，即可添加 trace 的系统调用接口： Run make qemu and you will see that the compiler cannot compile user/trace.c, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to user/user.h, a stub to user/usys.pl, and a syscall number to kernel/syscall.h. The Makefile invokes the perl script user/usys.pl, which produces user/usys.S, the actual system call stubs, which use the RISC-V ecall instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet. 之后，则需要我们自己在 kernel/syspro.c 中实现真正执行系统调用 trace 所需要执行的操作了： Lab 给出的提示中提到，我们需要将 trace(int mask) 的参数 mask 参数存放到 proc 结构体中的一个新成员变量中，这里我们直接用 mask 表示，于是，sys_trace 要做的其实很简单，就是取出寄存器 a0 中的地址然后解引用，得到 mask，然后将它赋给 proc 结构体中的 mask。 对于取出寄存器 a0 的参数，Xv6 已经给我们封装好了一个函数 argint，参照一下 sys_exit 的实现，以及 int argint(int n, int *p) 的实现，就能知道 argint 如何使用了，第一个参数表示从哪个寄存器中取值，取出来的值放在地址 p 中。 c // 修改 syscall.h，添加 #define SYS_trace 22 static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, [SYS_wait] sys_wait, [SYS_pipe] sys_pipe, [SYS_read] sys_read, [SYS_kill] sys_kill, [SYS_exec] sys_exec, [SYS_fstat] sys_fstat, [SYS_chdir] sys_chdir, [SYS_dup] sys_dup, [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk, [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open, [SYS_write] sys_write, [SYS_mknod] sys_mknod, [SYS_unlink] sys_unlink, [SYS_link] sys_link, [SYS_mkdir] sys_mkdir, [SYS_close] sys_close, [SYS_trace] sys_trace, }; // syscall for trace uint64 sys_trace(void) { struct proc *to_trace = myproc(); int mask; if (argint(0, \u0026mask) \u003c 0) { // 取出 trace 之后的 mask 参数 return -1; } to_trace-\u003emask = mask; return 0; } 然后需要修改 fork()，从而使得子进程也共享同一个 mask，这里很简单，在 fork() 的实现中添加 np-\u003emask = p-\u003emask; 即可。 最后还需要修改 syscall() 函数，从而当系统调用号属于 mask 使能的系统调用号时，按 Lab 要求进行 printf。 c void syscall(void) { int num; struct proc *p = myproc(); num = p-\u003etrapframe-\u003ea7; if (num \u003e 0 \u0026\u0026 num \u003c NELEM(syscalls) \u0026\u0026 syscalls[num]) { uint64 res = syscalls[num](); p-\u003etrapframe-\u003ea0 = res; int mask = p-\u003emask; if ((1 \u003c\u003c num) \u0026 mask) { printf(\"%d: syscall %s -\u003e %d\\n\", p-\u003epid, name[num], res); } } else { printf(\"%d %s: unknown sys call %d\\n\", p-\u003epid, p-\u003ename, num); p-\u003etrapframe-\u003ea0 = -1; } } ","date":"2023-07-01","objectID":"/xv6-lab2.zh/:2:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab2: System calls","uri":"/xv6-lab2.zh/#system-call-tracing"},{"categories":["notes"],"content":" 3 Sysinfo添加接口的操作同上，我们先实现 sys_sysinfo，由于 sysinfo 接口的参数是个指针（或者说地址），尽管该参数的地址依旧存放于 a0 寄存器中，但是我们不能再使用 argint 了，这里 Lab 给出了提示，参照 sys_fstat 的实现，我们知道了可以使用 argaddr 实现这一操作，a0 中的值被存放于 uint64 addr 中。 之后，我们需要创建一个新的 struct sysinfo 结构体变量 info，然后将统计的 amount of free memory 和 number of processes 存放于这个结构体变量中。 之后，Lab 提示我们使用 copyout 将 info 传递到 user space，其实参照 copyout 的注释就能清楚明白 copyout 是干嘛的，怎么用了。 c uint64 sys_sysinfo(void) { uint64 addr; // user pointer to struct sysinfo if (argaddr(0, \u0026addr) \u003c 0) { return -1; } struct proc *p = myproc(); struct sysinfo info; info.nproc = get_proc_num(); info.freemem = freemem_size(); if (copyout(p-\u003epagetable, addr, (char *)\u0026info, sizeof(info)) \u003c 0) { return -1; } return 0; } 在 defs.h 中添加 get_proc_num 和 freemem_size 的 prototype。 分别在 kernel/kalloc.c 和 kernel/proc.c 中实现。统计 amount of free memory，从 kalloc.c 中可以发现，Xv6 是使用 external free memory list 的形式来进行 malloc 的，所以我们只需要统计 free memory list 的结点数就能知道了；而对统计 number of processes 来说，从 proc.c 的 struct proc proc[NPROC]; 中可以得知，进程是以数组形式管理的，我们统计该数组中状态不为 unused 即可知 number of processes。 c // kernel/kalloc.c int freemem_size(void) { struct run *r; int num = 0; for (r = kmem.freelist; r; r = r-\u003enext) { ++num; } return num * PGSIZE; } // kernel/proc int get_proc_num(void) { struct proc *p; int num = 0; for (p = proc; p \u003c \u0026proc[NPROC]; ++p) { if (p-\u003estate != UNUSED) { ++num; } } return num; } ","date":"2023-07-01","objectID":"/xv6-lab2.zh/:3:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab2: System calls","uri":"/xv6-lab2.zh/#sysinfo"},{"categories":["notes"],"content":" 4 总结这个 Lab 设计得非常精妙，做了 System call tracing 之后，对系统调用的流程就有了比较深刻的理解了，Sysinfo 则是加深理解，两个实验一起，对系统调用时，参数的传入、结果的传出，都有了大致概念。 ","date":"2023-07-01","objectID":"/xv6-lab2.zh/:4:0","series":null,"tags":["xv6","os","lab","mit"],"title":"Xv6 Lab2: System calls","uri":"/xv6-lab2.zh/#总结"},{"categories":["notes"],"content":" 1 进程概述64 位的 RISC-V 的 VAS 是 39 位的，即 VA 只有 39 位，而 Xv6 则只有 38 位，最大虚拟地址为 #define MAXVA 0x3fffffffff。 VAS 的顶端，即最高位存放了两个 page，一个是用于 trampoline，一个用于 mapping the process’s trapframe。 Xv6 使用这两个 page 来切换到内核以及返回。 进程的状态被定义在 kernel/proc.h 的结构体 struct proc 所描述，进程在内核中最重要的信息就是它的 page table、 kernel stack 以及运行状态（run state）。 A process can make a system call by executing the RISC-V ecall instruction. This instruction raises the hardware privilege level and changes the program counter to a kernel-defined entry point. The code at the entry point switches to a kernel stack and executes the kernel instructions that implement the system call. When the system call completes, the kernel switches back to the user stack and returns to user space by calling the sret instruction. (x64 架构似乎是 iret？) ","date":"2023-06-29","objectID":"/xv6-os-organization.zh/:1:0","series":null,"tags":["xv6","mit"],"title":"MIT 6.S081 操作系统组织架构","uri":"/xv6-os-organization.zh/#进程概述"},{"categories":["notes"],"content":" 2 User/Kernel mode 切换我们是如何从 user mode 进入到 kernel mode 的？ 例如，当 ls 程序运行时，会调用 read/write 系统调用；shell 程序会调用 fork 或者 exec 系统调用，所以必须要有一张方式可以使得用户的应用程序能够将控制权以一种协同工作的方式转移到内核，这样内核才能提供相应的服务。 在 RISC-V 中，有一个专门的指令用于实现这一功能，叫做 ECALL（指令而非函数？），ECALL 接收一个数字参数，当一个用户程序想要将程序的执行控制权转移到内核，它只需要执行 ECALL 指令，并且传入一个数字。这里的数字参数代表了应用程序想要调用的 System Call。 System Call 表如下所示： c static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, [SYS_wait] sys_wait, [SYS_pipe] sys_pipe, [SYS_read] sys_read, [SYS_kill] sys_kill, [SYS_exec] sys_exec, [SYS_fstat] sys_fstat, [SYS_chdir] sys_chdir, [SYS_dup] sys_dup, [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk, [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open, [SYS_write] sys_write, [SYS_mknod] sys_mknod, [SYS_unlink] sys_unlink, [SYS_link] sys_link, [SYS_mkdir] sys_mkdir, [SYS_close] sys_close, [SYS_trace] sys_trace, }; ECALL 会跳转到内核中一个特定的、由内核控制的位置，在 Xv6 中存在一个唯一的系统调用接入点，每一次应用程序执行 ECALL 指令，应用程序都会通过这个接入点进入到内核中。例如，不论是 shell 还是其他的应用程序，当它在用户空间执行 fork 时，它并不是直接调用操作系统中对应的函数，而是调用 ECALL 指令，并将 fork 对应的数字 SYS_fork 作为参数传给 ECALL，之后再通过 ECALL 跳转到内核中。 在内核侧，有一个位于 syscall.c 的函数 syscall，每一个从用户程序发起的系统调用都会调用到这个 syscall 函数，syscall 函数会检查 ECALL 的参数，通过这个参数，内核可以知道要调用的是 fork。 假设现在要执行另外一个系统调用 exec，两个参数，用户代码会将 exec 需要的参数存放在寄存器 a0 和 a1 中，事实上这里的两个参数都是地址，并将系统调用号存放在寄存器 a7 中。 用户态中执行的 exec 系统调用并不能直接执行内核中的 exec 代码，而是要由封装好的系统调用函数执行 ECALL 指令，所以 exec 函数实际上调用的是 ECALL 指令，指令的参数代表了 exec 系统调用的索引数字，之后控制权到了 syscall 函数，syscall 函数才实际调用 exec 系统调用。 ","date":"2023-06-29","objectID":"/xv6-os-organization.zh/:2:0","series":null,"tags":["xv6","mit"],"title":"MIT 6.S081 操作系统组织架构","uri":"/xv6-os-organization.zh/#userkernel-mode-切换"},{"categories":["notes"],"content":" 3 Xv6 启动流程RISC-V 启动时，先运行一个存储于 ROM 中的 bootloader 程序 kernel.ld 来加载 xv6 kernel 到内存中，然后在 machine 模式下从 _entry 开始运行 Xv6。bootloader 将 xv6 kernel 加载到 0x80000000 的物理地址中，因为前面的地址中有 I/O 设备 在 _entry 中设置了一个初始 stack，stack0 来让 Xv6 执行 kernel/start.c。在 start 函数先在 machine 模式下做一些配置，然后通过 RISC-V 提供的 mret 指令切换到 supervisor mode，使 program counter 切换到 kernel/main.c。 main 先对一些设备和子系统进行初始化，然后调用 kernel/proc.c 中定义的 userinit 来创建第一个用户进程。这个进程执行了一个 initcode.S 的汇编程序，这个汇编程序调用了 exec 这个 system call 来执行 /init，重新进入 kernel。exec 将当前进程的内存和寄存器替换为一个新的程序（/init），当kernel执行完毕exec指定的程序后，回到 /init 进程。/init（user/init.c）创建了一个新的 console device 以文件描述符 0, 1, 2 打开，然后在 console device 中开启了一个 shell 进程，至此整个系统启动了。 ","date":"2023-06-29","objectID":"/xv6-os-organization.zh/:3:0","series":null,"tags":["xv6","mit"],"title":"MIT 6.S081 操作系统组织架构","uri":"/xv6-os-organization.zh/#xv6-启动流程"},{"categories":["tutorial"],"content":" 1 2021 版","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:1:0","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#2021-版"},{"categories":["tutorial"],"content":" 1.1 准备工作Linux 系统，我是在实验室配的主机上装了 Debian Bookworm，然后mac 通过 ssh 连接上去进行操作，宿舍里则是使用的 wsl2，里面的发行版也是 Debian Bookworm。 ","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:1:1","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#准备工作"},{"categories":["tutorial"],"content":" 1.2 开始配置 1.2.1 clone 源码在 ~/Documents/code/mit 目录下执行 git clone git://g.csail.mit.edu/xv6-labs-2021，将源码 clone 下来。并执行 git clone https://github.com/mit-pdos/xv6-riscv-book.git，这个是参考资料（即 PDF 对应的 Latex 源码） 前面 clone 下来的 repository 包含了多个分支，每个分支对应一个 Lab。 执行 cd xv6-labs-2021 \u0026\u0026 git checkout util，切换到 Lab Utilities 对应的 分支。 1.2.2 安装工具执行以下两条命令： sh $ sudo apt-get update \u0026\u0026 sudo apt-get upgrade $ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 从而安装对应工具。 ","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:1:2","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#开始配置"},{"categories":["tutorial"],"content":" 1.2 开始配置 1.2.1 clone 源码在 ~/Documents/code/mit 目录下执行 git clone git://g.csail.mit.edu/xv6-labs-2021，将源码 clone 下来。并执行 git clone https://github.com/mit-pdos/xv6-riscv-book.git，这个是参考资料（即 PDF 对应的 Latex 源码） 前面 clone 下来的 repository 包含了多个分支，每个分支对应一个 Lab。 执行 cd xv6-labs-2021 \u0026\u0026 git checkout util，切换到 Lab Utilities 对应的 分支。 1.2.2 安装工具执行以下两条命令： sh $ sudo apt-get update \u0026\u0026 sudo apt-get upgrade $ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 从而安装对应工具。 ","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:1:2","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#clone-源码"},{"categories":["tutorial"],"content":" 1.2 开始配置 1.2.1 clone 源码在 ~/Documents/code/mit 目录下执行 git clone git://g.csail.mit.edu/xv6-labs-2021，将源码 clone 下来。并执行 git clone https://github.com/mit-pdos/xv6-riscv-book.git，这个是参考资料（即 PDF 对应的 Latex 源码） 前面 clone 下来的 repository 包含了多个分支，每个分支对应一个 Lab。 执行 cd xv6-labs-2021 \u0026\u0026 git checkout util，切换到 Lab Utilities 对应的 分支。 1.2.2 安装工具执行以下两条命令： sh $ sudo apt-get update \u0026\u0026 sudo apt-get upgrade $ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 从而安装对应工具。 ","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:1:2","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#安装工具"},{"categories":["tutorial"],"content":" 1.3 开始调试这里会用到 tmux 的功能（非必需），在 util 分支下的 ~/Documents/code/mit/xv6-labs-2021 目录下，执行 make qemu-gdb， 然后先按 ctrl+b 再按 % 键，在 iterm2 的右侧创建一个新 panel，如图 我们需要修改一下源文件，在 sh.c 中，在 $56$ 行附近，void runcmd(struct cmd *cmd) 之前添加 __attribute__((noreturn)) ，这样才能正常启动系统。 右侧的 panel 也切换到上述目录，然后运行 gdb-multiarch，之后会进入 gdb 终端命令界面，执行 set architecture riscv:rv64 以调试 RISCV 架构，然后执行 target remote localhost:26000（这里端口号要看 make qemu-gdb 的输出），从而调试 QEMU 中的 xv6 系统，执行 file kernel/kernel 命令说明我们要调试 kernel/kerel.c 编译生成的可执行文件 kernel。 我们可以看一下 kernel.asm 的内容，如下图： 然后回到 GDB 对应的 panel，然后执行 b _entry，于是在 _entry 这里打了个断点。 说明我们调试 xv6 没什么问题了，亦说明环境已经配置好了。 之后，为了方便起见，我们可以在当前目录创建 .gdbinit，从而使得每次启动 GDB 都能执行 .gdbinit 中的命令，省得我们再一遍遍敲，.gdbinit 的内容如下： sh set architecture riscv:rv64 target remote localhost:26000 （事实上后面的实验目录中是有写好的 .gdbinit 文件的，不需要我们手动创建，但是需要修改 ~/.config/gdb/gdbinit） 然后在 ~/.config/gdb/gdbinit 文件中追加一行，内容为 add-auto-load-safe-path /home/zwyyy/Documents/code/mit/xv6-labs-2021/.gdbinit。 之后就能直接 gdb-multiarch 调试 xv6 了。 调试 Xv6 时，优先使用 make CPUS:=1 qemu-gdb 来进行调试，这样会方便一些。 ","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:1:3","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#开始调试"},{"categories":["tutorial"],"content":" 1.4 调试 trap 时无法跳转到 trampoline.S 的解决办法有两个方案： 参照 该方案 自行编译工具链； 停在 ecall 之后，再在 $\\text{0x3ffffff000}$ 处打上断点，即 stvec 寄存器保存的地址，该地址是 trampoline.S 的起始地址。 ","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:1:4","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#调试-trap-时无法跳转到-trampolines-的解决办法"},{"categories":["tutorial"],"content":" 2 2020 版","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:2:0","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#2020-版"},{"categories":["tutorial"],"content":" 2.1 准备工作2020 版的环境配置起来似乎比 21 版要复杂一些，因此我这里直接创建了个 docker 容器运行 debian，来搭建 2020 版的实验环境。 首先执行 docker pull debian 从 Docker Hub 拉取 debian 的镜像，然后执行 docker run --name mdeb -v /home/zwyyy/docker/mdeb/Documents:/home/zwyyy/Documents -it debian，这是将本地的 /home/zwyyy/docker/mdeb/Documents 目录与容器的 /home/zwyyy/Documents 目录映射起来了。 之后我们便进入了容器的终端，先执行 apt update \u0026\u0026 apt install ca-certificates 更新源，再执行 apt install vim fish sudo 以安装工具，之后执行 useradd zwyyy 和 usermod -aG sudo zwyyy，以创建用户 zwyyy 并将用户 zwyyy 添加到 sudo 用户组。 之后，我们执行 su zwyyy 将用户从 sudo 切换到 zwyyy 来执行后续命令，执行 sudo vim /etc/apt/sources.list，将文件修改为以下内容来更新软件源： sh deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware # # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware # deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware 执行 sudo apt update，并在 /home 目录下执行 sudo chown -R zwyyy:zwyyy zwyyy 将目录 zwyyy 的所有者修改为 zwyyy，并将所属用户组修改为 zwyyy。 还需要配置语言环境，执行 sudo apt install dialog locales，然后执行 sudo dpkg-reconfigure locales，输入 $97$，选择区域为 en_US.UTF-8 UTR-8，然后执行 sudo update-locale LANG=en_US.UTF-8。 注意不要手动安装 apt-utils，不安装该软件只是有警告，安装了就出现 error 了。 ","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:2:1","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#准备工作-1"},{"categories":["tutorial"],"content":" 2.2 安装环境参照 课程网站 的教程，开始安装环境。 首先执行 sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 以安装工具。 之后参照 vscode 使用 clangd，安装 lldb 系列工具，以搭配 vscode 使用。 值的一提的是，vscode 安装好 docker 插件之后，可以连接通过 vscode remote 连接的远程主机中的 container。 安装完工具之后，我们需要卸载 qemu-system-misc，这是因为 qemu-system-misc 的更新导致它与 Xv6 内核不兼容，因此我们需要安装旧版，首先执行 sudo apt-get remove qemu-system-misc，卸载 qemu-system-misc，由于我的镜像使用的 debian 12，因此需要手动编译安装 qemu，执行如下命令： sh wget https://download.qemu.org/qemu-5.1.0.tar.xz tar xf qemu-5.1.0.tar.xz cd qemu-5.1.0 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\"riscv64-softmmu\" make sudo make install cd .. 之后，可以参照 Lab: Xv6 and Unix utilities 的指导，执行 make qemu，如果成功进入 Xv6 的 shell，就说明环境已经配置好了，调试可以参照 2021 的部分。 ","date":"2023-06-28","objectID":"/mit6.s081-env-configuration.zh/:2:2","series":null,"tags":["trick"],"title":"MIT 6.s081 实验环境搭建","uri":"/mit6.s081-env-configuration.zh/#安装环境"},{"categories":["notes"],"content":" 1 异常控制流简介从给处理器上电起，直到断电，程序计数器（PC）假设一个值的序列： $$ a_0, a_1, \\cdots, a_{n - 1}$$ 每个 $a_k$ 是某个相应的指令 $I_k$ 的地址，每次从 $a_k$ 到 $a_{k + 1}$ 的过渡称为控制转移（control transfer）。这样的控制转移序列叫做处理器的控制流（flow of control 或 control flow）。 最简单的控制流是一个平滑的序列，即 $I_k$ 和 $I_{k + 1}$ 在内存中是连续的。 现代系统通过使控制流发生突变来应对系统状态的变化。一般而言我们把这些突变称为异常控制流（Exceptional Control Flow, ECF）。 例如当前程序在执行地址 $a_k$ 对应的指令 $I_k$，正常情况下，下一个指令应该是应该是地址 $a_{k + 1}$ 对应的指令 $I_{a_{k + 1}}$，但是由于发生了 page fault，它转去执行内核态的缺页异常处理程序，对应指令 $I_j$，执行完 $I_j$ 之后，它又回来执行 $I_k$。 For example, at the hardware level, events detected by the hardware trigger abrupt control transfers to exception handlers. At the operating systems level, the kernel transfers control from one user process to another via context switches. At the application level, a process can send a signal to another process that abruptly transfers control to a signal handler in the recipient. ECF 与进程管理直接相关 ","date":"2023-06-27","objectID":"/exceptional_control_flow.zh/:1:0","series":null,"tags":["csapp"],"title":"异常控制流（Exceptional Control Flow, ECF）","uri":"/exceptional_control_flow.zh/#异常控制流简介"},{"categories":["notes"],"content":" 2 异常（Exception）系统给所有可能的每种类型的异常都分配了一个唯一的非负整数的异常号（exception number）。其中一些号码是由处理器的设计者分配的，其它号码则是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。 CPU 设计者分配的：devided by zero、page fault、断点、算术运算溢出、内存访问非法； 内核设计者分配额：系统调用和来自外部 I/O 设备的信号。 在系统启动（计算机重启或者上电）时，操作系统分配和初始化一张被称为异常表（exception table）的跳转表，使得 table entry $k$ 包含异常 $k$ 的处理程序的地址。 异常表的起始地址存放在一个叫做异常表基址寄存器（exception table base register）的特殊 CPU 寄存器中，异常号 $k$ 可以看作是异常表的索引。 异常可以分为四类： ","date":"2023-06-27","objectID":"/exceptional_control_flow.zh/:2:0","series":null,"tags":["csapp"],"title":"异常控制流（Exceptional Control Flow, ECF）","uri":"/exceptional_control_flow.zh/#异常exception"},{"categories":["notes"],"content":" 2.1 中断（interrupt）中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。 硬件中断不是由任何一条专门的指令造成的，从这个意义上说它是异步的。硬件中断的异常处理程序常常被称为中断处理程序（interrupt handler）。 ","date":"2023-06-27","objectID":"/exceptional_control_flow.zh/:2:1","series":null,"tags":["csapp"],"title":"异常控制流（Exceptional Control Flow, ECF）","uri":"/exceptional_control_flow.zh/#中断interrupt"},{"categories":["notes"],"content":" 2.2 陷阱（trap）","date":"2023-06-27","objectID":"/exceptional_control_flow.zh/:2:2","series":null,"tags":["csapp"],"title":"异常控制流（Exceptional Control Flow, ECF）","uri":"/exceptional_control_flow.zh/#陷阱trap"},{"categories":["notes"],"content":" 2.3 故障（fault）","date":"2023-06-27","objectID":"/exceptional_control_flow.zh/:2:3","series":null,"tags":["csapp"],"title":"异常控制流（Exceptional Control Flow, ECF）","uri":"/exceptional_control_flow.zh/#故障fault"},{"categories":["notes"],"content":" 2.4 终止（abort）","date":"2023-06-27","objectID":"/exceptional_control_flow.zh/:2:4","series":null,"tags":["csapp"],"title":"异常控制流（Exceptional Control Flow, ECF）","uri":"/exceptional_control_flow.zh/#终止abort"},{"categories":["notes"],"content":" 1 自顶向下的 2-3-4 树","date":"2023-06-26","objectID":"/red-black-tree.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"红黑树","uri":"/red-black-tree.zh/#自顶向下的-2-3-4-树"},{"categories":["notes"],"content":" 1.1 插入结点2-3-4 树的插入算法，简而言之，就是在往下查找应该将待插入的 new_key 插入到何处的时候，一旦碰到 4- 结点，就将 4- 结点中间的 key 上溢，剩下的两个 key 作为两个 2- 结点，这个上溢的过程也是递归的，可以理解为向原先 4- 结点的父结点插入 4- 结点中间的这个 key，4- 结点剩下的部分作为两个 2- 结点。我们的这个分解算法，保证了4- 结点的父结点不会是 4- 结点。（这里可以用数学归纳法给出证明） 这样处理到最后，我们的 new_key 要插入的结点一定是 2- 结点或者 3- 结点，因此，我们可以直接插入。 要实现这个插入算法，我们需要： 将 4- 结点表示为由三个 2- 结点组成的一个平衡的子树，根结点和两个子结点都用 red link 连接； 在向下的过程中分解所有 4- 结点并进行颜色转换； 和插入操作一样，在向上的过程中用旋转将 4- 结点配平； 但实际上，我们只要移动 put 方法中的三行代码就能由 2-3 树对应的红黑树操作转移到 2-3-4 树对应的红黑树操作；即将 FlipColors 语句（以及 if 判断）移动到 nullptr 测试之后，递归调用之前，如下： cpp void Put(int key, int val) { root_ = Put(key, val, root_); root_-\u003ecolor_ = kBlack; // 根结点的颜色一定是黑色！ } auto Put(int key, int val, Node *h) -\u003e Node * { // h 表示我们往以 h 为根结点的树中插入结点 if (h == nullptr) { return new Node(key, val, 1, kRed); } if (isRed(h-\u003eleft_) \u0026\u0026 isRed(h-\u003eright_)) { // 左右子结点都是红色，翻转颜色 // 即碰到 4- 结点就分解成两个 2- 结点 FlipColors(h); } if (key \u003c h-\u003ekey_) { h-\u003eleft_ = Put(key, val, h-\u003eleft_); } else if (key \u003e h-\u003ekey_) { h-\u003eright_ = Put(key, val, h-\u003eright_); } else { h-\u003eval_ = val; } if (!isRed(h-\u003eleft_) \u0026\u0026 isRed(h-\u003eright_)) { // 只有右子结点是红色 h = RotateLeft(h); } if (isRed(h-\u003eleft_) \u0026\u0026 isRed(h-\u003eleft_-\u003eleft_)) { // 左子结点和左子结点的左子结点都是红色 h = RotateRight(h-\u003eright_); } h-\u003ecnt_ = h-\u003eleft_-\u003ecnt_ + h-\u003eright_-\u003ecnt_ + 1; return h; } ","date":"2023-06-26","objectID":"/red-black-tree.zh/:1:1","series":null,"tags":["data structure and algorithms"],"title":"红黑树","uri":"/red-black-tree.zh/#插入结点"},{"categories":["notes"],"content":" 2 红黑树","date":"2023-06-26","objectID":"/red-black-tree.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"红黑树","uri":"/red-black-tree.zh/#红黑树"},{"categories":["notes"],"content":" 2.1 性质红黑树可以说是由 2-3-4 树衍生而来，一棵合法的红黑树必须遵循以下四条性质： 结点为红色或者黑色； null 结点（叶子结点的子结点）为黑色； 红色结点的子结点为黑色（即不存在两个连续的红色结点）； 从根结点到 null 结点的每条路径上的黑色结点相同； 根结点一定是黑色； 这条性质要求完成插入操作后若根节点为红色则将其染黑，但由于将根节点染黑的操作也可以延迟至删除操作时进行，因此，该条性质并非必须满足。 红黑树的这几条性质从 2-3-4树的角度是很好理解的：红黑树的黑色结点和它的红色子结点构成了 2-3-4 树中的 3- 结点或者 4- 结点，如果黑色结点的两个子结点都是黑色结点，那么该结点对应 2-3-4 树中的 2- 结点。 红黑树中黑色结点的个数 = 2-3-4 树的结点数。 ","date":"2023-06-26","objectID":"/red-black-tree.zh/:2:1","series":null,"tags":["data structure and algorithms"],"title":"红黑树","uri":"/red-black-tree.zh/#性质"},{"categories":["notes"],"content":" 2.2 插入结点红黑树的插入过程还是可以从上述的 2-3-4 树去理解，首先，我们必定是把要插入的结点先标记为红色，这样有不小可能不会影响红黑树对应的 2-3-4 树的平衡。 case 1. 如果要插入的结点是作为根结点的，那么我们将它染为黑色； case 2. 如果要插入的结点是作为 3- 结点的子结点： case 2.1. 作为黑色结点的子结点插入，那么不会破坏红黑树的平衡性，直接插入即可； case 2.2. 如果作为红色结点的子结点插入，即父结点是红色，祖父结点是黑色，并且祖父结点只有一个红色子结点，那么，又可以分为 LL 型、LR 型、RL 型、 RR 型； 类似 AVL 树，LL 型需要一次右旋，RR 型需要一次左旋，LR 型需要一次左旋（对 h-\u003eleft_），一次右旋（对 h），RL 型需要一次右旋（对 h-\u003eright_），然后一次左旋（对 h） case 3. 如果要插入的结点是作为 4- 结点的子结点，即父结点是红色结点，祖父结点是黑色结点，并且祖父结点有两个红色子结点； 整体上来说，是需要做一个 FlipColors 的操作，即将祖父结点、祖父结点的两个子结点这三个结点的颜色翻转，翻转之后，相当于祖父结点的祖父结点被插入了一个红色结点，因此，可以再次转换到 case 1 或者 case 2 或者 case 3，通过递归操作进行处理。 ","date":"2023-06-26","objectID":"/red-black-tree.zh/:2:2","series":null,"tags":["data structure and algorithms"],"title":"红黑树","uri":"/red-black-tree.zh/#插入结点-1"},{"categories":["notes"],"content":" 2.3 删除结点红黑树的删除过程还是可以从 2-3-4 树去理解。B 树中如果要删除结点，那么都是转换成对它的前驱或者后继结点的删除，即将待删除结点的 h 的 key-value 修改为它的前驱或者后继结点的 key-value。 因此，我们只需要讨论叶子结点就好了，并且我们只讨论后继结点。这里的叶子结点，是指存在子结点为 null 结点的结点。 如果当前结点没有后继结点，那么对当前结点执行右旋即可。 那么，对叶子结点的删除，可以分为对红色结点的删除和对黑色结点的删除两种情况： 删除红色叶子结点 h，可以直接删除，不影响平衡； 删除黑色叶子结点 h：（作为后继结点的 h 不会存在黑色子结点） case 1. 有两个红色子结点的黑色结点，与后继结点的定义矛盾，转换为 case 1； case 2. 有一个红色子结点的黑色结点（另一个子结点是 null 结点）； case 2.1. 如果右子结点是红色，对 h 执行左旋，然后删除 h； case 2.2. 如果左子结点是红色，对 h 执行右旋，然后删除 h； case 2.3. 如果 h 是黑色结点并且没有红色子结点： a. h 是根结点，那么直接删除； b. h 的兄弟结点是黑色； 1）兄弟结点有红色子结点，删除之后对 h 的父结点进行旋转操作，即可满足平衡；（其实也有 LL，LR，RL，RR）的区分； 2）兄弟结点没有红色子结点，如果父结点是红色，这个好处理，父结点向下与 h 的兄弟结点合并成一个 3- 结点；否则就需要执行递归下溢。 c. h 的兄弟结点是红色；对父结点进行旋转，使它变成兄弟结点是黑色，父结点是红色的情况。 ","date":"2023-06-26","objectID":"/red-black-tree.zh/:2:3","series":null,"tags":["data structure and algorithms"],"title":"红黑树","uri":"/red-black-tree.zh/#删除结点"},{"categories":["notes"],"content":" 3 总结这个基于 2-3-4 树的红黑树手写实现，后面有空再写吧。。。主要是联系 2-3-4 树，来思考红黑树的插入与删除操作的平衡调整的本质。 ","date":"2023-06-26","objectID":"/red-black-tree.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"红黑树","uri":"/red-black-tree.zh/#总结"},{"categories":["notes"],"content":" 4 参考红黑树 - OI Wiki 【喵的算法课】红黑树 删除【12期】 ","date":"2023-06-26","objectID":"/red-black-tree.zh/:4:0","series":null,"tags":["data structure and algorithms"],"title":"红黑树","uri":"/red-black-tree.zh/#参考"},{"categories":["notes"],"content":" 1 简介红黑树是平衡二叉查找树的一种，前面我们提到，非平衡的 BST，在只有随机插入和查询的情况下，时间复杂度是 $O(\\log n)$ 的，然而，如果同时存在随机插入和随机删除，那么时间复杂度会退化到 $O(\\sqrt n)$，这是我们无法接受的。 红黑树在插入和删除时，会维持树的平衡，即保证树的高度在 $[\\log n, \\log(n + 1)]$，理论上极端情况可能树高最大会到达 $2 * \\log n$，实际上很难遇到（尽管这样，还是保证了 $O(\\log n)$ 的增删查改时间复杂度。 红黑树其实是 2-3 查找树或者 2-3-4 查找树的一种二叉树的实现方式。其中基于 2-3 树实现的红黑树被称为左倾红黑树（Left-Leaning Red-Black Trees, LLRB），基于 2-3-4 树实现的就是普通的红黑树，左倾红黑树实现起来比红黑树更简单一些（《算法 第四版》里面也主要讲的左倾红黑树），因此先讲左倾红黑树。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#简介"},{"categories":["notes"],"content":" 2 2-3 查找树在普通的二叉树中，非叶子结点可以有一个或者两个子结点，如果没有子结点，那么就是叶子结点。 而 2-3 查找树的限制要严格很多。我们将拥有一个 key 和两个链接 的结点称为 2- 结点，拥有两个 key 和三个链接的结点称为 3- 结点。 2- 结点含有一个 key，两个 link； 3- 结点含有两个不同的 key，三个 link。 3- 结点含有两个 key（$key_1 \u003c key_2$），三个链接，左链接指向 2-3 树中的 key 都小于 $key_1$，中间链接指向的 2-3 树中的 key 都满足 $key_1 \u003c key \u003c key_2$，右链接指向的 2-3 树中的 key 都大于 $key_2$。 2-3 查找树只能由 2- 结点或者 3- 结点组成（这里不统计空结点（null）），可以看到 2-3 查找树的限制是非常严格的，这也让它可以拥有一些非常理想的性质。 一颗完美平衡的 2-3 查找树中所有空结点（null）到根结点的距离都应该是相同的，后续我们都使用 2-3 树指代一颗完美平衡的 2-3 查找树。（其他情况下表示的可能是一种更一般的结构）。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#2-3-查找树"},{"categories":["notes"],"content":" 2.1 查找将二叉查找树的查找算法一般化就能得到 2-3 树的查找算法。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:2:1","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#查找"},{"categories":["notes"],"content":" 2.2 向 2- 结点中插入新 key首先进行一次未命中的查找，如果未命中的查找结束于一个 2- 结点，那么我们往这个 2- 结点中插入新的 key，使这个 2- 结点变成 3- 结点就好了，不影响所有结点的树高。 插入 key 时，由于 2-3 树的性质，我们必定是在叶子结点处执行插入。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:2:2","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#向-2--结点中插入新-key"},{"categories":["notes"],"content":" 2.3 向 3- 结点中插入新的 key 2.3.1 1. 向一个只含有一个 3- 结点的树中插入新 key先组成一个临时的 4- 结点，然后将 4- 结点中的三个 key 中间的 key 上移作为剩下的 3- 结点的父结点。如下图所示： 注意到，这样操作之后，2-3 树的高度 $+1$ 了，所有原来位置的结点高度均 $+1$。 2.3.2 2. 向一个父结点为 2- 结点的 3- 结点中插入新 key还是先组成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，将这个 key 插入到本来为 2-结点的父结点组成 3- 结点，树的高度不变，如下图所示： 2.3.3 3. 向一个父结点为 3- 结点的 3- 结点中插入新 key还是先组成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，即将这个 key 插入到父结点中：此时情形就可以转化成 $1$ 或者 $2$ 或者 $3$。 如果转换成 $3$，那么就相当于是递归操作。 因此，对于 $3$ 这一插入类型，我们可以从递归的角度去理解它，递归终止条件就是切换到情形 $1$ 或者 $2$，每次递归中执行的操作就是构成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，插入到父结点中。 如下图所示： 从插入操作我们可以分析得出，对 2-3 树来说，插入操作不会破坏它的完美平衡！要么整棵树的高度不变，要么整颗树的高度 $+1$，因此，根结点到所有 null 结点的长度依旧是相同的。 2-3 树的树高介于 $\\log n$ 和 $\\log_3 n$ 之间。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:2:3","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#向-3--结点中插入新的-key"},{"categories":["notes"],"content":" 2.3 向 3- 结点中插入新的 key 2.3.1 1. 向一个只含有一个 3- 结点的树中插入新 key先组成一个临时的 4- 结点，然后将 4- 结点中的三个 key 中间的 key 上移作为剩下的 3- 结点的父结点。如下图所示： 注意到，这样操作之后，2-3 树的高度 $+1$ 了，所有原来位置的结点高度均 $+1$。 2.3.2 2. 向一个父结点为 2- 结点的 3- 结点中插入新 key还是先组成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，将这个 key 插入到本来为 2-结点的父结点组成 3- 结点，树的高度不变，如下图所示： 2.3.3 3. 向一个父结点为 3- 结点的 3- 结点中插入新 key还是先组成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，即将这个 key 插入到父结点中：此时情形就可以转化成 $1$ 或者 $2$ 或者 $3$。 如果转换成 $3$，那么就相当于是递归操作。 因此，对于 $3$ 这一插入类型，我们可以从递归的角度去理解它，递归终止条件就是切换到情形 $1$ 或者 $2$，每次递归中执行的操作就是构成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，插入到父结点中。 如下图所示： 从插入操作我们可以分析得出，对 2-3 树来说，插入操作不会破坏它的完美平衡！要么整棵树的高度不变，要么整颗树的高度 $+1$，因此，根结点到所有 null 结点的长度依旧是相同的。 2-3 树的树高介于 $\\log n$ 和 $\\log_3 n$ 之间。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:2:3","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#1-向一个只含有一个-3--结点的树中插入新-key"},{"categories":["notes"],"content":" 2.3 向 3- 结点中插入新的 key 2.3.1 1. 向一个只含有一个 3- 结点的树中插入新 key先组成一个临时的 4- 结点，然后将 4- 结点中的三个 key 中间的 key 上移作为剩下的 3- 结点的父结点。如下图所示： 注意到，这样操作之后，2-3 树的高度 $+1$ 了，所有原来位置的结点高度均 $+1$。 2.3.2 2. 向一个父结点为 2- 结点的 3- 结点中插入新 key还是先组成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，将这个 key 插入到本来为 2-结点的父结点组成 3- 结点，树的高度不变，如下图所示： 2.3.3 3. 向一个父结点为 3- 结点的 3- 结点中插入新 key还是先组成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，即将这个 key 插入到父结点中：此时情形就可以转化成 $1$ 或者 $2$ 或者 $3$。 如果转换成 $3$，那么就相当于是递归操作。 因此，对于 $3$ 这一插入类型，我们可以从递归的角度去理解它，递归终止条件就是切换到情形 $1$ 或者 $2$，每次递归中执行的操作就是构成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，插入到父结点中。 如下图所示： 从插入操作我们可以分析得出，对 2-3 树来说，插入操作不会破坏它的完美平衡！要么整棵树的高度不变，要么整颗树的高度 $+1$，因此，根结点到所有 null 结点的长度依旧是相同的。 2-3 树的树高介于 $\\log n$ 和 $\\log_3 n$ 之间。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:2:3","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#2-向一个父结点为-2--结点的-3--结点中插入新-key"},{"categories":["notes"],"content":" 2.3 向 3- 结点中插入新的 key 2.3.1 1. 向一个只含有一个 3- 结点的树中插入新 key先组成一个临时的 4- 结点，然后将 4- 结点中的三个 key 中间的 key 上移作为剩下的 3- 结点的父结点。如下图所示： 注意到，这样操作之后，2-3 树的高度 $+1$ 了，所有原来位置的结点高度均 $+1$。 2.3.2 2. 向一个父结点为 2- 结点的 3- 结点中插入新 key还是先组成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，将这个 key 插入到本来为 2-结点的父结点组成 3- 结点，树的高度不变，如下图所示： 2.3.3 3. 向一个父结点为 3- 结点的 3- 结点中插入新 key还是先组成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，即将这个 key 插入到父结点中：此时情形就可以转化成 $1$ 或者 $2$ 或者 $3$。 如果转换成 $3$，那么就相当于是递归操作。 因此，对于 $3$ 这一插入类型，我们可以从递归的角度去理解它，递归终止条件就是切换到情形 $1$ 或者 $2$，每次递归中执行的操作就是构成一个临时的 4- 结点，然后将 4- 结点的三个 key 中中间的 key 上移，插入到父结点中。 如下图所示： 从插入操作我们可以分析得出，对 2-3 树来说，插入操作不会破坏它的完美平衡！要么整棵树的高度不变，要么整颗树的高度 $+1$，因此，根结点到所有 null 结点的长度依旧是相同的。 2-3 树的树高介于 $\\log n$ 和 $\\log_3 n$ 之间。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:2:3","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#3-向一个父结点为-3--结点的-3--结点中插入新-key"},{"categories":["notes"],"content":" 2.4 2-3 树的删除操作要学习 LLRB 的删除操作，我们先学习 2-3 树的删除最小的 key 的操作： 如果这个最小的 key 位于树底部的 3- 结点中，那么删除很简单； 但如果要删除的 key 是一个 2- 结点，那么麻烦了，假设我们直接从 2- 结点删除这个 key，那么就剩下了一个 null 结点，这会破坏 2-3 树的完美平衡性，因此，我们需要想办法保证，要删除的最小 key 一定在 3- 结点中，哪怕它原来在 2- 结点中，我们也让它变成 3- 结点。为了保证这一点，我们沿着左 link 向下进行变换，确保当前结点不是 2- 结点（可能是 3- 结点或者临时的 4- 结点）。 首先，根结点可能有两种情况，如果根结点是 2- 结点，并且它两个子结点都是 2- 结点，那么我们需要将这三个结点合并成一个临时的 4- 结点；否则，我们需要保证根结点的左子结点不是 2- 结点，例如如果左子结点是 2- 结点而右子结点是 3- 结点，那么我们可以从右子结点处“借”一个结点给左子结点。 在沿着左链接往下移动的过程中，保证以下情形之一成立： a. 如果当前结点的左子结点不是 2- 结点，完成，继续向左下遍历； b. 如果当前结点的左子结点是 2- 结点而左子结点的最近的右兄弟结点不是 2- 结点，那么我们从这个兄弟结点处“借”一个结点给左子结点，如下图所示： 我们可以看到，这个借的本质是 左子结点往父结点借，父结点往左子结点的右兄弟结点处借。 c. 如果当前结点的左子结点和左子结点右边的最近的亲兄弟结点不是 2- 结点，由于这里我们有这个父结点一定不是 2- 结点，因此，我们将这个父结点的最小的 key，左子结点，左子结点的最近的右兄弟结点，合并成一个临时的 4- 结点。 在遍历的过程中执行这个过程，最后能够得到一个含有最小 key 的 3- 结点或者 4- 结点，然后我们就可以直接从中将其删除，将 3- 结点变为 2- 结点，或者将 4- 结点变为 3- 结点。然后我们再回头向上分解所有临时的 4- 结点。 2-3 树对应到 LLRB，就是要保证在遍历的时候，当前结点是红色，或者当前结点的左子结点是红色。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:2:4","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#2-3-树的删除操作"},{"categories":["notes"],"content":" 2.5 总结直接实现 2-3 树比较复杂，执行插入、删除操作时要维护和变换的信息比较多，可能性能还不如普通的二叉查找树。 尽管我们可以用不同的数据类型表示 2- 结点和 3- 结点并写出变换所需的代码，但用这种直白的表示方法实现大多数的操作并不方便，因为需要处理的情况实在太多。我们需要维护两种不同类型的结点，将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:2:5","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#总结"},{"categories":["notes"],"content":" 3 左倾红黑树（LLRB）红黑树的基本思想是用标准的二叉查找树（结点都是 2- 结点），以及一些额外的信息（用来替换 3- 结点）来表示 2-3 树。 我们将树中的 link 分为两类，一类是 red link 将两个 2- 结点连接起来，就构成了一个 3- 结点，合法的 LLRB 要求只有父结点和左子结点之间的 link 才能是红色的；另一类是 black link 将两个 2- 结点连接起来，对应 2-3 树中的普通 link。 准确说，我们将 3- 结点表示为由一个左斜的 red link 相连的两个 2- 结点，如所示，我们可以直接使用标准 BST 的 get 方法。 LLRB 的另一种定义是含有 red 和 black link 并且满足下列条件的二叉查找树： red link 均为左斜 link； 没有一个结点同时和两条 red link 相连； 该树是完美黑色平衡的，即任意 null 结点到根结点的路径上的 black link 数量相同。 如果我们将一颗 LLRB 中的 red link 画平，那么所有 null 结点到根结点的距离都将是相同的。 由于每个结点都只有一个父结点，因此对每个结点来说，从它的父结点到它自身的 link 是唯一的，因此我们可以将 link 的颜色保存再表示结点的类 Node 的布尔成员变量 color 中。我们规定 null link 是黑色的 cpp const bool kRed = true; const bool kBlack = false; class Node { private: int key_; int val_; int cnt_; bool color_; Node *left_; Node *right_; public: Node(int key, int val, int cnt, bool color) : key_(key), val_(val), cnt_(cnt), color_(color), left_(nullptr), right_(nullptr) { } private: bool isRed(Node *x) { if (x == nullptr) { return false; } return x-\u003ecolor_ == kRed; } }; ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#左倾红黑树llrb"},{"categories":["notes"],"content":" 3.1 LLRB 的旋转当我们执行插入结点到 LLRB 中或者删除 LLRB 中的结点时，可能会出现操作后的树不满足 LLRB 的限制条件的情况。这时候，我们就需要通过旋转操作使这棵树重新满足 LLRB 的约束条件。 旋转可以分为左旋和右旋。 假设我们说左旋结点 E，即结点 E 绕它的右子结点 S 向左（即逆时针）旋转，使得 E 成为 S 的左儿子。由于此时 S 可能会有三个子结点，因此，我们要让 S 原来的左子结点变成新位置的 E 的右子结点； 假设我们说右旋结点 S，即结点 S 绕它的左子结点 E 向右（即顺时针）旋转，使得 S 成为 E 的右儿子，此时 E 可能会有三个子结点，因此，我们要让 E 原来的右子结点变成新位置的 S 的左子结点。 上面说的是普通的二叉树的左旋和右旋，对于红黑树来说，我们在进行旋转时，还要进行染色操作。即 E 和 S 的颜色要进行互换： 如下图所示： C++ 的实现代码如下，以左旋为例，之前我们说了，E 和 S 的颜色要进行互换，但是，S 必然是 RED 才会触发旋转操作，因此我们执行 rson-\u003ecolor_ = node-\u003ecolor_; 后，直接将 node-\u003ecolor_ 置为了 kRed。 cpp auto RotateLeft(Node *node) { auto *rson = node-\u003eright_; node-\u003eright_ = rson-\u003eleft_; rson-\u003eleft_ = node; rson-\u003ecolor_ = node-\u003ecolor_; node-\u003ecolor_ = kRed; return rson; } auto RotateRight(Node *node) { auto *lson = node-\u003eleft_; node-\u003eleft_ = lson-\u003eright_; lson-\u003eright_ = node; lson-\u003ecolor_ = node-\u003ecolor_; node-\u003ecolor_ = kRed; return lson; } 旋转操作可以完美保持 LLRB 的两个重要性质：有序性和完美平衡性。 ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:1","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#llrb-的旋转"},{"categories":["notes"],"content":" 3.2 LLRB 的插入操作我们在执行插入操作时，被插入的结点总是与父结点使用 red link 来连接，这样才有可能维护 LLRB 的完美平衡性。（与 2-3 树对应） 3.2.1 1. 向只有一个 2- 结点的树中插入新 key这里我们考虑的是树中只有一个结点 h的情况，然后推广到一般情况： 如果 key \u003c h-\u003ekey_，那么这个结点作为左子结点，新的 LLRB 和 单个 3- 结点完全等价，不会破坏 LLRB 的完美平衡； 否则，key \u003e h-\u003ekey_，出现了右斜 link 为 red link 的情况，因此我们需要对父结点执行一次左旋，即 root = RotateLeft(root);。 3.2.2 2. 向树底部的 2- 结点插入新 key与情况 1. 其实是一样的，如下图： 3.2.3 3. 向一个双 key 树（即 3- 结点）中插入新 key先考虑只有两个结点的情况： a. 新 key 大于原来 3- 结点中的两个 key，那么这个key 插入作为根结点的右子结点；如果此时我们将两个 link 的颜色都由红染黑，那么就得到了一个由 3 个结点组成、高为 2 的完美平衡的 2-3 树，也就是完美平衡的 LLRB； cpp void FlipColors(Node *x) { x-\u003ecolor_ = kRed; x-\u003eleft_-\u003ecolor_ = kBlack; x-\u003eright_-\u003ecolor_ = kBlack; } b. 新 key 小于原来 3- 结点中的两个 key，那么新 key 插入作为左子结点的左子结点，那么就出现了两个连续的 red link，此时我们只需要将根结点右旋，即可转化为情况 a； c. 新 key 介于原来 3- 结点的两个 key 中间，那么新 key 插入作为左子结点的右子结点，此时存在右倾的 red link，我们对根结点的左子结点执行左旋操作，则转化为情形 b，情形 b 可以再转化为情形 a。 注意情况 a. 中，结点 b 已经是根结点了，所以我们将 b 染成 黑色，否则需要向上传递（即将 b 染成红色），见后续对插入的讨论。 3.2.4 4. 向树底部的 3- 结点插入新键假设我们需要在树底部的一个 3- 结点下插入一个新结点，那么 a. b. c. 三种情况都可能会出现，在经过一次或者两次旋转之后，都会转换到情形 a.，只是结点 “b” 不再是根结点了，事实上 “b” 本来应该是红色才对，只是情形 a. 中，“b” 是根结点，因此最后染成了黑色。 在 4. 中，结点 “b” 被染成了红色，相当于在 “b” 的父结点中插入了一个红色结点，这就递归到了情形 1. 或者 情形2. 或者情形 3.。即我们相当于在一级一级地往上传递 red link，直到可以满足 LLRB 的要求。 在一级一级地往上传递 red link 时，即在沿着插入点到根结点的路径向上移动时经过的每个结点中顺序完成以下操作，我们就能完成插入操作： 如果结点 x 的左子结点是红色的而右子结点是黑色的，对 x 执行左旋操作； 如果结点 x 的左子结点是红色的，并且左子结点的左子结点也是红色的，对 x 执行 右旋操作； 如果结点 x 的左子结点和右子结点都是红色的，对 x 执行 FlipColors 操作； ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:2","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#llrb-的插入操作"},{"categories":["notes"],"content":" 3.2 LLRB 的插入操作我们在执行插入操作时，被插入的结点总是与父结点使用 red link 来连接，这样才有可能维护 LLRB 的完美平衡性。（与 2-3 树对应） 3.2.1 1. 向只有一个 2- 结点的树中插入新 key这里我们考虑的是树中只有一个结点 h的情况，然后推广到一般情况： 如果 key \u003c h-\u003ekey_，那么这个结点作为左子结点，新的 LLRB 和 单个 3- 结点完全等价，不会破坏 LLRB 的完美平衡； 否则，key \u003e h-\u003ekey_，出现了右斜 link 为 red link 的情况，因此我们需要对父结点执行一次左旋，即 root = RotateLeft(root);。 3.2.2 2. 向树底部的 2- 结点插入新 key与情况 1. 其实是一样的，如下图： 3.2.3 3. 向一个双 key 树（即 3- 结点）中插入新 key先考虑只有两个结点的情况： a. 新 key 大于原来 3- 结点中的两个 key，那么这个key 插入作为根结点的右子结点；如果此时我们将两个 link 的颜色都由红染黑，那么就得到了一个由 3 个结点组成、高为 2 的完美平衡的 2-3 树，也就是完美平衡的 LLRB； cpp void FlipColors(Node *x) { x-\u003ecolor_ = kRed; x-\u003eleft_-\u003ecolor_ = kBlack; x-\u003eright_-\u003ecolor_ = kBlack; } b. 新 key 小于原来 3- 结点中的两个 key，那么新 key 插入作为左子结点的左子结点，那么就出现了两个连续的 red link，此时我们只需要将根结点右旋，即可转化为情况 a； c. 新 key 介于原来 3- 结点的两个 key 中间，那么新 key 插入作为左子结点的右子结点，此时存在右倾的 red link，我们对根结点的左子结点执行左旋操作，则转化为情形 b，情形 b 可以再转化为情形 a。 注意情况 a. 中，结点 b 已经是根结点了，所以我们将 b 染成 黑色，否则需要向上传递（即将 b 染成红色），见后续对插入的讨论。 3.2.4 4. 向树底部的 3- 结点插入新键假设我们需要在树底部的一个 3- 结点下插入一个新结点，那么 a. b. c. 三种情况都可能会出现，在经过一次或者两次旋转之后，都会转换到情形 a.，只是结点 “b” 不再是根结点了，事实上 “b” 本来应该是红色才对，只是情形 a. 中，“b” 是根结点，因此最后染成了黑色。 在 4. 中，结点 “b” 被染成了红色，相当于在 “b” 的父结点中插入了一个红色结点，这就递归到了情形 1. 或者 情形2. 或者情形 3.。即我们相当于在一级一级地往上传递 red link，直到可以满足 LLRB 的要求。 在一级一级地往上传递 red link 时，即在沿着插入点到根结点的路径向上移动时经过的每个结点中顺序完成以下操作，我们就能完成插入操作： 如果结点 x 的左子结点是红色的而右子结点是黑色的，对 x 执行左旋操作； 如果结点 x 的左子结点是红色的，并且左子结点的左子结点也是红色的，对 x 执行 右旋操作； 如果结点 x 的左子结点和右子结点都是红色的，对 x 执行 FlipColors 操作； ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:2","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#1-向只有一个-2--结点的树中插入新-key"},{"categories":["notes"],"content":" 3.2 LLRB 的插入操作我们在执行插入操作时，被插入的结点总是与父结点使用 red link 来连接，这样才有可能维护 LLRB 的完美平衡性。（与 2-3 树对应） 3.2.1 1. 向只有一个 2- 结点的树中插入新 key这里我们考虑的是树中只有一个结点 h的情况，然后推广到一般情况： 如果 key \u003c h-\u003ekey_，那么这个结点作为左子结点，新的 LLRB 和 单个 3- 结点完全等价，不会破坏 LLRB 的完美平衡； 否则，key \u003e h-\u003ekey_，出现了右斜 link 为 red link 的情况，因此我们需要对父结点执行一次左旋，即 root = RotateLeft(root);。 3.2.2 2. 向树底部的 2- 结点插入新 key与情况 1. 其实是一样的，如下图： 3.2.3 3. 向一个双 key 树（即 3- 结点）中插入新 key先考虑只有两个结点的情况： a. 新 key 大于原来 3- 结点中的两个 key，那么这个key 插入作为根结点的右子结点；如果此时我们将两个 link 的颜色都由红染黑，那么就得到了一个由 3 个结点组成、高为 2 的完美平衡的 2-3 树，也就是完美平衡的 LLRB； cpp void FlipColors(Node *x) { x-\u003ecolor_ = kRed; x-\u003eleft_-\u003ecolor_ = kBlack; x-\u003eright_-\u003ecolor_ = kBlack; } b. 新 key 小于原来 3- 结点中的两个 key，那么新 key 插入作为左子结点的左子结点，那么就出现了两个连续的 red link，此时我们只需要将根结点右旋，即可转化为情况 a； c. 新 key 介于原来 3- 结点的两个 key 中间，那么新 key 插入作为左子结点的右子结点，此时存在右倾的 red link，我们对根结点的左子结点执行左旋操作，则转化为情形 b，情形 b 可以再转化为情形 a。 注意情况 a. 中，结点 b 已经是根结点了，所以我们将 b 染成 黑色，否则需要向上传递（即将 b 染成红色），见后续对插入的讨论。 3.2.4 4. 向树底部的 3- 结点插入新键假设我们需要在树底部的一个 3- 结点下插入一个新结点，那么 a. b. c. 三种情况都可能会出现，在经过一次或者两次旋转之后，都会转换到情形 a.，只是结点 “b” 不再是根结点了，事实上 “b” 本来应该是红色才对，只是情形 a. 中，“b” 是根结点，因此最后染成了黑色。 在 4. 中，结点 “b” 被染成了红色，相当于在 “b” 的父结点中插入了一个红色结点，这就递归到了情形 1. 或者 情形2. 或者情形 3.。即我们相当于在一级一级地往上传递 red link，直到可以满足 LLRB 的要求。 在一级一级地往上传递 red link 时，即在沿着插入点到根结点的路径向上移动时经过的每个结点中顺序完成以下操作，我们就能完成插入操作： 如果结点 x 的左子结点是红色的而右子结点是黑色的，对 x 执行左旋操作； 如果结点 x 的左子结点是红色的，并且左子结点的左子结点也是红色的，对 x 执行 右旋操作； 如果结点 x 的左子结点和右子结点都是红色的，对 x 执行 FlipColors 操作； ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:2","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#2-向树底部的-2--结点插入新-key"},{"categories":["notes"],"content":" 3.2 LLRB 的插入操作我们在执行插入操作时，被插入的结点总是与父结点使用 red link 来连接，这样才有可能维护 LLRB 的完美平衡性。（与 2-3 树对应） 3.2.1 1. 向只有一个 2- 结点的树中插入新 key这里我们考虑的是树中只有一个结点 h的情况，然后推广到一般情况： 如果 key \u003c h-\u003ekey_，那么这个结点作为左子结点，新的 LLRB 和 单个 3- 结点完全等价，不会破坏 LLRB 的完美平衡； 否则，key \u003e h-\u003ekey_，出现了右斜 link 为 red link 的情况，因此我们需要对父结点执行一次左旋，即 root = RotateLeft(root);。 3.2.2 2. 向树底部的 2- 结点插入新 key与情况 1. 其实是一样的，如下图： 3.2.3 3. 向一个双 key 树（即 3- 结点）中插入新 key先考虑只有两个结点的情况： a. 新 key 大于原来 3- 结点中的两个 key，那么这个key 插入作为根结点的右子结点；如果此时我们将两个 link 的颜色都由红染黑，那么就得到了一个由 3 个结点组成、高为 2 的完美平衡的 2-3 树，也就是完美平衡的 LLRB； cpp void FlipColors(Node *x) { x-\u003ecolor_ = kRed; x-\u003eleft_-\u003ecolor_ = kBlack; x-\u003eright_-\u003ecolor_ = kBlack; } b. 新 key 小于原来 3- 结点中的两个 key，那么新 key 插入作为左子结点的左子结点，那么就出现了两个连续的 red link，此时我们只需要将根结点右旋，即可转化为情况 a； c. 新 key 介于原来 3- 结点的两个 key 中间，那么新 key 插入作为左子结点的右子结点，此时存在右倾的 red link，我们对根结点的左子结点执行左旋操作，则转化为情形 b，情形 b 可以再转化为情形 a。 注意情况 a. 中，结点 b 已经是根结点了，所以我们将 b 染成 黑色，否则需要向上传递（即将 b 染成红色），见后续对插入的讨论。 3.2.4 4. 向树底部的 3- 结点插入新键假设我们需要在树底部的一个 3- 结点下插入一个新结点，那么 a. b. c. 三种情况都可能会出现，在经过一次或者两次旋转之后，都会转换到情形 a.，只是结点 “b” 不再是根结点了，事实上 “b” 本来应该是红色才对，只是情形 a. 中，“b” 是根结点，因此最后染成了黑色。 在 4. 中，结点 “b” 被染成了红色，相当于在 “b” 的父结点中插入了一个红色结点，这就递归到了情形 1. 或者 情形2. 或者情形 3.。即我们相当于在一级一级地往上传递 red link，直到可以满足 LLRB 的要求。 在一级一级地往上传递 red link 时，即在沿着插入点到根结点的路径向上移动时经过的每个结点中顺序完成以下操作，我们就能完成插入操作： 如果结点 x 的左子结点是红色的而右子结点是黑色的，对 x 执行左旋操作； 如果结点 x 的左子结点是红色的，并且左子结点的左子结点也是红色的，对 x 执行 右旋操作； 如果结点 x 的左子结点和右子结点都是红色的，对 x 执行 FlipColors 操作； ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:2","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#3-向一个双-key-树即-3--结点中插入新-key"},{"categories":["notes"],"content":" 3.2 LLRB 的插入操作我们在执行插入操作时，被插入的结点总是与父结点使用 red link 来连接，这样才有可能维护 LLRB 的完美平衡性。（与 2-3 树对应） 3.2.1 1. 向只有一个 2- 结点的树中插入新 key这里我们考虑的是树中只有一个结点 h的情况，然后推广到一般情况： 如果 key \u003c h-\u003ekey_，那么这个结点作为左子结点，新的 LLRB 和 单个 3- 结点完全等价，不会破坏 LLRB 的完美平衡； 否则，key \u003e h-\u003ekey_，出现了右斜 link 为 red link 的情况，因此我们需要对父结点执行一次左旋，即 root = RotateLeft(root);。 3.2.2 2. 向树底部的 2- 结点插入新 key与情况 1. 其实是一样的，如下图： 3.2.3 3. 向一个双 key 树（即 3- 结点）中插入新 key先考虑只有两个结点的情况： a. 新 key 大于原来 3- 结点中的两个 key，那么这个key 插入作为根结点的右子结点；如果此时我们将两个 link 的颜色都由红染黑，那么就得到了一个由 3 个结点组成、高为 2 的完美平衡的 2-3 树，也就是完美平衡的 LLRB； cpp void FlipColors(Node *x) { x-\u003ecolor_ = kRed; x-\u003eleft_-\u003ecolor_ = kBlack; x-\u003eright_-\u003ecolor_ = kBlack; } b. 新 key 小于原来 3- 结点中的两个 key，那么新 key 插入作为左子结点的左子结点，那么就出现了两个连续的 red link，此时我们只需要将根结点右旋，即可转化为情况 a； c. 新 key 介于原来 3- 结点的两个 key 中间，那么新 key 插入作为左子结点的右子结点，此时存在右倾的 red link，我们对根结点的左子结点执行左旋操作，则转化为情形 b，情形 b 可以再转化为情形 a。 注意情况 a. 中，结点 b 已经是根结点了，所以我们将 b 染成 黑色，否则需要向上传递（即将 b 染成红色），见后续对插入的讨论。 3.2.4 4. 向树底部的 3- 结点插入新键假设我们需要在树底部的一个 3- 结点下插入一个新结点，那么 a. b. c. 三种情况都可能会出现，在经过一次或者两次旋转之后，都会转换到情形 a.，只是结点 “b” 不再是根结点了，事实上 “b” 本来应该是红色才对，只是情形 a. 中，“b” 是根结点，因此最后染成了黑色。 在 4. 中，结点 “b” 被染成了红色，相当于在 “b” 的父结点中插入了一个红色结点，这就递归到了情形 1. 或者 情形2. 或者情形 3.。即我们相当于在一级一级地往上传递 red link，直到可以满足 LLRB 的要求。 在一级一级地往上传递 red link 时，即在沿着插入点到根结点的路径向上移动时经过的每个结点中顺序完成以下操作，我们就能完成插入操作： 如果结点 x 的左子结点是红色的而右子结点是黑色的，对 x 执行左旋操作； 如果结点 x 的左子结点是红色的，并且左子结点的左子结点也是红色的，对 x 执行 右旋操作； 如果结点 x 的左子结点和右子结点都是红色的，对 x 执行 FlipColors 操作； ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:2","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#4-向树底部的-3--结点插入新键"},{"categories":["notes"],"content":" 3.3 LLRB 的插入操作的实现通过递归，我们可以以一个比较优雅的方式实现 LLRB 的插入操作，尽量减少了需要分类讨论的情形： cpp const bool kRed = true; const bool kBlack = false; class Node { private: int key_; int val_; int cnt_; bool color_; Node *left_; Node *right_; Node *root_; public: Node(int key, int val, int cnt, bool color) : key_(key), val_(val), cnt_(cnt), color_(color), left_(nullptr), right_(nullptr) { } void Put(int key, int val) { root_ = Put(key, val, root_); root_-\u003ecolor_ = kBlack; // 根结点的颜色一定是黑色！ } private: static auto isRed(Node *x) -\u003e bool { if (x == nullptr) { return false; } return x-\u003ecolor_ == kRed; } auto RotateLeft(Node *node) { auto *rson = node-\u003eright_; // 右子结点 node-\u003eright_ = rson-\u003eleft_; rson-\u003eleft_ = node; rson-\u003ecolor_ = node-\u003ecolor_; node-\u003ecolor_ = kRed; return rson; } auto RotateRight(Node *node) { auto *lson = node-\u003eleft_; // 左子结点 node-\u003eleft_ = lson-\u003eright_; lson-\u003eright_ = node; lson-\u003ecolor_ = node-\u003ecolor_; node-\u003ecolor_ = kRed; return lson; } void FlipColors(Node *node) { node-\u003ecolor_ = kRed; node-\u003eleft_-\u003ecolor_ = kBlack; node-\u003eright_-\u003ecolor_ = kBlack; } auto Put(int key, int val, Node *root) -\u003e Node * { // root 表示我们往以 root 为根结点的树中插入结点 if (root == nullptr) { return new Node(key, val, 1, kRed); } if (key \u003c root-\u003ekey_) { root-\u003eleft_ = Put(key, val, root-\u003eleft_); } else if (key \u003e root-\u003ekey_) { root-\u003eright_ = Put(key, val, root-\u003eright_); } else { root-\u003eval_ = val; } if (!isRed(root-\u003eleft_) \u0026\u0026 isRed(root-\u003eright_)) { // 只有右子结点是红色 root = RotateLeft(root); } if (isRed(root-\u003eleft_) \u0026\u0026 isRed(root-\u003eleft_-\u003eleft_)) { // 左子结点和左子结点的左子结点都是红色 root = RotateRight(root); } if (isRed(root-\u003eleft_) \u0026\u0026 isRed(root-\u003eright_)) { // 左右子结点都是红色，翻转颜色 FlipColors(root); } root-\u003ecnt_ = root-\u003eleft_-\u003ecnt_ + root-\u003eright_-\u003ecnt_ + 1; return root; } }; ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:3","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#llrb-的插入操作的实现"},{"categories":["notes"],"content":" 3.4 LLRB 的删除操作LLRB 的删除操作比起插入来说要复杂很多。 类似插入操作，我们也需要一系列局部变化来删除一个结点的同时保持树的完美性，这个过程比插入结点更复杂。 我们不仅要在（为了删除一个结点而）构造临时 4- 结点时沿着查找路径向下进行变换，还要在分解遗留的 4- 结点时沿着查找路径向上进行变换（同插入操作）。 3.4.1 删除最小 key让我们从 2-3 树的删除最小 key 的步骤来理解这段代码： 首先是 DeleteMin()，如果根结点的左右子结点存在红色结点（事实上只可能左子结点为红色），那么将直接执行到 DeleteMin(root_-\u003eleft_)；而如果根结点的左右子结点均为黑色，即一共三个 2- 结点，那么，2-3 树中，我们需要将这三个 2- 结点合并成一个临时 4- 结点，对应代码中，则是先在 DeleteMin() 中将根结点染为红色，然后 DeleteMin(root_) 中，执行 FlipColorsForDel(root_)，从而将根结点重新染黑，左子结点和右子结点均染为红色，这与合并三个 2- 结点成一个临时 4- 结点是一致的。 MoveRedLeft(node) 做的事情其实不难理解，如果当前结点为红色（并且此时左子结点和右子结点一定都是黑色，右子结点黑色由 2-3 树的定义保证），如果右子结点是 2- 结点，即右子结点的左子结点也是黑色，那么就合并当前结点、当前结点的左子结点、当前结点的右子结点为一个 4- 结点，对应 FlipColorsForDel(node)；否则，当前结点的右子结点是个 3- 结点，那么就执行如下操作： 这里的操作类似于 2-3 结点的操作，但是不能完全对应起来，可以说是构建了一个临时的 5- 结点，继续往下删除了 b 之后，就可以将红色的 c 结点下溢，和 d 结点共同组成一个 3- 结点，然后进行递归的归过程，让 2-3 树重新恢复完美平衡。对应代码，就是一直遍历到当前结点为 c 才会进行 MoveRedLeft(node)。 然后在归的过程中，由下往上依次执行 FixUp(node)，就能让 LLRB 恢复平衡，完成删除。 在删除最小 key 的过程中，我们其实在维护一个隐含的不变量，那就是 h 或者 h-\u003eleft_ 其中之一一定是红色。因为这样能保证到最终要删除的那个叶子结点一定是红色，因此最终可以直接删除最小 key。 叶子结点的子结点是 null，一定是黑色，所以叶子结点本身一定是红色。 由于我们要维护 h 或者 h-\u003eleft_ 为红色这一性质，因此当我们碰到了 h-\u003eleft_ 以及 h-\u003eleft_-\u003eleft_ 为黑色这一情形时，就需要额外操作了，即执行 MoveRedLeft。 执行 MoveRedLeft 时，此时一定有 h-\u003eleft_ == kBlack \u0026\u0026 h-\u003eright_ == kBlack，我们需要分两种情况讨论 h-\u003eright_-\u003eleft_ != kRed，那么我们直接翻转 h、h-\u003eleft_、h-\u003eright_ 三个结点的颜色即可； h-\u003eright_-\u003eleft_ == kRed，我们还是要执行翻转 h、h-\u003eleft_、h-\u003eright_ 三个结点的颜色，但此时，我们注意到出现了一个新的违反平衡的情形（连续两个 Red link），并且这个对平衡的违反无法在归的过程中通过调用 FixUp 解决，因此我们还需要额外进行处理，即通过两次旋转，去除 h-\u003eright_ 为根结点的违反平衡的情况，如下图所示： 因此，MoveRedLeft(Node *h) 的实现代码如下： cpp auto MoveRedLeft(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eright_-\u003eleft_)) { h-\u003eright_ = RotateRight(h-\u003eright_); h = RotateLeft(h); FlipColors(h); // 这一行也可以不加，留给归过程中的 FixUp 解决 } } 由于我们只有碰到 h-\u003eleft_ 以及 h-\u003eleft_-\u003eleft_ 这一情形，才出现了违背我们要求的性质的情况，此时才需要调用 MoveRedLeft，因此也可以很方便写出 DelMin 的代码： cpp void DelMin() { root_ = DelMin(root_); root_-\u003ecolor_ = kBlack; } auto DelMin(Node *h) -\u003e Node * { if (h-\u003eleft_ == nullptr) { return nullptr; // 删除 h，h 是最小 key } if (!isRed(h-\u003eleft_) \u0026\u0026 !isRed(h-\u003eleft_-\u003eleft_)) { h = MoveRedLeft(h); } h = DelMin(h-\u003eleft_); return FixUp(h); } auto MoveRedLeft(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eright_-\u003eleft_)) { h-\u003eright_ = RotateRight(h-\u003eright_); h = RotateLeft(h); FlipColors(h); // 这一行也可以不加，留给归过程中的 FixUp 解决 } return h; } auto FixUp(Node *node) -\u003e Node * { if (!isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { // 只有右子结点是红色 node = RotateLeft(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eleft_-\u003eleft_)) { node = RotateRight(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { FlipColors(node); } node-\u003ecnt_ = node-\u003eleft_-\u003ecnt_ = node-\u003eright_-\u003ecnt_ + 1; return node; } 3.4.2 删除最大 key删除最大 key 的步骤和删除最小 key 类似，我们也需要维护一个性质，即 h 或者 h-\u003eright_ 为红色。我们可以先观察 h-\u003eleft_ 是否是红色，如果是，对 h 执行右旋，那么 h-\u003eright_ 一定会变成红色，我们继续往右下遍历即可。当我们往右下遍历时，如果碰到了 !isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_) 的情况时（h-\u003eleft_ 不为红色），就需要执行 MoveRedRight 操作了，不然就会出现违反性质的情况。 如果 h-\u003eleft_-\u003eleft_ 不是红色，那么直接对 h 执行 FlipColors 即可，翻转了 h、h-\u003eleft_、h-\u003eright_ 这三个结点的颜色，如下图： 如果 h-\u003eleft_-\u003eleft_ 是红色，就像 DelMin() 时那样，我们需要翻转 h、h-\u003eleft_、h-\u003eright_ 之后，会留下一个后续 FixUp 无法处理的不平衡性，即 h 左侧有两个连续 red link，同时 h 右侧也是 red link，而如果我们对 h 执行右旋，那么 h 右端就有连续两个 red link，h-\u003eright_ 必定能满足性质。 cpp auto MoveRedRight(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eleft_-\u003eleft_)) { h = RotateRight(h); FlipColors(h); // 可以留给后续 FixUp 执行 } return h; } 在 DelMax 的过程中，一旦碰到 h-\u003eleft_ 是红色的情况，我们就执行右旋，一旦碰到 !isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_) 的情况，就执行 MoveRedRgiht()。 之所以是判断 h-\u003eright_-\u003eleft_，是因为假如 h-\u003eright_ 是黑色，h-\u003eright_-\u003eleft_ 是红色，当我们遍历到 h-\u003eright_ 时，可以左旋 h-\u003eright_，一样可以满足条件； cpp void DelMax() { root_ = DelMax(root_); if (root_ != nullptr) { root_-\u003ecolor_ = kBlack; } } auto MoveRedRight(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eleft_-\u003eleft_)) { h = RotateRight(h); FlipColors(h); // 可以不加，等后续 FixUp 处理 } return h; } auto DelMax(Node *h) -\u003e Node * { if (isRed(h-\u003eleft_)) { h = RotateRight(h); } if (h-\u003eright_ == nullptr) { return nullptr; } if (!isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_)) { // h = ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:4","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#llrb-的删除操作"},{"categories":["notes"],"content":" 3.4 LLRB 的删除操作LLRB 的删除操作比起插入来说要复杂很多。 类似插入操作，我们也需要一系列局部变化来删除一个结点的同时保持树的完美性，这个过程比插入结点更复杂。 我们不仅要在（为了删除一个结点而）构造临时 4- 结点时沿着查找路径向下进行变换，还要在分解遗留的 4- 结点时沿着查找路径向上进行变换（同插入操作）。 3.4.1 删除最小 key让我们从 2-3 树的删除最小 key 的步骤来理解这段代码： 首先是 DeleteMin()，如果根结点的左右子结点存在红色结点（事实上只可能左子结点为红色），那么将直接执行到 DeleteMin(root_-\u003eleft_)；而如果根结点的左右子结点均为黑色，即一共三个 2- 结点，那么，2-3 树中，我们需要将这三个 2- 结点合并成一个临时 4- 结点，对应代码中，则是先在 DeleteMin() 中将根结点染为红色，然后 DeleteMin(root_) 中，执行 FlipColorsForDel(root_)，从而将根结点重新染黑，左子结点和右子结点均染为红色，这与合并三个 2- 结点成一个临时 4- 结点是一致的。 MoveRedLeft(node) 做的事情其实不难理解，如果当前结点为红色（并且此时左子结点和右子结点一定都是黑色，右子结点黑色由 2-3 树的定义保证），如果右子结点是 2- 结点，即右子结点的左子结点也是黑色，那么就合并当前结点、当前结点的左子结点、当前结点的右子结点为一个 4- 结点，对应 FlipColorsForDel(node)；否则，当前结点的右子结点是个 3- 结点，那么就执行如下操作： 这里的操作类似于 2-3 结点的操作，但是不能完全对应起来，可以说是构建了一个临时的 5- 结点，继续往下删除了 b 之后，就可以将红色的 c 结点下溢，和 d 结点共同组成一个 3- 结点，然后进行递归的归过程，让 2-3 树重新恢复完美平衡。对应代码，就是一直遍历到当前结点为 c 才会进行 MoveRedLeft(node)。 然后在归的过程中，由下往上依次执行 FixUp(node)，就能让 LLRB 恢复平衡，完成删除。 在删除最小 key 的过程中，我们其实在维护一个隐含的不变量，那就是 h 或者 h-\u003eleft_ 其中之一一定是红色。因为这样能保证到最终要删除的那个叶子结点一定是红色，因此最终可以直接删除最小 key。 叶子结点的子结点是 null，一定是黑色，所以叶子结点本身一定是红色。 由于我们要维护 h 或者 h-\u003eleft_ 为红色这一性质，因此当我们碰到了 h-\u003eleft_ 以及 h-\u003eleft_-\u003eleft_ 为黑色这一情形时，就需要额外操作了，即执行 MoveRedLeft。 执行 MoveRedLeft 时，此时一定有 h-\u003eleft_ == kBlack \u0026\u0026 h-\u003eright_ == kBlack，我们需要分两种情况讨论 h-\u003eright_-\u003eleft_ != kRed，那么我们直接翻转 h、h-\u003eleft_、h-\u003eright_ 三个结点的颜色即可； h-\u003eright_-\u003eleft_ == kRed，我们还是要执行翻转 h、h-\u003eleft_、h-\u003eright_ 三个结点的颜色，但此时，我们注意到出现了一个新的违反平衡的情形（连续两个 Red link），并且这个对平衡的违反无法在归的过程中通过调用 FixUp 解决，因此我们还需要额外进行处理，即通过两次旋转，去除 h-\u003eright_ 为根结点的违反平衡的情况，如下图所示： 因此，MoveRedLeft(Node *h) 的实现代码如下： cpp auto MoveRedLeft(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eright_-\u003eleft_)) { h-\u003eright_ = RotateRight(h-\u003eright_); h = RotateLeft(h); FlipColors(h); // 这一行也可以不加，留给归过程中的 FixUp 解决 } } 由于我们只有碰到 h-\u003eleft_ 以及 h-\u003eleft_-\u003eleft_ 这一情形，才出现了违背我们要求的性质的情况，此时才需要调用 MoveRedLeft，因此也可以很方便写出 DelMin 的代码： cpp void DelMin() { root_ = DelMin(root_); root_-\u003ecolor_ = kBlack; } auto DelMin(Node *h) -\u003e Node * { if (h-\u003eleft_ == nullptr) { return nullptr; // 删除 h，h 是最小 key } if (!isRed(h-\u003eleft_) \u0026\u0026 !isRed(h-\u003eleft_-\u003eleft_)) { h = MoveRedLeft(h); } h = DelMin(h-\u003eleft_); return FixUp(h); } auto MoveRedLeft(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eright_-\u003eleft_)) { h-\u003eright_ = RotateRight(h-\u003eright_); h = RotateLeft(h); FlipColors(h); // 这一行也可以不加，留给归过程中的 FixUp 解决 } return h; } auto FixUp(Node *node) -\u003e Node * { if (!isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { // 只有右子结点是红色 node = RotateLeft(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eleft_-\u003eleft_)) { node = RotateRight(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { FlipColors(node); } node-\u003ecnt_ = node-\u003eleft_-\u003ecnt_ = node-\u003eright_-\u003ecnt_ + 1; return node; } 3.4.2 删除最大 key删除最大 key 的步骤和删除最小 key 类似，我们也需要维护一个性质，即 h 或者 h-\u003eright_ 为红色。我们可以先观察 h-\u003eleft_ 是否是红色，如果是，对 h 执行右旋，那么 h-\u003eright_ 一定会变成红色，我们继续往右下遍历即可。当我们往右下遍历时，如果碰到了 !isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_) 的情况时（h-\u003eleft_ 不为红色），就需要执行 MoveRedRight 操作了，不然就会出现违反性质的情况。 如果 h-\u003eleft_-\u003eleft_ 不是红色，那么直接对 h 执行 FlipColors 即可，翻转了 h、h-\u003eleft_、h-\u003eright_ 这三个结点的颜色，如下图： 如果 h-\u003eleft_-\u003eleft_ 是红色，就像 DelMin() 时那样，我们需要翻转 h、h-\u003eleft_、h-\u003eright_ 之后，会留下一个后续 FixUp 无法处理的不平衡性，即 h 左侧有两个连续 red link，同时 h 右侧也是 red link，而如果我们对 h 执行右旋，那么 h 右端就有连续两个 red link，h-\u003eright_ 必定能满足性质。 cpp auto MoveRedRight(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eleft_-\u003eleft_)) { h = RotateRight(h); FlipColors(h); // 可以留给后续 FixUp 执行 } return h; } 在 DelMax 的过程中，一旦碰到 h-\u003eleft_ 是红色的情况，我们就执行右旋，一旦碰到 !isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_) 的情况，就执行 MoveRedRgiht()。 之所以是判断 h-\u003eright_-\u003eleft_，是因为假如 h-\u003eright_ 是黑色，h-\u003eright_-\u003eleft_ 是红色，当我们遍历到 h-\u003eright_ 时，可以左旋 h-\u003eright_，一样可以满足条件； cpp void DelMax() { root_ = DelMax(root_); if (root_ != nullptr) { root_-\u003ecolor_ = kBlack; } } auto MoveRedRight(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eleft_-\u003eleft_)) { h = RotateRight(h); FlipColors(h); // 可以不加，等后续 FixUp 处理 } return h; } auto DelMax(Node *h) -\u003e Node * { if (isRed(h-\u003eleft_)) { h = RotateRight(h); } if (h-\u003eright_ == nullptr) { return nullptr; } if (!isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_)) { // h = ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:4","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#删除最小-key"},{"categories":["notes"],"content":" 3.4 LLRB 的删除操作LLRB 的删除操作比起插入来说要复杂很多。 类似插入操作，我们也需要一系列局部变化来删除一个结点的同时保持树的完美性，这个过程比插入结点更复杂。 我们不仅要在（为了删除一个结点而）构造临时 4- 结点时沿着查找路径向下进行变换，还要在分解遗留的 4- 结点时沿着查找路径向上进行变换（同插入操作）。 3.4.1 删除最小 key让我们从 2-3 树的删除最小 key 的步骤来理解这段代码： 首先是 DeleteMin()，如果根结点的左右子结点存在红色结点（事实上只可能左子结点为红色），那么将直接执行到 DeleteMin(root_-\u003eleft_)；而如果根结点的左右子结点均为黑色，即一共三个 2- 结点，那么，2-3 树中，我们需要将这三个 2- 结点合并成一个临时 4- 结点，对应代码中，则是先在 DeleteMin() 中将根结点染为红色，然后 DeleteMin(root_) 中，执行 FlipColorsForDel(root_)，从而将根结点重新染黑，左子结点和右子结点均染为红色，这与合并三个 2- 结点成一个临时 4- 结点是一致的。 MoveRedLeft(node) 做的事情其实不难理解，如果当前结点为红色（并且此时左子结点和右子结点一定都是黑色，右子结点黑色由 2-3 树的定义保证），如果右子结点是 2- 结点，即右子结点的左子结点也是黑色，那么就合并当前结点、当前结点的左子结点、当前结点的右子结点为一个 4- 结点，对应 FlipColorsForDel(node)；否则，当前结点的右子结点是个 3- 结点，那么就执行如下操作： 这里的操作类似于 2-3 结点的操作，但是不能完全对应起来，可以说是构建了一个临时的 5- 结点，继续往下删除了 b 之后，就可以将红色的 c 结点下溢，和 d 结点共同组成一个 3- 结点，然后进行递归的归过程，让 2-3 树重新恢复完美平衡。对应代码，就是一直遍历到当前结点为 c 才会进行 MoveRedLeft(node)。 然后在归的过程中，由下往上依次执行 FixUp(node)，就能让 LLRB 恢复平衡，完成删除。 在删除最小 key 的过程中，我们其实在维护一个隐含的不变量，那就是 h 或者 h-\u003eleft_ 其中之一一定是红色。因为这样能保证到最终要删除的那个叶子结点一定是红色，因此最终可以直接删除最小 key。 叶子结点的子结点是 null，一定是黑色，所以叶子结点本身一定是红色。 由于我们要维护 h 或者 h-\u003eleft_ 为红色这一性质，因此当我们碰到了 h-\u003eleft_ 以及 h-\u003eleft_-\u003eleft_ 为黑色这一情形时，就需要额外操作了，即执行 MoveRedLeft。 执行 MoveRedLeft 时，此时一定有 h-\u003eleft_ == kBlack \u0026\u0026 h-\u003eright_ == kBlack，我们需要分两种情况讨论 h-\u003eright_-\u003eleft_ != kRed，那么我们直接翻转 h、h-\u003eleft_、h-\u003eright_ 三个结点的颜色即可； h-\u003eright_-\u003eleft_ == kRed，我们还是要执行翻转 h、h-\u003eleft_、h-\u003eright_ 三个结点的颜色，但此时，我们注意到出现了一个新的违反平衡的情形（连续两个 Red link），并且这个对平衡的违反无法在归的过程中通过调用 FixUp 解决，因此我们还需要额外进行处理，即通过两次旋转，去除 h-\u003eright_ 为根结点的违反平衡的情况，如下图所示： 因此，MoveRedLeft(Node *h) 的实现代码如下： cpp auto MoveRedLeft(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eright_-\u003eleft_)) { h-\u003eright_ = RotateRight(h-\u003eright_); h = RotateLeft(h); FlipColors(h); // 这一行也可以不加，留给归过程中的 FixUp 解决 } } 由于我们只有碰到 h-\u003eleft_ 以及 h-\u003eleft_-\u003eleft_ 这一情形，才出现了违背我们要求的性质的情况，此时才需要调用 MoveRedLeft，因此也可以很方便写出 DelMin 的代码： cpp void DelMin() { root_ = DelMin(root_); root_-\u003ecolor_ = kBlack; } auto DelMin(Node *h) -\u003e Node * { if (h-\u003eleft_ == nullptr) { return nullptr; // 删除 h，h 是最小 key } if (!isRed(h-\u003eleft_) \u0026\u0026 !isRed(h-\u003eleft_-\u003eleft_)) { h = MoveRedLeft(h); } h = DelMin(h-\u003eleft_); return FixUp(h); } auto MoveRedLeft(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eright_-\u003eleft_)) { h-\u003eright_ = RotateRight(h-\u003eright_); h = RotateLeft(h); FlipColors(h); // 这一行也可以不加，留给归过程中的 FixUp 解决 } return h; } auto FixUp(Node *node) -\u003e Node * { if (!isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { // 只有右子结点是红色 node = RotateLeft(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eleft_-\u003eleft_)) { node = RotateRight(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { FlipColors(node); } node-\u003ecnt_ = node-\u003eleft_-\u003ecnt_ = node-\u003eright_-\u003ecnt_ + 1; return node; } 3.4.2 删除最大 key删除最大 key 的步骤和删除最小 key 类似，我们也需要维护一个性质，即 h 或者 h-\u003eright_ 为红色。我们可以先观察 h-\u003eleft_ 是否是红色，如果是，对 h 执行右旋，那么 h-\u003eright_ 一定会变成红色，我们继续往右下遍历即可。当我们往右下遍历时，如果碰到了 !isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_) 的情况时（h-\u003eleft_ 不为红色），就需要执行 MoveRedRight 操作了，不然就会出现违反性质的情况。 如果 h-\u003eleft_-\u003eleft_ 不是红色，那么直接对 h 执行 FlipColors 即可，翻转了 h、h-\u003eleft_、h-\u003eright_ 这三个结点的颜色，如下图： 如果 h-\u003eleft_-\u003eleft_ 是红色，就像 DelMin() 时那样，我们需要翻转 h、h-\u003eleft_、h-\u003eright_ 之后，会留下一个后续 FixUp 无法处理的不平衡性，即 h 左侧有两个连续 red link，同时 h 右侧也是 red link，而如果我们对 h 执行右旋，那么 h 右端就有连续两个 red link，h-\u003eright_ 必定能满足性质。 cpp auto MoveRedRight(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eleft_-\u003eleft_)) { h = RotateRight(h); FlipColors(h); // 可以留给后续 FixUp 执行 } return h; } 在 DelMax 的过程中，一旦碰到 h-\u003eleft_ 是红色的情况，我们就执行右旋，一旦碰到 !isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_) 的情况，就执行 MoveRedRgiht()。 之所以是判断 h-\u003eright_-\u003eleft_，是因为假如 h-\u003eright_ 是黑色，h-\u003eright_-\u003eleft_ 是红色，当我们遍历到 h-\u003eright_ 时，可以左旋 h-\u003eright_，一样可以满足条件； cpp void DelMax() { root_ = DelMax(root_); if (root_ != nullptr) { root_-\u003ecolor_ = kBlack; } } auto MoveRedRight(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eleft_-\u003eleft_)) { h = RotateRight(h); FlipColors(h); // 可以不加，等后续 FixUp 处理 } return h; } auto DelMax(Node *h) -\u003e Node * { if (isRed(h-\u003eleft_)) { h = RotateRight(h); } if (h-\u003eright_ == nullptr) { return nullptr; } if (!isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_)) { // h = ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:4","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#删除最大-key"},{"categories":["notes"],"content":" 3.4 LLRB 的删除操作LLRB 的删除操作比起插入来说要复杂很多。 类似插入操作，我们也需要一系列局部变化来删除一个结点的同时保持树的完美性，这个过程比插入结点更复杂。 我们不仅要在（为了删除一个结点而）构造临时 4- 结点时沿着查找路径向下进行变换，还要在分解遗留的 4- 结点时沿着查找路径向上进行变换（同插入操作）。 3.4.1 删除最小 key让我们从 2-3 树的删除最小 key 的步骤来理解这段代码： 首先是 DeleteMin()，如果根结点的左右子结点存在红色结点（事实上只可能左子结点为红色），那么将直接执行到 DeleteMin(root_-\u003eleft_)；而如果根结点的左右子结点均为黑色，即一共三个 2- 结点，那么，2-3 树中，我们需要将这三个 2- 结点合并成一个临时 4- 结点，对应代码中，则是先在 DeleteMin() 中将根结点染为红色，然后 DeleteMin(root_) 中，执行 FlipColorsForDel(root_)，从而将根结点重新染黑，左子结点和右子结点均染为红色，这与合并三个 2- 结点成一个临时 4- 结点是一致的。 MoveRedLeft(node) 做的事情其实不难理解，如果当前结点为红色（并且此时左子结点和右子结点一定都是黑色，右子结点黑色由 2-3 树的定义保证），如果右子结点是 2- 结点，即右子结点的左子结点也是黑色，那么就合并当前结点、当前结点的左子结点、当前结点的右子结点为一个 4- 结点，对应 FlipColorsForDel(node)；否则，当前结点的右子结点是个 3- 结点，那么就执行如下操作： 这里的操作类似于 2-3 结点的操作，但是不能完全对应起来，可以说是构建了一个临时的 5- 结点，继续往下删除了 b 之后，就可以将红色的 c 结点下溢，和 d 结点共同组成一个 3- 结点，然后进行递归的归过程，让 2-3 树重新恢复完美平衡。对应代码，就是一直遍历到当前结点为 c 才会进行 MoveRedLeft(node)。 然后在归的过程中，由下往上依次执行 FixUp(node)，就能让 LLRB 恢复平衡，完成删除。 在删除最小 key 的过程中，我们其实在维护一个隐含的不变量，那就是 h 或者 h-\u003eleft_ 其中之一一定是红色。因为这样能保证到最终要删除的那个叶子结点一定是红色，因此最终可以直接删除最小 key。 叶子结点的子结点是 null，一定是黑色，所以叶子结点本身一定是红色。 由于我们要维护 h 或者 h-\u003eleft_ 为红色这一性质，因此当我们碰到了 h-\u003eleft_ 以及 h-\u003eleft_-\u003eleft_ 为黑色这一情形时，就需要额外操作了，即执行 MoveRedLeft。 执行 MoveRedLeft 时，此时一定有 h-\u003eleft_ == kBlack \u0026\u0026 h-\u003eright_ == kBlack，我们需要分两种情况讨论 h-\u003eright_-\u003eleft_ != kRed，那么我们直接翻转 h、h-\u003eleft_、h-\u003eright_ 三个结点的颜色即可； h-\u003eright_-\u003eleft_ == kRed，我们还是要执行翻转 h、h-\u003eleft_、h-\u003eright_ 三个结点的颜色，但此时，我们注意到出现了一个新的违反平衡的情形（连续两个 Red link），并且这个对平衡的违反无法在归的过程中通过调用 FixUp 解决，因此我们还需要额外进行处理，即通过两次旋转，去除 h-\u003eright_ 为根结点的违反平衡的情况，如下图所示： 因此，MoveRedLeft(Node *h) 的实现代码如下： cpp auto MoveRedLeft(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eright_-\u003eleft_)) { h-\u003eright_ = RotateRight(h-\u003eright_); h = RotateLeft(h); FlipColors(h); // 这一行也可以不加，留给归过程中的 FixUp 解决 } } 由于我们只有碰到 h-\u003eleft_ 以及 h-\u003eleft_-\u003eleft_ 这一情形，才出现了违背我们要求的性质的情况，此时才需要调用 MoveRedLeft，因此也可以很方便写出 DelMin 的代码： cpp void DelMin() { root_ = DelMin(root_); root_-\u003ecolor_ = kBlack; } auto DelMin(Node *h) -\u003e Node * { if (h-\u003eleft_ == nullptr) { return nullptr; // 删除 h，h 是最小 key } if (!isRed(h-\u003eleft_) \u0026\u0026 !isRed(h-\u003eleft_-\u003eleft_)) { h = MoveRedLeft(h); } h = DelMin(h-\u003eleft_); return FixUp(h); } auto MoveRedLeft(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eright_-\u003eleft_)) { h-\u003eright_ = RotateRight(h-\u003eright_); h = RotateLeft(h); FlipColors(h); // 这一行也可以不加，留给归过程中的 FixUp 解决 } return h; } auto FixUp(Node *node) -\u003e Node * { if (!isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { // 只有右子结点是红色 node = RotateLeft(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eleft_-\u003eleft_)) { node = RotateRight(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { FlipColors(node); } node-\u003ecnt_ = node-\u003eleft_-\u003ecnt_ = node-\u003eright_-\u003ecnt_ + 1; return node; } 3.4.2 删除最大 key删除最大 key 的步骤和删除最小 key 类似，我们也需要维护一个性质，即 h 或者 h-\u003eright_ 为红色。我们可以先观察 h-\u003eleft_ 是否是红色，如果是，对 h 执行右旋，那么 h-\u003eright_ 一定会变成红色，我们继续往右下遍历即可。当我们往右下遍历时，如果碰到了 !isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_) 的情况时（h-\u003eleft_ 不为红色），就需要执行 MoveRedRight 操作了，不然就会出现违反性质的情况。 如果 h-\u003eleft_-\u003eleft_ 不是红色，那么直接对 h 执行 FlipColors 即可，翻转了 h、h-\u003eleft_、h-\u003eright_ 这三个结点的颜色，如下图： 如果 h-\u003eleft_-\u003eleft_ 是红色，就像 DelMin() 时那样，我们需要翻转 h、h-\u003eleft_、h-\u003eright_ 之后，会留下一个后续 FixUp 无法处理的不平衡性，即 h 左侧有两个连续 red link，同时 h 右侧也是 red link，而如果我们对 h 执行右旋，那么 h 右端就有连续两个 red link，h-\u003eright_ 必定能满足性质。 cpp auto MoveRedRight(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eleft_-\u003eleft_)) { h = RotateRight(h); FlipColors(h); // 可以留给后续 FixUp 执行 } return h; } 在 DelMax 的过程中，一旦碰到 h-\u003eleft_ 是红色的情况，我们就执行右旋，一旦碰到 !isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_) 的情况，就执行 MoveRedRgiht()。 之所以是判断 h-\u003eright_-\u003eleft_，是因为假如 h-\u003eright_ 是黑色，h-\u003eright_-\u003eleft_ 是红色，当我们遍历到 h-\u003eright_ 时，可以左旋 h-\u003eright_，一样可以满足条件； cpp void DelMax() { root_ = DelMax(root_); if (root_ != nullptr) { root_-\u003ecolor_ = kBlack; } } auto MoveRedRight(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eleft_-\u003eleft_)) { h = RotateRight(h); FlipColors(h); // 可以不加，等后续 FixUp 处理 } return h; } auto DelMax(Node *h) -\u003e Node * { if (isRed(h-\u003eleft_)) { h = RotateRight(h); } if (h-\u003eright_ == nullptr) { return nullptr; } if (!isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_)) { // h = ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:4","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#删除任意结点"},{"categories":["notes"],"content":" 3.5 完整实现LLRB 的完整实现代码如下： cpp const bool kRed = true; const bool kBlack = false; class Node { private: int key_; int val_; int cnt_; bool color_; Node *left_; Node *right_; Node *root_; public: Node(int key, int val, int cnt, bool color) : key_(key), val_(val), cnt_(cnt), color_(color), left_(nullptr), right_(nullptr) { } void Put(int key, int val) { root_ = Put(key, val, root_); root_-\u003ecolor_ = kBlack; // 根结点的颜色一定是黑色！ } void DelMin() { root_ = DelMin(root_); if (root_ != nullptr) { root_-\u003ecolor_ = kBlack; } } void DelMax() { root_ = DelMax(root_); if (root_ != nullptr) { root_-\u003ecolor_ = kBlack; } } auto Delete(int key, Node *h) -\u003e Node * { if (key \u003c h-\u003ekey_) { if (!isRed(h-\u003eleft_) \u0026\u0026 !isRed(h-\u003eleft_-\u003eleft_)) { h = MoveRedLeft(h); } h-\u003eleft_ = Delete(key, h-\u003eleft_); } else { if (isRed(h-\u003eleft_)) { h = RotateRight(h); } if (key == h-\u003ekey_ \u0026\u0026 h-\u003eright_ == nullptr) { return nullptr; } if (!isRed(h-\u003eleft_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_)) { h = MoveRedRight(h); } // 经过这些操作，h-\u003ekey_ 只会变小，不会变大，因此不可能出现 key \u003c h-\u003ekey_ 的情况 if (key == h-\u003ekey_) { h-\u003ekey_ = GetMin(h-\u003eright_)-\u003ekey_; h-\u003eval_ = GetMin(h-\u003eright_)-\u003eval_; h-\u003eright_ = DelMin(h-\u003eright_); } else { h-\u003eright_ = Delete(key, h-\u003eright_); } } return FixUp(h); } private: auto GetMin(Node *x) -\u003e Node * { if (x-\u003eleft_ == nullptr) { return x; } return GetMin(x-\u003eleft_); } static auto isRed(Node *x) -\u003e bool { if (x == nullptr) { return false; } return x-\u003ecolor_ == kRed; } static auto RotateLeft(Node *node) -\u003e Node * { auto *rson = node-\u003eright_; node-\u003eright_ = rson-\u003eleft_; rson-\u003eleft_ = node; rson-\u003ecolor_ = node-\u003ecolor_; node-\u003ecolor_ = kRed; return rson; } static auto RotateRight(Node *node) -\u003e Node * { auto *lson = node-\u003eleft_; node-\u003eleft_ = lson-\u003eright_; lson-\u003eright_ = node; lson-\u003ecolor_ = node-\u003ecolor_; node-\u003ecolor_ = kRed; return lson; } static void FlipColors(Node *node) { node-\u003ecolor_ = !node-\u003ecolor_; node-\u003eleft_-\u003ecolor_ = !node-\u003eleft_-\u003ecolor_; node-\u003eright_-\u003ecolor_ = !node-\u003eright_-\u003ecolor_; } auto Put(int key, int val, Node *node) -\u003e Node * { // node 表示我们往以 node 为根结点的树中插入结点 if (node == nullptr) { return new Node(key, val, 1, kRed); } if (key \u003c node-\u003ekey_) { node-\u003eleft_ = Put(key, val, node-\u003eleft_); } else if (key \u003e node-\u003ekey_) { node-\u003eright_ = Put(key, val, node-\u003eright_); } else { node-\u003eval_ = val; } if (!isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { // 只有右子结点是红色 node = RotateLeft(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eleft_-\u003eleft_)) { node = RotateRight(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { FlipColors(node); } node-\u003ecnt_ = node-\u003eleft_-\u003ecnt_ + node-\u003eright_-\u003ecnt_ + 1; return node; } auto FixUp(Node *node) -\u003e Node * { if (!isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { // 只有右子结点是红色 node = RotateLeft(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eleft_-\u003eleft_)) { node = RotateRight(node); } if (isRed(node-\u003eleft_) \u0026\u0026 isRed(node-\u003eright_)) { FlipColors(node); } node-\u003ecnt_ = node-\u003eleft_-\u003ecnt_ = node-\u003eright_-\u003ecnt_ + 1; return node; } auto MoveRedLeft(Node *h) -\u003e Node * { // 假定 node 是红色，我们的删除结点的代码也能够保证这一点； // 同时 node-\u003eleft_ 和 node-\u003eleft_-\u003eleft_ 都是黑色 FlipColors(h); if (isRed(h-\u003eright_-\u003eleft_)) { h-\u003eright_ = RotateRight(h-\u003eright_); h = RotateLeft(h); FlipColors(h); // 可以不加，等后续处理 } return h; } auto MoveRedRight(Node *h) -\u003e Node * { FlipColors(h); if (isRed(h-\u003eleft_-\u003eleft_)) { h = RotateRight(h); FlipColors(h); // 可以不加，等后续 FixUp 处理 } return h; } auto DelMin(Node *node) -\u003e Node * { if (node-\u003eleft_ == nullptr) { return nullptr; } if (!isRed(node-\u003eleft_) \u0026\u0026 !isRed(node-\u003eleft_-\u003eleft_)) { node = MoveRedLeft(node); } node-\u003eleft_ = DelMin(node-\u003eleft_); return FixUp(node); } auto DelMax(Node *h) -\u003e Node * { if (isRed(h-\u003eleft_)) { h = RotateRight(h); } if (h-\u003eright_ == nullptr) { return nullptr; } if (!isRed(h-\u003eright_) \u0026\u0026 !isRed(h-\u003eright_-\u003eleft_)) { // 之所以是判断 h-\u003eright_-\u003eleft_，是因为假如 h-\u003eright_ 是黑色，h-\u003eright_-\u003eleft_ 是红色 // 当我们遍历到 h-\u003eright_ 时，可以左旋 h-\u003eright_，一样可以满足条件； h = MoveRedRight(h); } h-\u003eright_ = DelMax(h-\u003eright_); return FixUp(h); } }; ","date":"2023-06-24","objectID":"/left-lean-red-black-tree.zh/:3:5","series":null,"tags":["data structure and algorithms"],"title":"左倾红黑树 （LLRB）","uri":"/left-lean-red-black-tree.zh/#完整实现"},{"categories":["notes"],"content":" 1 引入数装数组是一种支持单点修改和区间查询的数据结构。 这里的区间查询一般指求和。 普通树状数组维护的信息以及运算要满足结合律并且可以差分。 ","date":"2023-06-23","objectID":"/binary_index_tree.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"树状数组","uri":"/binary_index_tree.zh/#引入"},{"categories":["notes"],"content":" 2 定义考虑下标从 $1$ 开始的数组 $a[1]\\sim a[8]$，如下图所示： 我们可以发现： $c[2]$ 管辖 $\\sum\\limits_{i = 1}^2 a[i]$； $c[4]$ 管辖 $\\sum\\limits_{i = 1}^4 a[i]$； $c[6]$ 管辖 $\\sum\\limits_{i = 5}^6 a[i]$； $c[8]$ 管辖 $\\sum\\limits_{i = 1}^8 a[i]$； 即 $c[x]$ 管辖 $\\sum\\limits_{i = x - (x \\text{AND} -x) + 1}^x a[i]$。例如 $6\\text{AND}(-6) + 1 = 5$。 同时我们定义 $\\text{lowbit}(x) = x \\text{AND} -x$ ","date":"2023-06-23","objectID":"/binary_index_tree.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"树状数组","uri":"/binary_index_tree.zh/#定义"},{"categories":["notes"],"content":" 3 使用那么如何使用树状数组呢，第一步是初始化，我们先假定原数组也是下标从 $1$ 开始，从 $0$ 开始那么做相应变换即可。 ","date":"2023-06-23","objectID":"/binary_index_tree.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"树状数组","uri":"/binary_index_tree.zh/#使用"},{"categories":["notes"],"content":" 3.1 初始化我们先令 $c[i] = 0$，然后遍历 $a[j]$，每次遍历相当于是（假设原数组元素均为 $0$，然后将其值加上 $a[i]$），即初始化树状数组相当于是做了 $n$ 次单点修改。 cpp void build(vector\u003cint\u003e \u0026a, vector\u003cint\u003e \u0026c) { for (int i = 1; i \u003c a.size(); ++i) { update(i, c, a[i]); } } ","date":"2023-06-23","objectID":"/binary_index_tree.zh/:3:1","series":null,"tags":["data structure and algorithms"],"title":"树状数组","uri":"/binary_index_tree.zh/#初始化"},{"categories":["notes"],"content":" 3.2 单点修改每次修改 $i$ 处的值，只会影响到 $i$ 以及 $t = i + \\text{lowbit}(i)$，并令 $i = t$，如此循环。 cpp int lowbit(int x) { return x \u0026 (-x); } void update(int idx, vector\u003cint\u003e \u0026c, int val) { while (idx \u003c c.size()) { c[idx] += val; idx = idx + lowbit(idx); } } ","date":"2023-06-23","objectID":"/binary_index_tree.zh/:3:2","series":null,"tags":["data structure and algorithms"],"title":"树状数组","uri":"/binary_index_tree.zh/#单点修改"},{"categories":["notes"],"content":" 3.3 区间查询例如求 $[a, b]$ 之间的和。 cpp int getsum(vector\u003cint\u003e \u0026c, int idx) { int res = 0; while (idx \u003e 0) { res += c[idx]; idx = idx - lowbit(idx); } return res; } int getsum(vector\u003cint\u003e \u0026c, int a, int b) { return getsum(c, b) - getsum(a - 1); } ","date":"2023-06-23","objectID":"/binary_index_tree.zh/:3:3","series":null,"tags":["data structure and algorithms"],"title":"树状数组","uri":"/binary_index_tree.zh/#区间查询"},{"categories":["leetcode"],"content":" 1 Description354. Russian Doll Envelopes (Hard) You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope.   Example 1: Input: envelopes = [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =\u003e [5,4] =\u003e [6,7]). Example 2: Input: envelopes = [[1,1],[1,1],[1,1]] Output: 1   Constraints: 1 \u003c= envelopes.length \u003c= 105 envelopes[i].length == 2 1 \u003c= wi, hi \u003c= 105 ","date":"2023-06-23","objectID":"/354.russian-doll-envelopes/:1:0","series":null,"tags":["binary search"],"title":"354. Russian Doll Envelopes (Hard)","uri":"/354.russian-doll-envelopes/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe initial reaction to this problem is definitely sorting. The question is, should the second dimension be sorted in ascending or descending order? Firstly, let’s observe the question. It states that both dimensions must be strictly smaller. When I attempted the problem myself, I didn’t notice this point and got stuck for a while. However, once we consider this requirement, it becomes much clearer. Let’s assume we sort in ascending order based on the second dimension. When we choose $(w_i, h_i)$, we need to find the maximum $(w_j, h_j)$ that satisfies both dimensions being strictly smaller than $(w_i, h_i)$. This connects to the Longest Increasing Subsequence (LIS) problem. At this point, we realize that the second dimension should be sorted in descending order. By sorting in descending order, we can transform the problem into finding the LIS of the array composed of $h_i$ values. If the second dimension is sorted in ascending order, both $(4, 5)$ and $(4, 6)$ would be included in the LIS, which doesn’t meet the requirements of the problem. By sorting in descending order based on the second dimension, we can ensure that only one envelope with the same $w$ value is included in the LIS. ","date":"2023-06-23","objectID":"/354.russian-doll-envelopes/:2:0","series":null,"tags":["binary search"],"title":"354. Russian Doll Envelopes (Hard)","uri":"/354.russian-doll-envelopes/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int Bfind(vector\u003cint\u003e \u0026lis, int target, vector\u003cvector\u003cint\u003e\u003e \u0026envelopes, int right) { int left = 0; while (left \u003c right) { int mid = left + (right - left) / 2; if (lis[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return left; } int maxEnvelopes(vector\u003cvector\u003cint\u003e\u003e \u0026envelopes) { auto cmp = [](vector\u003cint\u003e \u0026vec1, vector\u003cint\u003e \u0026vec2) { if (vec1[0] == vec2[0]) { return vec1[1] \u003e= vec2[1]; } return vec1[0] \u003c vec2[0]; }; sort(envelopes.begin(), envelopes.end(), cmp); int n = envelopes.size(), ans = 0; vector\u003cint\u003e lis(n); for (int i = 0; i \u003c n; ++i) { int idx = Bfind(lis, envelopes[i][1], envelopes, ans); if (idx \u003e= ans) { ++ans; } lis[idx] = envelopes[i][1]; } return ans; } }; ","date":"2023-06-23","objectID":"/354.russian-doll-envelopes/:3:0","series":null,"tags":["binary search"],"title":"354. Russian Doll Envelopes (Hard)","uri":"/354.russian-doll-envelopes/#code"},{"categories":["leetcode"],"content":" 1 问题描述354. 俄罗斯套娃信封问题 (Hard) 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wᵢ, hᵢ] ，表示第 i 个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 注意：不允许旋转信封。 示例 1： text 输入：envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出：3 解释：最多信封的个数为 3, 组合为: [2,3] =\u003e [5,4] =\u003e [6,7]。 示例 2： text 输入：envelopes = [[1,1],[1,1],[1,1]] 输出：1 提示： 1 \u003c= envelopes.length \u003c= 10⁵ envelopes[i].length == 2 1 \u003c= wᵢ, hᵢ \u003c= 10⁵ ","date":"2023-06-23","objectID":"/354.russian-doll-envelopes.zh/:1:0","series":null,"tags":["binary search"],"title":"354. 俄罗斯套娃信封问题 (Hard)","uri":"/354.russian-doll-envelopes.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题的第一反应肯定是排序，按照第数组的第一个维度升序排序，问题在于，第二个维度是应该升序还是降序呢？ 首先，观察题目，题目要求是两个维度都必须严格小于才行，我自己做的时候就没观察到这一点，卡了很久，注意到这一点的话，其实就好想很多了。 我们先假设按照第二个升序排列，当我们选择了 $(w_i, h_i)$ 之后，那么我们就是要找满足 $(w_j, h_j)$ 两个维度都严格小于 $(w_i, h_i)$ 的最大的 $(w_j, h_j)$，这里就可以联系到 LIS 问题了。 到这里的话，就可以意识到应该按照第二维度降序排列了，因为按照第二维度降序排列的话，我们就可以完全转化成 $h_i$ 组成的数组的 LIS 问题了。 而如果是第二维度按照升序排列，那么 $(4, 5), (4, 6)$ 就都会选为 LIS 的一部分，与题目要求不符合。 按第二维度降序排列，能保证构成 LIS 时，相同的 $w$ 的信封只会有一个在 LIS 中。 ","date":"2023-06-23","objectID":"/354.russian-doll-envelopes.zh/:2:0","series":null,"tags":["binary search"],"title":"354. 俄罗斯套娃信封问题 (Hard)","uri":"/354.russian-doll-envelopes.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int Bfind(vector\u003cint\u003e \u0026lis, int target, vector\u003cvector\u003cint\u003e\u003e \u0026envelopes, int right) { int left = 0; while (left \u003c right) { int mid = left + (right - left) / 2; if (lis[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return left; } int maxEnvelopes(vector\u003cvector\u003cint\u003e\u003e \u0026envelopes) { auto cmp = [](vector\u003cint\u003e \u0026vec1, vector\u003cint\u003e \u0026vec2) { if (vec1[0] == vec2[0]) { return vec1[1] \u003e= vec2[1]; } return vec1[0] \u003c vec2[0]; }; sort(envelopes.begin(), envelopes.end(), cmp); int n = envelopes.size(), ans = 0; vector\u003cint\u003e lis(n); for (int i = 0; i \u003c n; ++i) { int idx = Bfind(lis, envelopes[i][1], envelopes, ans); if (idx \u003e= ans) { ++ans; } lis[idx] = envelopes[i][1]; } return ans; } }; ","date":"2023-06-23","objectID":"/354.russian-doll-envelopes.zh/:3:0","series":null,"tags":["binary search"],"title":"354. 俄罗斯套娃信封问题 (Hard)","uri":"/354.russian-doll-envelopes.zh/#代码"},{"categories":["notes"],"content":" 1 二叉搜索树二叉搜索树（Binary Search Tree，BST）是指一颗空树或者有下列性质的二叉树： 若任意节点的左子树不为空，那么左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不为空，那么右子树上所有节点的值均小于它的根节点的值； 任意节点的左、右子树也分别为二叉搜索树； 二叉树的定义是从一个递归的角度来定义的，验证二叉树其实很简单，即中序遍历二叉树，节点的值从严格递增。换言之，二叉搜索树也可以定义成中序遍历时节点值严格递增的二叉树。 ","date":"2023-06-23","objectID":"/bst.zh/:1:0","series":null,"tags":["tree","data structure and algorithms"],"title":"二叉搜索树","uri":"/bst.zh/#二叉搜索树"},{"categories":["notes"],"content":" 2 BST 的删除对树的定义，我们采取 Leetcode 中的定义： cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) { } TreeNode(int x) : val(x), left(nullptr), right(nullptr) { } TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) { } }; 首先，我们定义两个辅助函数 TreeNode *delMax(TreeNode *root, int key); 和 TreeNode *delMin(TreeNode *root, int key);，分别表示删除二叉树中的值最大的节点和值最小的节点。还需要辅助函数 int getMin(TreeNode *root); 和 int getMax(TreeNode *root)。 getMin 和 getMax 自不必多说，以 delMax 为例，都是利用递归进行处理，递归返回的是当前以 root 为根节点的树，删除了最大值之后的 root。递归终止条件即 root-\u003eright == nullptr，说明找到了树的最大值，此时返回 root-\u003eleft。（以避免左子树不为空的情况，左子树为空则相当于返回了 nulltpr） cpp int getMax(TreeNode *root) { if (root-\u003eright == nullptr) { return root-\u003eval; } return getMax(root-\u003eright); } int getMin(TreeNode *root) { // 不考虑空树的情况 if (root-\u003eleft == nullptr) { return root-\u003eval; } return getMin(root-\u003eleft); } TreeNode *delMax(TreeNode *root) { if (root == nullptr) { return root; } if (root-\u003eright == nullptr) { return root-\u003eleft; } root-\u003eright = delMax(root-\u003eright); return root; } TreeNode *delMin(TreeNode *root) { if (root == nullptr) { return root; } if (root-\u003eleft == nullptr) { return root-\u003eright; } root-\u003eleft = delMin(root-\u003eleft); return root; } 那么，有了这几个辅助函数之后，我们要如何处理 BST 的删除节点呢。还是递归进行处理，递归返回的是将以当前节点为根节点的树删除 key 对应节点之后的根节点 root。 如果 key 小于当前节点值，那么递归删除左子树； 如果 key 大于当前节点值，那么递归删除右子树； 如果 key 等于当前节点值，分两种情况讨论： 如果当前节点没有右子节点，那么返回当前节点的左子节点，即 return root-\u003eleft;，这样也能处理左子树也为空的情况； 如果当前节点的右子树不为空，那么我们将当前节点的值替换为右子树的最小值 val，val 相当于是满足 k \u003e key 的最小的 k，然后对该右子树，执行 delMin。 当然，碰到 key 等于当前节点值的情况时，我们考虑左子节点也是可以的，与考虑右子节点是对称的。 cpp TreeNode *del(int key, TreeNode *root) { if (root == nullptr) { return nullptr; } if (key \u003c root-\u003eval) { root-\u003eleft = del(key, root-\u003eleft); } else if (key \u003e root-\u003eval) { root-\u003eright = del(key, root-\u003eright); } else { // root-\u003eval == key if (root-\u003eright == nullptr) { // 没有右子树 return root-\u003eleft; } root-\u003eval = getMin(root-\u003eright); root-\u003eright = delMin(root-\u003eright); } return root; } ","date":"2023-06-23","objectID":"/bst.zh/:2:0","series":null,"tags":["tree","data structure and algorithms"],"title":"二叉搜索树","uri":"/bst.zh/#bst-的删除"},{"categories":["notes"],"content":" 3 BST 的时间复杂度分析我们知道，假设 BST 没有额外的限制，那么，最坏情况下，它可能退化成一个有序链表，此时插入和查找的时间复杂度为 $O(n)$。 而我们如果利用插入节点，从无到有构造一棵 BST，并且插入的节点的值都是随机的，那么这棵 BST 的最大深度是 $O(\\log n)$ 的（$n$ 为 BST 的节点数），即查找和插入的时间复杂度是 $O(\\log n)$ 的。 但如果，我们除了执行随机节点的插入之外，还执行随机删除，那么 BST 的最大深度就会变成 $O(\\sqrt n)$，即查找、插入、删除的时间复杂度变成了 $O(\\sqrt n)$。 ","date":"2023-06-23","objectID":"/bst.zh/:3:0","series":null,"tags":["tree","data structure and algorithms"],"title":"二叉搜索树","uri":"/bst.zh/#bst-的时间复杂度分析"},{"categories":["tutorial"],"content":" 1 Java 环境配置前往 Adoptium 下载他们预编译的 JDK 17（最新的 LTS 版本）的安装器，安装好之后，命令行执行 java -version，输出如下： sh openjdk version \"17.0.7\" 2023-04-18 OpenJDK Runtime Environment Temurin-17.0.7+7 (build 17.0.7+7) OpenJDK 64-Bit Server VM Temurin-17.0.7+7 (build 17.0.7+7, mixed mode) 说明环境变量已经自动配置好了。 同时前往 Jetbrains 官网下载 IntelliJ IDEA CE（懒得再申请教育优惠了），安装好之后打开，在 ~/Documets/zCode/Algs_4th/ 目录下创建名为 algs4 的新项目，JDK 选择我们安装的 JDK 17。如下图： ","date":"2023-06-22","objectID":"/algs4-java-mac-configure.zh/:1:0","series":null,"tags":["java","trick"],"title":"macOS 配置算法（第四版）的开发环境","uri":"/algs4-java-mac-configure.zh/#java-环境配置"},{"categories":["tutorial"],"content":" 2 algs4 配置先去书籍官网下载 algs4.jar，我这里直接放到了上面 IDEA 创建的项目的目录下，即 ~/Documets/zCode/Algs_4th/algs4/，然后用 IDEA 打开该项目，File-\u003eProject Structure-\u003eModules-\u003eDependencies 点击 Module SDK 下面的加号，选择 JARs or directories，再选择我们放在项目目录下的 algs4.jar 文件，然后就会看到 algs4.jar 已经被添加到该工程的 Dependencies 依赖包中，勾选，然后点击确定，就完成了环境的搭建。 ","date":"2023-06-22","objectID":"/algs4-java-mac-configure.zh/:2:0","series":null,"tags":["java","trick"],"title":"macOS 配置算法（第四版）的开发环境","uri":"/algs4-java-mac-configure.zh/#algs4-配置"},{"categories":["leetcode"],"content":" 1 Description741. Cherry Pickup (Hard) You are given an n x n grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through, 1 means the cell contains a cherry that you can pick up and pass through, or -1 means the cell contains a thorn that blocks your way. Return the maximum number of cherries you can collect by following the rules below: Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1). After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells. When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0. If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected.   Example 1: Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]] Output: 5 Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible. Example 2: Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]] Output: 0   Constraints: n == grid.length n == grid[i].length 1 \u003c= n \u003c= 50 grid[i][j] is -1, 0, or 1. grid[0][0] != -1 grid[n - 1][n - 1] != -1 ","date":"2023-06-21","objectID":"/741.cherry-pickup/:1:0","series":null,"tags":["dynamic programming"],"title":"741. Cherry Pickup (Hard)","uri":"/741.cherry-pickup/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem can be approached using dynamic programming, and although the concept is straightforward, there are several details to consider. The process of picking cherries back and forth is equivalent to two individuals moving from $[0, 0]$ to $[n - 1, n - 1]$. Let’s use $k$ to represent the number of steps taken, $x_1$ to represent the current $x$ coordinate of the first person, and $x_2$ to represent the current $x$ coordinate of the second person. The current coordinates of the first and second persons can be calculated as $k - x_1$ and $k - x_2$, respectively. $dp[k][x_1][x_2]$ represents the total number of cherries picked by the two persons after taking $k$ steps, with the first person at position $(x_1, k - x_1)$ and the second person at position $(x_2, k - x_2)$. The state $(k, x_1, x_2)$ can be reached from four possible previous states: $(k - 1, x_1 - 1, x_2)$, $(k - 1, x_1 - 1, x_2 - 1)$, $(k - 1, x_1, x_2)$, and $(k - 1, x_1, x_2 - 1)$. Based on this, we can establish the following recurrence relation: If $x_1 = x_2$, then $dp[k][x_1][x_2] = dp[k - 1][prex_1][prex_2] + grid[x_1][y_1]$. Otherwise, $dp[k][x_1][x_2] = dp[k - 1][prex_1][prex_2] + grid[x_1][y_1] + grid[x_2][y_2]$. $dp[k - 1][prex_1][prex_2]$ represents the maximum value among the four possible previous states. It’s important to note that if a thorny bush is encountered, $dp[k][x_1][x_2]$ should be set to $-\\infty$ instead of $0$ to indicate that the path is impassable. ","date":"2023-06-21","objectID":"/741.cherry-pickup/:2:0","series":null,"tags":["dynamic programming"],"title":"741. Cherry Pickup (Hard)","uri":"/741.cherry-pickup/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int cherryPickup(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { int n = grid.size(); vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e dp(2 * n + 1, vector\u003cvector\u003cint\u003e\u003e(n, vector\u003cint\u003e(n, INT_MIN))); vector\u003cvector\u003cint\u003e\u003e mov{{-1, 0}, {-1, -1}, {0, -1}, {0, 0}}; dp[0][0][0] = grid[0][0]; for (int i = 1; i \u003c= 2 * n - 2; ++i) { for (int x1 = 0; x1 \u003c= i \u0026\u0026 x1 \u003c n; ++x1) { for (int x2 = 0; x2 \u003c= x1 \u0026\u0026 x2 \u003c n; ++x2) { int y1 = i - x1, y2 = i - x2; if (y1 \u003c 0 || y1 \u003e= n || y2 \u003c 0 || y2 \u003e= n) { continue; } if (grid[x1][i - x1] == -1 || grid[x2][i - x2] == -1) { dp[i][x1][x2] = INT_MIN; continue; } int tmp = INT_MIN; // tmp must be -infty for (int j = 0; j \u003c 4; ++j) { int prex1 = x1 + mov[j][0], prey1 = i - 1 - prex1; int prex2 = x2 + mov[j][1], prey2 = i - 1 - prex2; if (prex1 \u003c 0 || prex1 \u003e= n || prey1 \u003c 0 || prey1 \u003e= n || prex2 \u003c 0 || prex2 \u003e= n || prey2 \u003c 0 || prey2 \u003e= n) { continue; } if (grid[prex1][prey1] == -1 || grid[prex2][prey2] == -1) { continue; } tmp = max(tmp, dp[i - 1][prex1][prex2]); } if (x1 == x2) { dp[i][x1][x2] = max(dp[i][x1][x2], tmp + grid[x1][i - x1]); } else { dp[i][x1][x2] = max(dp[i][x1][x2], tmp + grid[x1][i - x1] + grid[x2][i - x2]); } } } } return max(dp[2 * n - 2][n - 1][n - 1], 0); } }; ","date":"2023-06-21","objectID":"/741.cherry-pickup/:3:0","series":null,"tags":["dynamic programming"],"title":"741. Cherry Pickup (Hard)","uri":"/741.cherry-pickup/#code"},{"categories":["leetcode"],"content":" 1 问题描述741. 摘樱桃 (Hard) 给你一个 n x n 的网格 grid ，代表一块樱桃地，每个格子由以下三种数字的一种来表示： 0 表示这个格子是空的，所以你可以穿过它。 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 -1 表示这个格子里有荆棘，挡着你的路。 请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数： 从位置 (0, 0) 出发，最后到达 (n - 1, n - 1) ，只能向下或向右走，并且只能穿越有效的格子（即只可 以穿过值为 0 或者 1 的格子）； 当到达 (n - 1, n - 1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的 格子； 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 0 ）； 如果在 (0, 0) 和 (n - 1, n - 1) 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。 示例 1： text 输入：grid = [[0,1,-1],[1,0,-1],[1,1,1]] 输出：5 解释：玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。 在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。 然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。 总共捡到 5 个樱桃，这是最大可能值。 示例 2： text 输入：grid = [[1,1,-1],[1,-1,1],[-1,1,1]] 输出：0 提示： n == grid.length n == grid[i].length 1 \u003c= n \u003c= 50 grid[i][j] 为 -1、 0 或 1 grid[0][0] != -1 grid[n - 1][n - 1] != -1 ","date":"2023-06-21","objectID":"/741.cherry-pickup.zh/:1:0","series":null,"tags":["dynamic programming"],"title":"741. 摘樱桃 (Hard)","uri":"/741.cherry-pickup.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路这题从思路上说，其实是一道比较常规的 DP。但是要处理的细节很多。 一来一回取樱桃，其实就相当于两个人分别从 $[0, 0]$ 到 $[n - 1, n - 1]$。 我们以 $k$ 表示走的步数，$x1$ 表示第一个人当前的 $x$ 轴坐标，$x2$ 表示第二个人当前的 $x$ 轴坐标，第一个人当前坐标即 $k - x_1$，第二个人是 $k - x_2$。 $dp[k][x_1][x_2]$ 表示两个人各走了 $k$ 步，分别走到 $(x_1, k - x_1)$ 处和 $(x_2, k - x_2)$ 处摘得的樱桃。 $(k, x_1, x_2)$ 可能从 $(k - 1, x_1 - 1, x_2), (k - 1, x_1 - 1, x_2 - 1), (k - 1, x_1, x_2), (k - 1, x_1, x_2 - 1)$ 这四种情况转移过来，因此，考虑转移方程： 如果 $x_1 = x_2$，则 $dp[k][x_1][x_2] = dp[k - 1][prex_1][prex_2] + grid[x_1][y_1]$； 否则，$dp[k][x_1][x_2] = dp[k - 1][prex_1][prex_2] + grid[x_1][y_1] + grid[x_2][y_2]$； $dp[k - 1][prex_1][prex_2]$ 是上述四种情况的最大值，注意，如果碰到荆棘应该取 $dp[k][x_1][x_2] = -\\infty$ 而不是 $0$，以表示不能通过。 ","date":"2023-06-21","objectID":"/741.cherry-pickup.zh/:2:0","series":null,"tags":["dynamic programming"],"title":"741. 摘樱桃 (Hard)","uri":"/741.cherry-pickup.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int cherryPickup(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { // dp[k][x1][x2] 表示两点分别从 (x1, k - x1) 和 (x2, k - x2) 出发所能收集到的最多樱 int n = grid.size(); vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e dp(2 * n + 1, vector\u003cvector\u003cint\u003e\u003e(n, vector\u003cint\u003e(n, INT_MIN))); vector\u003cvector\u003cint\u003e\u003e mov{{-1, 0}, {-1, -1}, {0, -1}, {0, 0}}; dp[0][0][0] = grid[0][0]; for (int i = 1; i \u003c= 2 * n - 2; ++i) { for (int x1 = 0; x1 \u003c= i \u0026\u0026 x1 \u003c n; ++x1) { for (int x2 = 0; x2 \u003c= x1 \u0026\u0026 x2 \u003c n; ++x2) { int y1 = i - x1, y2 = i - x2; if (y1 \u003c 0 || y1 \u003e= n || y2 \u003c 0 || y2 \u003e= n) { continue; } if (grid[x1][i - x1] == -1 || grid[x2][i - x2] == -1) { dp[i][x1][x2] = INT_MIN; continue; } int tmp = INT_MIN; // 这里 tmp 也必须取无穷小 for (int j = 0; j \u003c 4; ++j) { int prex1 = x1 + mov[j][0], prey1 = i - 1 - prex1; int prex2 = x2 + mov[j][1], prey2 = i - 1 - prex2; if (prex1 \u003c 0 || prex1 \u003e= n || prey1 \u003c 0 || prey1 \u003e= n || prex2 \u003c 0 || prex2 \u003e= n || prey2 \u003c 0 || prey2 \u003e= n) { continue; } if (grid[prex1][prey1] == -1 || grid[prex2][prey2] == -1) { continue; } tmp = max(tmp, dp[i - 1][prex1][prex2]); } if (x1 == x2) { dp[i][x1][x2] = max(dp[i][x1][x2], tmp + grid[x1][i - x1]); } else { dp[i][x1][x2] = max(dp[i][x1][x2], tmp + grid[x1][i - x1] + grid[x2][i - x2]); } } } } return max(dp[2 * n - 2][n - 1][n - 1], 0); } }; ","date":"2023-06-21","objectID":"/741.cherry-pickup.zh/:3:0","series":null,"tags":["dynamic programming"],"title":"741. 摘樱桃 (Hard)","uri":"/741.cherry-pickup.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1595. Minimum Cost to Connect Two Groups of Points (Hard) You are given two groups of points where the first group has size1 points, the second group has size2 points, and size1 \u003e= size2. The cost of the connection between any two points are given in an size1 x size2 matrix where cost[i][j] is the cost of connecting point i of the first group and point j of the second group. The groups are connected if each point in both groups is connected to one or more points in the opposite group. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group. Return the minimum cost it takes to connect the two groups.   Example 1: Input: cost = [[15, 96], [36, 2]] Output: 17 Explanation: The optimal way of connecting the groups is: 1--A 2--B This results in a total cost of 17. Example 2: Input: cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]] Output: 4 Explanation: The optimal way of connecting the groups is: 1--A 2--B 2--C 3--A This results in a total cost of 4. Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost. Example 3: Input: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]] Output: 10   Constraints: size1 == cost.length size2 == cost[i].length 1 \u003c= size1, size2 \u003c= 12 size1 \u003e= size2 0 \u003c= cost[i][j] \u003c= 100 ","date":"2023-06-21","objectID":"/1595.minimum-cost-to-connect-two-groups-of-points/:1:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1595. Minimum Cost to Connect Two Groups of Points] (Hard)","uri":"/1595.minimum-cost-to-connect-two-groups-of-points/#description"},{"categories":["leetcode"],"content":" 2 SolutionDynamic Programming + State Compression We use a binary number $j$ to represent the set of chosen elements from the second group. $dp[i][j]$ denotes the minimum cost of connecting the first $i$ elements from the first group and the set of elements $j$ from the second group. To establish the recurrence relation, we consider the elements from the first group. Let’s focus on the $i$-th element and iterate through the elements $k$ in the set (where $k$ represents the element index). We encounter the following scenarios: The $i$-th element is only connected to $k$. In this case, we have two possibilities: The element in the second group with index $k$ is solely connected to the $i$-th element: $dp[i][j] = \\min(dp[i][j], dp[i - 1][j\\oplus(1 « k)] + \\text{cost}[i - 1][k])$. The element in the second group with index $k$ is connected to other elements as well: $dp[i][j] = \\min(dp[i][j], dp[i - 1][j] + \\text{cost}[i - 1][k])$. The $i$-th element is connected to elements other than $k$. In this case, we also have two possibilities: The element in the second group with index $k$ is solely connected to the $i$-th element: $dp[i][j] = \\min(dp[i][j], dp[i][j\\oplus (1 « k)] + \\text{cost}[i - 1][k])$. The element in the second group with index $k$ is connected to other elements besides the $i$-th element. At this point, the $i$-th element does not need to be connected to the element with index $k$ anymore. Thus, we can eliminate the unnecessary edge. If we forcibly connect the $i$-th element and element $k$, redundant edges will be introduced. Therefore, we consider the aforementioned three cases by enumerating $k_1$, $k$, or $k_2$. Please note that each time we iterate through $k$, we need to compare it with the previously calculated $dp[i][j]$! Additionally, if the condition in the for loop is not satisfied, the loop will terminate. ","date":"2023-06-21","objectID":"/1595.minimum-cost-to-connect-two-groups-of-points/:2:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1595. Minimum Cost to Connect Two Groups of Points] (Hard)","uri":"/1595.minimum-cost-to-connect-two-groups-of-points/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int connectTwoGroups(vector\u003cvector\u003cint\u003e\u003e \u0026cost) { int m = cost.size(), n = cost[0].size(); vector\u003cvector\u003cint\u003e\u003e dp(m + 1, vector\u003cint\u003e(1 \u003c\u003c n, INT_MAX)); dp[0][0] = 0; for (int i = 1; i \u003c= m; ++i) { for (int j = 1; j \u003c (1 \u003c\u003c n); ++j) { for (int k = 0; (1 \u003c\u003c k) \u003c= j; ++k) { if (((1 \u003c\u003c k) \u0026 j) == 0) { continue; } int tmp = min(dp[i][j ^ (1 \u003c\u003c k)], min(dp[i - 1][j ^ (1 \u003c\u003c k)], dp[i - 1][j])) + cost[i - 1][k]; dp[i][j] = min(tmp, dp[i][j]); } } } return dp[m][(1 \u003c\u003c n) - 1]; } }; ","date":"2023-06-21","objectID":"/1595.minimum-cost-to-connect-two-groups-of-points/:3:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1595. Minimum Cost to Connect Two Groups of Points] (Hard)","uri":"/1595.minimum-cost-to-connect-two-groups-of-points/#code"},{"categories":["leetcode"],"content":" 1 问题描述1595. 连通两组点的最小成本 (Hard) 给你两组点，其中第一组中有 size₁ 个点，第二组中有 size₂ 个点，且 size₁ \u003e= size₂ 。 任意两点间的连接成本 cost 由大小为 size₁ x size₂ 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。 如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是 连通的。 换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一 组中的一个点连接。 返回连通两组点所需的最小成本。 示例 1： text 输入：cost = [[15, 96], [36, 2]] 输出：17 解释：连通两组点的最佳方法是： 1--A 2--B 总成本为 17 。 示例 2： text 输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]] 输出：4 解释：连通两组点的最佳方法是： 1--A 2--B 2--C 3--A 最小成本为 4 。 请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需 要关心最低总成本。 示例 3： text 输入：cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]] 输出：10 提示： size₁ == cost.length size₂ == cost[i].length 1 \u003c= size₁, size₂ \u003c= 12 size₁ \u003e= size₂ 0 \u003c= cost[i][j] \u003c= 100 ","date":"2023-06-21","objectID":"/1595.minimum-cost-to-connect-two-groups-of-points.zh/:1:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1595. 连通两组点的最小成本 (Hard)","uri":"/1595.minimum-cost-to-connect-two-groups-of-points.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路动态规划 + 状态压缩 我们用二进制数 $j$ 表示对第二组选择的元素的集合，dp[i][j] 表示对第一组的前 $i$ 个数组成的的集合，以及第二组中元素的集合 $j$，这两个集合的最小联通成本。 那么如何思考递推关系呢，对第一组的元素，我们考虑第 $i$ 个元素，同时枚举集合中的元素 $k$，（$k$ 表示元素索引），那么有以下几种情况： 第 $i$ 个元素只与 $k$ 相连，那么可以分两种情况： 第二组索引为 $k$ 的元素只与第 $i$ 个元素相连：$dp[i][j] = min(dp[i][j], dp[i - 1][j\\oplus(1 « k)] + cost[i - 1][k])$； 第二组索引为 $k$ 的元素不只与第 $i$ 个元素相连：$dp[i][j] = min(dp[i][j], dp[i - 1][j] + cost[i - 1][k])$； 第 $i$ 个元素不只与 $k$ 相连，那么可以再分两种情况。 第二组的索引为 $k$ 的元素只与第 $i$ 个元素相连：$dp[i][j] = min(dp[i][j], dp[i][j\\oplus (1 « k)] + cost[i - 1][k])$； 第二组的索引为 $k$ 的元素与除了第 $i$ 个元素之外的其他元素也相连，那么这时候第 $i$ 个元素不需要与索引为 $k$ 的元素相连了，因此不用考虑，假设强行连接第 $i$ 个元素和元素 $k$，那么必然会出现多余的边，去掉多余的边，则情况变成了枚举 $k_1$ 或者 $k$ 或者 $k2$ 的上述三种情况了。 注意每次枚举 $k$ 时，都要与之前计算过的 $dp[i][j]$ 进行比较！同时 for 循环中一旦出现不满足判断条件了情况，就会终止循环了！ ","date":"2023-06-21","objectID":"/1595.minimum-cost-to-connect-two-groups-of-points.zh/:2:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1595. 连通两组点的最小成本 (Hard)","uri":"/1595.minimum-cost-to-connect-two-groups-of-points.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int connectTwoGroups(vector\u003cvector\u003cint\u003e\u003e \u0026cost) { int m = cost.size(), n = cost[0].size(); vector\u003cvector\u003cint\u003e\u003e dp(m + 1, vector\u003cint\u003e(1 \u003c\u003c n, INT_MAX)); dp[0][0] = 0; // dp[i][j] 表示前 i 个点与集合 j 的最小值 // 对点 i - 1，枚举集合 j 中的点 k，如果 k 只与点 i - 1 相连，dp[i][j] = dp[i][j\\k] + cost[i - 1][k]; // 如果点 i - 1 只与 k 相连，那么 dp[i][j] = min(dp[i - 1][j\\k], dp[i - 1][j]) + cost[i - 1][k] for (int i = 1; i \u003c= m; ++i) { for (int j = 1; j \u003c (1 \u003c\u003c n); ++j) { for (int k = 0; (1 \u003c\u003c k) \u003c= j; ++k) { if (((1 \u003c\u003c k) \u0026 j) == 0) { continue; } int tmp = min(dp[i][j ^ (1 \u003c\u003c k)], min(dp[i - 1][j ^ (1 \u003c\u003c k)], dp[i - 1][j])) + cost[i - 1][k]; dp[i][j] = min(tmp, dp[i][j]); } } } return dp[m][(1 \u003c\u003c n) - 1]; } }; ","date":"2023-06-21","objectID":"/1595.minimum-cost-to-connect-two-groups-of-points.zh/:3:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1595. 连通两组点的最小成本 (Hard)","uri":"/1595.minimum-cost-to-connect-two-groups-of-points.zh/#代码"},{"categories":["notes"],"content":" 1 动态内存分配器进程中名为 heap 的 VM area 就是由动态内存分配器（dynamic memory allocator）来维护的。Heap 会向高地址（向上）增长。对每个进程，内核维护着一个名为 brk 的变量，该变量指向 Heap 的顶部，如下图所示： Allocator 将 Heap 视为一组不同大小的 block 组成的集合来维护。这里 block 和 chunk 的概念是等价的，该 block 要么是已分配的（allocated），要么是空闲的（free）。 Each block is a contiguous chunk of virtual memory that is either allocated or free. Allocator 可以分为显式分配器（explicit allocator）和隐式分配器（implicit allocator）。 显示分配器要求应用显示地释放任何已分配的块，分配也需要手动分配。例如 C 中的 malloc 和 free，C++ 中的 new 和 delete； 隐式分配器又被称为垃圾收集（garbage collection），例如 Java、C#。 ","date":"2023-06-20","objectID":"/linux_memory_allocate.zh/:1:0","series":null,"tags":["csapp"],"title":"Linux 动态内存分配","uri":"/linux_memory_allocate.zh/#动态内存分配器"},{"categories":["notes"],"content":" 2 malloc 和 free$32$ 位系统中，malloc 返回的地址总是 $8$ 的倍数，即 malloc 返回的地址的最低三位总是 $0$，亦即 malloc 分配的 block 至少占据 $8$ 的倍数个 byte；而 $64$ 位系统中，malloc 返回的地址总是 $16$ 的倍数。 即 $32$ 系统中，malloc 分配内存是 $8$ 字节对齐的；$64$ 位系统中，malloc 分配内存是 $16$ 字节对齐的。 ","date":"2023-06-20","objectID":"/linux_memory_allocate.zh/:2:0","series":null,"tags":["csapp"],"title":"Linux 动态内存分配","uri":"/linux_memory_allocate.zh/#malloc-和-free"},{"categories":["notes"],"content":" 3 Allocator 的设计要求和目标显式分配器必须在一些相当严格的约束条件下也能正常工作： 处理任意请求序列：不能假设所有分配都有相匹配的释放请求等； 立即响应请求：不允许分配器为了提高性能重新排列或者缓冲请求； 只使用 Heap 对齐（aligning） block：$32$ 位系统 $8$ 字节对齐，$64$ 位系统 $16$ 字节对齐； 不允许修改已分配的 block：一旦 block 被分配就不允许修改或者移动，除非被释放（free）； 同时我们希望设计的分配器能最大化内存利用率并最大化吞吐率（即每秒能完成的分配或者释放请求数量）。 ","date":"2023-06-20","objectID":"/linux_memory_allocate.zh/:3:0","series":null,"tags":["csapp"],"title":"Linux 动态内存分配","uri":"/linux_memory_allocate.zh/#allocator-的设计要求和目标"},{"categories":["notes"],"content":" 4 碎片（Fragmentation）碎片分为内部碎片（internal fragmentation）和外部碎片（external fragmentation）。 内部碎片即要分配的 $size$ 只占分配的 $block size$ 的一部分的情况，例如分配一个 $2$ 字节的空间，由于要求至少 $8$ 字节对齐，那么必然有一部分用不到的空间为了满足对齐要求也被分配了出来。 外部碎片即空闲的空间总和大于要分配的 $size$，但是没有一个单独的 $block$ 的 $size$ 大到可以处理该分配请求。 ","date":"2023-06-20","objectID":"/linux_memory_allocate.zh/:4:0","series":null,"tags":["csapp"],"title":"Linux 动态内存分配","uri":"/linux_memory_allocate.zh/#碎片fragmentation"},{"categories":["notes"],"content":" 5 分配器实现分配器实现过程中，我们需要考虑以下问题： 空闲 block 组织：如何记录空闲 block？ 放置：如何选择一个合适的空闲 block来放置一个新分配的 block？ 分割：将一个新分配的块放置到某个空闲 block 之后，如何处理空闲 block 的剩余部分？ 合并：如何处理一个刚刚释放的 block（例如前或者后也有 free 的 block 呢）？ ","date":"2023-06-20","objectID":"/linux_memory_allocate.zh/:5:0","series":null,"tags":["csapp"],"title":"Linux 动态内存分配","uri":"/linux_memory_allocate.zh/#分配器实现"},{"categories":["notes"],"content":" 6 隐式空闲链表一般来说，allocator 需要一些数据结构，从而区分 block 的边界并区分 allocated block 和 free block。大多数的 allocator 将信息嵌入这个块本身，就像 elf 文件有一个 elf header 一样，block 中也会有一个 header，存储了该 block 是否空闲，占据的空间 size 等信息。 假设 malloc 返回的指针是 p，由于 header 占据了 $32$ 个字节，header 本身是 uint32_t 类型的。那么 block 的起始地址 start： cpp uint64_t start = (uint64_t)p - 4; // block 的起始地址 uint32_t header_val = *((uint32_t *)start); // header 的值 int allocated = header_val \u0026 0x1; // 为 1 表示已分配，为 0 表示块仍然是空闲的 int size = header_val \u0026 0xfffffffe; // 即将 header_val 的最后一位置 0 这种结构被称为隐式空闲链表，我们可以利用 block 的 header_val 中的 size 找到下一个块：next = (uint64_t)start + size; 隐式空闲链表的主要优点是简单，缺点则是：任何操作都可能需要遍历 heap 中的所有 block，时间复杂度是 $O(n)$ 的，此外还有个缺点是可能造成内部碎片。 ","date":"2023-06-20","objectID":"/linux_memory_allocate.zh/:6:0","series":null,"tags":["csapp"],"title":"Linux 动态内存分配","uri":"/linux_memory_allocate.zh/#隐式空闲链表"},{"categories":["notes"],"content":" 7 显式空闲链表（Explicit Free List）显式空闲链表是组织所有 free block 的显示数据结构，相比隐式空闲链表，显式空闲链表的每个空闲块中，都包含一个 pred（前驱）和 succ（后继）指针：如下图所示： pred 和 succ 各占 $4bytes$。 在使用显式空闲链表后，首次适配（First fit）（即第一次找到大小满足的 free block），所需时间从 block 总数的线性时间减少到了 free block 数量的线性时间。释放一个 allocated block 所需时间也可以是常数的。 ","date":"2023-06-20","objectID":"/linux_memory_allocate.zh/:7:0","series":null,"tags":["csapp"],"title":"Linux 动态内存分配","uri":"/linux_memory_allocate.zh/#显式空闲链表explicit-free-list"},{"categories":["notes"],"content":" 7.1 分离的空闲链表（Segregated Free List） – 分离适配分配器维护着一个空闲链表的数组，每个空闲链表是和一个大小类（size class）相关联的， ","date":"2023-06-20","objectID":"/linux_memory_allocate.zh/:7:1","series":null,"tags":["csapp"],"title":"Linux 动态内存分配","uri":"/linux_memory_allocate.zh/#分离的空闲链表segregated-free-list----分离适配"},{"categories":["notes"],"content":" 1 Linux 虚拟内存系统首先，对 Linux 的虚拟内存系统做一个概述，以了解一个实际的操作系统是如何组织虚拟内存，以及如何处理缺页（page fault）的。 Linux 位为每个进程维护了一个单独的虚拟地址空间，形式如下： 可以看到，虚拟地址空间可以分为内核虚拟内存空间和用户虚拟内存空间两部分，实际上，$64$ 位系统的虚拟空间划分是这样的： 我们可以看到，在用户内存空间和内核内存空间之间还有一大片的“未定义”的区域，这是为什么呢？（注意，后续图片将有灵魂画手出没！）。 之前我们提到，AMD 制定的 $64$ 位 CPU 架构时，虽然是 $64$ 位的，即总的虚拟地址空间是 $64$ 位的，但实际上，用到的虚拟地址其实只有其中的低 $48$ 位。 当我们把 addr_val 解释为一个虚拟地址时，我们使用的真正的虚拟地址，其实只有它的低 $48$ 位，（由 AMD 设计 CPU 架构的时候规定，其实 $48$ 位也完全够用了），后 $16$ 位的值会与 addr_val 的第 $47$ 位保持一致（全 $0$ 或者全 $1$），全 $0$ 表示该虚拟地址处于当前虚拟地址空间的用户态部分，全 $1$ 表示处于内核态部分。 换言之，虚拟地址的高 $16$ 位是由 CPU 在生成要访问的虚拟地址时，先生成低 $48$ 位的虚拟地址，再根据第 $47$ 位的值是 $0$ 还是 $1$，判断地址属于内核虚拟地址空间还是用户虚拟地址空间（或者说进程虚拟地址空间），再生成虚拟地址的高 $16$ 位。 如下图所示： ","date":"2023-06-18","objectID":"/linux_virtual_memory.zh/:1:0","series":null,"tags":["csapp","linux"],"title":"Linux 虚拟内存系统","uri":"/linux_virtual_memory.zh/#linux-虚拟内存系统"},{"categories":["notes"],"content":" 2 Linux 虚拟内存区域（area） Linux organizes the virtual memory as a collection of areas (also called segments). An area is a contiguous chunk of existing (allocated) virtual memory whose pages are related in some way. For example, the code segment, data segment, heap, shared library segment, and user stack are all distinct areas. 已分配的虚拟页必然存在于某个 area 中，换言之，不存在于任一 area 的虚拟页是不存在的，对应的虚拟地址是非法的！Heap 中可能存在有多个 area，这些 area 对应的 VP 都是堆上动态创建的数据的虚拟地址对应的 VP。 area 的存在，说明 Linux 系统允许虚拟地址空间有间隙，不存在的虚拟页不会占用内存、磁盘或者内核的任何额外资源。 下图是一个内核用来记录进程的虚拟内存区域的数据结构，这个数据结构存在于内核虚拟内存空间中。 内核为系统中的每一个进程维护一个单独的 task_struct，task_struct 中的元素包含或者指向（即为指针）内核运行该进程所需要的所有信息（例如 PID、指向用户栈的指针、可执行目标文件的名字以及程序计数器 PC 等）。 task_struct 中的一个条目指向 mm_struct，mm_struct 描述了该进程的当前虚拟内存的状态，mm_struct 包含 pgd 和 mmap 两个字段，pgd 指向 PGD 的基地址，而 mmap 指向一个 vm_area_structs 的链表，该链表的每个 vm_area_struct 都描述了当前虚拟地址空间中的一个区域，一个 vm_area_struct 包含以下字段： vm_start：指向该区域的起始地址（应该是虚拟地址）； vm_end：指向该区域的结束处的地址； vm_prot：描述该区域包含的所有 VP 的读写许可权限； vm_flags：描述这个区域内的页面是与其他进程共享的，还是这个进程私有的（还描述了一些其他的信息）； vm_next：指向链表中下一个区域结构； 到这里，我们其实可以大致猜想进程的上下文切换时会发生什么，假设单核 CPU，从进程 $1$ 切换到进程 $2$，那么内核就会将 task_struct2 的 pgd 存放在当前 CPU 的 CR3 中，同时将 CPU 的 rip 寄存器更新为 task_struct2 中的 PC。 ","date":"2023-06-18","objectID":"/linux_virtual_memory.zh/:2:0","series":null,"tags":["csapp","linux"],"title":"Linux 虚拟内存系统","uri":"/linux_virtual_memory.zh/#linux-虚拟内存区域area"},{"categories":["notes"],"content":" 3 Linux 缺页异常处理假设 MMU 要翻译某个 vaddr，触发了一个 page fault。这个异常会导致控制转移到内核的缺页处理程序，处理程序随后会执行以下步骤： vaddr 是否合法，即 vaddr 对应的 VP 是否存在于该进程的某个 area 中？因此缺页处理程序需要搜索 vm_areas_structs 链表，把 vaddr 和每个 vm_area_struct 的 vm_start 和 vm_end 进行比较，如果 vm_start \u003c= vaddr \u003c vm_end，那么说明该 vaddr 属于该 vm_area_struct 对应的 area，否则说明不属于。缺页处理程序会触发一个段错误，下图中标识为“1”，从而终止该进程； 由于一个进程可以创建任意数量的 area，利用（mmap），所以实际上 Linux 对各个 area 构建了一棵 红黑树（RB-Tree），在这棵树上查找 vm_area_struct。类比 C++ STL 中的 map。 假设 vaddr 合法，访问该 vaddr 是否合法，即该进程是否有权限？如果没有权限，例如不能写，或者用户进程试图访问内核虚拟内存，缺页处理程序会触发一个保护异常，从而终止该进程，下图中被标识为“2”； 正常缺页：选择一个 victim page，如果该 victim page 为 dirty，就执行 swap_out 换出该 page，然后执行 swap_in 换入新的 page 并更新 PTE，然后缺页处理程序返回，CPU 重新执行导致缺页的指令，即读取 vaddr。 ","date":"2023-06-18","objectID":"/linux_virtual_memory.zh/:3:0","series":null,"tags":["csapp","linux"],"title":"Linux 虚拟内存系统","uri":"/linux_virtual_memory.zh/#linux-缺页异常处理"},{"categories":["notes"],"content":" 4 内存映射（Memory Mapping）许多进程包含同样的只读代码区域，例如，每个 C 程序都需要来自标准 C 库的诸如 printf 这样的函数，如果每个进程都在物理内存中存放这些常用代码的副本，那就是对内存的极大浪费。内存映射提供了一种用于控制多个进程如何共享对的象清晰的机制。 Linux 通过将一个磁盘上的对象（object）与一个 virtual memory area 关联起来，以初始化这个 virtual memory area，这个过程被称为内存映射（memory mapping）。 VM area 可以映射到两种文件类型的对象中的一种（Areas can be mapped to one of two types of objects）。（这里的映射我觉得翻译成关联似乎更合适） Regualr file in the Linux file system：一个 VM area 被关联到一个 disk 的连续部分，例如一个可执行目标文件。File section 被划分成 VP 大小的的 pieces，每个 piece 包含一个 VP 的初始内容。这个 VP 就被称为 file-backed page。因此，文件的内容可以像内存一样被访问和操作，按需进行页面调度，这些 VP 在被 CPU 第一次引用之前，并没有被 swap_in 到物理内存中去。 Anonymous file：一个 VM area 也可以被映射到一个匿名文件，这个 VM area 中的 page 就被称为匿名页（Anonymous page）。当 CPU 第一次访问这个匿名页时，内核在物理内存中找一个合适的 victim page，如果 victim page 是 dirty 的，就将该 victim page 执行 swap_out，然后将该 PP 全置为 $0x0$，然后将 CPU 访问的这个 VP 对应的 PTE 的 pte-\u003epresent 置为 $1$，说明该 VP 在物理内存中有对应的 PP 了。 ","date":"2023-06-18","objectID":"/linux_virtual_memory.zh/:4:0","series":null,"tags":["csapp","linux"],"title":"Linux 虚拟内存系统","uri":"/linux_virtual_memory.zh/#内存映射memory-mapping"},{"categories":["notes"],"content":" 5 内存反向映射（Reversed Mapping）内存反向映射其实主要要解决三个问题： 当我们把一个 PP 换出到磁盘（swap space） 时，我们要如何找到这个 PP 对应的 VP，从而更新该 VP 的 PTE 的 pte-\u003epresent，并且 这个 PP 要换出到磁盘的何处； 当发生缺页中断后，要将 VP 对应的 PP 从磁盘（swap space）中 swap_in 到内存时，我们如何找到这个存在于磁盘中的 “VP 对应的 PP”； 这里说的内存反向映射其实就是从 PP 到 VP 的一个映射： 在 yangminz 给出的 swap 和内存反向映射的简单 实现 中，添加了一个额外的 PP Descriptor 数据结构 pd_t，同时 pte4_t 中也添加了一个 daddr 字段，表示物理页要换出时，会换出到磁盘何处。 cpp typedef union { uint64_t pte_value; struct { uint64_t present : 1; // present = 1 uint64_t readonly : 1; uint64_t usermode : 1; uint64_t writethough : 1; uint64_t cachedisabled : 1; uint64_t reference : 1; uint64_t dirty : 1; // dirty bit - 1: dirty; 0: clean uint64_t zero7 : 1; uint64_t global : 1; uint64_t unused9_11 : 3; uint64_t ppn : 40; uint64_t unused52_62 : 10; uint64_t xdisabled : 1; }; struct { uint64_t _present : 1; // present = 0 uint64_t daddr : 63; // disk address }; } pte4_t; // PT // physical page descriptor typedef struct { int allocated; int dirty; int time; // LRU cache // real world: mapping to anon_vma or address_space // we simply the situation here // TODO: if multiple processes are using this page? E.g. Shared library pte4_t *pte4; // the reversed mapping: from PPN to page table entry uint64_t daddr; // binding the revesed mapping with mapping to disk } pd_t; pd_t page_map[MAX_NUM_PHYSICAL_PAGE]; 由这个数据结构，我们可以很容易的找到 PP 对应的 VP，毕竟 pd_t 中有 pte4_t *pte4 字段。 执行 swap_out 时，我们以 PP 的 daddr 作为实参执行 swap_out(page_map[ppn].daddr, ppn);，然后我们更新 victim pte 的字段内容，将 PP 的 daddr 赋给 victim-\u003eaddr，并更新 victim-\u003epresent = 0，表示该页表项对应的 VP 在物理内存中没有对应的 PP。然后执行 swap_in，pte-\u003edaddr 表示要换入的磁盘中的 PP 在磁盘中的地址，执行 swap_in(pte-\u003edaddr, ppn)。然后更新 PP 的 daddr 为新换入的磁盘中的 PP 的 daddr。 cpp static void page_fault_handler(pte4_t *pte, address_t vaddr) { // select one victim physical page to swap to disk assert(pte-\u003epresent == 0); // this is the selected ppn for vaddr int ppn = -1; pte4_t *victim = NULL; uint64_t daddr = 0xffffffffffffffff; // 3. no free nor clean physical page: select one LRU victim // write back (swap out) the DIRTY victim to disk lru_ppn = -1; lru_time = -1; for (int i = 0; i \u003c MAX_NUM_PHYSICAL_PAGE; ++ i) { if (lru_time \u003c page_map[i].time) { lru_time = page_map[i].time; lru_ppn = i; } } assert(0 \u003c= lru_ppn \u0026\u0026 lru_ppn \u003c MAX_NUM_PHYSICAL_PAGE); ppn = lru_ppn; // reversed mapping victim = page_map[ppn].pte4; // write back swap_out(page_map[ppn].daddr, ppn); victim-\u003epte_value = 0; // 将 victim pte 置零 victim-\u003epresent = 0; victim-\u003edaddr = page_map[ppn].daddr; // load page from disk to physical memory first daddr = pte-\u003edaddr; swap_in(daddr, ppn); pte-\u003epte_value = 0; pte-\u003epresent = 1; pte-\u003eppn = ppn; pte-\u003edirty = 0; page_map[ppn].allocated = 1; page_map[ppn].time = 0; page_map[ppn].dirty = 0; page_map[ppn].pte4 = pte; page_map[ppn].daddr = daddr; } 这只是内存反向映射的一个非常非常简化的实现，实际上的内存反向映射是非常复杂的。如果 PP 对应的 VP 是 file-backed page，那么我们可以向上面的简化实现那样，得到 PP 对应的 VP，具体实现参加 The object-based reverse-mapping；如果 PP 对应的 VP 是 anonymous page，那么还要复杂很多，参加 匿名反向映射的前世今生 和 图解匿名反向映射。 ","date":"2023-06-18","objectID":"/linux_virtual_memory.zh/:5:0","series":null,"tags":["csapp","linux"],"title":"Linux 虚拟内存系统","uri":"/linux_virtual_memory.zh/#内存反向映射reversed-mapping"},{"categories":["notes"],"content":" 6 总结到这里，我想我可以说对 Linux 虚拟内存系统有了一点很基础的了解。感谢 yangminz 大佬的 视频讲解，如有不对，敬请指正。 ","date":"2023-06-18","objectID":"/linux_virtual_memory.zh/:6:0","series":null,"tags":["csapp","linux"],"title":"Linux 虚拟内存系统","uri":"/linux_virtual_memory.zh/#总结"},{"categories":["notes"],"content":" 7 参考CSAPP yangminz: bcst_csapp Kernel Exploring ","date":"2023-06-18","objectID":"/linux_virtual_memory.zh/:7:0","series":null,"tags":["csapp","linux"],"title":"Linux 虚拟内存系统","uri":"/linux_virtual_memory.zh/#参考"},{"categories":["leetcode"],"content":" 1 Description1494. Parallel Courses II (Hard) You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k. In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking. Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course.   Example 1: Input: n = 4, relations = [[2,1],[3,1],[1,4]], k = 2 Output: 3 Explanation: The figure above represents the given graph. In the first semester, you can take courses 2 and 3. In the second semester, you can take course 1. In the third semester, you can take course 4. Example 2: Input: n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2 Output: 4 Explanation: The figure above represents the given graph. In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester. In the second semester, you can take course 4. In the third semester, you can take course 1. In the fourth semester, you can take course 5.   Constraints: 1 \u003c= n \u003c= 15 1 \u003c= k \u003c= n 0 \u003c= relations.length \u003c= n * (n-1) / 2 relations[i].length == 2 1 \u003c= prevCoursei, nextCoursei \u003c= n prevCoursei != nextCoursei All the pairs [prevCoursei, nextCoursei] are unique. The given graph is a directed acyclic graph. ","date":"2023-06-16","objectID":"/1494.parallel-courses-ii/:1:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1494. Parallel Courses II (Hard)","uri":"/1494.parallel-courses-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem readily brings to mind the concept of topological sorting, followed by a greedy approach. However, this approach is erroneous! In essence, this problem is NP-Hard and can only be solved through brute force. Let’s consider the application of state-compressed dynamic programming (DP). The subproblems are relatively straightforward to identify. We start by choosing $1, 2$, followed by selecting $3, 4, 5 $(meeting the prerequisites). We can use a binary number, $to$$study$, to represent the set of courses we currently need to study, and $pre[j]$ to represent the set of prerequisite courses for course $j$. The recursive function can be denoted as $dfs(to$$study, pre)$. Within this recursive function, we first calculate the set of courses $tmp$ that can be studied at the moment: cpp for (int i = 0; i \u003c n; ++i) { if ((((1 \u003c\u003c i) \u0026 to_study) != 0) \u0026\u0026 (pre[i] \u0026 to_study) == 0) { // Indicates that i is in to_study and its prerequisite courses have been studied (or it has no prerequisites) tmp = (tmp | (1 \u003c\u003c i)); ++cnt; } } If the number of courses $cnt$ in $tmp$ is less than or equal to k, we can directly study all the courses in the $tmp$ set. Otherwise, we iterate through the subsets of $tmp$. If the number of courses $m$ in subset $i$ satisfies $m \u003c= k$, we study that subset. In the next recursive call, the courses to be studied can be represented as $to$_$study \\oplus i$. For a method to enumerate subsets, refer to Bitwise Operations and Sets. In C++, the library function to count the number of $1$ bits in a binary number is __builtin_popcount(i). ","date":"2023-06-16","objectID":"/1494.parallel-courses-ii/:2:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1494. Parallel Courses II (Hard)","uri":"/1494.parallel-courses-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: static auto dfs(int to_study, vector\u003cint\u003e \u0026cache, int full, vector\u003cint\u003e \u0026pre, int n, int k) -\u003e int { if (to_study == 0) { return 0; } if (cache[to_study] != -1) { return cache[to_study]; } int studied = (to_study ^ full); int count = 0; // Count the number of courses that can be studied int tmp = 0; // Courses to be studied in this recursive call for (int i = 0; i \u003c n; ++i) { if ((((1 \u003c\u003c i) \u0026 to_study) != 0) \u0026\u0026 (pre[i] \u0026 to_study) == 0) { // Indicates that i is in to_study and its prerequisite courses have been studied (or it has no prerequisites) tmp = (tmp | (1 \u003c\u003c i)); ++count; } } if (count \u003c= k) { cache[to_study] = dfs(to_study ^ tmp, cache, full, pre, n, k) + 1; return cache[to_study]; } int result = INT_MAX; for (int i = tmp; i != 0; i = (i - 1) \u0026 tmp) { if (__builtin_popcount(i) \u003c= k) { result = min(result, dfs(to_study ^ i, cache, full, pre, n, k) + 1); } } cache[to_study] = result; return cache[to_study]; } int minNumberOfSemesters(int n, vector\u003cvector\u003cint\u003e\u003e \u0026relations, int k) { vector\u003cint\u003e pre(n); for (auto \u0026vec : relations) { int x = vec[0] - 1, y = vec[1] - 1; // Adjusting indices to start from 0 to n-1 pre[y] = (pre[y] | (1 \u003c\u003c x)); } int full = (1 \u003c\u003c n) - 1; // Full set vector\u003cint\u003e cache(1 \u003c\u003c n, -1); return dfs(full, cache, full, pre, n, k); } }; ","date":"2023-06-16","objectID":"/1494.parallel-courses-ii/:3:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1494. Parallel Courses II (Hard)","uri":"/1494.parallel-courses-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述1494. 并行课程 II (Hard) 给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 relations 中， relations[i] = [xᵢ, yᵢ] 表示一个先修课的关系，也就是课程 xᵢ 必须在课程 yᵢ 之前上。同时你还有一个整数 k 。 在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。 请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。 示例 1： text 输入：n = 4, relations = [[2,1],[3,1],[1,4]], k = 2 输出：3 解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ， 第三个学期上课程 4 。 示例 2： text 输入：n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2 输出：4 解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课 程 1 ，第四学期上课程 5 。 示例 3： text 输入：n = 11, relations = [], k = 2 输出：6 提示： 1 \u003c= n \u003c= 15 1 \u003c= k \u003c= n 0 \u003c= relations.length \u003c= n * (n-1) / 2 relations[i].length == 2 1 \u003c= xᵢ, yᵢ \u003c= n xᵢ != yᵢ 所有先修关系都是不同的，也就是说 relations[i] != relations[j] 。 题目输入的图是个有向无环图。 ","date":"2023-06-16","objectID":"/1494.parallel-courses-ii.zh/:1:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1494. 并行课程 II (Hard)","uri":"/1494.parallel-courses-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题很容易想到拓扑排序，然后基于拓扑排序进行贪心，但是这个做法是错的！本题实质上是个 NP-Hard 问题，只能暴力求解。 考虑状压 DP，其实很容易想到子问题。即先选择 $1, 2$，再选择 $3, 4, 5$（满足先修的要求）。用二进制数 $to$$study$ 表示当前要学习的课程的集合，用 $pre[j]$ 表示课程 $j$ 的先修课程的集合。那么递归函数即为 $dfs(to$$study, pre)$。 在本次递归中，我们先求出当前可以学习的课程的集合 $tmp$： cpp for (int i = 0; i \u003c n; ++i) { if ((((1 \u003c\u003c i) \u0026 to_study) != 0) \u0026\u0026 (pre[i] \u0026 to_study) == 0) { // 说明 i 在 to_study 中 且 i 的先修课程已经学习过了（或者没有先修课程） tmp = (tmp | (1 \u003c\u003c i)); ++cnt; } } 如果 $tmp$ 的课程个数 $cnt \u003c= k$，那么直接学习集合 $tmp$ 的所有课程，否则枚举 $tmp$ 的子集 $i$，如果子集 $i$ 的课程个数 $m$ 满足 $m \u003c= k$，那么就学习该子集，那么下次递归中待学习的课程就可以用 $to$_$study \\oplus i$ 表示。 枚举子集的方法参见 位运算与集合 C++ 中统计二进制数的 $1$ 的个数的库函数为 __builtin_popcount(i)。 ","date":"2023-06-16","objectID":"/1494.parallel-courses-ii.zh/:2:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1494. 并行课程 II (Hard)","uri":"/1494.parallel-courses-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: static auto dfs(int to_study, vector\u003cint\u003e \u0026cach, int full, vector\u003cint\u003e \u0026pre, int n, int k) -\u003e int { if (to_study == 0) { return 0; } if (cach[to_study] != -1) { return cach[to_study]; } int studied = (to_study ^ full); int cnt = 0; // 统计可以学习的课程数 int tmp = 0; // 本次递归要学习的课程 for (int i = 0; i \u003c n; ++i) { if ((((1 \u003c\u003c i) \u0026 to_study) != 0) \u0026\u0026 (pre[i] \u0026 to_study) == 0) { // 说明 i 在 to_study 中 且 i 的先修课程已经学习过了（或者没有先修课程） tmp = (tmp | (1 \u003c\u003c i)); ++cnt; } } if (cnt \u003c= k) { cach[to_study] = dfs(to_study ^ tmp, cach, full, pre, n, k) + 1; return cach[to_study]; // return dfs(to_study ^ tmp, cach, full, pre, n, k) + 1; } int res = INT_MAX; for (int i = tmp; i != 0; i = (i - 1) \u0026 tmp) { if (__builtin_popcount(i) \u003c= k) { res = min(res, dfs(to_study ^ i, cach, full, pre, n, k) + 1); } } cach[to_study] = res; return cach[to_study]; } int minNumberOfSemesters(int n, vector\u003cvector\u003cint\u003e\u003e \u0026relations, int k) { // 合集 i 表示要修的课程 // 合集 j 是 i 的子集，且 pre(j)（表示 j 的先修课程）与 i 没有交集，并且 size(j) \u003c= k vector\u003cint\u003e pre(n); for (auto \u0026vec : relations) { int x = vec[0] - 1, y = vec[1] - 1; // 下标选择从 0 到 n - 1 pre[y] = (pre[y] | (1 \u003c\u003c x)); } int full = (1 \u003c\u003c n) - 1; // 全集 vector\u003cint\u003e cach(1 \u003c\u003c n, -1); return dfs(full, cach, full, pre, n, k); } }; ","date":"2023-06-16","objectID":"/1494.parallel-courses-ii.zh/:3:0","series":null,"tags":["bitmask","dynamic programming"],"title":"1494. 并行课程 II (Hard)","uri":"/1494.parallel-courses-ii.zh/#代码"},{"categories":["notes"],"content":"我写博客的初心很简单，一是记录一些软件的配置过程（防止第二次配置的时候又抓瞎）；二是记录下一下自己学习过程中的一些心得体会。 在 高乙超的博客 中，我曾经看到一句话，叫 “To learn, read; To know, write; To master, teach”。 过去二十年里，在学习的过程中，我一直是作为一个输入方，应付考试倒是没啥问题，但也仅此而已了。 为了更好地体会和领悟这些知识，我决定写写博客，既是做笔记，也是对自己的所学的一种整理和输出，也希望能有更多同道者看到，从而一起交流学习、共同进步。 ","date":"2023-06-14","objectID":"/about_me.zh/:0:0","series":null,"tags":["trick"],"title":"关于我","uri":"/about_me.zh/#"},{"categories":["tutorial"],"content":" 1 前言我写博客的初心很简单，一是一些软件的配置过程（防止第二次配置的时候又抓瞎）；二是记录下一下自己学习过程中的一些心得体会，在 高乙超的博客 中，我曾经看到一句话，叫 “To learn, read; To know, write; To master, teach”。 过去二十年里，在学习的过程中，一直是作为一个输入方，应付考试倒是没啥问题，但也仅此而已了。为了更好地体会和领悟这些知识，我决定写写博客，既是做笔记，也是对自己的所学的一种整理和输出，也希望能有更多同道者看到，从而一起交流学习、共同进步。 最一开始么，其实是告诫自己，写博客的核心在于动笔输出，而不是折腾博客的主题又或是如何搭建博客站点，因此就想着选择一个现有的公开的博客平台，经过一番比较之下选择了博客园。说是比较，其实也没得太多选择的余地，除了博客园也就是 CSDN 了，然而对于 CSDN 我实在是深恶痛绝。博客园相较之下克制很多，广告少，更聚焦于技术，原创内容更多且更有深度，虽然界面以 2023 年的眼光来看比较老土了，但博客园支持自定义 CSS 啊。 没错，我还是无法控制自己，折腾了一下博客园的主题，鉴于本人对前端一窍不通，就算以后了解了，以我这种纠结来纠结去的性子，自己动手写主题，选择配色、主题、字号等绝对是噩梦，因此仅限于在 GitHub 上搜索他人做好的主题，挑了一番之后，网上比较热门的诸如 Silence 之类的主题，我都觉得太花里胡哨了，而且字体并不喜欢，找到一个设计风格不错的，奈何主题又太久没更新了，最后作罢。 最后，我还是选择了博客园自带的 Coding Life 主题，修改了一下代码块的 CSS，主要是改了代码块字体。 然而写了几篇博客之后，又发现博客园自带的编辑器太难用了。还是要自己现在本地用 VsCode 配合 Markdown Preview Enhanced 插件写好，再复制粘贴到博客园上发布，就觉得有点麻烦，倒不如用 Hugo 或者 Hexo 了，配置好之后，写好博客再敲一下命令就能搞定了。 于是我又动了用 Hexo 或者 Hugo 自己搭一个博客网站的念头，首先简单对比了一下，选择了 Hugo，比起 Hexo 来说，它性能高，配置起来更方便，Hexo 非常流行的 Next 主题我也并不喜欢，倒是 Hugo 的不少主题我非常喜欢，我个人在用的主题是 hugo-PaperMod 和 hugo-coder，没错，我一口气搭了两个网站，在我看来 hugo-coder 更好看一点，而 hugo-PaperMod 功能更为齐全，用的人更多，教程也更多。 两个博客网址分别是 zwyyy456.tech 和 paper.zwyyy456.tech。 我这两个基于 Hugo 的博客可以说是纯白嫖实现的，域名是白嫖的 Freenom 的 .tk 和 .ml 域名，自动部署方案是基于 GitHub 和 Vercel 实现的，将本地修改同步到 GitHub 之后，Vercel 就会自动构建站点。 这个方案我用了快半年，总体上来说是很满意的，写起博客来非常方便，站点颜值也很高，唯一美中不足的是，Google 或者 百度基本没有人看，估计和用的白嫖域名有关吧，我也不懂 SEO 优化，也没时间折腾这些，还有就是没有评论系统（反正也没人看）。其实搭建好个人博客之后，我还是坚持用复制粘贴的方式把博客同步到博客园坚持了一段时间的，后来太懒了，作罢。 就在前两天，我在查找 C++ 的内存分布相关资料的时候，发现了博主 sinkinben 的这篇 文章，我承认，肤浅的我一下子被他的博客主题吸引到了（内容反倒是其次了），在他的博客中有给出他的 Github 链接，点进去一看，果然有他的博客园主题的 CSS 和 html 文件，更改了一下博客园主题，看了一下实际效果，果然很好看。于是，我那把文章同步发布在博客园的心又蠢蠢欲动了起来。 ","date":"2023-06-14","objectID":"/cnblog_hugo.zh/:1:0","series":null,"tags":["trick"],"title":"便捷同步本地的博客文档到博客园","uri":"/cnblog_hugo.zh/#前言"},{"categories":["tutorial"],"content":" 2 博客园同步脚本其实我一直有在关注博客园的 VsCode 插件，也使用过，其实挺好用的，但是有一个非常致命的问题。那就是执行 hugo new xxx.md 生成的文档都会带有如下图的 Yaml Front Matter 信息，这些信息不属于正文内容，Hugo 会基于这些信息解析出本文的标题、所属分类、标签等信息。而插件在上传文章到博客园时，并不会解析或者去除这些信息，而是作为正文的一部分直接上传，GitHub 上已经有人提 issue 了，开发者也注意到了这个问题，但还没来得及修改。 因此，如果想便捷地同步文章到博客园，在插件开发者做出修改之前，我只能另寻出路。经过我的一番检索，我发现了一个基本符合我需求的发布文章到博客园的 Python 脚本，基础教程见该脚本的 GitHub 地址。 首先，需要执行 conda install markdown-it-py 和 conda install mdit-py-plugins 安装所需要的模块， 配置好脚本文件中对应的文章路径、MetaWeblog 账户信息之后，运行该脚本即可，运行时后面可以带一个数字作为参数，表示一次更新或者发布多少文章，脚本会自动发布指定数量的最近修改过的文章到博客园，如果未指定则参数默认为 $1$。 注意，运行脚本时，如果碰到 Yaml Front Matter 部分的 tags 一栏为空的 .md 文件，脚本会直接结束运行，同时 Hugo 限制了 _index.zh.md 不能有 tags 这一栏，因此要特别作一点处理，但其实只要保证最近更新的文章不包括 _index.zh.md 即可。 该脚本只有原来只能处理 tags，对于 categories 这一栏则不会处理，因此我做了一点修改。这里要注意 MetaWeblog API 的 categories 字段应该是一个字符串列表，作者对 tags 是作为字符串来处理的。 py import xmlrpc.client import ssl import os import sys import logging # logging.basicConfig(level=logging.INFO) # 设置 ssl 很重要，否则将报 ssl 错 ssl._create_default_https_context = ssl._create_unverified_context # dict config = { \"user_unique_name\": \"zwyyy456\", # 你的用户名，用于拼接文章 url \"url\": \"https://rpc.cnblogs.com/metaweblog/zwyyy456\", # 你的 MetaWeblog 访问地址 \"username\": \"zwyyy456\", # 你的登录用户名，可能跟上面的不一致 \"password\": \"*********\", # 你的登录密码 \"local_post_path\": \"/home/zwyyy/Documents/.../\", # 你的本地博文路径 } class MetaWeblog: def __init__(self, url, username, password): self.url, self.username, self.password = url, username, password self.proxy = xmlrpc.client.ServerProxy(self.url) def getRecentPosts(self, count): return self.proxy.metaWeblog.getRecentPosts( \"\", self.username, self.password, count ) def deletePost(self, post_id): return self.proxy.blogger.deletePost( \"\", post_id, self.username, self.password, True ) def newPost(self, article): return self.proxy.metaWeblog.newPost( \"\", self.username, self.password, dict( title=article[\"title\"], description=article[\"content\"], categories=article[\"categories\"], mt_keywords=article[\"tags\"], ), True, ) def editPost(self, post_id, article): return self.proxy.metaWeblog.editPost( post_id, self.username, self.password, dict( title=article[\"title\"], description=article[\"content\"], mt_keywords=article[\"tags\"], categories=article[\"categories\"], ), True, ) def set_article(article_path: str) -\u003e dict: \"\"\"根据文章路径设置文章（标题、标签和内容）\"\"\" import re from markdown_it import MarkdownIt from mdit_py_plugins.front_matter import front_matter_plugin from mdit_py_plugins.footnote import footnote_plugin with open(article_path, \"rb\") as f: content = f.read().decode(\"utf-8\") # 使用分组 reg = r\"(---(.|[\\n])*?---)\" p = re.compile(reg) headers = p.findall(content) logging.info(\"headers: %s\", headers) if len(headers) \u003c 1: raise ValueError(\"文章 %s 不存在 header 信息块「--- ** ---」，请检查！\" % article_path) # headers[0] 为 tuple header_str = headers[0][0] lines = header_str.split(\"\\n\") title, tags_categories, category = \"\", [], \"\" for line in lines: # 不使用':', 再替换所有空格为 null，因为可能存在中英文空格 line_ele = line.split(\": \") if line_ele[0] == \"title\": title = line_ele[1].rstrip() title = title.strip('\"') # 去除首尾的引号 elif line_ele[0] == \"tags\": tags = line_ele[1].rstrip() tags = tags.replace(\"[\", \"\") tags = tags.replace('\"', \"\") tags = tags.replace(\"]\", \"\") tags_categories.append(tags) # 处理 categories elif line_ele[0] == \"categories\": category = line_ele[1].rstrip() category = category.replace(\"[\", \"\") category = category.replace('\"', \"\") category = category.replace(\"]\", \"\") separator = \", \" tags = separator.join(tags_categories) categories = category.split(\", \") logging.info(\"tags: %s\", tags) logging.info(\"categories: %s\", categories) # 只替换第一个 content = content.replace(header_str, \"\", 1) md = ( MarkdownIt() .use(front_matter_plugin) .use(footnote_plugin) .enable(\"image\") .enable(\"table\") ) # markdown 转换为 HTML content = md.render(content) # cnblogs-markdown 属性用于代码块样式 content = '\u003cdiv class=\"cnblogs-markdown\"\u003e%s\u003c/div\u003e' % content if title == \"\" or content == \"\" or tags == \"\": raise ValueError(\"文章 title、content、tags 均不能为空；': '后有空格。请检查！\") article = { \"title\": title, \"content\": content","date":"2023-06-14","objectID":"/cnblog_hugo.zh/:2:0","series":null,"tags":["trick"],"title":"便捷同步本地的博客文档到博客园","uri":"/cnblog_hugo.zh/#博客园同步脚本"},{"categories":["tutorial"],"content":" 3 修改主题博主 sinkinben 制作的主题已经非常完善了，我主要是针对自己需求修改了一下 header.html。 一是将 🌳 Home、📮 Email、🐶 About 这三个 menuItem 对应的链接修改为自己的相关链接，而是添加了 🏷️ Tag 和 📂 Category 以及相关的 subMenuItem 链接，并将头像换成了自己的。 ","date":"2023-06-14","objectID":"/cnblog_hugo.zh/:3:0","series":null,"tags":["trick"],"title":"便捷同步本地的博客文档到博客园","uri":"/cnblog_hugo.zh/#修改主题"},{"categories":["notes"],"content":" 1 引入线段树是算法竞赛中常用的用来维护区间信息的数据结构。 树状数组可以在 $O(\\log n)$ 的时间内实现单点修改、区间查询（求和、求最值、求异或等）；而线段树还可以在 $O(\\log n)$ 时间内实现区间修改操作，例如将 $[L, R]$ 区间范围内的值都加上一个常数，乘以一个常数，或者都置为某个数。 ","date":"2023-06-13","objectID":"/seg_tree.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"线段树","uri":"/seg_tree.zh/#引入"},{"categories":["notes"],"content":" 2 常规线段树","date":"2023-06-13","objectID":"/seg_tree.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"线段树","uri":"/seg_tree.zh/#常规线段树"},{"categories":["notes"],"content":" 2.1 结构就我的理解而言，常规的线段树能实现的功能其实与树状数组没什么区别，都只能在 $O(\\log n)$ 时间内实现单点修改和区间查询。 线段树的构造：给定一个区间 $[L, R]$，取 $mid = L + (R - L) / 2$，将它划分为 $[L, mid]$ 和 $[mid + 1, R]$ 两个区间，如此递归地划分，直到区间长度为 $1$ 为止，这些父区间和划分为左右两边的子区间，在组织结构上很像二叉树的父结点和子结点，这也就是线段树的名字由来。 我们这里以区间求和为例，线段树的每个结点对应着相应的线段上的点的和，以数组 $a = {1,2,3,4,5,6,7,8,9,10}$ 为例，线段树的结构如图所示： 可以看到，线段树存储的基础形式是数组，与二叉堆的存储方式一致，假设当前父结点的编号为 $p$，那么左儿子的编号为 $2 * p$，右儿子的编号为 $2 * p + 1$，结点的值为对应区间的和。 构建线段树的方式其实与“求以该节点为根节点的子树的和”类似，递归处理是很容易的。 代码实现： cpp void Build(int idx, int l, int r, vector\u003cint\u003e \u0026nums) { if (l == r) { seg[idx] = nums[l]; return; } int mid = l + (r - l) / 2; Build(2 * idx, l, mid, nums); // 递归构建左子树 Build(2 * idx, mid + 1, r, nums); // 递归构建右子树 seg[idx] = seg[2 * idx] + seg[2 * idx + 1]; // 更新 seg[idx] } ","date":"2023-06-13","objectID":"/seg_tree.zh/:2:1","series":null,"tags":["data structure and algorithms"],"title":"线段树","uri":"/seg_tree.zh/#结构"},{"categories":["notes"],"content":" 2.2 区间查询线段树的区间查询，其实只要掌握了递归，就很好理解了。 我们也是对线段树一层一层地往下查询，先比较待查询区间是否能完全覆盖当前线段树区间，如果能完全覆盖，则返回当前区间的值；否则继续比较待查询区间 $[L, R]$ 与当前区间的 $mid$ 的大小，如果 $L \\leq mid$，则递归查询左子区间 $[l, mid]$，如果 $R \u003e mid$，则递归查询右子区间 $[mid + 1, R]$。 例如我们要查询 $[1, 7]$，先考察线段树结点 $1$，它的 $mid$ 为 $4$，于是左子区间和右子区间都要递归查询： 左子区间 $[0, 4]$ 的 $mid$ 为 $2$，继续递归查询左子区间和右子区间； 区间 $[0,2]$ 还要继续往下查询，右子区间 $[3,4]$ 被待查询区间覆盖，直接返回； 右子区间 $[5, 9]$ 的 $mid$ 为 $7$，继续递归查询左子区间 $[5, 7]$，发现区间 $[5, 7]$ 被待查询区间 $[1, 7]$ 完全覆盖，于是直接返回； 最后返回的区间为 $[1,1], [2,2],[3,4],[5,7]$，和为 $35$。 代码实现： cpp int Query (int idx, int l, int r, int L, int R) { // [L, R] 表示待查询区间 if (L \u003c= l \u0026\u0026 R \u003e= r) { // 当前区间被待查询区间完全覆盖 return seg[idx]; } int sum = 0; if (L \u003c= mid) { sum += Query(2 * idx, l, mid, L, R); // 递归查询左子区间，左子区间索引为 2 * idx } if (R \u003e mid) { sum += Query(2 * idx, mid + 1, r, L, R); // 递归查询右子区间 } return sum; } 对线段树的单点修改，也是一层层遍历线段树，修改对应区间的和即可，如果只有单点修改而不存在区间修改，那么一般用树状数组就能解决，因此这里就不给出单点修改的实现了。 ","date":"2023-06-13","objectID":"/seg_tree.zh/:2:2","series":null,"tags":["data structure and algorithms"],"title":"线段树","uri":"/seg_tree.zh/#区间查询"},{"categories":["notes"],"content":" 3 带 Lazy 标记的线段树前面提到，常规的线段树，个人认为相比树状数组其实没什么优势，时间复杂度的常数还大，占用空间也大，假设待处理的数组 $nums$ 的 $size()$ 为 $n$，那么我们一般要开一个长度为 $4n$ 数组来存储线段树。 即 int seg[4 * n] = {0};。 那为什么说线段树支持 $O(\\log n)$ 时间复杂度的区间修改呢，这就需要 Lazy 标记出马了。 int todo[4 * n] = {0};，这里的 $todo[idx]$ 就是所说的 Lazy 标记了。 Lazy 标记，简单来说，就是通过延迟对子节点信息的修改，从而减少可能的不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点 $idx$ 对应的区间在某一次操作中被更改，同时更新 $seg[idx]$，但是，我们选择先不更新子节点的信息，而是等到 $idx$ 的区间被“破坏”时，再更新子区间，这里说的区间被破坏，就是指我们要更新或者查询 $idx$ 区间对应的子区间的情况。 例如，第一次更新，我们需要对区间 $[0, 4]$ 都 $+1$，经过遍历，我们知道区间 $[0, 4]$ 对应的 $idx$ 是 $1$，因此我们更新 seg[1] += 5;，同时将 todo[1] += 1;，这就是给 $idx = 1$ 打上了 Lazy 标记。 下一次更新或者查询，我们要对区间 $[3, 4]$ 都 $+2$，显然它是区间 $[0, 4]$ 的子区间，因此发生了对区间 $idx = 1$ 的“破坏”，于是我们需要把 Lazy 标记往区间 $[0, 4]$ 的左子区间和右子区间传递，因此我们更新 seg[2] += 3, seg[3] += 2;，同时将 todo[2] += todo[1], todo[2] += todo[1], todo[1] = 0;。 从递归的角度上来说，我们还是处于 $idx = 1$ 的这一层，然后继续递归右子结点，到了 $idx = 3$，更新 seg[3] += 2 * 2;，同时将 todo[3] += 2;。 带 Lazy 标记的更新操作具体实现如下： cpp int seg[4 * n] = {0}, todo[4 * n] = {0}; void Update(int idx, int l, int r, int L, int R, int add) { if (L \u003c= l \u0026\u0026 R \u003e= r) { todo[idx] += add; // 更新 Lazy 标记 seg[idx] += add * (r - l + 1); // 更新线段树 return; } int mid = l + (r - l) / 2; if (todo[idx] != 0) { // 说明当前区间存在 Lazy 标记。 // 我们要查询的区间没有完全覆盖当前区间，必然还要往下递归 // “破坏”了当前区间，因此将 Lazy 标记传递到左子区间和右子区间 todo[2 * idx] += todo[idx]; seg[2 * idx] += todo[idx] * (mid - l + 1); todo[2 * idx + 1] += todo[idx]; seg[2 * idx + 1] += todo[idx] * (r - mid); todo[idx] = 0; } if (L \u003c= mid) { Update(2 * idx, l, mid, L, R, add); // 递归更新左子树 } if (R \u003e mid) { Update(2 * idx + 1, mid + 1, r, L, R, add); // 递归更新右子树 } seg[idx] = seg[2 * idx] + seg[2 * idx + 1]; // 更新“更新了左右子树”之后的当前区间和 } 带 Lazy 标记的查询其实与更新类似，当查询区间完全覆盖当前区间时，直接 return seg[idx]; 即可，因为当前区间的值已经是最新的了，只是子区间并没有更新（我们这里也不需要子区间的值）； 没有完全覆盖时，就跟更新操作一样，出现了“破坏”当前区间的情况，因此更将 Lazy 标记传递到子区间，再继续递归； cpp int Query(int idx, int l, int r, int L, int R) { if (L \u003c= l \u0026\u0026 R \u003e= r) { return seg[idx]; // 配合上面的 Update 可知，打上 Lazy 标记时，当前区间的值已经更新，只是没有更新子区间 } int mid = l + (r - l) / 2; if (todo[idx] != 0) { // 说明当前区间存在 Lazy 标记。 // 我们要查询的区间没有完全覆盖当前区间，必然还要往下递归 // “破坏”了当前区间，因此将 Lazy 标记传递到左子区间和右子区间 todo[2 * idx] += todo[idx]; seg[2 * idx] += todo[idx] * (mid - l + 1); todo[2 * idx + 1] += todo[idx]; seg[2 * idx + 1] += todo[idx] * (r - mid); todo[idx] = 0; } int sum = 0; if (L \u003c= mid) { sum += Query(2 * idx, l, mid, L, R); } if (R \u003e mid) { sum += Query(2 * idx + 1, mid + 1, r, L, R); } return sum; } ","date":"2023-06-13","objectID":"/seg_tree.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"线段树","uri":"/seg_tree.zh/#带-lazy-标记的线段树"},{"categories":["notes"],"content":" 4 动态开点线段树前面讲到堆式储存的情况下，需要给线段树开 $4n$ 大小的数组。为了节省空间，我们可以不一次性建好树，而是在最初只建立一个根结点代表整个区间。当我们需要访问某个子区间时，才建立代表这个区间的子结点。这样我们不再使用 $2 * idx$ 和 $2 * idx + 1$ 代表 $idx$ 结点的儿子，而是用 $ls$ 和 $rs$ 记录儿子的编号。总之，动态开点线段树的核心思想就是：结点只有在有需要的时候才被创建。 单次操作的时间复杂度是不变的，为 $O(\\log n)$ 。由于每次操作都有可能创建并访问全新的一系列结点，因此 $m$ 次单点操作后结点的数量规模是 $O(m\\log n)$ 。最多也只需要 $2n-1$ 个结点，没有浪费。 具体的实现留待后面碰到需要动态开点的情况再写吧。 ","date":"2023-06-13","objectID":"/seg_tree.zh/:4:0","series":null,"tags":["data structure and algorithms"],"title":"线段树","uri":"/seg_tree.zh/#动态开点线段树"},{"categories":["notes"],"content":" 5 时间复杂度分析对区间查询 $[L, R]$，考虑 $[L, L]$ 和区间 $[R, R]$ 的到他们最近公共祖先的路径，所有划分的区间必然是这个路径上的结点的直接子结点，树的深度为 $\\log n$，因此经过的点最多为 $2 * 2 * \\log n$ 个，所以时间复杂度为 $O(\\log n)$。 单点修改显然是 $O(\\log n)$，区间修改在有 Lazy 标记的情况下，类似于区间查询。 ","date":"2023-06-13","objectID":"/seg_tree.zh/:5:0","series":null,"tags":["data structure and algorithms"],"title":"线段树","uri":"/seg_tree.zh/#时间复杂度分析"},{"categories":["notes"],"content":" 1 引入在 LeetCode 中，二叉树一般是以链表结点的形式组织的，定义如下： cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} }; 其实也可以用数组的形式组织，即使用 $parent$ 数组，$y = parent[x]$ 说明 $y$ 是 $x$ 的父结点，根结点的父结点为 $-1$，表示父结点不存在。 ","date":"2023-06-12","objectID":"/tree_in_array.zh/:1:0","series":null,"tags":["tree","data structure and algorithms"],"title":"数组形式组织的树","uri":"/tree_in_array.zh/#引入"},{"categories":["notes"],"content":" 2 最近公共祖先","date":"2023-06-12","objectID":"/tree_in_array.zh/:2:0","series":null,"tags":["tree","data structure and algorithms"],"title":"数组形式组织的树","uri":"/tree_in_array.zh/#最近公共祖先"},{"categories":["notes"],"content":" 2.1 链表形式对链表形式树，求最近公共祖先可以使用递归很方便的解决： cpp /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr || root == p || root == q) { return root; } TreeNode *left = lowestCommonAncestor(root-\u003eleft, p, q); TreeNode *right = lowestCommonAncestor(root-\u003eright, p, q); if (left != nullptr \u0026\u0026 right != nullptr) { return root; } if (left != nullptr \u0026\u0026 right == nullptr) { return left; } if (left == nullptr \u0026\u0026 right != nullptr) { return right; } return nullptr; } }; 也可以这样写，更好理解，与上面的写法的含义是一样的： cpp class Solution { public: pair\u003cbool, bool\u003e Ancestor(TreeNode *root, TreeNode *p, TreeNode *q, TreeNode **res) { if (root == nullptr) { return {false, false}; } auto flagp = root == p, flagq = root == q; auto [pleft, qleft] = Ancestor(root-\u003eleft, p, q, res); auto [pright, qright] = Ancestor(root-\u003eright, p, q, res); bool res_p = flagp || pleft || pright; bool res_q = flagq || qleft || qright; // 最近公共祖先的条件 // 左子树，右子树都不是最近公共祖先 if (res_p \u0026\u0026 res_q \u0026\u0026 !(pleft \u0026\u0026 qleft) \u0026\u0026 !(pright \u0026\u0026 qright)) { *res = root; } return {pleft || pright || flagp, qleft || qright || flagq}; } TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) { TreeNode *res = nullptr; Ancestor(root, p, q, \u0026res); return res; } }; ","date":"2023-06-12","objectID":"/tree_in_array.zh/:2:1","series":null,"tags":["tree","data structure and algorithms"],"title":"数组形式组织的树","uri":"/tree_in_array.zh/#链表形式"},{"categories":["notes"],"content":" 2.2 数组形式对数组形式的树来说，求二叉树的最近公共祖先则要复杂很多。 我们需要以 1483. 树节点的第 K 个祖先 (Hard) 的解法作为先决条件，即先处理 $dp[i][j]$ 数组，其中 $dp[i][j]$ 表示编号 $i$ 结点的第 $2^j$ 个祖先的编号，则有递推公式： $dp[i][j] = dp[dp[i][j - 1]][j - 1]$。 处理好 $dp[i][j]$ 数组之后，我们可以用类似二分查找的办法确定编号为 $m$ 和编号为 $n$ 的结点的深度，这里深度可以定义为满足 $pars[i][k] = -1$ 的最小的 $k$，其中 $pars[i][k]$ 表示编号为 $i$ 结点的第 $k$ 个祖先的编号，可以由 $dp[i][j]$ 在 $O(\\log n)$ 时间内求得。 对于求解公共祖先，其实我们也是用二分查找的思想求解，假设 $m$ 结点的深度为 $d_m$，$n$ 结点的深度为 $d_n$，且 $d_m \u003e= d_n$（如果不满足，交换一下两个结点即可），那么等同于求 $n$ 的第 $k$ 个祖先 $p_n$ 以及 $m$ 的第 $k + d_m - d_n$ 个祖先 $p_m$ ，它们满足 $p_m = p_n$ 并且对应的 $k$ 最小。 预处理 $dp[i][j]$ 数组的时间复杂度为 $O(n\\log n)$，总的时间复杂度为 $O(n\\log n)$。 ","date":"2023-06-12","objectID":"/tree_in_array.zh/:2:2","series":null,"tags":["tree","data structure and algorithms"],"title":"数组形式组织的树","uri":"/tree_in_array.zh/#数组形式"},{"categories":["leetcode"],"content":" 1 Description1483. Kth Ancestor of a Tree Node (Hard) You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node. The kth ancestor of a tree node is the kth node in the path from that node to the root node. Implement the TreeAncestor class: TreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array. int getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1. Example 1: text Input [\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"] [[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]] Output [null, 1, 0, -1] Explanation TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3 treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5 treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor Constraints: 1 \u003c= k \u003c= n \u003c= 5 * 10⁴ parent.length == n parent[0] == -1 0 \u003c= parent[i] \u003c n for all 0 \u003c i \u003c n 0 \u003c= node \u003c n There will be at most 5 * 10⁴ queries. ","date":"2023-06-12","objectID":"/1483.kth-ancestor-of-a-tree-node/:1:0","series":null,"tags":["dynamic programming","tree"],"title":"1483. Kth Ancestor of a Tree Node (Hard)","uri":"/1483.kth-ancestor-of-a-tree-node/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe simplistic notion entails gradually searching for the parent node, resulting in a time complexity of O(n). Therefore, the overall time complexity becomes O(n^2), leading to a potential TLE (Time Limit Exceeded). Thus, we need to devise a more efficient approach for finding the parent node with a lower time complexity of O(log n). This leads us to contemplate a binary-like strategy. For instance, let’s assume we need to find getKthAncestor(1, 8). We can first determine x = getKthAncestor(1, 4) and then compute getKthAncestor(x, 4). This approach bears resemblance to dynamic programming. Let’s define $dp[i][j]$ as the i-th node’s ancestor at the $2^j$ position, where $dp[i][j] = dp[dp[i][j-1]][j]$ and $dp[i][0] = parent[i]$. During initialization, we can initialize the $dp[i][j]$ array. Given that $1 \\leq k \\leq n \\leq 5 * 10^4$, the first dimension of the $dp$ array should have a size of n, and the second dimension’s size can be set to logk = 20. In the constructor, we compute the $dp[i][j]$ array, taking care to handle the case when $dp[i][j] = -1$. In the getKthAncestor() function, we can employ bitwise operations to calculate the parent node: $pa = dp[pa][i]$, provided that $((1 « i) \u0026 k) \\neq 0$. If we compute $pa = -1$, we simply return pa. ","date":"2023-06-12","objectID":"/1483.kth-ancestor-of-a-tree-node/:2:0","series":null,"tags":["dynamic programming","tree"],"title":"1483. Kth Ancestor of a Tree Node (Hard)","uri":"/1483.kth-ancestor-of-a-tree-node/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class TreeAncestor { public: TreeAncestor(int n, vector\u003cint\u003e \u0026parent) : cnt_(n), index_(0), dp(n) { int x = 0; for (int i = 0; i \u003c parent.size(); ++i) { parent_.push_back(parent[i]); } for (int i = 0; i \u003c cnt_; ++i) { for (int j = 0; j \u003c logk; ++j) { dp[i].push_back(-1); } } for (int i = 0; i \u003c cnt_; ++i) { dp[i][0] = parent_[i]; } while (index_ \u003c logk) { for (int i = 0; i \u003c cnt_; ++i) { if (dp[i][index_] != -1) { dp[i][index_ + 1] = dp[dp[i][index_]][index_]; } } x *= 2; ++index_; } } int getKthAncestor(int node, int k) { int pa = node; for (int i = 0; (1 \u003c\u003c i) \u003c= k; ++i) { if (((1 \u003c\u003c i) \u0026 k) != 0) { pa = dp[pa][i]; if (pa == -1) { return pa; } } } return pa; } private: int cnt_; vector\u003cint\u003e parent_; int index_; vector\u003cvector\u003cint\u003e\u003e dp; const int logk = 20; }; ","date":"2023-06-12","objectID":"/1483.kth-ancestor-of-a-tree-node/:3:0","series":null,"tags":["dynamic programming","tree"],"title":"1483. Kth Ancestor of a Tree Node (Hard)","uri":"/1483.kth-ancestor-of-a-tree-node/#code"},{"categories":["leetcode"],"content":" 1 问题描述1483. 树节点的第 K 个祖先 (Hard) 给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。 树节点的第 k个祖先节点是从该节点到根节点路径上的第 k 个节点。 实现 TreeAncestor 类： TreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。 getKthAncestor (int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。 示例 1： text 输入： [\"TreeAncestor\",\"getKthAncestor\",\"getKthAncestor\",\"getKthAncestor\"] [[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]] 输出： [null,1,0,-1] 解释： TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // 返回 1 ，它是 3 的父节点 treeAncestor.getKthAncestor(5, 2); // 返回 0 ，它是 5 的祖父节点 treeAncestor.getKthAncestor(6, 3); // 返回 -1 因为不存在满足要求的祖先节点 提示： 1 \u003c= k \u003c= n \u003c= 5 * 10⁴ parent[0] == -1 表示编号为 0 的节点是根节点。 对于所有的 0 \u003c i \u003c n ， 0 \u003c= parent[i] \u003c n 总成立 0 \u003c= node \u003c n 至多查询 5 * 10⁴ 次 ","date":"2023-06-12","objectID":"/1483.kth-ancestor-of-a-tree-node.zh/:1:0","series":null,"tags":["dynamic programming","tree"],"title":"1483. 树节点的第 K 个祖先 (Hard)","uri":"/1483.kth-ancestor-of-a-tree-node.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路朴素的想法即一层一层地找父结点，时间复杂度为 $O(n)$，因此总的时间复杂度为 $O(n^2)$，会 TLE，因此我们需要构思一个时间复杂度更低的寻找父结点的办法，其实从时间复杂度也可以想到，这个寻找父结点的时间复杂度应该是 $O(\\log n)$ 的，于是我们就可以想到类似二分的思路。 例如，假设要求 getKthAncestor(1, 8)，那么我们可以先求 x = getKthAncestor(1, 4)，再求 getKthAncestor(x, 4)，这里其实就有点像是动态规划的意思了。 我们令 $dp[i][j]$ 为 结点 $i$ 的第 $2^j$ 个祖先结点，那么 $dp[i][j] = dp[dp[i][j - 1]][j]$，且 $dp[i][0] = parent[i]$。 我们可以类初始化的时候，初始化这个 $dp[i][j]$ 数组，由于 $1 \\leq k \\leq n \\leq 5 * 10^4$，因此 $dp$ 的第一维度的大小为 $n$，第二维度的大小开到 $logk = 20$ 就够了，在构造函数中，计算 $dp[i][j]$ 数组，计算时要注意 $dp[i][j] = -1$ 的情况。 到了 getKthAncestor() 函数中，我们可以结合位运算去计算父结点：$pa = dp[pa][i]$，前提是 $ ((1 « i) \u0026 k) \\neq 0$，如果计算出来 $pa = -1$，直接 return pa。 ","date":"2023-06-12","objectID":"/1483.kth-ancestor-of-a-tree-node.zh/:2:0","series":null,"tags":["dynamic programming","tree"],"title":"1483. 树节点的第 K 个祖先 (Hard)","uri":"/1483.kth-ancestor-of-a-tree-node.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class TreeAncestor { public: TreeAncestor(int n, vector\u003cint\u003e \u0026parent) : cnt_(n), index_(0), dp(n) { int x = 0; for (int i = 0; i \u003c parent.size(); ++i) { parent_.push_back(parent[i]); } for (int i = 0; i \u003c cnt_; ++i) { for (int j = 0; j \u003c logk; ++j) { dp[i].push_back(-1); } } for (int i = 0; i \u003c cnt_; ++i) { dp[i][0] = parent_[i]; } while (index_ \u003c logk) { for (int i = 0; i \u003c cnt_; ++i) { if (dp[i][index_] != -1) { dp[i][index_ + 1] = dp[dp[i][index_]][index_]; } } x *= 2; ++index_; } } int getKthAncestor(int node, int k) { // dp[node][i] 表示出 node 的第 2^i 个祖先 // dp[node][i] = dp[dp[node][i - 1]][i - 1]; int pa = node; for (int i = 0; (1 \u003c\u003c i) \u003c= k; ++i) { if (((1 \u003c\u003c i) \u0026 k) != 0) { pa = dp[pa][i]; if (pa == -1) { return pa; } } } return pa; } private: int cnt_; vector\u003cint\u003e parent_; int index_; vector\u003cvector\u003cint\u003e\u003e dp; const int logk = 20; }; ","date":"2023-06-12","objectID":"/1483.kth-ancestor-of-a-tree-node.zh/:3:0","series":null,"tags":["dynamic programming","tree"],"title":"1483. 树节点的第 K 个祖先 (Hard)","uri":"/1483.kth-ancestor-of-a-tree-node.zh/#代码"},{"categories":["notes"],"content":" 1 概述MESI（也称伊利诺斯协议）是一种广泛使用的支持 write-back 策略的缓存一致性协议。 ","date":"2023-06-07","objectID":"/cache_mesi.zh/:1:0","series":null,"tags":["csapp"],"title":"CPU 缓存一致性：MESI","uri":"/cache_mesi.zh/#概述"},{"categories":["notes"],"content":" 2 MESI 状态我们假设 CPU 中共有 $k$ 个核； CPU 中每个 cacheline 使用 $4$ 种状态进行标记： 状态 介绍 所有核中该状态的个数 MODIFIED 实际上是 exclusive dirty，说明该核的缓存数据被修改了，且并未写入到更低一层存储中；当某个核的缓存处于该状态时，其余核的对应 cacheline 均为 INVALID 1 EXCLUSIVE 实际上是 exclusive clean，说明该核的缓存刚从更低一层存储中读取到了最新的数据；当某个核的缓存处于该状态时，其余核的对应 cacheline 均为 INVALID 1 SHARED 实际上是 shared clean，说明多个核的缓存从更低一层存储中读到的数据都是最新的，处于该状态的核的数量一定 $\\geq 2$，其余核的对应 cacheline 均为 INVALID $\\geq 2$ INVALID 说明该核的 cacheline 无效 ","date":"2023-06-07","objectID":"/cache_mesi.zh/:2:0","series":null,"tags":["csapp"],"title":"CPU 缓存一致性：MESI","uri":"/cache_mesi.zh/#mesi-状态"},{"categories":["notes"],"content":" 3 状态切换我们以四个核为例，用四元组如 $(M, I, I, I)$ 表示四个核的 cacheline 状态，假设只操作第一个核的 cacheline： ","date":"2023-06-07","objectID":"/cache_mesi.zh/:3:0","series":null,"tags":["csapp"],"title":"CPU 缓存一致性：MESI","uri":"/cache_mesi.zh/#状态切换"},{"categories":["notes"],"content":" 3.1 执行读操作 $(M,I,I,I)$ 执行读，状态仍为 $(M, I, I, I)$； $(E,I,I,I)$ 执行读，状态仍为 $(E, I, I, I)$； $(S,S,I,I)$ 执行读，状态仍为 $(S, S, I, I)$； $(I,M,I,I)$ 执行读，将第二个核的 cacheline 的数值 $val$ 写入内存，然后更新第一个核的 cacheline 的值为 $val$，状态切换为 $(S,S,I,I)$； $(I,E,I,I)$ 执行读，更新第一个核的 cacheline 为第二个核的数值 $val$，状态切换为 $(S,S,I,I)$； $(I,S,S,I)$ 执行读，更新第一个核的 cacheline 为第二个或第三个核的数值 $val$，状态切换为 $(S,S,S,I)$； $(I,I,I,I)$ 执行读，从内存中读取对应的地址的数值 $*addr$ 到 cacheline，状态切换为 $(E, I, I, I)$； ","date":"2023-06-07","objectID":"/cache_mesi.zh/:3:1","series":null,"tags":["csapp"],"title":"CPU 缓存一致性：MESI","uri":"/cache_mesi.zh/#执行读操作"},{"categories":["notes"],"content":" 3.2 执行写操作 $(M,I,I,I)$ 执行写，状态仍为 $(M, I, I, I)$； $(E,I,I,I)$ 执行写，状态变为 $(M, I, I, I)$； $(S,S,I,I)$ 执行写，将其他所有状态为 $S$ 的 cacheline 的状态全都设置为 $I$，状态变为 $(M, I, I, I)$； $(I,M,I,I)$ 执行写，将第二个核的 cacheline 的数值 $val$ 写入内存（为了防止 ABA 问题，这里为什么要写回 TODO(zwyyy)，是否和指令原子性有关），状态变为 $I$，然后更新第一个核的 cacheline 的值为 $val$，再更新值为待写入的值 $write$_$value$，状态切换为 $(M,I,I,I)$； $(I,E,I,I)$ 执行写，更新第一个核的 cacheline 为第二个核的数值 $val$，将第二个核的状态设为 $I$，状态切换为 $(M,I,I,I)$； $(I,I,I,I)$ 执行写，将 $write$_$val$ 写到 cacheline 中，状态切换为 $(M, I, I, I)$； ","date":"2023-06-07","objectID":"/cache_mesi.zh/:3:2","series":null,"tags":["csapp"],"title":"CPU 缓存一致性：MESI","uri":"/cache_mesi.zh/#执行写操作"},{"categories":["notes"],"content":" 3.3 执行 evict 操作","date":"2023-06-07","objectID":"/cache_mesi.zh/:3:3","series":null,"tags":["csapp"],"title":"CPU 缓存一致性：MESI","uri":"/cache_mesi.zh/#执行-evict-操作"},{"categories":["notes"],"content":" 1 跳表介绍跳表是一种数据结构，使得包含 $n$ 个元素的有序序列的查找和插入操作的平均时间复杂度都是 $O(\\log n)$，与红黑树、AVL 性能类似。 跳表的快速查询效果是通过维护一个多层次的链表实现的，且与前一层（下面一层）的链表元素相比，每一层链表中的元素的数量更少，一开始，算法在最上层（也是最稀疏的一层）查找，直到要查询的元素在该层相邻的两个元素中间。这时，算法将跳转到下一个层，重复刚才的搜索，直到找到需要查找的元素为止如下图所示： 层数索引从低到高逐渐递增。 ","date":"2023-06-06","objectID":"/skiplist.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"跳表","uri":"/skiplist.zh/#跳表介绍"},{"categories":["notes"],"content":" 2 描述跳表是按照层构建的，跳表的最底层是一个普通的有序链表，每个更高层都是下层列表的子列表，相当于下层列表的快速通道，这里可以类比一下 B树 或者 B+树。 在跳表中，第 $i$ 层的元素会有概率 $p$ 出现在第 $i + 1$ 层中（$p$ 通常取 $\\frac{1}{2}$ 或者 $\\frac{1}{4}$），每个元素平均出现在 $\\frac{1}{1 - p}$ 个列表中。 一般认为，列表有 $log_{\\frac{1}{p}}n$ 层，在后面的实现中，我们固定了列表的层数为 $klevel = 8$，动态层数的列表实现起来比较复杂。 在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾： 如果该元素等于目标元素，则表明该元素已被找到； 如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。 每层链表中预期的查找步数最多为 $\\frac{1}{p}$，而层数为 $\\log_{\\frac{1}{p}}n$，因此查找的总体步数为 $\\frac{\\frac{1}{p}}{\\log_{\\frac{1}{p}}n}$，$p$ 是常数，因此总体查找的时间复杂度为 $O(\\log n)$ 的。 跳跃列表不像平衡树等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。 但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。 ","date":"2023-06-06","objectID":"/skiplist.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"跳表","uri":"/skiplist.zh/#描述"},{"categories":["notes"],"content":" 3 实现以 1206. Design Skiplist (Hard) 为例，进行跳表的简单实现。 由上述图片，我们可以构想出结点的数据结构： 结点值 $val$； 存储当前结点每一层的 $next_$ 指针（这里使用 vector 存储）。 为了方便理解，我们其实可以把每个结点都看成图中 $klevel$ 高度，只是我们只画出来 $next_[i]$ 不为 $nullptr$ 的对应层罢了。 cpp const int klevel = 8; struct Node { int val_; vector\u003cNode *\u003e next_; // next[i] 表示当前结点在第 i 层的 next，i 从 0 开始 Node(int val) : val_(val), next_{klevel, nullptr} { // 初始化 } }; 之后，我们使用一个辅助函数 void Find(int target, veoctor\u003cNode *\u003e pre); 来存储每一层中：满足值小于 $target$ 并且值最大的结点。 cpp void Find(int target, vector\u003cNode *\u003e \u0026pre) { // 辅助函数，找到每一层 pre[i] 小于 target 的最大的 i // 从头结点开始遍历每一层 for (int i = 0; i \u003c klevel; ++i) { pre[i] = nullptr; } auto *ptr = head; for (int i = klevel - 1; i \u003e= 0; --i) { // 从上层开始往下层找，这里从下往上是不是也可以？ // 如果当前层 i 对应结点的 next 不为空，且它的值小于 target，则 ptr 往前走指向这一层 ptr 的 next while ((ptr-\u003enext_[i] != nullptr) \u0026\u0026 ptr-\u003enext_[i]-\u003eval_ \u003c target) { ptr = ptr-\u003enext_[i]; } pre[i] = ptr; } } 有了这个辅助函数之后，我们的后续操作就方便很多了： ","date":"2023-06-06","objectID":"/skiplist.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"跳表","uri":"/skiplist.zh/#实现"},{"categories":["notes"],"content":" 3.1 查找（search）首先执行 Find(target, pre) 得到每一层小于 $target$ 的最大结点，由于第 $0$ 层是完整的有序链表，我们直接在第 $0$ 层查找元素即可： cpp bool search(int target) { Find(target, pre_); auto *ptr = (pre_[0]-\u003enext_)[0]; return ptr != nullptr \u0026\u0026 ptr-\u003eval_ == target; } ","date":"2023-06-06","objectID":"/skiplist.zh/:3:1","series":null,"tags":["data structure and algorithms"],"title":"跳表","uri":"/skiplist.zh/#查找search"},{"categories":["notes"],"content":" 3.2 插入（add）首先执行 Find(target, pre) 得到每一层小于 $target$ 的最大结点。从第 $0$ 层开始，执行类似链表的插入操作，然后利用 rand() 来决定是否执行后续层的插入操作。 cpp void add(int num) { Find(num, pre_); auto *ptr = new Node(num); for (int i = 0; i \u003c klevel; ++i) { ptr-\u003enext_[i] = pre_[i]-\u003enext_[i]; // 其实就是链表的插入操作 pre_[i]-\u003enext_[i] = ptr; if (random() % 2 == 1) { break; } } } ","date":"2023-06-06","objectID":"/skiplist.zh/:3:2","series":null,"tags":["data structure and algorithms"],"title":"跳表","uri":"/skiplist.zh/#插入add"},{"categories":["notes"],"content":" 3.3 删除可以先执行查找（search）判断待删除元素是否存在，不存在则返回 $false$，如果存在，则从第 $0$ 层开始，删除该层等于目标值结点，直到不存在目标值的层为止； cpp bool erase(int num) { if (!search(num)) { return false; } auto *ptr = pre_[0]-\u003enext_[0]; for (int i = 0; i \u003c klevel \u0026\u0026 pre_[i]-\u003enext_[i] == ptr; ++i) { pre_[i]-\u003enext_[i] = ptr-\u003enext_[i]; } delete ptr; return true; } ","date":"2023-06-06","objectID":"/skiplist.zh/:3:3","series":null,"tags":["data structure and algorithms"],"title":"跳表","uri":"/skiplist.zh/#删除"},{"categories":["notes"],"content":" 3.4 完整实现 cpp const int klevel = 8; struct Node { int val_; vector\u003cNode *\u003e next_; // next[i] 表示当前结点在第 i 层的 next，i 从 0 开始 Node(int val) : val_(val), next_{klevel, nullptr} { } }; class Skiplist { public: Skiplist() : head(new Node(-1)), pre_(klevel) { // 初始化为 -1，表示结点不存在 } void Find(int target, vector\u003cNode *\u003e \u0026pre) { // 辅助函数，找到每一层 pre[i] 小于 target 的最大的 i // 从头结点开始遍历每一层 for (int i = 0; i \u003c klevel; ++i) { pre[i] = nullptr; } auto *ptr = head; for (int i = klevel - 1; i \u003e= 0; --i) { // 从上层开始往下层找，这里从下往上是不是也可以？ // 如果当前层 i 对应结点的 next 不为空，且它的值小于 target，则 ptr 往前走指向这一层 ptr 的 next while ((ptr-\u003enext_[i] != nullptr) \u0026\u0026 ptr-\u003enext_[i]-\u003eval_ \u003c target) { ptr = ptr-\u003enext_[i]; } pre[i] = ptr; } } bool search(int target) { Find(target, pre_); auto *ptr = (pre_[0]-\u003enext_)[0]; return ptr != nullptr \u0026\u0026 ptr-\u003eval_ == target; } void add(int num) { Find(num, pre_); auto *ptr = new Node(num); for (int i = 0; i \u003c klevel; ++i) { ptr-\u003enext_[i] = pre_[i]-\u003enext_[i]; // 其实就是链表的插入操作 pre_[i]-\u003enext_[i] = ptr; if (random() % 2 == 1) { break; } } } bool erase(int num) { if (!search(num)) { return false; } auto *ptr = pre_[0]-\u003enext_[0]; for (int i = 0; i \u003c klevel \u0026\u0026 pre_[i]-\u003enext_[i] == ptr; ++i) { pre_[i]-\u003enext_[i] = ptr-\u003enext_[i]; } delete ptr; return true; } private: Node *head; // 跳表头结点 vector\u003cNode *\u003e pre_; }; ","date":"2023-06-06","objectID":"/skiplist.zh/:3:4","series":null,"tags":["data structure and algorithms"],"title":"跳表","uri":"/skiplist.zh/#完整实现"},{"categories":["notes"],"content":" 4 参考C++ 手写跳表最简单的实现方式 维基百科：跳跃列表 OI-Wiki：跳表 ","date":"2023-06-06","objectID":"/skiplist.zh/:4:0","series":null,"tags":["data structure and algorithms"],"title":"跳表","uri":"/skiplist.zh/#参考"},{"categories":["leetcode"],"content":" 1 Description2718. Sum of Matrix After Queries (Medium) You are given an integer n and a 0-indexed 2D array queries where queries[i] = [typeᵢ, indexᵢ, valᵢ]. Initially, there is a 0-indexed n x n matrix filled with 0’s. For each query, you must apply one of the following changes: if typeᵢ == 0, set the values in the row with indexᵢ to valᵢ, overwriting any previous values. if typeᵢ == 1, set the values in the column with indexᵢ to valᵢ, overwriting any previous values. Return the sum of integers in the matrix after all queries are applied. Example 1: text Input: n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]] Output: 23 Explanation: The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 23. Example 2: text Input: n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]] Output: 17 Explanation: The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 17. Constraints: 1 \u003c= n \u003c= 10⁴ 1 \u003c= queries.length \u003c= 5 * 10⁴ queries[i].length == 3 0 \u003c= typeᵢ \u003c= 1 0 \u003c= indexᵢ \u003c n 0 \u003c= valᵢ \u003c= 10⁵ ","date":"2023-06-06","objectID":"/2718.sum-of-matrix-after-queries/:1:0","series":null,"tags":["math"],"title":"2718. Sum of Matrix After Queries (Medium)","uri":"/2718.sum-of-matrix-after-queries/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem is the third question in Leetcode’s 348th contest. At that time, I was struggling with it for a long time and felt foolish. I kept thinking that I needed to use some advanced data structure. However, it turns out that it’s not that difficult; the main challenge is to think differently. Essentially, this problem is a simulation task. However, if we follow the given instructions and simulate the process in ascending order, making incremental modifications and adjustments, we will fall into a trap and inevitably exceed the time limit. To approach the problem from a different angle, we can try simulating it in reverse order. By doing so, we don’t need to worry about overwriting. Instead, we only need to consider how many cells to fill during row or column filling. We can use a hash table to keep track of the unfilled rows or columns. During the reverse traversal, if we find that the current row has already been filled, we skip it. Otherwise, we add the product of $val \\times k$ to $total$, where $k$ represents the number of unfilled columns. The process for column filling is similar. ","date":"2023-06-06","objectID":"/2718.sum-of-matrix-after-queries/:2:0","series":null,"tags":["math"],"title":"2718. Sum of Matrix After Queries (Medium)","uri":"/2718.sum-of-matrix-after-queries/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: long long matrixSumQueries(int n, vector\u003cvector\u003cint\u003e\u003e \u0026queries) { unordered_set\u003cint\u003e col_hash, row_hash; for (int i = 0; i \u003c n; ++i) { col_hash.insert(i); row_hash.insert(i); } int m = queries.size(); long long total = 0; for (int i = m - 1; i \u003e= 0 \u0026\u0026 !col_hash.empty() \u0026\u0026 !row_hash.empty(); --i) { if (queries[i][0] == 0) { if (row_hash.find(queries[i][1]) == row_hash.end()) { continue; } total += col_hash.size() * queries[i][2]; row_hash.erase(queries[i][1]); } else { if (col_hash.find(queries[i][1]) == col_hash.end()) { continue; } total += row_hash.size() * queries[i][2]; col_hash.erase(queries[i][1]); } } return total; } }; ","date":"2023-06-06","objectID":"/2718.sum-of-matrix-after-queries/:3:0","series":null,"tags":["math"],"title":"2718. Sum of Matrix After Queries (Medium)","uri":"/2718.sum-of-matrix-after-queries/#code"},{"categories":["leetcode"],"content":" 1 问题描述2718. 查询后矩阵的和 (Medium) 给你一个整数 n 和一个下标从 0 开始的 二维数组 que ries ，其中 queries[i] = [typeᵢ, indexᵢ, valᵢ] 。 一开始，给你一个下标从 0 开始的 n x n 矩阵，所有元素均 为 0 。每一个查询，你需要执行以下操作之一： 如果 typeᵢ == 0 ，将第 indexᵢ 行的元素全部修改为 valᵢ ，覆盖任何之前的值。 如果 typeᵢ == 1 ，将第 indexᵢ 列的元素全部修改为 valᵢ ，覆盖任何之前的值。 请你执行完所有查询以后，返回矩阵中所有整数的和。 示例 1： text 输入：n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]] 输出：23 解释：上图展示了每个查询以后矩阵的值。所有操作执行完以后，矩 阵元素之和为 23 。 示例 2： text 输入：n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2 ,1]] 输出：17 解释：上图展示了每一个查询操作之后的矩阵。所有操作执行完以后 ，矩阵元素之和为 17 。 提示： 1 \u003c= n \u003c= 10⁴ 1 \u003c= queries.length \u003c= 5 * 10⁴ queries[i].length == 3 0 \u003c= typeᵢ \u003c= 1 0 \u003c= indexᵢ \u003c n 0 \u003c= valᵢ \u003c= 10⁵ ","date":"2023-06-06","objectID":"/2718.sum-of-matrix-after-queries.zh/:1:0","series":null,"tags":["math"],"title":"2718. 查询后矩阵的和 (Medium)","uri":"/2718.sum-of-matrix-after-queries.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题是 Leetcode 第 348 期的第三题，当时太蠢了，做了半天搞不定，一直在想是不是要用什么高级的数据结构，实际上并不难，主要是脑子要转过这个弯。 本题本质上还是个模拟题，只是如果按照题目意思，正序模拟，一步步修改数值并调整覆盖，那么就掉坑里了，必然超时。 正难则反，实际上，我们可以尝试倒序进行模拟，那么我们就不用考虑覆盖了，只需考虑行填充或者列填充时，填充多少个。 我们可以用哈希表来记录未被填充的行或者列，倒序遍历时，如果发现当前行已经被填充了，那就跳过，否则给 $total$ 加上 $val \\times k$，$k$ 表示还没有被填充的列的数目；填充列的情况是类似的。 ","date":"2023-06-06","objectID":"/2718.sum-of-matrix-after-queries.zh/:2:0","series":null,"tags":["math"],"title":"2718. 查询后矩阵的和 (Medium)","uri":"/2718.sum-of-matrix-after-queries.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: long long matrixSumQueries(int n, vector\u003cvector\u003cint\u003e\u003e \u0026queries) { // 倒序处理 unordered_set\u003cint\u003e col_hash, row_hash; for (int i = 0; i \u003c n; ++i) { col_hash.insert(i); row_hash.insert(i); } int m = queries.size(); long long total = 0; for (int i = m - 1; i \u003e= 0 \u0026\u0026 !col_hash.empty() \u0026\u0026 !row_hash.empty(); --i) { if (queries[i][0] == 0) { // 修改行 if (row_hash.find(queries[i][1]) == row_hash.end()) { // 说明后面还会被修改，直接不管他 continue; } total += col_hash.size() * queries[i][2]; row_hash.erase(queries[i][1]); } else { // 修改列 if (col_hash.find(queries[i][1]) == col_hash.end()) { continue; } total += row_hash.size() * queries[i][2]; col_hash.erase(queries[i][1]); } } return total; } }; ","date":"2023-06-06","objectID":"/2718.sum-of-matrix-after-queries.zh/:3:0","series":null,"tags":["math"],"title":"2718. 查询后矩阵的和 (Medium)","uri":"/2718.sum-of-matrix-after-queries.zh/#代码"},{"categories":["notes"],"content":" 1 引入数位是指把一个数字按照个、十、百、千、万等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 $0\\sim 9$。 数位 DP 一般是用来解决一类特定问题，以 1012. Numbers With Repeated Digits (Hard) 为例，这一类问题的特征非常明显 要求统计满足一定条件的数的数量； 这些条件经过转化后可以使用“数位”的思想去理解和判断； 输入会提供一个数字区间（有时候只提供上界）来作为统计的限制； 上界很大（例如 $10^{22}$），暴力枚举会超时。 ","date":"2023-06-06","objectID":"/number_dp.zh/:1:0","series":null,"tags":["dynamic programming","data structure and algorithms"],"title":"数位 DP","uri":"/number_dp.zh/#引入"},{"categories":["notes"],"content":" 2 思路对 1012. Numbers With Repeated Digits (Hard)，思路如下： 首先，正难则反，我们可以考虑 $[1, n]$ 范围内无重复数字的正整数的个数，记为 $res$，然后最终结果就是 $n - res + 1$（至于为什么还要再加上 $1$，后面会说明）。 因此问题转化为求 $[1, n]$ 范围内无重复数字的正整数的个数，符合上述的数位 DP 的特征，我们可以从记忆化搜索的角度去考虑，首先将 $n$ 转化为对应的字符串，对字符串的每一位，枚举每一位可能的数，如果最后组成的数字满足 $num \u003c n$，那么 $res += 1$，这里很容易想到 dfs(string \u0026str, int idx, int mask)，$mask$ 以二进制的形式表示 $0\\sim 9$ 范围内的数是否被选择过； 但是仅仅是这样，我们不能方便的判断当前组成的数字是否满足 $num \u003c n$，因此，我们需要一个额外的参数 $is_limit$。例如对数字 $n = 12345$，如果前面已经选择的数字为 $123$，那么对本次枚举，$is_limit$ 为 $true$，即数字只能选择 $0\\sim4$，又因为 $1,\\ 2,\\ 3$ 已经选择了，$mask = 14$，因此只有 $0,\\ 4$ 可以选，事实上，我们可以发现，在递归的过程中，当且仅当当前 $is_limit$ 为 $true$，且当前选择的数字与对应数位上的数字相等时，更深一层递归的 $is_limit$ 仍为 $true$，至此，递归函数为 dfs(string \u0026str, int idx, int mask, bool is_limit)； 此外，由于我们递归的终止条件应该是 $idx \\geq str.size()$，这样就只能统计出位数与 $n$ 相同的情况，而位数小于 $n$ 的就被忽略了，这是我们不能接受的，因此我们还需要一个参数 $filled$ 来标记之前的位有没有被填充，假设 $filled$ 为 $false$，说明之前没有被填充，那么有两种选择 当前位也不填充，res += dfs(str, idx + 1, false, mask, filled, cach)； 如果要填充，那么必须从 $1$ 开始填充（因为不能有前导 $0$）,res += dfs(str, idx + 1, false, mask, true, cach)。 ","date":"2023-06-06","objectID":"/number_dp.zh/:2:0","series":null,"tags":["dynamic programming","data structure and algorithms"],"title":"数位 DP","uri":"/number_dp.zh/#思路"},{"categories":["notes"],"content":" 3 模板根据以上分析，我们可以总结出一个数位 DP 适用的模板，如下： cpp int dfs(string \u0026str, int idx, bool is_limit, int mask, bool filled, vector\u003cvector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e\u003e \u0026cach) { if (idx == str.size()) { return 1; // 说明找到了一个合理的选择 } if (cach[idx][is_limit][mask][filled] != -1) { return cach[idx][is_limit][mask][filled]; } int limit = is_limit ? str[idx] - '0' : 9; int res = 0; if (!filled) { // 前面的数位都没有填充 res += dfs(str, idx + 1, false, mask, false, cach); } int left = filled ? 0 : 1; for (int i = left; i \u003c= limit; ++i) { if (((1 \u003c\u003c i) \u0026 mask) != 0) { // 说明 i 已经选择过了 continue; } res += dfs(str, idx + 1, is_limit \u0026\u0026 (i == str[idx] - '0'), mask | (1 \u003c\u003c i), true, cach); } cach[idx][is_limit][mask][filled] = res; return res; } 在这个模板中，由于所有位都不填，也会被统计进结果中，因此 $res$ 比实际的 $res$ 多了 $1$，我们可以在最后计算的时候减去 $1$，也可以把边界条件的返回值修改为如下： cpp if (idx == str.size()) { return is_num; // is_num 为 true 说明找到了一个合法的数字，为 false 说明所有位都不填 } ","date":"2023-06-06","objectID":"/number_dp.zh/:3:0","series":null,"tags":["dynamic programming","data structure and algorithms"],"title":"数位 DP","uri":"/number_dp.zh/#模板"},{"categories":["notes"],"content":" 4 参考OI-Wiki：数位 DP 0x3f：数位 DP 通用模板 ","date":"2023-06-06","objectID":"/number_dp.zh/:4:0","series":null,"tags":["dynamic programming","data structure and algorithms"],"title":"数位 DP","uri":"/number_dp.zh/#参考"},{"categories":["leetcode"],"content":" 1 Description1156. Swap For Longest Repeated Character Substring (Medium) You are given a string text. You can swap two of the characters in the text. Return the length of the longest substring with repeated characters. Example 1: text Input: text = \"ababa\" Output: 3 Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is \"aaa\" with length 3. Example 2: text Input: text = \"aaabaaa\" Output: 6 Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring \"aaaaaa\" with length 6. Example 3: text Input: text = \"aaaaa\" Output: 5 Explanation: No need to swap, longest repeated character substring is \"aaaaa\" with length is 5. Constraints: 1 \u003c= text.length \u003c= 2 * 10⁴ text consist of lowercase English characters only. ","date":"2023-06-03","objectID":"/1156.swap-for-longest-repeated-character-substring/:1:0","series":null,"tags":["two pointers"],"title":"1156. Swap For Longest Repeated Character Substring (Medium)","uri":"/1156.swap-for-longest-repeated-character-substring/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe problem can be solved using a dual-pointer approach. Firstly, we can utilize an array called $cnt$ to track the frequency of each character in the given text. Next, we establish three pointers: $i$, $j$, and $k$. Initially, all pointers are set to 0. We increment $j$ until $text[j]$ is not equal to $text[i]$. Then, we set $k = j + 1$ and continue incrementing $k$ until $text[k]$ is not equal to $text[i]$. At this point, we can calculate a partial result: $res = \\max(res, \\min(k - i, cnt[text[i]]))$. Afterwards, we update $i = j$ and repeat the above steps until $i \u003e= text.size()$. ","date":"2023-06-03","objectID":"/1156.swap-for-longest-repeated-character-substring/:2:0","series":null,"tags":["two pointers"],"title":"1156. Swap For Longest Repeated Character Substring (Medium)","uri":"/1156.swap-for-longest-repeated-character-substring/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maxRepOpt1(string text) { int n = text.size(); vector\u003cint\u003e prefix(26); for (int i = 1; i \u003c= n; ++i) { int c = text[i - 1] - 'a'; for (int j = 0; j \u003c 26; ++j) { if (j == c) { prefix[j] = prefix[j] + 1; } } } int res = 0; int i = 0, j = 0, k = 0; while (i \u003c n) { while (j \u003c n \u0026\u0026 text[j] == text[i]) { ++j; } k = j + 1; while (k \u003c n \u0026\u0026 text[k] == text[i]) { ++k; } res = max(res, min(k - i, prefix[text[i] - 'a'])); i = j; } return res; } }; ","date":"2023-06-03","objectID":"/1156.swap-for-longest-repeated-character-substring/:3:0","series":null,"tags":["two pointers"],"title":"1156. Swap For Longest Repeated Character Substring (Medium)","uri":"/1156.swap-for-longest-repeated-character-substring/#code"},{"categories":["leetcode"],"content":" 1 问题描述1156. 单字符重复子串的最大长度 (Medium) 如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字 符串。 给你一个字符串 text，你只能交换其中两个字符一次或者什么都 不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度 。 示例 1： text 输入：text = \"ababa\" 输出：3 示例 2： text 输入：text = \"aaabaaa\" 输出：6 示例 3： text 输入：text = \"aaabbaaa\" 输出：4 示例 4： text 输入：text = \"aaaaa\" 输出：5 示例 5： text 输入：text = \"abcdef\" 输出：1 提示： 1 \u003c= text.length \u003c= 20000 text 仅由小写英文字母组成。 ","date":"2023-06-03","objectID":"/1156.swap-for-longest-repeated-character-substring.zh/:1:0","series":null,"tags":["two pointers"],"title":"1156. 单字符重复子串的最大长度 (Medium)","uri":"/1156.swap-for-longest-repeated-character-substring.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路可以利用双指针解决，我们先用数组 $cnt$ 统计 $text$ 中每个字符的出现的次数。 然后我们定一个三个指针，分别为 $i$，$j$，$k$。初始时都为 $0$，然后我们让 $j$ 右移，直到 $text[j] \\neq text[i]$，然后令 $k = j + 1$，再右移 $k$，直到 $text[k] \\neq text[i]$，这里可以统计一次结果，$res = \\max(res, \\min(k - i, cnt[text[i]]))$，然后令 $i = j$，重复以上步骤直到 $i \u003e= text.size()$。 ","date":"2023-06-03","objectID":"/1156.swap-for-longest-repeated-character-substring.zh/:2:0","series":null,"tags":["two pointers"],"title":"1156. 单字符重复子串的最大长度 (Medium)","uri":"/1156.swap-for-longest-repeated-character-substring.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxRepOpt1(string text) { int n = text.size(); vector\u003cint\u003e prefix(26); for (int i = 1; i \u003c= n; ++i) { int c = text[i - 1] - 'a'; for (int j = 0; j \u003c 26; ++j) { if (j == c) { prefix[j] = prefix[j] + 1; } } } int res = 0; int i = 0, j = 0, k = 0; while (i \u003c n) { while (j \u003c n \u0026\u0026 text[j] == text[i]) { ++j; } k = j + 1; while (k \u003c n \u0026\u0026 text[k] == text[i]) { ++k; } res = max(res, min(k - i, prefix[text[i] - 'a'])); i = j; } return res; } }; ","date":"2023-06-03","objectID":"/1156.swap-for-longest-repeated-character-substring.zh/:3:0","series":null,"tags":["two pointers"],"title":"1156. 单字符重复子串的最大长度 (Medium)","uri":"/1156.swap-for-longest-repeated-character-substring.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2517. Maximum Tastiness of Candy Basket (Medium) You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k. The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket. Return the maximum tastiness of a candy basket. Example 1: text Input: price = [13,5,1,8,21,2], k = 3 Output: 8 Explanation: Choose the candies with the prices [13,5,21]. The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8. It can be proven that 8 is the maximum tastiness that can be achieved. Example 2: text Input: price = [1,3,1], k = 2 Output: 2 Explanation: Choose the candies with the prices [1,3]. The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2. It can be proven that 2 is the maximum tastiness that can be achieved. Example 3: text Input: price = [7,7,7,7], k = 2 Output: 0 Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0. Constraints: 2 \u003c= k \u003c= price.length \u003c= 10⁵ 1 \u003c= price[i] \u003c= 10⁹ ","date":"2023-06-01","objectID":"/2517.maximum-tastiness-of-candy-basket/:1:0","series":null,"tags":["binary search"],"title":"2517. Maximum Tastiness of Candy Basket (Medium)","uri":"/2517.maximum-tastiness-of-candy-basket/#description"},{"categories":["leetcode"],"content":" 2 SolutionFor problems that involve minimizing the maximum value or maximizing the minimum value, it is often appropriate to consider using the binary search technique. In this case, since we can combine candies in any way and the order of the candies is irrelevant, we can start by sorting the price array. Let’s denote the correct answer for this problem as ans. If $mid \\leq ans$, it means that the candies can be packed into $k$ types of candy boxes. Otherwise, if $mid \u003e ans$, it means that it is not possible to pack the candies into $k$ types of boxes. This allows us to identify the binary search’s binary nature. Moreover, we still need to utilize binary search to determine whether it is possible to pack the candies into $k$ types of candy boxes, based on the sorted price array. ","date":"2023-06-01","objectID":"/2517.maximum-tastiness-of-candy-basket/:2:0","series":null,"tags":["binary search"],"title":"2517. Maximum Tastiness of Candy Basket (Medium)","uri":"/2517.maximum-tastiness-of-candy-basket/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int Bsearch(int target, vector\u003cint\u003e \u0026price, int left) { int right = price.size(); while (left \u003c right) { int mid = left + (right - left) / 2; if (price[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return left; } bool Check(int mid, vector\u003cint\u003e \u0026price, int k, int n) { int start = 0; for (int i = 0; i \u003c k - 1; ++i) { start = Bsearch(price[start] + mid, price, start); // cout \u003c\u003c start \u003c\u003c \" start\\n\"; if (start \u003e= n) { return false; } } return true; } int maximumTastiness(vector\u003cint\u003e \u0026price, int k) { // 先排序，然后考虑是二分答案还是双指针 sort(price.begin(), price.end()); // 二分答案，时间复杂度为 log(price[i]) * k * log(n) int n = price.size(); int left = 0, right = (price[n - 1] - price[0]) / (k - 1) + 1; // 先看看 k 行不行，不行就改成 2 while (left \u003c right) { // 左闭右开 int mid = left + (right - left) / 2; if (Check(mid, price, k, n)) { left = mid + 1; } else { right = mid; } } return left - 1; } }; ","date":"2023-06-01","objectID":"/2517.maximum-tastiness-of-candy-basket/:3:0","series":null,"tags":["binary search"],"title":"2517. Maximum Tastiness of Candy Basket (Medium)","uri":"/2517.maximum-tastiness-of-candy-basket/#code"},{"categories":["leetcode"],"content":" 1 问题描述2517. 礼盒的最大甜蜜度 (Medium) 给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖 果的价格，另给你一个正整数 k 。 商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 **甜蜜度 ** 是礼盒中任意两种糖果 价格 绝对差的最小值。 返回礼盒的 最大 甜蜜度。 示例 1： text 输入：price = [13,5,1,8,21,2], k = 3 输出：8 解释：选出价格分别为 [13,5,21] 的三类糖果。 礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8 , 16) = 8 。 可以证明能够取得的最大甜蜜度就是 8 。 示例 2： text 输入：price = [1,3,1], k = 2 输出：2 解释：选出价格分别为 [1,3] 的两类糖果。 礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。 可以证明能够取得的最大甜蜜度就是 2 。 示例 3： text 输入：price = [7,7,7,7], k = 2 输出：0 解释：从现有的糖果中任选两类糖果，甜蜜度都会是 0 。 提示： 1 \u003c= price.length \u003c= 10⁵ 1 \u003c= price[i] \u003c= 10⁹ 2 \u003c= k \u003c= price.length ","date":"2023-06-01","objectID":"/2517.maximum-tastiness-of-candy-basket.zh/:1:0","series":null,"tags":["binary search"],"title":"517. 礼盒的最大甜蜜度 (Medium)","uri":"/2517.maximum-tastiness-of-candy-basket.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路对于这种最小化最大值或者最大化最小值的题目，应该想到二分答案。 由于本题可以任意组合糖果，与糖果之间的顺序无关，因此可以考虑先对 price 数组排序。 记本题的正确答案为 ans，如果 $mid \\leq ans$，那么糖果可以被打包成 $k$ 类糖果礼盒，否则不可以打包成 $k$ 类礼盒，于是我们就找到了满足二分的二段性条件。 同时，我们仍需要使用二分查找来判断是否可以打包成 $k$ 类糖果礼盒，基于排序后的 price 数组。 ","date":"2023-06-01","objectID":"/2517.maximum-tastiness-of-candy-basket.zh/:2:0","series":null,"tags":["binary search"],"title":"517. 礼盒的最大甜蜜度 (Medium)","uri":"/2517.maximum-tastiness-of-candy-basket.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int Bsearch(int target, vector\u003cint\u003e \u0026price, int left) { int right = price.size(); while (left \u003c right) { int mid = left + (right - left) / 2; if (price[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return left; } bool Check(int mid, vector\u003cint\u003e \u0026price, int k, int n) { int start = 0; for (int i = 0; i \u003c k - 1; ++i) { start = Bsearch(price[start] + mid, price, start); // cout \u003c\u003c start \u003c\u003c \" start\\n\"; if (start \u003e= n) { return false; } } return true; } int maximumTastiness(vector\u003cint\u003e \u0026price, int k) { // 先排序，然后考虑是二分答案还是双指针 sort(price.begin(), price.end()); // 二分答案，时间复杂度为 log(price[i]) * k * log(n) int n = price.size(); int left = 0, right = (price[n - 1] - price[0]) / (k - 1) + 1; // 先看看 k 行不行，不行就改成 2 while (left \u003c right) { // 左闭右开 int mid = left + (right - left) / 2; if (Check(mid, price, k, n)) { left = mid + 1; } else { right = mid; } } return left - 1; } }; ","date":"2023-06-01","objectID":"/2517.maximum-tastiness-of-candy-basket.zh/:3:0","series":null,"tags":["binary search"],"title":"517. 礼盒的最大甜蜜度 (Medium)","uri":"/2517.maximum-tastiness-of-candy-basket.zh/#代码"},{"categories":["notes"],"content":" 1 概述二分答案即利用二分查找来得到答案，一般情况下，左边界 $left$ 是 $0$ 或者 $1$；右边界 $right$ 则视题目条件而定，取一个很大的数，然后利用二分查找的思想，来找到答案。 ","date":"2023-06-01","objectID":"/binary_search.zh/:1:0","series":null,"tags":["binary search","data structure and algorithms"],"title":"二分答案","uri":"/binary_search.zh/#概述"},{"categories":["notes"],"content":" 2 二分答案的要求如果题目能够使用二分答案的思想来解决，那么 $[left, right]$ 范围内，要满足二段性，即对 $[left, res]$ 满足条件 $A$，而 $(res, right]$ 不满足条件 $A$，并且 res 的取值范围是连续的。 ","date":"2023-06-01","objectID":"/binary_search.zh/:2:0","series":null,"tags":["binary search","data structure and algorithms"],"title":"二分答案","uri":"/binary_search.zh/#二分答案的要求"},{"categories":["notes"],"content":" 3 适用情况如果题目要求满足 xxx 条件下的最大值或者最小值，就可以考虑二分答案，特别的，如果题目要求最小化的最大值或者最大化的最小值，那么要首先考虑使用二分答案。 ","date":"2023-06-01","objectID":"/binary_search.zh/:3:0","series":null,"tags":["binary search","data structure and algorithms"],"title":"二分答案","uri":"/binary_search.zh/#适用情况"},{"categories":["notes"],"content":" 4 例题2517. 礼盒的最大甜蜜度 (Medium) cpp class Solution { public: int Bsearch(int target, vector\u003cint\u003e \u0026price, int left) { int right = price.size(); while (left \u003c right) { int mid = left + (right - left) / 2; if (price[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return left; } bool Check(int mid, vector\u003cint\u003e \u0026price, int k, int n) { int start = 0; for (int i = 0; i \u003c k - 1; ++i) { start = Bsearch(price[start] + mid, price, start); // cout \u003c\u003c start \u003c\u003c \" start\\n\"; if (start \u003e= n) { return false; } } return true; } int maximumTastiness(vector\u003cint\u003e \u0026price, int k) { // 先排序，然后考虑是二分答案还是双指针 sort(price.begin(), price.end()); // 二分答案，时间复杂度为 log(price[i]) * k * log(n) int n = price.size(); int left = 0, right = (price[n - 1] - price[0]) / (k - 1) + 1; // 先看看 k 行不行，不行就改成 2 while (left \u003c right) { // 左闭右开 int mid = left + (right - left) / 2; if (Check(mid, price, k, n)) { left = mid + 1; } else { right = mid; } } return left - 1; } }; ","date":"2023-06-01","objectID":"/binary_search.zh/:4:0","series":null,"tags":["binary search","data structure and algorithms"],"title":"二分答案","uri":"/binary_search.zh/#例题"},{"categories":["notes"],"content":" 1 算法介绍","date":"2023-05-31","objectID":"/lru_lfu.zh/:1:0","series":null,"tags":["data structure and algorithms","hash table"],"title":"LRU 算法与 LFU 算法","uri":"/lru_lfu.zh/#算法介绍"},{"categories":["notes"],"content":" 1.1 LRULRU 全称是 Least Recently Used，即最近最久未使用算法。 LRU 根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高，它是页面置换算法的一种，也常用于缓存设计。 ","date":"2023-05-31","objectID":"/lru_lfu.zh/:1:1","series":null,"tags":["data structure and algorithms","hash table"],"title":"LRU 算法与 LFU 算法","uri":"/lru_lfu.zh/#lru"},{"categories":["notes"],"content":" 1.2 LFULFU 全称是 Least Frequently Used，根据频率来选择要淘汰的元素，即删除访问频率最低的元素，如果两个元素的访问频率相同，则淘汰访问频率最低的元素中最久没有被访问的元素。 ","date":"2023-05-31","objectID":"/lru_lfu.zh/:1:2","series":null,"tags":["data structure and algorithms","hash table"],"title":"LRU 算法与 LFU 算法","uri":"/lru_lfu.zh/#lfu"},{"categories":["notes"],"content":" 2 数据结构不管是 LRU 还是 LFU 算法，我们都需要使用到双向链表作为基础数据结构，由于 LRU 与 LFU 涉及的对双向链表的元素的操作比较复杂，还涉及对链表结点的其他操作，因此选择自己手写一个简单的双向链表，同时复习双向链表的实现（阿里一面就被问到了，半天没写对😅）。 这里根据 LRU 和 LFU 的需要，简单封装了删除结点、尾部插入结点、和判断双向链表是否为空三个函数，很大程度上简化了 LRU 和 LFU 的实现，降低了写算法实现代码的出错概率。 cpp struct Node { Node() { } Node(int val, int key) : val_(val), key_(key), next_(nullptr), pre_(nullptr) { } int val_; int freq_; Node *next_; Node *pre_; int key_; }; struct List { Node *vhead_; // 虚拟头结点 Node *vtail_; // 虚拟尾结点 int size_ = 0; // 链表中有效结点的数量 List() : vhead_(new Node()), vtail_(new Node()) { vhead_-\u003enext_ = vtail_; vtail_-\u003epre_ = vhead_; vhead_-\u003epre_ = nullptr; vtail_-\u003enext_ = nullptr; } ~List() { delete vtail_; delete vhead_; vhead_ = nullptr; vtail_ = nullptr; } void Insert(Node *node) { // 双向链表的插入, node 表示待插入结点，插入作为双向链表的尾结点 node-\u003epre_ = vtail_-\u003epre_; vtail_-\u003epre_-\u003enext_ = node; vtail_-\u003epre_ = node; node-\u003enext_ = vtail_; ++size_; } void Delete(Node *node) { // node 指向待删除结点 node-\u003enext_-\u003epre_ = node-\u003epre_; node-\u003epre_-\u003enext_ = node-\u003enext_; --size_; } bool Empty() { return size_ \u003c= 0; } }; ","date":"2023-05-31","objectID":"/lru_lfu.zh/:2:0","series":null,"tags":["data structure and algorithms","hash table"],"title":"LRU 算法与 LFU 算法","uri":"/lru_lfu.zh/#数据结构"},{"categories":["notes"],"content":" 3 LRU 实现对于 LRU 的实现，我们需要借助两个数组结构哈希表和双向链表来组成一个新的数据结构。我们利用哈希表实现 $O(1)$ 时间复杂度的查找，获取元素的 val 以及在双向链表中的位置；利用双向链表实现 $O(1)$ 时间复杂度内的元素插入和删除。 删除元素时，要么通过哈希表获取了待删除元素在链表中的位置，要么是删除头结点； 删除元素后，需要在哈希表中也删除该元素，因此 Node 需要有 key_ 成员； 插入元素则都是插入到链表的末尾结点。 注意插入和删除时的结点数量变化，只有当结点数量小于 capacity 时插入结点需要递增 cnt_。 cpp class LRUCache { public: LRUCache(int capacity) : lst(new List()), cap_(capacity) { } int get(int key) { if (hash.find(key) == hash.end()) { return -1; } Node *node = hash[key]; lst-\u003eDelete(node); lst-\u003eInsert(node); return node-\u003eval_; } void put(int key, int value) { if (hash.find(key) != hash.end()) { // key 已经存在 Node *node = hash[key]; node-\u003eval_ = value; node-\u003ekey_ = key; get(key); return; } // key 不存在，需要插入 if (cnt_ == cap_) { // 这里先插入或者先删除都能满足题义，我选择先插入，再删除（防止 capacity 为 0 的极限情况） Node *node = new Node(value, key); lst-\u003eInsert(node); hash[key] = node; // 删除头结点 Node *head = lst-\u003evhead_-\u003enext_; lst-\u003eDelete(head); hash.erase(head-\u003ekey_); delete head; head = nullptr; } else { // 直接插入即可 Node *node = new Node(value, key); lst-\u003eInsert(node); hash[key] = node; // 记得修改数量 ++cnt_; } } private: unordered_map\u003cint, Node *\u003e hash; List *lst; int cnt_ = 0; int cap_; }; ","date":"2023-05-31","objectID":"/lru_lfu.zh/:3:0","series":null,"tags":["data structure and algorithms","hash table"],"title":"LRU 算法与 LFU 算法","uri":"/lru_lfu.zh/#lru-实现"},{"categories":["notes"],"content":" 4 LFU 实现LFU 的实现比起 LRU 来说可要复杂太多了，要注意的地方也很多。LFU 需要用到两个哈希表，$N$ 个双向链表。 第一个哈希表是 key-node 哈希表，如下图所示，key 就是输入元素的 key； 第二个哈希表则是 Freq-List 哈希表，key 是元素的使用频率，value 是指向双向链表的指针，该双向链表与 LRU 中的双向链表形式类似。 将两个哈希表看起来看一下完整的数据结构： LFU 实现时，我们针对 get 操作和 put 操作分别讨论需要注意的地方。 get 操作相比 put 要简单一点，与 LRU 中的 get 操作类似， 区别在于要注意 get(key) 时，与 key 对应的 node 的 freq_ 需要递增，因此，还需要变更频率哈希表和它对应的链表; 如果链表变成了空链表，需要从频率哈希表中移除空链表对应的频率。 put 操作则要复杂很多： 如果 key 已经存在缓存中了，那么执行一次 get(key) 再更新一下 node 中的 val_ 即可； 如果 key 不存在于缓存中，那么我们要分缓存已满和缓存未满两种情况来讨论： 如果缓存已满，即 cnt_ == cap_，那么我们先执行删除结点，删除结点后，如果 min_freq_ 对应的链表变成了空链表，那么就要 delete 该链表，并且从频率哈希表中移除该最小频率；然后插入该结点（结点频率为 1），并且更新 min_freq_ 为 1； 如果缓存未满，我们插入该结点（结点频率为 1），并且更新 min_freq_ 为 1。 cpp class LFUCache { public: LFUCache(int capacity) : cap_(capacity), min_freq_(0), cnt_(0) { } int get(int key) { if (hash_.find(key) == hash_.end()) { return -1; } Node *node = hash_[key]; int freq = node-\u003efreq_; // 要更新频率，因此要从原先的频率链表上删除该结点 freqs_[freq]-\u003eDelete(node); if (freqs_[freq]-\u003eEmpty()) { // 删除该链表，频率哈希表中移除该频率 delete freqs_[freq]; freqs_.erase(freq); if (min_freq_ == freq) { // 则需要更新最小频率 min_freq_ = freq + 1; } } // 更新频率 ++node-\u003efreq_; freq = node-\u003efreq_; if (freqs_.find(freq) == freqs_.end()) { freqs_[freq] = new List(); } freqs_[freq]-\u003eInsert(node); return node-\u003eval_; } void put(int key, int value) { // key 已经在缓存中了 if (hash_.find(key) != hash_.end()) { get(key); hash_[key]-\u003eval_ = value; return; } /* key 不在缓存中 */ // 缓存已满 if (cnt_ == cap_) { // 删除 min_freq_ 链表对应的头结点 List *lst = freqs_[min_freq_]; Node *to_del = lst-\u003evhead_-\u003enext_; lst-\u003eDelete(to_del); hash_.erase(to_del-\u003ekey_); delete to_del; to_del = nullptr; // 如果 lst 变为空 if (lst-\u003eEmpty()) { delete lst; lst = nullptr; freqs_.erase(min_freq_); } // 现在执行插入 Node *node = new Node(value, key); node-\u003efreq_ = 1; min_freq_ = 1; if (freqs_.find(node-\u003efreq_) == freqs_.end()) { freqs_[node-\u003efreq_] = new List(); } freqs_[node-\u003efreq_]-\u003eInsert(node); hash_[key] = node; } else { // 现在执行插入 Node *node = new Node(value, key); node-\u003efreq_ = 1; min_freq_ = 1; if (freqs_.find(node-\u003efreq_) == freqs_.end()) { freqs_[node-\u003efreq_] = new List(); } freqs_[node-\u003efreq_]-\u003eInsert(node); hash_[key] = node; ++cnt_; } } private: unordered_map\u003cint, Node *\u003e hash_; unordered_map\u003cint, List *\u003e freqs_; int min_freq_; int cnt_; int cap_; }; 这里还要注意的是，类中 int 成员变量，如果没有在构造函数中显式执行初始化，其默认值很可能不是0。 ","date":"2023-05-31","objectID":"/lru_lfu.zh/:4:0","series":null,"tags":["data structure and algorithms","hash table"],"title":"LRU 算法与 LFU 算法","uri":"/lru_lfu.zh/#lfu-实现"},{"categories":["leetcode"],"content":" 1 问题描述2646. 最小化旅行的价格总和 (Hard) 现有一棵无向、无根的树，树中有 n 个节点，按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数 组 edges ，其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条边。 每个节点都关联一个价格。给你一个整数数组 price ，其中 pri ce[i] 是第 i 个节点的价格。 给定路径的 价格总和 是该路径上所有节点的价格之和。 另给你一个二维整数数组 trips ，其中 trips[i] = [startᵢ, e ndᵢ] 表示您从节点 startᵢ 开始第 i 次旅行，并通过任何你 喜欢的路径前往节点 endᵢ 。 在执行第一次旅行之前，你可以选择一些 非相邻节点 并将价格 减半。 返回执行所有旅行的最小价格总和。 示例 1： ![](https://assets.leetcode.com/uploads/2023/03/16/diagram2. png) text 输入：n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6] , trips = [[0,3],[2,1],[2,3]] 输出：23 解释： 上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第 二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。 第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。 第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。 第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。 所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实 现的最小答案。 示例 2： ![](https://assets.leetcode.com/uploads/2023/03/16/diagram3. png) text 输入：n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]] 输出：1 解释： 上图表示将节点 0 视为根之后的树结构。第一个图表示初始树，第 二个图表示选择节点 0 并使其价格减半后的树。 第 1 次旅行，选择路径 [0] 。路径的价格总和为 1 。 所有旅行的价格总和为 1 。可以证明，1 是可以实现的最小答案。 提示： 1 \u003c= n \u003c= 50 edges.length == n - 1 0 \u003c= aᵢ, bᵢ \u003c= n - 1 edges 表示一棵有效的树 price.length == n price[i] 是一个偶数 1 \u003c= price[i] \u003c= 1000 1 \u003c= trips.length \u003c= 100 0 \u003c= startᵢ, endᵢ \u003c= n - 1 ","date":"2023-05-31","objectID":"/2646.minimize-the-total-price-of-the-trips.zh/:1:0","series":null,"tags":["dfs"],"title":"2646. 最小化旅行的价格总和 (Hard)","uri":"/2646.minimize-the-total-price-of-the-trips.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贡献法 + 树上 dp 首先，对每条路径，在树上所有结点的价格已经确定的情况下，由于树是不存在环的，那么从起点到终点的非重复路径是唯一的，而这一最短路径必定对应着最小的路径价格。 因此，我们需要遍历 trip，并对树上每个结点，标记它一共被经过了多少次。 然后便是树上 dp 的思想了，即枚举当前结点选或不选两种情况，划分为更简单的子问题，从而可以递归解决，这里的返回值最好是 pair\u003cint, int\u003e，一个表示当前结点价格减半的最小价格之和，一个表示不减半的价格之和。 对于树的遍历，由于不存在环，我们不需要使用 vis 数组进行标记，只需要在 dfs 函数中添加一个参数表示其父结点就可以了。 ","date":"2023-05-31","objectID":"/2646.minimize-the-total-price-of-the-trips.zh/:2:0","series":null,"tags":["dfs"],"title":"2646. 最小化旅行的价格总和 (Hard)","uri":"/2646.minimize-the-total-price-of-the-trips.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: // 寻找不重复路径 void dfs(int cur, int end, vector\u003cint\u003e \u0026path, vector\u003cvector\u003cint\u003e\u003e \u0026graph, vector\u003cbool\u003e \u0026vis, vector\u003cvector\u003cint\u003e\u003e \u0026all_path) { if (cur == end) { all_path.push_back(path); return; } for (auto next : graph[cur]) { if (!vis[next]) { path.push_back(next); vis[next] = true; dfs(next, end, path, graph, vis, all_path); path.pop_back(); vis[next] = false; } } } pair\u003cint, int\u003e GetRes(vector\u003cvector\u003cint\u003e\u003e \u0026graph, vector\u003cint\u003e \u0026times, int fa, int idx, vector\u003cint\u003e \u0026price) { // 如何避免重复？ int half = price[idx] * times[idx] / 2, not_half = price[idx] * times[idx]; for (auto next : graph[idx]) { if (next == fa) { continue; } auto [sum_half, sum_not_half] = GetRes(graph, times, idx, next, price); half += sum_not_half; // next 不能减半了 not_half += min(sum_half, sum_not_half); } return {half, not_half}; } int minimumTotalPrice(int n, vector\u003cvector\u003cint\u003e\u003e \u0026edges, vector\u003cint\u003e \u0026price, vector\u003cvector\u003cint\u003e\u003e \u0026trips) { // 统计每个结点的贡献，即每个结点会被经过多少次 vector\u003cint\u003e times(n); vector\u003cvector\u003cint\u003e\u003e graph(n); for (int i = 0; i \u003c edges.size(); ++i) { int x = edges[i][0], y = edges[i][1]; graph[x].push_back(y); graph[y].push_back(x); } vector\u003cvector\u003cint\u003e\u003e all_path; for (auto \u0026vec : trips) { int start = vec[0], end = vec[1]; vector\u003cint\u003e path; vector\u003cbool\u003e vis(n); vis[start] = true; path.push_back(start); dfs(start, end, path, graph, vis, all_path); } vector\u003cint\u003e cnt(n); for (const auto \u0026path_ : all_path) { for (int idx : path_) { ++times[idx]; } } auto [half, not_half] = GetRes(graph, times, 0, 0, price); return min(half, not_half); } }; ","date":"2023-05-31","objectID":"/2646.minimize-the-total-price-of-the-trips.zh/:3:0","series":null,"tags":["dfs"],"title":"2646. 最小化旅行的价格总和 (Hard)","uri":"/2646.minimize-the-total-price-of-the-trips.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description421. Maximum XOR of Two Numbers in an Array (Medium) Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 \u003c= i \u003c= j \u003c n. Example 1: text Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28. Example 2: text Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127 Constraints: 1 \u003c= nums.length \u003c= 2 * 10⁵ 0 \u003c= nums[i] \u003c= 2³¹ - 1 ","date":"2023-05-30","objectID":"/421.maximum-xor-of-two-numbers-in-an-array/:1:0","series":null,"tags":["trie"],"title":"421. Maximum XOR of Two Numbers in an Array (Medium)","uri":"/421.maximum-xor-of-two-numbers-in-an-array/#description"},{"categories":["leetcode"],"content":" 2 SolutionIf we directly use a brute-force approach to find the maximum XOR value, the time complexity would be $O(n^2)$, which would inevitably lead to timeout errors. In reality, we can view the binary representation of each number as a string. Therefore, we can optimize the process of finding the XOR value by utilizing a data structure called a trie. In the brute-force scenario, when calculating the XOR value of nums[i] with other values, we need to traverse the entire array, resulting in a time complexity of $O(n)$. However, by using a trie, we can reduce this comparison time complexity from $O(n)$ to $O(\\log_2C)$, where $C$ represents the magnitude of the numbers and $\\log_2C$ corresponds to the number of bits in the binary representation of the numbers. To find the maximum XOR value, we should compare the numbers starting from the highest bit. Therefore, the trie should be constructed from the most significant bit. Since 0 \u003c= nums[i] \u003c= 2^31 - 1, we can insert the result of right-shifting nums[i] by j bits into the trie, with j decreasing from $31$ to $0$. ","date":"2023-05-30","objectID":"/421.maximum-xor-of-two-numbers-in-an-array/:2:0","series":null,"tags":["trie"],"title":"421. Maximum XOR of Two Numbers in an Array (Medium)","uri":"/421.maximum-xor-of-two-numbers-in-an-array/#solution"},{"categories":["leetcode"],"content":" 1 问题描述421. 数组中两个数的最大异或值 (Medium) 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大 运算结果，其中 0 ≤ i ≤ j \u003c n 。 示例 1： text 输入：nums = [3,10,5,25,2,8] 输出：28 解释：最大运算结果是 5 XOR 25 = 28. 示例 2： text 输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70] 输出：127 提示： 1 \u003c= nums.length \u003c= 2 * 10⁵ 0 \u003c= nums[i] \u003c= 2³¹ - 1 ","date":"2023-05-30","objectID":"/421.maximum-xor-of-two-numbers-in-an-array.zh/:1:0","series":null,"tags":["trie"],"title":"421. 数组中两个数的最大异或值 (Medium)","uri":"/421.maximum-xor-of-two-numbers-in-an-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路如果直接暴力，求解最大异或值，时间复杂度为 $O(n^2)$，必定会超时。 实际上，我们可以把每个数字的二进制表示看成字符串，因此可以使用 字典树 这一数据结构来优化求解异或值的过程。暴力情况下，求解 nums[i] 与其他值的异或值，需要遍历整个数组，时间复杂度为 $O(n)$，而利用字典树，我们可以将这个比较的时间复杂度从 $O(n)$ 优化为 $O(\\log_2C)$，其中 $C$ 为数字的大小，$\\log_2C$ 即为数字的二进制表示的位数。 如果我们要找到最大异或值，应该从数字的最高位开始比较，字典树也应该从数字的高位开始构建，由于 0 \u003c= nums[i] \u003c= 2^31 - 1，因此我们可以将 nums[i] 右移 j 位的结果插入字典树，j 从 $31$ 递减到 $0$。 ","date":"2023-05-30","objectID":"/421.maximum-xor-of-two-numbers-in-an-array.zh/:2:0","series":null,"tags":["trie"],"title":"421. 数组中两个数的最大异或值 (Medium)","uri":"/421.maximum-xor-of-two-numbers-in-an-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Trie { public: Trie() : tree_{nullptr, nullptr}, end_(false) { } void Insert(int num) { Trie *node = this; for (int i = 31; i \u003e= 0; --i) { int idx = ((num \u003e\u003e i) \u0026 1); if (node-\u003etree_[idx] == nullptr) { node-\u003etree_[idx] = new Trie(); } node = node-\u003etree_[idx]; } node-\u003eend_ = true; } int Count(int x) { Trie *node = this; int res = 0; for (int i = 31; i \u003e= 0; --i) { int a = (x \u003e\u003e i) \u0026 1, b = 1 - a; if (node-\u003etree_[b] != nullptr) { res |= (1 \u003c\u003c i); node = node-\u003etree_[b]; } else { node = node-\u003etree_[a]; } } return res; } private: vector\u003cTrie *\u003e tree_; bool end_; }; class Solution { public: int findMaximumXOR(vector\u003cint\u003e \u0026nums) { int res = 0; Trie *tree = new Trie(); for (auto num : nums) { tree-\u003eInsert(num); } for (auto num : nums) { res = max(res, tree-\u003eCount(num)); } return res; } }; ","date":"2023-05-30","objectID":"/421.maximum-xor-of-two-numbers-in-an-array.zh/:3:0","series":null,"tags":["trie"],"title":"421. 数组中两个数的最大异或值 (Medium)","uri":"/421.maximum-xor-of-two-numbers-in-an-array.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2681. Power of Heroes (Hard) You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows: Let i₀, i₁, … , iₖ be the indices of the heroes in a group. Then, the power of this group is max(nums[i₀], nums[i₁], ... ,nums[iₖ])² * min(nums[i₀], nums[i₁], ... ,nums[iₖ]). Return the sum of the power of all non-empty groups of heroes possible. Since the sum could be very large, return it modulo 10⁹ + 7. Example 1: text Input: nums = [2,1,4] Output: 141 Explanation: 1st group: [2] has power = 2² * 2 = 8. 2ⁿd group: [1] has power = 1² * 1 = 1. 3rd group: [4] has power = 4² * 4 = 64. 4th group: [2,1] has power = 2² * 1 = 4. 5th group: [2,4] has power = 4² * 2 = 32. 6th group: [1,4] has power = 4² * 1 = 16. 7th group: [2,1,4] has power = 4² * 1 = 16. The sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141. Example 2: text Input: nums = [1,1,1] Output: 7 Explanation: A total of 7 groups are possible, and the power of each group will be 1. Therefore, the sum of the powers of all groups is 7. Constraints: 1 \u003c= nums.length \u003c= 10⁵ 1 \u003c= nums[i] \u003c= 10⁹ ","date":"2023-05-29","objectID":"/2681.power-of-heroes/:1:0","series":null,"tags":["math"],"title":"2681.power of Heroes","uri":"/2681.power-of-heroes/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirstly, when dealing with array-related problems, we should consider whether sorting the array in advance would be beneficial. In this particular problem of selecting subsequences, since the subsequence can be non-contiguous, the order of the elements in the array does not affect the result. Next, we can adopt the approach of contribution, where we consider the contribution of each element as the maximum value to the final result. For example, let’s consider the array $[1, 2, 3, 4, 5]$. The contribution of the element $4$ as the maximum value can be calculated as $4^2 \\times (1 \\times 2^2 + 2 \\times 2^1 + 3 \\times 2^0) + 4^3$, which we denote as $a_3^2 s_3 + a_3^3$. Similarly, the contribution of the element $5$ as the maximum value is calculated as $5^2 \\times (1 \\times 2^3 + 2 \\times 2^2 + 3 \\times 2^1 + 4) + 5^3$, denoted as $a_4^2 s_4 + a_4^3$. We have the recurrence relation $s_i = 2 \\times s_{i - 1} + a_{i - 1}$. Hence, we can compute the result in constant time $O(1)$, while being mindful of taking modulo to prevent overflow. ","date":"2023-05-29","objectID":"/2681.power-of-heroes/:2:0","series":null,"tags":["math"],"title":"2681.power of Heroes","uri":"/2681.power-of-heroes/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int sumOfPower(vector\u003cint\u003e \u0026nums) { int mod = 1000000007; sort(nums.begin(), nums.end()); long res = 0; long s = 0; int n = nums.size(); for (long num : nums) { res = (res + ((num * num) % mod) * ((num + s) % mod)) % mod; s = (2 * s + num) % mod; } return res; } }; ","date":"2023-05-29","objectID":"/2681.power-of-heroes/:3:0","series":null,"tags":["math"],"title":"2681.power of Heroes","uri":"/2681.power-of-heroes/#code"},{"categories":["leetcode"],"content":" 1 问题描述2681. 英雄的力量 (Hard) 给你一个下标从 0 开始的整数数组 nums ，它表示英雄的能 力值。如果我们选出一部分英雄，这组英雄的 力量 定义为： i₀ ， i₁ ，… iₖ 表示这组英雄在数组中的下标。那么这组英雄的力量为 max(nums[i₀],nums[i₁] ... nums[iₖ])² * min(nums[i₀],nums[i₁] ... nums[iₖ]) 。 请你返回所有可能的 非空 英雄组的 力量 之和。由于答案 可能非常大，请你将结果对 10⁹ + 7 取余。 示例 1： text 输入：nums = [2,1,4] 输出：141 解释： 第 1 组：[2] 的力量为 2² * 2 = 8 。 第 2 组：[1] 的力量为 1² * 1 = 1 。 第 3 组：[4] 的力量为 4² * 4 = 64 。 第 4 组：[2,1] 的力量为 2² * 1 = 4 。 第 5 组：[2,4] 的力量为 4² * 2 = 32 。 第 6 组：[1,4] 的力量为 4² * 1 = 16 。 第 7 组：[2,1,4] 的力量为 4² * 1 = 16 。 所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。 示例 2： text 输入：nums = [1,1,1] 输出：7 解释：总共有 7 个英雄组，每一组的力量都是 1 。所以所有英雄组 的力量之和为 7 。 提示： 1 \u003c= nums.length \u003c= 10⁵ 1 \u003c= nums[i] \u003c= 10⁹ ","date":"2023-05-29","objectID":"/2681.power-of-heroes.zh/:1:0","series":null,"tags":["math"],"title":"2681. 英雄的力量 (Hard)","uri":"/2681.power-of-heroes.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，对数组相关的问题，我们要思考了能不能先对数组进行排序，由于这题是选择子序列，即可以不连续，因此数组的顺序对结果没有影响。 然后，我们可以采取贡献法的思路，即对每个元素，考虑它作为最大值时，对结果的贡献。 例如，考虑 $[1,\\ 2,\\ 3,\\ 4,\\ 5]$，$4$ 作为最大值时，对结果的贡献为 $4^2 \\times(1 \\times 2^2 + 2\\times 2^1 + 3 \\times 2^0 ) + 4^3$，记为 $a_3^2 s_3 + a_3^3$，$5$ 作为最大值时，对结果的贡献为 $5^2\\times (1\\times 2^3 + 2\\times 2^2+ 3\\times2^1 + 4) + 5^3$，记为 $a_4^2 s_4 + a_4^3$。 有 $s_i = 2 * s_{i - 1} + a_{i - 1}$。 因此，我们可以在 $O(1)$ 时间内计算出结果，注意取模防止溢出！。 ","date":"2023-05-29","objectID":"/2681.power-of-heroes.zh/:2:0","series":null,"tags":["math"],"title":"2681. 英雄的力量 (Hard)","uri":"/2681.power-of-heroes.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int sumOfPower(vector\u003cint\u003e \u0026nums) { int mod = 1000000007; sort(nums.begin(), nums.end()); long res = 0; long s = 0; int n = nums.size(); for (long num : nums) { res = (res + ((num * num) % mod) * ((num + s) % mod)) % mod; // 防止溢出 s = (2 * s + num) % mod; } return res; } }; ","date":"2023-05-29","objectID":"/2681.power-of-heroes.zh/:3:0","series":null,"tags":["math"],"title":"2681. 英雄的力量 (Hard)","uri":"/2681.power-of-heroes.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述2712. 使所有字符相等的最小成本 (Medium) 给你一个下标从 0 开始、长度为 n 的二进制字符串 s ， 你可以对其执行两种操作： 选中一个下标 i 并且反转从下标 0 到下标 i（包括下标 0 和下标 i ）的所有字符，成本为 i + 1 。 选中一个下标 i 并且反转从下标 i 到下标 n - 1（包括下 标 i 和下标 n - 1 ）的所有字符，成本为 n - i 。 返回使字符串内所有字符 相等 需要的 最小成本 。 反转 字符意味着：如果原来的值是 ‘0’ ，则反转后值变为 ‘1’ ，反之亦然。 示例 1： text 输入：s = \"0011\" 输出：2 解释：执行第二种操作，选中下标 i = 2 ，可以得到 s = \"0000\" ，成本为 2 。可以证明 2 是使所有字符相等的最小成本。 示例 2： text 输入：s = \"010101\" 输出：9 解释：执行第一种操作，选中下标 i = 2 ，可以得到 s = \"101101\" ，成本为 3 。 执行第一种操作，选中下标 i = 1 ，可以得到 s = \"011101\" ，成 本为 2 。 执行第一种操作，选中下标 i = 0 ，可以得到 s = \"111101\" ，成 本为 1 。 执行第二种操作，选中下标 i = 4 ，可以得到 s = \"111110\" ，成 本为 2 。 执行第一种操作，选中下标 i = 5 ，可以得到 s = \"111111\" ，成 本为 1 。 使所有字符相等的总成本等于 9 。可以证明 9 是使所有字符相等的 最小成本。 提示： 1 \u003c= s.length == n \u003c= 10⁵ s[i] 为 '0' 或 '1' ","date":"2023-05-29","objectID":"/2712.minimum-cost-to-make-all-characters-equal.zh/:1:0","series":null,"tags":["greedy algorithm"],"title":"2712. 使所有字符相等的最小成本 (Medium)","uri":"/2712.minimum-cost-to-make-all-characters-equal.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路遍历字符串，当碰到 s[i] 与 s[i + 1] 不相等的情况时，我们需要翻转字符串，可以执行第一种或者第二种方案，执行成本较小的那个方案。 这样执行后，s[i] 左侧的字符，包括 s[i] 都是相同的。 ","date":"2023-05-29","objectID":"/2712.minimum-cost-to-make-all-characters-equal.zh/:2:0","series":null,"tags":["greedy algorithm"],"title":"2712. 使所有字符相等的最小成本 (Medium)","uri":"/2712.minimum-cost-to-make-all-characters-equal.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: long long minimumCost(string s) { long long res = 0; int n = s.size(); for (int i = 0; i \u003c n - 1; ++i) { if (s[i] != s[i + 1]) { res += min(i + 1, n - i - 1); } } return res; } }; ","date":"2023-05-29","objectID":"/2712.minimum-cost-to-make-all-characters-equal.zh/:3:0","series":null,"tags":["greedy algorithm"],"title":"2712. 使所有字符相等的最小成本 (Medium)","uri":"/2712.minimum-cost-to-make-all-characters-equal.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2712. Minimum Cost to Make All Characters Equal (Medium) You are given a 0-indexed binary string s of length n on which you can apply two types of operations: Choose an index i and invert all characters from index 0 to index i (both inclusive), with a cost of i + 1 Choose an index i and invert all characters from index i to index n - 1 (both inclusive), with a cost of n - i Return the minimum cost to make all characters of the string equal. Invert a character means if its value is ‘0’ it becomes ‘1’ and vice-versa. Example 1: text Input: s = \"0011\" Output: 2 Explanation: Apply the second operation with i = 2 to obtain s = \"0000\" for a cost of 2. It can be shown that 2 is the minimum cost to make all characters equal. Example 2: text Input: s = \"010101\" Output: 9 Explanation: Apply the first operation with i = 2 to obtain s = \"101101\" for a cost of 3. Apply the first operation with i = 1 to obtain s = \"011101\" for a cost of 2. Apply the first operation with i = 0 to obtain s = \"111101\" for a cost of 1. Apply the second operation with i = 4 to obtain s = \"111110\" for a cost of 2. Apply the second operation with i = 5 to obtain s = \"111111\" for a cost of 1. The total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal. Constraints: 1 \u003c= s.length == n \u003c= 10⁵ s[i] is either '0' or '1' ","date":"2023-05-29","objectID":"/2712.minimum-cost-to-make-all-characters-equal/:1:0","series":null,"tags":["greedy algorithm"],"title":"2712. Minimum Cost to Make All Characters Equal (Medium)","uri":"/2712.minimum-cost-to-make-all-characters-equal/#description"},{"categories":["leetcode"],"content":" 2 SolutionWhile traversing the string, when encountering a situation where s[i] is not equal to s[i + 1], we need to reverse the string. We can choose to execute either the first or second approach, opting for the one with the lower cost. By following this procedure, the characters to the left of s[i], including s[i] itself, will all be identical. ","date":"2023-05-29","objectID":"/2712.minimum-cost-to-make-all-characters-equal/:2:0","series":null,"tags":["greedy algorithm"],"title":"2712. Minimum Cost to Make All Characters Equal (Medium)","uri":"/2712.minimum-cost-to-make-all-characters-equal/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: long long minimumCost(string s) { long long res = 0; int n = s.size(); for (int i = 0; i \u003c n - 1; ++i) { if (s[i] != s[i + 1]) { res += min(i + 1, n - i - 1); } } return res; } }; ","date":"2023-05-29","objectID":"/2712.minimum-cost-to-make-all-characters-equal/:3:0","series":null,"tags":["greedy algorithm"],"title":"2712. Minimum Cost to Make All Characters Equal (Medium)","uri":"/2712.minimum-cost-to-make-all-characters-equal/#code"},{"categories":["notes"],"content":" 1 定义字典树（Trie），是一个像字典一样的树，又称前缀树。 可以高效的查询某个字符串是否在一组给定的字符串中，或者说查询某个单词是否在字典中。 字典树的查询时间复杂度可以认为是 $O(l)$，其中 $l$ 为待查询单词的长度。 ","date":"2023-05-29","objectID":"/trie.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"字典树","uri":"/trie.zh/#定义"},{"categories":["notes"],"content":" 2 引入字典树示意图： 可以发现，这棵字典树用边来代表字母，而根结点到树上面某一个节点的路径就代表一个字符串，例如 $1\\rightarrow 4\\rightarrow 8\\rightarrow 12$ 表示的就是字符串 caa，如果结点 $12$ 对应的 end_ 字段的值为 $true$，说明 caa 是字典树中一个完整的字符串，否则只是一个前缀。 trie 的结构非常好懂，我们用 $\\delta(u,c)$ 表示结点 $u$ 的 $c$ 字符指向的下一个结点，或着说是结点 $u$ 代表的字符串后面添加一个字符 $c$ 形成的字符串的结点。（ $c$ 的取值范围和字符集大小有关，不一定是 $0\\sim 26$ 。） ","date":"2023-05-29","objectID":"/trie.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"字典树","uri":"/trie.zh/#引入"},{"categories":["notes"],"content":" 3 字典树的实现这里放一个简单的前缀树的类的实现， cpp struct Trie { int nex[10000][26], cnt; // nex 的第一维度表示前缀树的结点数量，与上面的图相对应 bool end[10000]; // 该结点结尾的字符串是否存在 void insert(char *s, int l) { // 插入字符串 int p = 0; for (int i = 0; i \u003c l; i++) { int c = s[i] - 'a'; if (!nex[p][c]) nex[p][c] = ++cnt; // 如果没有，就添加结点 p = nex[p][c]; } exist[p] = 1; } bool find(char *s, int l) { // 查找字符串 int p = 0; for (int i = 0; i \u003c l; i++) { int c = s[i] - 'a'; if (!nex[p][c]) return 0; p = nex[p][c]; } return exist[p]; } }; 也可以使用 new 动态创建前缀树，例如： cpp class Trie { private: vector\u003cTrie *\u003e vec; bool is_end; public: Trie() : vec(26), is_end(false) { for (int i = 0; i \u003c 26; ++i) { vec[i] = nullptr; } } void insert(string word) { Trie *node = this; for (int i = 0; i \u003c word.size(); ++i) { if (node-\u003evec[word[i] - 'a'] != nullptr) { node = node-\u003evec[word[i] - 'a']; } else { node-\u003evec[word[i] - 'a'] = new Trie(); node = node-\u003evec[word[i] - 'a']; } } node-\u003eis_end = true; } } ","date":"2023-05-29","objectID":"/trie.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"字典树","uri":"/trie.zh/#字典树的实现"},{"categories":["notes"],"content":" 4 应用","date":"2023-05-29","objectID":"/trie.zh/:4:0","series":null,"tags":["data structure and algorithms"],"title":"字典树","uri":"/trie.zh/#应用"},{"categories":["notes"],"content":" 4.1 字典查找字典树的最经典的应用——查找一个字符串是否在“字典”中出现过。 745. Prefix and Suffix Search (Hard) 676. Implement Magic Dictionary (Medium) 212. Word Search II (Hard) 648. Replace Words (Medium) ","date":"2023-05-29","objectID":"/trie.zh/:4:1","series":null,"tags":["data structure and algorithms"],"title":"字典树","uri":"/trie.zh/#字典查找"},{"categories":["notes"],"content":" 4.2 01 字典树将数的二进制表示看成一个字符串，就可以构建出字符集为 ${0, 1}$ 的字典树。 可以用于维护异或极值或者异或和。 421. Maximum XOR of Two Numbers in an Array (Medium) ","date":"2023-05-29","objectID":"/trie.zh/:4:2","series":null,"tags":["data structure and algorithms"],"title":"字典树","uri":"/trie.zh/#01-字典树"},{"categories":["notes"],"content":" 5 参考OI-Wiki ","date":"2023-05-29","objectID":"/trie.zh/:5:0","series":null,"tags":["data structure and algorithms"],"title":"字典树","uri":"/trie.zh/#参考"},{"categories":["notes"],"content":" 1 目标文件的格式目前，Linux 平台流行的 可执行文件（Executable）主要包含以下格式： Linux 下的 ELF（Executable Linkable Format），注意这里是二进制文件其内容的组织格式，与后缀无关； 目标文件是源代码经过编译后但是未进行链接的那些中间文件（Linux 下为 .o 文件），它与可执行文件格式非常相似，一般与可执行文件一起采用同一种格式存储，Linux 下采用 ELF 文件格式。 动态链接库（Dynamic Linking Library）、静态链接库（Static Linking Library）均采用可执行文件格式存储，Linux 下均按照 ELF 格式存储。 Linux 下的 .so、.a； ","date":"2023-05-28","objectID":"/elf_file_structure.zh/:1:0","series":null,"tags":["csapp"],"title":"ELF 文件结构分析","uri":"/elf_file_structure.zh/#目标文件的格式"},{"categories":["notes"],"content":" 2 ELF 文件结构CSAPP 上的 ELF 格式文件结构图： 更详细的 ELF 文件结构图： 可以看到，ELF 文件包含四个部分： 第一部分为 ELF Header； 第二部分为 Program Header Table，Relocatable object file 中该部分不存在，Executable object file 中该部分存在； 第三部分为 ELF Sections，包括 .text、.rodata、.data、.bss等； 第四部分为 ELF Section Header Table（或称节头表，后面以 sht 指代），注意 sht 不像 ELF Header 那样只有一块，它由多个 Section header table entry 组成。 ","date":"2023-05-28","objectID":"/elf_file_structure.zh/:2:0","series":null,"tags":["csapp"],"title":"ELF 文件结构分析","uri":"/elf_file_structure.zh/#elf-文件结构"},{"categories":["notes"],"content":" 3 ELF 的 16 进制内容elf.c 的内容如下： c unsigned long long data1 = 0xdddddddd11111111; unsigned long long data2 = 0xdddddddd22222222; void func1() { } void func2() { } 执行 gcc -c elf.c，会生成 elf.o，执行 hexdump elf.o \u003e elf.txt，会将 elf.o 的内容以 16 进制形式存储在 elf.txt 中，elf.txt 的内容如下： txt 00000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............| 00000010 01 00 3e 00 01 00 00 00 00 00 00 00 00 00 00 00 |..\u003e.............| 00000020 00 00 00 00 00 00 00 00 28 02 00 00 00 00 00 00 |........(.......| 00000030 00 00 00 00 40 00 00 00 00 00 40 00 0b 00 0a 00 |....@.....@.....| 00000040 55 48 89 e5 90 5d c3 55 48 89 e5 90 5d c3 00 00 |UH...].UH...]...| 00000050 11 11 11 11 dd dd dd dd 22 22 22 22 dd dd dd dd |........\"\"\"\"....| 00000060 00 47 43 43 3a 20 28 44 65 62 69 61 6e 20 31 32 |.GCC: (Debian 12| 00000070 2e 32 2e 30 2d 31 34 29 20 31 32 2e 32 2e 30 00 |.2.0-14) 12.2.0.| 00000080 14 00 00 00 00 00 00 00 01 7a 52 00 01 78 10 01 |.........zR..x..| 00000090 1b 0c 07 08 90 01 00 00 1c 00 00 00 1c 00 00 00 |................| 000000a0 00 00 00 00 07 00 00 00 00 41 0e 10 86 02 43 0d |.........A....C.| 000000b0 06 42 0c 07 08 00 00 00 1c 00 00 00 3c 00 00 00 |.B..........\u003c...| 000000c0 00 00 00 00 07 00 00 00 00 41 0e 10 86 02 43 0d |.........A....C.| 000000d0 06 42 0c 07 08 00 00 00 00 00 00 00 00 00 00 00 |.B..............| 000000e0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 000000f0 01 00 00 00 04 00 f1 ff 00 00 00 00 00 00 00 00 |................| 00000100 00 00 00 00 00 00 00 00 00 00 00 00 03 00 01 00 |................| 00000110 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000120 07 00 00 00 11 00 02 00 00 00 00 00 00 00 00 00 |................| 00000130 08 00 00 00 00 00 00 00 0d 00 00 00 11 00 02 00 |................| 00000140 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 |................| 00000150 13 00 00 00 12 00 01 00 00 00 00 00 00 00 00 00 |................| 00000160 07 00 00 00 00 00 00 00 19 00 00 00 12 00 01 00 |................| 00000170 07 00 00 00 00 00 00 00 07 00 00 00 00 00 00 00 |................| 00000180 00 65 6c 66 2e 63 00 64 61 74 61 31 00 64 61 74 |.elf.c.data1.dat| 00000190 61 32 00 66 75 6e 63 31 00 66 75 6e 63 32 00 00 |a2.func1.func2..| 000001a0 20 00 00 00 00 00 00 00 02 00 00 00 02 00 00 00 | ...............| 000001b0 00 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 |........@.......| 000001c0 02 00 00 00 02 00 00 00 07 00 00 00 00 00 00 00 |................| 000001d0 00 2e 73 79 6d 74 61 62 00 2e 73 74 72 74 61 62 |..symtab..strtab| 000001e0 00 2e 73 68 73 74 72 74 61 62 00 2e 74 65 78 74 |..shstrtab..text| 000001f0 00 2e 64 61 74 61 00 2e 62 73 73 00 2e 63 6f 6d |..data..bss..com| 00000200 6d 65 6e 74 00 2e 6e 6f 74 65 2e 47 4e 55 2d 73 |ment..note.GNU-s| 00000210 74 61 63 6b 00 2e 72 65 6c 61 2e 65 68 5f 66 72 |tack..rela.eh_fr| 00000220 61 6d 65 00 00 00 00 00 00 00 00 00 00 00 00 00 |ame.............| 00000230 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 00000260 00 00 00 00 00 00 00 00 1b 00 00 00 01 00 00 00 |................| 00000270 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000280 40 00 00 00 00 00 00 00 0e 00 00 00 00 00 00 00 |@...............| 00000290 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 |................| 000002a0 00 00 00 00 00 00 00 00 21 00 00 00 01 00 00 00 |........!.......| 000002b0 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 000002c0 50 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00 |P...............| 000002d0 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 |................| 000002e0 00 00 00 00 00 00 00 00 27 00 00 00 08 00 00 00 |........'.......| 000002f0 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000300 60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |`...............| 00000310 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 |................| 00000320 00 00 00 00 00 00 00 00 2c 00 00 00 01 00 00 00 |........,.......| 00000330","date":"2023-05-28","objectID":"/elf_file_structure.zh/:3:0","series":null,"tags":["csapp"],"title":"ELF 文件结构分析","uri":"/elf_file_structure.zh/#elf-的-16-进制内容"},{"categories":["notes"],"content":" 4 解析 ELF 文件elf.txt 第一行 00000000 对应的内容为 magic number，又称魔数，标识该文件格式，例如 0x7f 说明是 ELF 格式，0x45、0x4c、0x46 分别是 E、 L、F 的 ascii 码。 第二行 00000010 前 8 个字节分别表示 e_type、e_machine、e_version，e_type 为 0x01 表示为 Relocatable object file，e_machine 为 0x3e 表示为 x86_64 机器，后 8 个字节为 e_entry，规定 ELF 程序的入口虚拟地址，操作系统在加载完程序之后从这个地址开始执行进程的指令，Relocatable object file 一般没有入口地址，该值为 0。 第三行 00000020 前 8 个字节为 e_phoff，表示文件中 Program Header Table 的偏移量，对 Relocatable object file 来说无意义，为 0；后 8 个字节为 e_shoff，注意是小端机，其值为 0x228，说明 sht 的偏移量为 0x228（也可以认为从 0x228 处起为 sht）。 第四行 00000040 前 4 个字节为 e_flags，我们不关心；5、6 字节为 e_ehsize，为 0x40，说明 ELF Header 占据大小为 40 字节；7、8 字节为 e_phentsize，为每个 Program header table entry 占据的大小，由于是 Relocatable object file，这里为 0；9、10 字节为 Program header table entry 的个数，也为0；11、12 字节为 sht entry 的大小，为 0x40，即 64 字节；13、14 字节为 sht entry 的个数，为 0x0b；最后两个字节为 e_shstrndx，值为 0xa，指示了节名称字符串表在 sht 中的位置。 到这里，前四行的内容即为 ELF Header 的所有内容，我们已经可以计算出该 ELF 格式文件的大小了，为 $size = e_shoff + e_shentsize * e_shnum = \\texttt{0x228} + \\texttt{0x40} * \\texttt{0x0b} = \\texttt{0x4e8}$，elf.txt 文件的最后一行正好是 0x4e8。 我们也可以执行 readelf -h elf.o，其内容如下： txt ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x0 Start of program headers: 0 (bytes into file) Start of section headers: 552 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 11 Section header string table index: 10 与我们之前的分析也能够对应起来。 ","date":"2023-05-28","objectID":"/elf_file_structure.zh/:4:0","series":null,"tags":["csapp"],"title":"ELF 文件结构分析","uri":"/elf_file_structure.zh/#解析-elf-文件"},{"categories":["notes"],"content":" 5 Section header table 解析首先，执行 readelf -S elf.o，输出如下： sh There are 11 section headers, starting at offset 0x228: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 000000000000000e 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000050 0000000000000010 0000000000000000 WA 0 0 8 [ 3] .bss NOBITS 0000000000000000 00000060 0000000000000000 0000000000000000 WA 0 0 1 [ 4] .comment PROGBITS 0000000000000000 00000060 0000000000000020 0000000000000001 MS 0 0 1 [ 5] .note.GNU-stack PROGBITS 0000000000000000 00000080 0000000000000000 0000000000000000 0 0 1 [ 6] .eh_frame PROGBITS 0000000000000000 00000080 0000000000000058 0000000000000000 A 0 0 8 [ 7] .rela.eh_frame RELA 0000000000000000 000001a0 0000000000000030 0000000000000018 I 8 6 8 [ 8] .symtab SYMTAB 0000000000000000 000000d8 00000000000000a8 0000000000000018 9 3 8 [ 9] .strtab STRTAB 0000000000000000 00000180 000000000000001f 0000000000000000 0 0 1 [10] .shstrtab STRTAB 0000000000000000 000001d0 0000000000000054 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) 首先，从之前的 ELF Header 我们可以得知，sht 是从 0x228 开始的，sht entry 的 size 为 0x40，第零号 entry 的 name 为空，其他值也全都是 0，我们可以看第一号 entry。 前 4 个字节为 sh_name，值为 0x1b，表示的是它所代表的字符串在 section header string table 中的起始位置的偏移（或者说索引），我们可以看到，.shstrtab 的 offset 为 0x1d0，0x1d0 + 0x1b 的位置，以该位置起始的字符串为 0x2e、0x74、0x65、0x78、0x74，其 ascii 码对应的字符组成的字符串为 .text。 5~8 四个字节为 sh_type，值为 0x1； 9～16 这八个字节为 sh_flags，值为0x6，对应二进制为 $110_{(2)}$，要从二进制掩码的角度考虑这个值，通过 sh_flags 和 sh_type 即可确定该 Section 是 PROGBITS 类型，具有可写和可分配的属性； 17～24 这八个字节为 sh_addr，为 Section 在内存中的虚拟地址，对于 Relocatable object file 来说，该值没什么意义，因此为 0； 25～32 这八个字节为 sh_offset，即该 sht 对应的 Section table 的在文件中的 offset，值为 0x40； 33～40 这八个字节为 sh_size，表示 Sectionn table 的大小，这里为 0x0e； 41～48 这八个字节为 sh_link 和 sh_info，这里对其意义暂时不予讨论； 49～56 这八个字节为 sh_addralign，表示节头表的对齐方式； 59～64 这八个字节为 sh_entsize，表示 Section table 的单个表项的大小，这里值为 0x0，没有意义； 我们可以查看 .symtab sht 的 sh_entsize 为 0x18，其 sh_size 为 0xa8，$\\frac{\\texttt{0xa8}}{\\texttt{0x18}} = \\texttt{0x7}$，所以 .symtab Section table 一共有七个表项。 执行 readelf -s elf.o，输出为 sh Symbol table '.symtab' contains 7 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS elf.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 .text 3: 0000000000000000 8 OBJECT GLOBAL DEFAULT 2 data1 4: 0000000000000008 8 OBJECT GLOBAL DEFAULT 2 data2 5: 0000000000000000 7 FUNC GLOBAL DEFAULT 1 func1 6: 0000000000000007 7 FUNC GLOBAL DEFAULT 1 func2 输出与计算结果一致。 ","date":"2023-05-28","objectID":"/elf_file_structure.zh/:5:0","series":null,"tags":["csapp"],"title":"ELF 文件结构分析","uri":"/elf_file_structure.zh/#section-header-table-解析"},{"categories":["notes"],"content":" 6 参考计算机那些事(4)——ELF文件结构 CSAPP yangaaamin ","date":"2023-05-28","objectID":"/elf_file_structure.zh/:6:0","series":null,"tags":["csapp"],"title":"ELF 文件结构分析","uri":"/elf_file_structure.zh/#参考"},{"categories":["leetcode"],"content":" 1 Description Maximal Rectangle (Hard) Given a rows x cols binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. Example 1: text Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Example 2: text Input: matrix = [[\"0\"]] Output: 0 Example 3: text Input: matrix = [[\"1\"]] Output: 1 Constraints: rows == matrix.length cols == matrix[i].length 1 \u003c= row, cols \u003c= 200 matrix[i][j] is '0' or '1'. ","date":"2023-05-23","objectID":"/85.maximal-rectangle/:1:0","series":null,"tags":["monotone stack"],"title":"85. Maximal Rectangle (Hard)","uri":"/85.maximal-rectangle/#description"},{"categories":["leetcode"],"content":" 2 SolutionIn essence, this problem is akin to a layer encapsulating 84. Largest Rectangle in Histogram (Hard). Once this point is realized, the problem becomes less challenging. ","date":"2023-05-23","objectID":"/85.maximal-rectangle/:2:0","series":null,"tags":["monotone stack"],"title":"85. Maximal Rectangle (Hard)","uri":"/85.maximal-rectangle/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int largestRectangleArea(vector\u003cint\u003e \u0026heights) { if (heights.size() == 1) { return heights[0]; } stack\u003cint\u003e stk; int n = heights.size(); int res = 0; for (int i = 0; i \u003c n; ++i) { while (!stk.empty() \u0026\u0026 heights[i] \u003c heights[stk.top()]) { int h = heights[stk.top()]; stk.pop(); if (!stk.empty()) { res = max(res, (i - stk.top() - 1) * h); } else { res = max(res, (i)*h); } } stk.push(i); } int right = stk.top(); while (!stk.empty()) { int h = heights[stk.top()]; stk.pop(); if (!stk.empty()) { res = max(res, (right - stk.top()) * h); } else { res = max(res, h * n); } } return res; } }; ","date":"2023-05-23","objectID":"/85.maximal-rectangle/:3:0","series":null,"tags":["monotone stack"],"title":"85. Maximal Rectangle (Hard)","uri":"/85.maximal-rectangle/#code"},{"categories":["leetcode"],"content":" 1 问题描述85. 最大矩形 (Hard) 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进 制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例 1： ![](https://assets.leetcode.com/uploads/2020/09/14/maximal.j pg) text 输入：matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"], [\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] 输出：6 解释：最大矩形如上图所示。 示例 2： text 输入：matrix = [] 输出：0 示例 3： text 输入：matrix = [[\"0\"]] 输出：0 示例 4： text 输入：matrix = [[\"1\"]] 输出：1 示例 5： text 输入：matrix = [[\"0\",\"0\"]] 输出：0 提示： rows == matrix.length cols == matrix[0].length 1 \u003c= row, cols \u003c= 200 matrix[i][j] 为 '0' 或 '1' ","date":"2023-05-23","objectID":"/85.maximal-rectangle.zh/:1:0","series":null,"tags":["monotone stack"],"title":"85. 最大矩形 (Hard)","uri":"/85.maximal-rectangle.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路其实本题就相当于是 84. 柱状图中最大的矩形 (Hard) 套了一层皮，想到了这一点之后就不难了。 ","date":"2023-05-23","objectID":"/85.maximal-rectangle.zh/:2:0","series":null,"tags":["monotone stack"],"title":"85. 最大矩形 (Hard)","uri":"/85.maximal-rectangle.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int Count(int row, int n, vector\u003cint\u003e \u0026vec, vector\u003cvector\u003cchar\u003e\u003e \u0026matrix) { for (int i = 0; i \u003c n; ++i) { vec[i] = matrix[row][i] == '0' ? 0 : vec[i] + 1; } // 单调递增栈 stack\u003cint\u003e stk; int res = 0; for (int i = 0; i \u003c n; ++i) { while (!stk.empty() \u0026\u0026 vec[i] \u003c vec[stk.top()]) { int idx = stk.top(), h = vec[idx]; stk.pop(); int rec = stk.empty() ? h * i : h * (i - stk.top() - 1); res = max(rec, res); } stk.push(i); } while (!stk.empty()) { int idx = stk.top(); int h = vec[idx]; stk.pop(); int rec = stk.empty() ? h * n : h * (n - stk.top() - 1); res = max(res, rec); } return res; } int maximalRectangle(vector\u003cvector\u003cchar\u003e\u003e \u0026matrix) { // 二维前缀和？ // 转化为 84 题，即可用单调栈解决 int m = matrix.size(), n = matrix[0].size(); int res = 0; vector\u003cint\u003e vec(n); for (int i = 0; i \u003c m; ++i) { res = max(res, Count(i, n, vec, matrix)); } return res; } }; ","date":"2023-05-23","objectID":"/85.maximal-rectangle.zh/:3:0","series":null,"tags":["monotone stack"],"title":"85. 最大矩形 (Hard)","uri":"/85.maximal-rectangle.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description84. Largest Rectangle in Histogram (Hard) Given an array of integers heights representing the histogram’s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram. Example 1: text Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. Example 2: text Input: heights = [2,4] Output: 4 Constraints: 1 \u003c= heights.length \u003c= 10⁵ 0 \u003c= heights[i] \u003c= 10⁴ ","date":"2023-05-23","objectID":"/84.largest-rectangle-in-histogram/:1:0","series":null,"tags":["monotone stack"],"title":"84. Largest Rectangle in Histogram (Hard)","uri":"/84.largest-rectangle-in-histogram/#description"},{"categories":["leetcode"],"content":" 2 SolutionIndeed, this problem essentially seeks the minimum value within a variable length, continuous interval, as well as the length of this interval. The employment of a monotonic stack could be considered for this purpose. Whether to utilize a monotonically increasing or decreasing stack can be determined by simulating the examples provided in the problem statement. In this case, a monotonically increasing stack (from bottom to top) should be used. In this problem, we traverse the array. For nums[i], we identify the smallest r (denoted as ridx) that satisfies nums[r] \u003c nums[i] and r \u003e i, and the largest l (denoted as lidx) that satisfies nums[l] \u003c nums[i] and l \u003c i. Therefore, res = max(res, nums[i] * (ridx - lidx - 1)). We can utilize a monotonic stack to solve this problem within a time complexity of $O(n)$. ","date":"2023-05-23","objectID":"/84.largest-rectangle-in-histogram/:2:0","series":null,"tags":["monotone stack"],"title":"84. Largest Rectangle in Histogram (Hard)","uri":"/84.largest-rectangle-in-histogram/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int largestRectangleArea(vector\u003cint\u003e \u0026heights) { if (heights.size() == 1) { return heights[0]; } stack\u003cint\u003e stk; int n = heights.size(); int res = 0; for (int i = 0; i \u003c n; ++i) { while (!stk.empty() \u0026\u0026 heights[i] \u003c heights[stk.top()]) { int h = heights[stk.top()]; stk.pop(); if (!stk.empty()) { res = max(res, (i - stk.top() - 1) * h); } else { res = max(res, (i)*h); } } stk.push(i); } int right = stk.top(); while (!stk.empty()) { int h = heights[stk.top()]; stk.pop(); if (!stk.empty()) { res = max(res, (right - stk.top()) * h); } else { res = max(res, h * n); } } return res; } }; ","date":"2023-05-23","objectID":"/84.largest-rectangle-in-histogram/:3:0","series":null,"tags":["monotone stack"],"title":"84. Largest Rectangle in Histogram (Hard)","uri":"/84.largest-rectangle-in-histogram/#code"},{"categories":["leetcode"],"content":" 1 问题描述84. 柱状图中最大的矩形 (Hard) 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子 彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例 1: ![](https://assets.leetcode.com/uploads/2021/01/04/histogram .jpg) text 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2： ![](https://assets.leetcode.com/uploads/2021/01/04/histogram -1.jpg) text 输入： heights = [2,4] 输出： 4 提示： 1 \u003c= heights.length \u003c=10⁵ 0 \u003c= heights[i] \u003c= 10⁴ ","date":"2023-05-23","objectID":"/84.largest-rectangle-in-histogram.zh/:1:0","series":null,"tags":["monotone stack"],"title":"84. 柱状图中最大的矩形 (Hard)","uri":"/84.largest-rectangle-in-histogram.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题其实还是求一个连续变长区间的最小值，以及该区间的长度，可以考虑到使用单调栈来解决，至于使用单调递增还是单调递减栈，代入题目中的示例模拟一下就知道了，本题应该使用单调递增栈（栈底到栈顶单调递增）。 在本题中，我们遍历数组，对 nums[i]，找到满足 nums[r] \u003c nums[i] 且 r \u003e i 的最小的 r，记为 ridx，找到满足 nums[l] \u003c nums[i] 且 l \u003c i 的最大的 l，记为 lidx，则 res = max(res, nums[i] * (ridx - lidx - 1))，我们可以利用单调栈在 $O(n)$ 时间内完成求解。 ","date":"2023-05-23","objectID":"/84.largest-rectangle-in-histogram.zh/:2:0","series":null,"tags":["monotone stack"],"title":"84. 柱状图中最大的矩形 (Hard)","uri":"/84.largest-rectangle-in-histogram.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int largestRectangleArea(vector\u003cint\u003e \u0026heights) { // 栈底到栈顶单调递增，栈中存储的是索引 if (heights.size() == 1) { return heights[0]; } stack\u003cint\u003e stk; int n = heights.size(); int res = 0; for (int i = 0; i \u003c n; ++i) { while (!stk.empty() \u0026\u0026 heights[i] \u003c heights[stk.top()]) { int h = heights[stk.top()]; stk.pop(); if (!stk.empty()) { res = max(res, (i - stk.top() - 1) * h); } else { res = max(res, (i)*h); } } stk.push(i); } int right = stk.top(); while (!stk.empty()) { int h = heights[stk.top()]; stk.pop(); if (!stk.empty()) { res = max(res, (right - stk.top()) * h); } else { res = max(res, h * n); } } return res; } }; ","date":"2023-05-23","objectID":"/84.largest-rectangle-in-histogram.zh/:3:0","series":null,"tags":["monotone stack"],"title":"84. 柱状图中最大的矩形 (Hard)","uri":"/84.largest-rectangle-in-histogram.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2104. Sum of Subarray Ranges (Medium) You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray. Return the sum of all subarray ranges of nums. A subarray is a contiguous non-empty sequence of elements within an array. Example 1: text Input: nums = [1,2,3] Output: 4 Explanation: The 6 subarrays of nums are the following: [1], range = largest - smallest = 1 - 1 = 0 [2], range = 2 - 2 = 0 [3], range = 3 - 3 = 0 [1,2], range = 2 - 1 = 1 [2,3], range = 3 - 2 = 1 [1,2,3], range = 3 - 1 = 2 So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4. Example 2: text Input: nums = [1,3,3] Output: 4 Explanation: The 6 subarrays of nums are the following: [1], range = largest - smallest = 1 - 1 = 0 [3], range = 3 - 3 = 0 [3], range = 3 - 3 = 0 [1,3], range = 3 - 1 = 2 [3,3], range = 3 - 3 = 0 [1,3,3], range = 3 - 1 = 2 So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4. Example 3: text Input: nums = [4,-2,-3,4,1] Output: 59 Explanation: The sum of all subarray ranges of nums is 59. Constraints: 1 \u003c= nums.length \u003c= 1000 -10⁹ \u003c= nums[i] \u003c= 10⁹ Follow-up: Could you find a solution with O(n) time complexity? ","date":"2023-05-21","objectID":"/2104.sum-of-subarray-ranges/:1:0","series":null,"tags":["monotone stack"],"title":"2104. Sum of Subarray Ranges (Medium)","uri":"/2104.sum-of-subarray-ranges/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe brute force approach, that is, enumerating the left endpoint and then enumerating the right endpoint in the sub-loop, identifies the maximum and minimum values in the subarray, entailing a time complexity of $O(n^2)$. The outcome this problem seeks can be translated into the summation of the maximum values of all subarrays subtracted by the summation of the minimum values of all subarrays. The summation of the maximum values of all subarrays is denoted as $sum_{max} = \\sum\\limits_{i=0}^{n-1} nums[i] * cnt_i$, where $cnt_i$ represents the quantity of subarrays in which nums[i] is the maximum value. At this point, the problem has been transformed into the task 795. Number of Subarrays with Bounded Maximum (Medium). The summation of the minimum values of all subarrays is denoted as $sum_{min} = \\sum\\limits_{i=0}^{n-1} nums[i] *cnt_i$, where in this case $cnt_i$ is the number of subarrays in which nums[i] is the minimum value. ","date":"2023-05-21","objectID":"/2104.sum-of-subarray-ranges/:2:0","series":null,"tags":["monotone stack"],"title":"2104. Sum of Subarray Ranges (Medium)","uri":"/2104.sum-of-subarray-ranges/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: long long subArrayRanges(vector\u003cint\u003e \u0026nums) { stack\u003cint\u003e stk; int n = nums.size(); long sum_max = 0; for (int i = 0; i \u003c n; ++i) { while (!stk.empty() \u0026\u0026 nums[i] \u003e nums[stk.top()]) { int len1 = i - stk.top(); int idx = stk.top(); long val = nums[idx]; stk.pop(); int len2 = stk.empty() ? idx + 1 : idx - stk.top(); sum_max += val * len1 * len2; } stk.push(i); } while (!stk.empty()) { int idx = stk.top(); int len1 = n - idx; long val = nums[idx]; stk.pop(); int len2 = stk.empty() ? idx + 1 : idx - stk.top(); sum_max += val * len1 * len2; } long sum_min = 0; stack\u003cint\u003e stk_min; for (int i = 0; i \u003c n; ++i) { while (!stk_min.empty() \u0026\u0026 nums[i] \u003c nums[stk_min.top()]) { int idx = stk_min.top(); int len1 = i - idx; long val = nums[idx]; stk_min.pop(); int len2 = stk_min.empty() ? idx + 1 : idx - stk_min.top(); sum_min += val * len1 * len2; } stk_min.push(i); } while (!stk_min.empty()) { int idx = stk_min.top(); int len1 = n - idx; long val = nums[idx]; stk_min.pop(); int len2 = stk_min.empty() ? idx + 1 : idx - stk_min.top(); sum_min += val * len1 * len2; } return sum_max - sum_min; } }; ","date":"2023-05-21","objectID":"/2104.sum-of-subarray-ranges/:3:0","series":null,"tags":["monotone stack"],"title":"2104. Sum of Subarray Ranges (Medium)","uri":"/2104.sum-of-subarray-ranges/#code"},{"categories":["leetcode"],"content":" 1 问题描述2104. 子数组范围和 (Medium) 给你一个整数数组 nums 。 nums 中，子数组的 范围 是子 数组中最大元素和最小元素的差值。 返回 nums 中 所有 子数组范围的 和。 子数组是数组中一个连续 非空 的元素序列。 示例 1： text 输入：nums = [1,2,3] 输出：4 解释：nums 的 6 个子数组如下所示： [1]，范围 = 最大 - 最小 = 1 - 1 = 0 [2]，范围 = 2 - 2 = 0 [3]，范围 = 3 - 3 = 0 [1,2]，范围 = 2 - 1 = 1 [2,3]，范围 = 3 - 2 = 1 [1,2,3]，范围 = 3 - 1 = 2 所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4 示例 2： text 输入：nums = [1,3,3] 输出：4 解释：nums 的 6 个子数组如下所示： [1]，范围 = 最大 - 最小 = 1 - 1 = 0 [3]，范围 = 3 - 3 = 0 [3]，范围 = 3 - 3 = 0 [1,3]，范围 = 3 - 1 = 2 [3,3]，范围 = 3 - 3 = 0 [1,3,3]，范围 = 3 - 1 = 2 所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4 示例 3： text 输入：nums = [4,-2,-3,4,1] 输出：59 解释：nums 中所有子数组范围的和是 59 提示： 1 \u003c= nums.length \u003c= 1000 -10⁹ \u003c= nums[i] \u003c= 10⁹ 进阶： 你可以设计一种时间复杂度为 O(n) 的解决方案吗？ ","date":"2023-05-21","objectID":"/2104.sum-of-subarray-ranges.zh/:1:0","series":null,"tags":["monotone stack"],"title":"2104. 子数组范围和 (Medium)","uri":"/2104.sum-of-subarray-ranges.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路暴力方案，即枚举左端点，子循环再枚举右端点，找到子数组的最大值和最小值，时间复杂度为 $O(n^2)$。 本题所求的结果，可以转化为求所有子数组的最大值之和减去所有子数组的最小值之和。 所有子数组的最大值之和为 $sum_{max} = \\sum\\limits_{i=0}^{n-1} nums[i] * cnt_i$，其中 $cnt_i$ 为以 nums[i] 为最大值的子数组的数量，到这里题目就转化成了 795.区间子数组个数 (Medium)。 所有子数组的最小值之和为 $sum_{min} = \\sum\\limits_{i=0}^{n-1} nums[i] *cnt_i$，这里 $cnt_i$ 则是以 nums[i] 为最小值的子数组的数量。 ","date":"2023-05-21","objectID":"/2104.sum-of-subarray-ranges.zh/:2:0","series":null,"tags":["monotone stack"],"title":"2104. 子数组范围和 (Medium)","uri":"/2104.sum-of-subarray-ranges.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: long long subArrayRanges(vector\u003cint\u003e \u0026nums) { // 结果可以表示为所有子数组的最大值的和减去最小值的和 // 对 nums[i]，假设有 nums[idx] \u003c= nums[i] 小且 idx \u003c= i 的最大 idx 为 l， // 同理最小 idx 为 r，则以 nums[idx] 为最大值的子数组共有 (r - idx + 1) * (idx - l + 1)； // 可以用单调递减栈来解决，从栈底到栈顶单调递减 stack\u003cint\u003e stk; int n = nums.size(); long sum_max = 0; for (int i = 0; i \u003c n; ++i) { while (!stk.empty() \u0026\u0026 nums[i] \u003e nums[stk.top()]) { int len1 = i - stk.top(); int idx = stk.top(); long val = nums[idx]; stk.pop(); int len2 = stk.empty() ? idx + 1 : idx - stk.top(); sum_max += val * len1 * len2; } stk.push(i); } while (!stk.empty()) { int idx = stk.top(); int len1 = n - idx; long val = nums[idx]; stk.pop(); int len2 = stk.empty() ? idx + 1 : idx - stk.top(); sum_max += val * len1 * len2; } long sum_min = 0; stack\u003cint\u003e stk_min; for (int i = 0; i \u003c n; ++i) { while (!stk_min.empty() \u0026\u0026 nums[i] \u003c nums[stk_min.top()]) { int idx = stk_min.top(); int len1 = i - idx; long val = nums[idx]; stk_min.pop(); int len2 = stk_min.empty() ? idx + 1 : idx - stk_min.top(); sum_min += val * len1 * len2; } stk_min.push(i); } while (!stk_min.empty()) { int idx = stk_min.top(); int len1 = n - idx; long val = nums[idx]; stk_min.pop(); int len2 = stk_min.empty() ? idx + 1 : idx - stk_min.top(); sum_min += val * len1 * len2; } return sum_max - sum_min; } }; ","date":"2023-05-21","objectID":"/2104.sum-of-subarray-ranges.zh/:3:0","series":null,"tags":["monotone stack"],"title":"2104. 子数组范围和 (Medium)","uri":"/2104.sum-of-subarray-ranges.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述795. 区间子数组个数 (Medium) 给你一个整数数组 nums 和两个整数： left 及 right 。找 出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。 生成的测试用例保证结果符合 32-bit 整数范围。 示例 1： text 输入：nums = [2,1,4,3], left = 2, right = 3 输出：3 解释：满足条件的三个子数组：[2], [2, 1], [3] 示例 2： text 输入：nums = [2,9,2,5,6], left = 2, right = 8 输出：7 提示： 1 \u003c= nums.length \u003c= 10⁵ 0 \u003c= nums[i] \u003c= 10⁹ 0 \u003c= left \u003c= right \u003c= 10⁹ ","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum.zh/:1:0","series":null,"tags":["monotone stack","two pointers"],"title":"795.区间子数组个数 (Medium)","uri":"/795.number-of-subarrays-with-bounded-maximum.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum.zh/:2:0","series":null,"tags":["monotone stack","two pointers"],"title":"795.区间子数组个数 (Medium)","uri":"/795.number-of-subarrays-with-bounded-maximum.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 单调栈当我们看到这种连续区间中的最大值的题目时，就可以考虑使用单调栈。 对 nums[idx]，我们需要找到以 nums[idx] 为最大值的子数组的数量，设 lidx 为满足 nums[l] \u003e= nums[idx] 且 l \u003c idx 的最大的 l；设 ridx 为满足 nums[r] \u003e nums[idx] 且 r \u003e idx 中的最小的 r。我们要做的就是枚举满足 0 \u003c= idx \u003c n 的所有的 idx，找到对应的 lidx 和 ridx，从而计算出子数组的数量。 子数组的数量为 (ridx - idx) * (idx - lidx) 在本题中，我们可以考虑使用从栈底到栈顶单调递减的栈，来求出 ridx 和 lidx。注意，栈中的元素是索引 idx。枚举 i，当 nums[i] \u003e nums[stk.top()] 时，对 idx = stk.top()，将栈顶元素出栈，ridx = i，lidx 为新栈顶，如果栈为空，则 lidx = -1。 当枚举完 i 之后，对栈中剩余元素，idx = stk.top(), ridx = n，将栈中元素出栈，如果栈为空，lidx = -1，否则 lidx = stk.top();。 ","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum.zh/:2:1","series":null,"tags":["monotone stack","two pointers"],"title":"795.区间子数组个数 (Medium)","uri":"/795.number-of-subarrays-with-bounded-maximum.zh/#单调栈"},{"categories":["leetcode"],"content":" 2.2 双指针","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum.zh/:2:2","series":null,"tags":["monotone stack","two pointers"],"title":"795.区间子数组个数 (Medium)","uri":"/795.number-of-subarrays-with-bounded-maximum.zh/#双指针"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum.zh/:3:0","series":null,"tags":["monotone stack","two pointers"],"title":"795.区间子数组个数 (Medium)","uri":"/795.number-of-subarrays-with-bounded-maximum.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 单调栈 cpp class Solution { public: int numSubarrayBoundedMax(vector\u003cint\u003e \u0026nums, int left, int right) { // 单调栈，以 nums[i] 为最大值的子数组的个数 // 栈底到栈顶单调递减 int res = 0; stack\u003cint\u003e stk; int n = nums.size(); for (int i = 0; i \u003c n; ++i) { while (!stk.empty() \u0026\u0026 nums[i] \u003e nums[stk.top()]) { int idx = stk.top(); int len1 = i - idx; int val = nums[idx]; stk.pop(); int len2 = stk.empty() ? idx + 1 : idx - stk.top(); if (val \u003c= right \u0026\u0026 val \u003e= left) { res += len1 * len2; } } stk.push(i); } while (!stk.empty()) { int idx = stk.top(); int len1 = n - idx; int val = nums[idx]; stk.pop(); int len2 = stk.empty() ? idx + 1 : idx - stk.top(); if (val \u003c= right \u0026\u0026 val \u003e= left) { res += len1 * len2; } } return res; } }; ","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum.zh/:3:1","series":null,"tags":["monotone stack","two pointers"],"title":"795.区间子数组个数 (Medium)","uri":"/795.number-of-subarrays-with-bounded-maximum.zh/#单调栈-1"},{"categories":["leetcode"],"content":" 1 Description795. Number of Subarrays with Bounded Maximum (Medium) Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right]. The test cases are generated so that the answer will fit in a 32-bit integer. Example 1: text Input: nums = [2,1,4,3], left = 2, right = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3]. Example 2: text Input: nums = [2,9,2,5,6], left = 2, right = 8 Output: 7 Constraints: 1 \u003c= nums.length \u003c= 10⁵ 0 \u003c= nums[i] \u003c= 10⁹ 0 \u003c= left \u003c= right \u003c= 10⁹ ","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum/:1:0","series":null,"tags":["monotone stack","two pointers"],"title":"795.number of Subarrays With Bounded Maximum","uri":"/795.number-of-subarrays-with-bounded-maximum/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum/:2:0","series":null,"tags":["monotone stack","two pointers"],"title":"795.number of Subarrays With Bounded Maximum","uri":"/795.number-of-subarrays-with-bounded-maximum/#solution"},{"categories":["leetcode"],"content":" 2.1 Monotone stackWhen we encounter problems concerning the maximum value within a continuous interval, the application of a monotonic stack is worth considering. For nums[idx], we aim to determine the quantity of subarrays where nums[idx] is the maximum value. Let lidx be the largest l that satisfies nums[l] \u003e= nums[idx] and l \u003c idx; let ridx be the smallest r that satisfies nums[r] \u003e nums[idx] and r \u003e idx. Our task is to enumerate all idx that satisfy 0 \u003c= idx \u003c n, find the corresponding lidx and ridx, and thereby calculate the quantity of subarrays. The quantity of subarrays equals (ridx - idx) * (idx - lidx) In this problem, we can consider using a stack that decreases monotonically from the bottom to the top to find ridx and lidx. Note that the elements in the stack are indices idx. When enumerating i, if nums[i] \u003e nums[stk.top()], for idx = stk.top(), pop the top element of the stack, ridx = i, lidx is the new top of the stack, if the stack is empty, then lidx = -1. After enumerating i, for the remaining elements in the stack, idx = stk.top(), ridx = n, pop the elements in the stack, if the stack is empty, lidx = -1, otherwise lidx = stk.top();. ","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum/:2:1","series":null,"tags":["monotone stack","two pointers"],"title":"795.number of Subarrays With Bounded Maximum","uri":"/795.number-of-subarrays-with-bounded-maximum/#monotone-stack"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum/:3:0","series":null,"tags":["monotone stack","two pointers"],"title":"795.number of Subarrays With Bounded Maximum","uri":"/795.number-of-subarrays-with-bounded-maximum/#code"},{"categories":["leetcode"],"content":" 3.1 Monotone stack cpp class Solution { public: int numSubarrayBoundedMax(vector\u003cint\u003e \u0026nums, int left, int right) { int res = 0; stack\u003cint\u003e stk; int n = nums.size(); for (int i = 0; i \u003c n; ++i) { while (!stk.empty() \u0026\u0026 nums[i] \u003e nums[stk.top()]) { int idx = stk.top(); int len1 = i - idx; int val = nums[idx]; stk.pop(); int len2 = stk.empty() ? idx + 1 : idx - stk.top(); if (val \u003c= right \u0026\u0026 val \u003e= left) { res += len1 * len2; } } stk.push(i); } while (!stk.empty()) { int idx = stk.top(); int len1 = n - idx; int val = nums[idx]; stk.pop(); int len2 = stk.empty() ? idx + 1 : idx - stk.top(); if (val \u003c= right \u0026\u0026 val \u003e= left) { res += len1 * len2; } } return res; } }; ","date":"2023-05-21","objectID":"/795.number-of-subarrays-with-bounded-maximum/:3:1","series":null,"tags":["monotone stack","two pointers"],"title":"795.number of Subarrays With Bounded Maximum","uri":"/795.number-of-subarrays-with-bounded-maximum/#monotone-stack-1"},{"categories":["notes"],"content":" 1 问题描述考虑 1044. 最长重复子串 (Hard)，本题思路并不难，可以使用二分答案来解决，假设答案为 mid，那么长度大于 mid 的子串在 s 中只会出现一次，否则至少出现两次。 因此只需要考虑子串在 s 中的出现次数即可，比较直接的想法是使用 key 为 string 的 unordered_map，然而 unoredere_map 自带的哈希函数，其时间复杂度和空间复杂度都很高，为 $O(len)$，因此，需要一个简单一点的哈希函数。 ","date":"2023-05-15","objectID":"/string_hash.zh/:1:0","series":null,"tags":["hash table","string"],"title":"字符串哈希算法","uri":"/string_hash.zh/#问题描述"},{"categories":["notes"],"content":" 2 字符串哈希参照宫水三叶大佬的 字符串哈希。 我们需要使用一个比字符串 s 略长的哈希数组 vector\u003cint\u003e h(s.size() + 10)，以及次方数组 vector\u003cint\u003e p(s.size() + 10)。 对长度为 len 的数组，只需要利用前缀和思想 h[i + len] - h[i] * p[len] 即可在 $O(1)$ 时间内计算出哈希值。 其中 p[0] = 1，h[i] = h[i - 1] * P + s[i - 1]；p[i] = p[i - 1] * P。 $P$ 可以依次取 $131,\\ 13131,\\ 1313131$ 等，出现哈希碰撞就考虑取更大的质数。 其所使用的哈希函数计算方法本质为：$hash(s) = \\sum\\limits_{i = 1}^{l} s[i - 1] * P^{l - i}$（其中 $l$ 是字符串 $s$ 的长度）。 对这个前缀和计算公式作一个简单证明： $hash(s[1…r]) = \\sum\\limits_{i = 1}^{r}s[i - 1] * P^{r - i}，hash(s[1…l]) = \\sum\\limits_{i = 1}^{l}s[i - 1]*P^{l - i}$ $hash(s[1…r]) -P^{r - l} * hash(s[1…l]) = \\sum\\limits_{i = 1}^{l}s[i - 1]P^{r-l+l-i} +\\sum\\limits_{i=l+1}^{r}s[i - 1] P^{r-i}-P^{r-l}*\\sum\\limits_{i = 1}^{l}s[i - 1]P^{l - i} = \\sum\\limits_{i=l+1}^{r}s[i - 1] P^{r-i}$ 而 $hash(s[l + 1…r]) = \\sum\\limits_{i = l}^{r}s[i - 1] * P^{r - i}$ 即 $hash(s[1…r]) - hash(s[1…l]) * P^{r - l} = hash(s[l + 1…r])$ ","date":"2023-05-15","objectID":"/string_hash.zh/:2:0","series":null,"tags":["hash table","string"],"title":"字符串哈希算法","uri":"/string_hash.zh/#字符串哈希"},{"categories":["notes"],"content":" 3 代码 cpp class Solution { public: string check(int mid, string \u0026s, vector\u003cuint64_t\u003e \u0026h, vector\u003cuint64_t\u003e \u0026p) { unordered_set\u003cuint64_t\u003e substrs; for (int i = 0; i + mid \u003c= s.size(); ++i) { int j = i + mid; long hash = h[j] - h[i] * p[j - i]; if (substrs.find(hash) != substrs.end()) { return s.substr(i, mid); } substrs.insert(hash); } return \"\"; } string longestDupSubstring(string s) { // 二分查找答案，左边界为0，右边界为 s.size()，左闭右开 unordered_map\u003cstring, int\u003e substr; int left = 0, right = s.size(); string ans; int P = 1313131, n = s.size(); vector\u003cuint64_t\u003e h(n + 10); vector\u003cuint64_t\u003e p(n + 10); p[0] = 1; for (int i = 0; i \u003c n; ++i) { p[i + 1] = p[i] * P; h[i + 1] = h[i] * P + s[i]; } while (left \u003c right) { int mid = left + (right - left) / 2; string tmp_res = check(mid, s, h, p); if (!tmp_res.empty()) { left = mid + 1; } else { right = mid; } ans = ans.size() \u003c tmp_res.size() ? tmp_res : ans; } return ans; } }; ","date":"2023-05-15","objectID":"/string_hash.zh/:3:0","series":null,"tags":["hash table","string"],"title":"字符串哈希算法","uri":"/string_hash.zh/#代码"},{"categories":["notes"],"content":" 1 简单定义简单起见，我们这里只考虑三位二进制数所能表示的范围，即$[-4, -3, -2, -1, 0,\\ 1,\\ 2,\\ 3]$。 ","date":"2023-05-08","objectID":"/2_complement.zh/:1:0","series":null,"tags":["csapp"],"title":"二进制下的补码、反码、原码——适用于有符号整数","uri":"/2_complement.zh/#简单定义"},{"categories":["notes"],"content":" 2 机器数和真值一个数在计算机中的二进制表现形式，就是这个数的机器数（相当于数的原码）。 例如，$-3$ 的机器数即为 $111$，$2$ 的机器数为 $010$。 机器数在考虑最高位为符号位的情况下，换算出来的值就是真值，例如 $111$ 的真值为 $-3$，而形式值为 $7$；$010$ 的形式值和真值都为 $2$。 ","date":"2023-05-08","objectID":"/2_complement.zh/:2:0","series":null,"tags":["csapp"],"title":"二进制下的补码、反码、原码——适用于有符号整数","uri":"/2_complement.zh/#机器数和真值"},{"categories":["notes"],"content":" 3 原码、反码、补码有符号整数的原码就是它的机器数，正数的反码与原码相同，而负数的反码则是符号位不变，其余位取反。 正数的补码（Complement）不变，负数的补码则是它的反码 $+1$，例如 $-1$ 的反码为 $110$，补码为 $111$；也可以说负数的补码是该负数的相反数的原码取反 $+1$。 ","date":"2023-05-08","objectID":"/2_complement.zh/:3:0","series":null,"tags":["csapp"],"title":"二进制下的补码、反码、原码——适用于有符号整数","uri":"/2_complement.zh/#原码反码补码"},{"categories":["notes"],"content":" 4 为什么要用补码？使用补码可以解决减法运算的问题。 例如 $2 - 1 = 2 + (-1) = 010 + 111 = 001 = 1$ （$1001$ 去掉超出的最高位）。 使用原码或者反码都不好处理这个问题。 ","date":"2023-05-08","objectID":"/2_complement.zh/:4:0","series":null,"tags":["csapp"],"title":"二进制下的补码、反码、原码——适用于有符号整数","uri":"/2_complement.zh/#为什么要用补码"},{"categories":["notes"],"content":" 5 为什么补码会有这个效果？我们首先要意识到一点，$-1$ 的补码为 $111$，$111$ 对应的形式值为 $7$，而 $7 - (-1) = 8$。 例如，当我们使用 $2 - 1$ 时，相当于 $2 + 7 = 9$，然而，由于我们只能表示 $-4 \\sim 3$ 这个范围内的所有数，大于 3 的数，就变成了 $9\\mod 8 = 1$。 或者我们可以从循环的角度考虑：$[-4, -3, -2, -1,\\ 0, \\ 1,\\ 2,\\ 3,-4,-3,-2,-1,\\ 0,\\ 1,\\ 2,\\ 3]$，正好循环到 $1$。 从数学的角度，$-1$ 与 $7$ 对 $8$ 同余，那么: $(2 + -1)\\mod\\ 8 = (2\\mod 8)\\ +\\ ((-1)\\mod 8)\\ =\\ (2\\mod8)\\ +\\ (7\\mod 8)\\ =\\ (2+7)\\mod 8\\ =\\ 1$。（$8$ 对应开始提到的用三位二进制表示）。 注意：$-4$ 没有原码和反码表示，补码为 $100$。（可以理解为由 $011 + 1$ 得到）。 ","date":"2023-05-08","objectID":"/2_complement.zh/:5:0","series":null,"tags":["csapp"],"title":"二进制下的补码、反码、原码——适用于有符号整数","uri":"/2_complement.zh/#为什么补码会有这个效果"},{"categories":["leetcode"],"content":" 1 问题描述373. 查找和最小的 K 对数字 (Medium) 给定两个以 升序排列 的整数数组 nums1 和 nums2, 以及 一个整数 k。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来 自 nums2。 请找到和最小的 k 个数对 (u₁,v₁), (u₂,v₂) … (uₖ,v ₖ) 。 示例 1: text 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 输出: [1,2],[1,4],[1,6] 解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6 ] 示例 2: text 输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 输出: [1,1],[1,1] 解释: 返回序列中的前 2 对数： [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] 示例 3: text 输入: nums1 = [1,2], nums2 = [3], k = 3 输出: [1,3],[2,3] 解释: 也可能序列中所有的数对都被返回:[1,3],[2,3] 提示: 1 \u003c= nums1.length, nums2.length \u003c= 10⁵ -10⁹ \u003c= nums1[i], nums2[i] \u003c= 10⁹ nums1 和 nums2 均为升序排列 1 \u003c= k \u003c= 1000 ","date":"2023-05-06","objectID":"/373.find-k-pairs-with-smallest-sums.zh/:1:0","series":null,"tags":["priority queue"],"title":"373. 查找和最小的 K 对数字 (Medium)","uri":"/373.find-k-pairs-with-smallest-sums.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，可以使用小根堆来得到每次最小的数对，假设当前最小数对为 $(a_i, b_j)$，那么比该数对大，但是最小的数对可能有两个：$(a_{i + 1}, b_j)$ 或 $(a_i, b_{j + 1})$，然而，直接将 $(a_{i + 1}, b_j)$ 或 $(a_i, b_{j + 1})$ 数对加入到队列中，可能会导致选入了重复的数对，解决方案，可以参照这两张图： 出现重复的情况： 去除重复的方案： ","date":"2023-05-06","objectID":"/373.find-k-pairs-with-smallest-sums.zh/:2:0","series":null,"tags":["priority queue"],"title":"373. 查找和最小的 K 对数字 (Medium)","uri":"/373.find-k-pairs-with-smallest-sums.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e kSmallestPairs(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2, int k) { auto cmp = [\u0026nums1, \u0026nums2](const pair\u003cint, int\u003e \u0026 a, const pair\u003cint, int\u003e \u0026 b) { return nums1[a.first] + nums2[a.second] \u003e nums1[b.first] + nums2[b.second]; }; int m = nums1.size(); int n = nums2.size(); vector\u003cvector\u003cint\u003e\u003e ans; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq(cmp); for (int i = 0; i \u003c min(k, m); i++) { pq.emplace(i, 0); } while (k-- \u003e 0 \u0026\u0026 !pq.empty()) { auto [x, y] = pq.top(); pq.pop(); ans.emplace_back(initializer_list\u003cint\u003e{nums1[x], nums2[y]}); if (y + 1 \u003c n) { pq.emplace(x, y + 1); } } return ans; } }; ","date":"2023-05-06","objectID":"/373.find-k-pairs-with-smallest-sums.zh/:3:0","series":null,"tags":["priority queue"],"title":"373. 查找和最小的 K 对数字 (Medium)","uri":"/373.find-k-pairs-with-smallest-sums.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description373. Find K Pairs with Smallest Sums (Medium) You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u, v) which consists of one element from the first array and one element from the second array. Return the kpairs (u₁, v₁), (u₂, v₂), ..., (uₖ, vₖ)with the smallest sums. Example 1: text Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: text Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [[1,1],[1,1]] Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: text Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [[1,3],[2,3]] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] Constraints: 1 \u003c= nums1.length, nums2.length \u003c= 10⁵ -10⁹ \u003c= nums1[i], nums2[i] \u003c= 10⁹ nums1 and nums2 both are sorted in ascending order. 1 \u003c= k \u003c= 10⁴ ","date":"2023-05-06","objectID":"/373.find-k-pairs-with-smallest-sums/:1:0","series":null,"tags":["priority queue"],"title":"373. Find K Pairs with Smallest Sums (Medium)","uri":"/373.find-k-pairs-with-smallest-sums/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirstly, a min-heap can be used to obtain the smallest pair of numbers each time. Assuming that the current smallest pair is $(a_i, b_j)$, there may be two pairs that are larger but still the smallest: $(a_{i+1}, b_j)$ and $(a_i, b_{j+1})$. However, directly adding these pairs to the queue may result in duplicate pairs being selected. To solve this problem, you can refer to the following two diagrams: In case of duplicate pairs: To remove duplicates: ","date":"2023-05-06","objectID":"/373.find-k-pairs-with-smallest-sums/:2:0","series":null,"tags":["priority queue"],"title":"373. Find K Pairs with Smallest Sums (Medium)","uri":"/373.find-k-pairs-with-smallest-sums/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e kSmallestPairs(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2, int k) { auto cmp = [\u0026nums1, \u0026nums2](const pair\u003cint, int\u003e \u0026 a, const pair\u003cint, int\u003e \u0026 b) { return nums1[a.first] + nums2[a.second] \u003e nums1[b.first] + nums2[b.second]; }; int m = nums1.size(); int n = nums2.size(); vector\u003cvector\u003cint\u003e\u003e ans; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq(cmp); for (int i = 0; i \u003c min(k, m); i++) { pq.emplace(i, 0); } while (k-- \u003e 0 \u0026\u0026 !pq.empty()) { auto [x, y] = pq.top(); pq.pop(); ans.emplace_back(initializer_list\u003cint\u003e{nums1[x], nums2[y]}); if (y + 1 \u003c n) { pq.emplace(x, y + 1); } } return ans; } }; ","date":"2023-05-06","objectID":"/373.find-k-pairs-with-smallest-sums/:3:0","series":null,"tags":["priority queue"],"title":"373. Find K Pairs with Smallest Sums (Medium)","uri":"/373.find-k-pairs-with-smallest-sums/#code"},{"categories":["OS"],"content":" 1 代码测试代码内容如下，定义了一个 add 函数，用来求两个函数的和。 c int add(int a, int b) { return a + b; } int sum(int a, int b) { return 10 + add(a, b); } int main() { int res = sum(10, 20); return 0; } 汇编代码如下: asm .file \"add.c\" .text .globl add .type add, @function add: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl %edi, -4(%rbp) movl %esi, -8(%rbp) movl -4(%rbp), %edx movl -8(%rbp), %eax addl %edx, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size add, .-add .globl sum .type sum, @function sum: .LFB1: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $8, %rsp movl %edi, -4(%rbp) movl %esi, -8(%rbp) movl -8(%rbp), %edx movl -4(%rbp), %eax movl %edx, %esi movl %eax, %edi call add addl $10, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE1: .size sum, .-sum .globl main .type main, @function main: .LFB2: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp movl $2, %esi movl $1, %edi call sum movl %eax, -4(%rbp) movl $0, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE2: .size main, .-main .ident \"GCC: (Debian 12.2.0-14) 12.2.0\" .section .note.GNU-stack,\"\",@progbits 我们先分析 main() 函数的汇编代码，关注主要部分： asm pushq %rbp ; 将原先的 rbp 再入栈 movq %rsp, %rbp ; 即rbp = rsp，相当于让 rbp 也指向栈顶 subq $16, %rsp ; 从内存中分配空间给栈，因为栈是从高地址向低地址扩展，因此是 subq movl $2, %esi movl $1, %edi call add rbp 表示的是 64 位系统环境下的栈基地址寄存器，rsp 表示栈顶地址寄存器。完成分配内存后，将函数实参存入对应的寄存器。 ","date":"2023-05-01","objectID":"/function_call_stack.zh/:1:0","series":null,"tags":["Cpp"],"title":"从汇编的角度理解 C/Cpp 的函数调用过程","uri":"/function_call_stack.zh/#代码"},{"categories":["OS"],"content":" 2 栈帧我们可以把函数调用抽象成栈中的一个元素，这个元素就被称为栈帧（stack frame）。开始时，rbp 中其实是上一个栈帧的的地址，可以看到 main() 和 add() 都是先执行了 pushq %rbp，一个新的栈帧就生成了，此时 rsp 就指向这个栈帧（可以认为这个栈帧里面此时只有一个元素），然后执行 movq %rsp, %rbp，即让 rbp 中的数据变成这个新的栈帧的栈底，然后开始执行 subq $16, %rsp，由于栈在内存中是由高地址向低地址扩张，因此是 subq。 调用者栈帧的地址会比被调用者栈帧的地址小。 图片的上半部分是调用者的栈帧，可以看到里面存有参数（也就是一种局部变量）。也有当前函数的返回地址（不是 return 语句），通过这个地址可以找到当前这个函数运行完了应该返回哪里。 返回地址是通过当前栈帧的帧指针（即 rbp 中的内容）确定的，它总是储存在当前帧指针 +8 的位置（在 64 位机器中，如果是图中的 32 位，那就是 +4 的位置）。 下半部分存的是当前函数的栈帧，里面同样存有局部变量。ebp 和 esp 分别标注了这个栈帧的起始和结束位置。通过帧指针加上一些偏移量，就可以访问到这个栈帧里的局部变量。 ","date":"2023-05-01","objectID":"/function_call_stack.zh/:2:0","series":null,"tags":["Cpp"],"title":"从汇编的角度理解 C/Cpp 的函数调用过程","uri":"/function_call_stack.zh/#栈帧"},{"categories":["OS"],"content":" 3 调用函数时栈帧的变化 调用一个函数时，我们先把函数的返回地址（也就是执行调用时 pc 的值）压入栈中（是否可以认为栈帧的栈顶存储函数的返回地址？）； pc 即 program counter, 程序计数器，它指向下一条指令所在的内存单元的地址，通过 pc，计算机总是可以知道下一步该干什么。 call add 相当于一次做了两件事情，把 call 指令执行时的 pc 压入栈中，然后把 pc 的值改成 add 函数的起始地址。 将旧的 rbp 的值压入栈中，此时可以认为已经到了一个新的栈帧中了，rsp 指向这个新的栈帧，但是 rbp 还是指向上一个栈帧的栈底； movq %rsp, %rbp：让 rbp 指向这个新的栈帧； subq $16, %rsp：更新栈顶指针的值，扩充这个新的栈帧； 栈帧已经有了足够的空间，可以放入局部变量并执行这个函数了，至此，新帧的插入全部完成。 ","date":"2023-05-01","objectID":"/function_call_stack.zh/:3:0","series":null,"tags":["Cpp"],"title":"从汇编的角度理解 C/Cpp 的函数调用过程","uri":"/function_call_stack.zh/#调用函数时栈帧的变化"},{"categories":["OS"],"content":" 4 函数返回时栈帧的变化 释放之前占用的内存，因此直接把 rsp 的值设为 rbp 的值，相当于移动了栈顶指针； leave 会做两件事，将栈帧的栈顶指针指向栈底；恢复备份的栈帧的栈底指针；（相当于movq %rbp, %rsp 和 pop %rbp 的结合） 从栈中弹出栈帧的栈底指针； 弹出返回地址，赋值到 pc； 根据 pc 的值，继续执行原函数； ","date":"2023-05-01","objectID":"/function_call_stack.zh/:4:0","series":null,"tags":["Cpp"],"title":"从汇编的角度理解 C/Cpp 的函数调用过程","uri":"/function_call_stack.zh/#函数返回时栈帧的变化"},{"categories":["OS"],"content":" 5 参考内容函数调用是如何实现的 ","date":"2023-05-01","objectID":"/function_call_stack.zh/:5:0","series":null,"tags":["Cpp"],"title":"从汇编的角度理解 C/Cpp 的函数调用过程","uri":"/function_call_stack.zh/#参考内容"},{"categories":["notes"],"content":" 1 多态与动态绑定为了实现 C++ 的多态，C++ 使用了动态绑定技术，该技术的核心是虚函数表（简称虚表）。 ","date":"2023-04-23","objectID":"/virtual_func.zh/:1:0","series":null,"tags":["cpp"],"title":"C++ 虚函数与动态绑定","uri":"/virtual_func.zh/#多态与动态绑定"},{"categories":["notes"],"content":" 2 类的虚函数表每个包含了虚函数的类都包含一个虚表，一个子类如果继承了包含虚函数的父类，那么这个类也拥有自己的虚表，例如 cpp class A { public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int data1_, data2_; }; class B : public A { public: void vfunc1() override; void func1(); }; class C : public B { public: void vfunc2() override; void func2(); private: int data1_, data2_; }; A 包含虚函数 vfunc1() ，B 继承自 A，A 的虚表如图所示 虚表是一个指针数组，其元素是虚函数的指针，数组中的每个元素对应一个虚函数的指针。普通的函数（即非虚函数），其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。 虚函数指针的赋值发生在编译器的编译阶段，也就是在编译阶段，虚表就被构建出来了。 ","date":"2023-04-23","objectID":"/virtual_func.zh/:2:0","series":null,"tags":["cpp"],"title":"C++ 虚函数与动态绑定","uri":"/virtual_func.zh/#类的虚函数表"},{"categories":["notes"],"content":" 3 虚表指针虚表是属于类的（有点像静态成员变量），而不属于某个具体的对象，一个类只需要一个虚表即可，同一个类的所有对象都使用同一个虚表。 为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。 一个子类的父类如果包含虚函数，那么这个子类也拥有自己的虚表，所以这个子类的对象也包含一个虚表指针，用来指向它的虚表。 类 A 包括两个虚函数，故 A 的虚函数表包含两个指针，分别指向 A::vfunc1()和 A::vfunc2()。 类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了 B::vfunc1() 函数，故 B 的虚函数表的两个指针分别指向 B::vfunc1() 和 A::vfunc2()。 类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了 C::vfunc2() 函数，故C 的虚表的两个指针分别指向B::vfunc1()（指向继承的最近的一个类的函数）和 C::vfunc2()。 对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。 ","date":"2023-04-23","objectID":"/virtual_func.zh/:3:0","series":null,"tags":["cpp"],"title":"C++ 虚函数与动态绑定","uri":"/virtual_func.zh/#虚表指针"},{"categories":["notes"],"content":" 4 动态绑定C++ 的动态绑定即是通过虚表和虚表指针来实现的。 承接上面的代码，假设我们实例化子类 B 的对象bObj，并声明基类 A 的指针 p，然后让 p 指向 bObj，即 A *p = \u0026bObj;，那么，当我们使用 p 来调用 vfunc1() 时，由于 __vptr 也是基类的一部分，因此 p-\u003e__vptr 的值实际上是 \u0026bOjb-\u003e__ptr，即 p-\u003e__vptr 指向了类 B 的虚函数表，因此 p-\u003evfunc1() 实际上调用了 B::vfunc1()。 因此，我们只要注意虚表指针的值，即可弄清楚到底调用了哪个类的函数。 我们把虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态，传统的函数调用我们称为静态绑定（函数调用在编译阶段就能确定下来了）。 执行函数的动态绑定需要符合以下三个条件： 通过指针调用函数； 指针发生从子类向父类的转换，例如 A *p = \u0026bObj;； 调用的是虚函数； ","date":"2023-04-23","objectID":"/virtual_func.zh/:4:0","series":null,"tags":["cpp"],"title":"C++ 虚函数与动态绑定","uri":"/virtual_func.zh/#动态绑定"},{"categories":["notes"],"content":" 5 参考资料 《Cpp Primer》第五版 C++ 虚函数表剖析 ","date":"2023-04-23","objectID":"/virtual_func.zh/:5:0","series":null,"tags":["cpp"],"title":"C++ 虚函数与动态绑定","uri":"/virtual_func.zh/#参考资料"},{"categories":["notes"],"content":" 1 介绍CMake是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个库。 它用配置文件控制建构过程（build process）的方式和Unix的make相似，只是CMake的配置文件取名为CMakeLists.txt。CMake并不直接建构出最终的软件，而是产生标准的建构档（如Unix的Makefile或Windows Visual C++的projects/workspaces），然后再依一般的建构方式使用。 ","date":"2023-04-13","objectID":"/cmake_tutorial.zh/:1:0","series":null,"tags":["tutorial","cpp"],"title":"Cmake 基础教程","uri":"/cmake_tutorial.zh/#介绍"},{"categories":["notes"],"content":" 2 CmakeLists.txt一个简单的CmakeLists.txt示例如下: text # 指定最小 CMake 版本要求 cmake_minimum_required(VERSION 3.9) # 设置项目名称 project(answer) #[[ 添加可执行文件 target，类似于原来 Makefile 的： answer: main.o answer.o main.o: main.cpp answer.hpp answer.o: answer.cpp answer.hpp CMake 会自动找到依赖的头文件，因此不需要特别指定， 当头文件修改的时候，会重新编译依赖它的目标文件。 #]] add_executable(answer main.cpp answer.cpp) #[[ 使用如下命令构建本项目： cmake -B build # 生成构建目录 cmake --build build # 执行构建 ./build/answer # 运行 answer 程序 #]] 其中cmake -B build命令中的-B参数是可选的，生成的文件会放到build文件夹中（没有该文件夹则会自动创建，最好原先没有）。 cmake --build build是执行构建，生成可执行文件，build指的是上一步-B参数指定的文件夹。 ","date":"2023-04-13","objectID":"/cmake_tutorial.zh/:2:0","series":null,"tags":["tutorial","cpp"],"title":"Cmake 基础教程","uri":"/cmake_tutorial.zh/#cmakeliststxt"},{"categories":["notes"],"content":" 3 分离库文件情形下的CMakeLists.txt cmake cmake_minimum_required(VERSION 3.9) project(answer) # 添加 libanswer 库目标，STATIC 指定为静态库 add_library(libanswer STATIC answer.cpp) add_executable(answer main.cpp) # 为 answer 这一可执行目标链接库 libanswer target_link_libraries(answer libanswer) ","date":"2023-04-13","objectID":"/cmake_tutorial.zh/:3:0","series":null,"tags":["tutorial","cpp"],"title":"Cmake 基础教程","uri":"/cmake_tutorial.zh/#分离库文件情形下的cmakeliststxt"},{"categories":["notes"],"content":" 4 子目录设置我们考虑将answer相关的头文件和源文件都放入到answer目录下，则在CmakeLists.txt中要做对应修改，使cmake会检索对应目录下的文件。 cmake cmake_minimum_required(VERSION 3.9) project(answer) # 添加 answer 子目录 add_subdirectory(answer) add_executable(answer_app main.cpp) target_link_libraries(answer_app libanswer) #[[ 使用如下命令构建本项目： cmake -B build # 生成构建目录 cmake --build build # 执行构建 ./build/answer_app # 运行 answer_app 程序 #]] 子目录中CmakeLists.txt内容如下： cmake add_library(libanswer STATIC answer.cpp) #[[ message 可用于打印调试信息或错误信息，除了 STATUS 外还有 DEBUG WARNING SEND_ERROR FATAL_ERROR 等。 #]] message(STATUS \"Current source dir: ${CMAKE_CURRENT_SOURCE_DIR}\") #[[ 给 libanswer 库目标添加 include 目录，PUBLIC 使 这个 include 目录能被外部使用者看到。 当链接 libanswer 库时，这里指定的 include 目录会被 自动添加到使用此库的 target 的 include 路径中。 CMAKE_CURRENT_SOURCE_DIR 表示当前 CmakeLists.txt 所在的目录； PUBLIC 标志使得 头文件接口会被传递给依赖 libanswer 库的文件 #]] target_include_directories(libanswer PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include) ","date":"2023-04-13","objectID":"/cmake_tutorial.zh/:4:0","series":null,"tags":["tutorial","cpp"],"title":"Cmake 基础教程","uri":"/cmake_tutorial.zh/#子目录设置"},{"categories":["notes"],"content":" 5 使用系统安装的第三方库，以curl为例 cmake #[[ find_package 用于在系统中寻找已经安装的第三方库的头文件和库文件 的位置，并创建一个名为 CURL::libcurl 的库目标，以供链接。 #]] find_package(CURL REQUIRED) add_library(libanswer STATIC answer.cpp) target_include_directories(libanswer PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include) #[[ 为 libanswer 库链接 libcurl，这里 PRIVATE 和 PUBLIC 的区别是： CURL::libcurl 库只会被 libanswer 看到，根级别的 main.cpp 中 无法 include curl 的头文件。 #]] target_link_libraries(libanswer PRIVATE CURL::libcurl) ","date":"2023-04-13","objectID":"/cmake_tutorial.zh/:5:0","series":null,"tags":["tutorial","cpp"],"title":"Cmake 基础教程","uri":"/cmake_tutorial.zh/#使用系统安装的第三方库以curl为例"},{"categories":["leetcode"],"content":" 1 Description1020. Number of Enclaves (Medium) You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell. A move consists of walking from one land cell to another adjacent ( 4-directionally) land cell or walking off the boundary of the grid. Return the number of land cells in gridfor which we cannot walk off the boundary of the grid in any number of moves. Example 1: text Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary. Example 2: text Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. Constraints: m == grid.length n == grid[i].length 1 \u003c= m, n \u003c= 500 grid[i][j] is either 0 or 1. ","date":"2023-04-13","objectID":"/1020.number-of-enclaves/:1:0","series":null,"tags":["dsu"],"title":"1020.Number of Enclaves (Medium)","uri":"/1020.number-of-enclaves/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use dsu to solve this problem. ","date":"2023-04-13","objectID":"/1020.number-of-enclaves/:2:0","series":null,"tags":["dsu"],"title":"1020.Number of Enclaves (Medium)","uri":"/1020.number-of-enclaves/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp struct Dsu { vector\u003cint\u003e par_; vector\u003cint\u003e siz_; int cnt_; explicit Dsu(int cnt) : par_(cnt + 1), siz_(cnt + 1, 1), cnt_(cnt) { for (int i = 0; i \u003c= cnt; ++i) { par_[i] = i; } }; auto find(int x) -\u003e int { return par_[x] == x ? x : (par_[x] = find(par_[x])); } void uni(int x, int y) { x = find(x), y = find(y); if (x == y) { return; } if (siz_[x] \u003c siz_[y]) { std::swap(x, y); } par_[y] = x; siz_[x] += siz_[y]; --cnt_; } }; class Solution { public: int numEnclaves(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { // 并查集 int m = grid.size(), n = grid[0].size(); vector\u003cvector\u003cint\u003e\u003e move{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; Dsu dsu(m * n); int cnt = 0; for (int i = 0; i \u003c m * n; ++i) { int x = i / n, y = i % n; if (grid[x][y] == 1) { if (x == m - 1 || x == 0 || y == 0 || y == n - 1) { dsu.uni(i, m * n); } for (int j = 0; j \u003c 4; ++j) { int x_new = x + move[j][0], y_new = y + move[j][1]; if (x_new \u003c 0 || x_new \u003e= m || y_new \u003c 0 || y_new \u003e= n || grid[x_new][y_new] == 0) { continue; } dsu.uni(i, x_new * n + y_new); } } else { ++cnt; } } return m * n - dsu.siz_[dsu.find(m * n)] - cnt + 1; } }; ","date":"2023-04-13","objectID":"/1020.number-of-enclaves/:3:0","series":null,"tags":["dsu"],"title":"1020.Number of Enclaves (Medium)","uri":"/1020.number-of-enclaves/#code"},{"categories":["leetcode"],"content":" 1 问题描述1020. 飞地的数量 (Medium) 给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、 1 表示一个陆地单元格。 一次 移动 是指从一个陆地单元格走到另一个相邻（ 上、下、左、右）的陆地单元格或跨过 grid 的边界。 返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。 示例 1： text 输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] 输出：3 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。 示例 2： text 输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] 输出：0 解释：所有 1 都在边界上或可以到达边界。 提示： m == grid.length n == grid[i].length 1 \u003c= m, n \u003c= 500 grid[i][j] 的值为 0 或 1 ","date":"2023-04-13","objectID":"/1020.number-of-enclaves.zh/:1:0","series":null,"tags":["dsu"],"title":"1020.飞地的数量 (Medium)","uri":"/1020.number-of-enclaves.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路使用并查集，令cnt1为包含索引为m * n的节点树的节点数，cnt2为海水的节点数，res = m * n - (cnt1 - 1) - cnt2;。 ","date":"2023-04-13","objectID":"/1020.number-of-enclaves.zh/:2:0","series":null,"tags":["dsu"],"title":"1020.飞地的数量 (Medium)","uri":"/1020.number-of-enclaves.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp struct Dsu { vector\u003cint\u003e par_; vector\u003cint\u003e siz_; int cnt_; explicit Dsu(int cnt) : par_(cnt + 1), siz_(cnt + 1, 1), cnt_(cnt) { for (int i = 0; i \u003c= cnt; ++i) { par_[i] = i; } }; auto find(int x) -\u003e int { return par_[x] == x ? x : (par_[x] = find(par_[x])); } void uni(int x, int y) { x = find(x), y = find(y); if (x == y) { return; } if (siz_[x] \u003c siz_[y]) { std::swap(x, y); } par_[y] = x; siz_[x] += siz_[y]; --cnt_; } }; class Solution { public: int numEnclaves(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { // 并查集 int m = grid.size(), n = grid[0].size(); vector\u003cvector\u003cint\u003e\u003e move{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; Dsu dsu(m * n); int cnt = 0; for (int i = 0; i \u003c m * n; ++i) { int x = i / n, y = i % n; if (grid[x][y] == 1) { if (x == m - 1 || x == 0 || y == 0 || y == n - 1) { dsu.uni(i, m * n); } for (int j = 0; j \u003c 4; ++j) { int x_new = x + move[j][0], y_new = y + move[j][1]; if (x_new \u003c 0 || x_new \u003e= m || y_new \u003c 0 || y_new \u003e= n || grid[x_new][y_new] == 0) { continue; } dsu.uni(i, x_new * n + y_new); } } else { ++cnt; } } return m * n - dsu.siz_[dsu.find(m * n)] - cnt + 1; } }; ","date":"2023-04-13","objectID":"/1020.number-of-enclaves.zh/:3:0","series":null,"tags":["dsu"],"title":"1020.飞地的数量 (Medium)","uri":"/1020.number-of-enclaves.zh/#代码"},{"categories":["notes"],"content":" 1 问题描述给定一个长度为$n$的数组，如何在$O(n)$的时间复杂度内找到第$k$大的数。 ","date":"2023-04-11","objectID":"/quick-select.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"快速选择算法","uri":"/quick-select.zh/#问题描述"},{"categories":["notes"],"content":" 2 思路朴素的想法是先排序，然后直接找到第$k$个元素，时间复杂度为$O(n\\log n)$。 我们可以利用快速排序的思想来解决这个问题，考虑快速排序的划分过程，在快速排序的“划分”结束后，数组$A_p \\cdots A_r$被分成了$A_p\\cdots A_q$和$A_{q+1}\\cdots A_r$，此时可以按照左边元素的个数（$q-p+1$）和$k$的大小关系来判断是只在左边还是右边递归的求解。 ","date":"2023-04-11","objectID":"/quick-select.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"快速选择算法","uri":"/quick-select.zh/#思路"},{"categories":["notes"],"content":" 3 代码 cpp template \u003cTypename T\u003e // 类型T需要定义 \u003c 运算 // arr 为查找范围数组，rk 为需要查找的排名（从 0 开始），len 为数组长度 T find_kth_element(T arr[], int rk, const int len) { if (len \u003c= 1) { return arr[0]; } // 随机选择基准 const T pivot = arr[rand() % len]; // i 当前操作的元素 // j 第一个等于pivot的元素 // k 第一个大于pivot的元素 // 完成一趟三路快排，将序列分为： // 小于 pivot 的元素 ｜ 等于 pivot 的元素 ｜ 大于 pivot 的元素 int i = 0, j = 0, k = len; while (i \u003c k) { if (arr[i] \u003c pivot) { swap(arr[i++], arr[j++]); } else if (arr[i] \u003e pivot) { swap(arr[i], arr[--k]); } else { ++i; } } // 根据要找的排名与两条分界线的位置，去不同的区间递归查找第k大的数 // 如果小于pivot的元素个数比k多，则第k大的元素一定是一个小于pivot的数 if (rk \u003c j) { return find_kth_element(arr, rk, j); } else if (rk \u003e= k){ // 否则，如果小于pivot和等于pivot的元素加起来也没有k多 // 则第k大的元素一定是一个大于pivot的元素 return find_kth_element(arr + k, rk - k, len - k); } else { // 否则，pivot就是第k大的元素 return pivot; } } ","date":"2023-04-11","objectID":"/quick-select.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"快速选择算法","uri":"/quick-select.zh/#代码"},{"categories":["notes"],"content":" 4 优化：中位数的中位数中位数中的中位数（英文：Median of medians），提供了一种确定性的选择划分过程中分界值的方法，从而能够让找第$k$大的数算法在最坏情况下也能实现线性时间复杂度。 该算法的流程如下： 将整个序列划分为 $\\left \\lfloor \\dfrac{n}{5} \\right \\rfloor$组，每组元素数不超过$5$个； 寻找每组元素的中位数（因为元素个数较少，可以直接使用插入排序等算法）； 找出这$\\left \\lfloor \\dfrac{n}{5} \\right \\rfloor$组元素中位数中的中位数。将该元素作为前述算法中每次划分时的分界值即可。 该优化后，最坏情况下，算法也有$O(n)$的时间复杂度。 ","date":"2023-04-11","objectID":"/quick-select.zh/:4:0","series":null,"tags":["data structure and algorithms"],"title":"快速选择算法","uri":"/quick-select.zh/#优化中位数的中位数"},{"categories":["notes"],"content":" 5 参考OI-Wiki：快速排序 ","date":"2023-04-11","objectID":"/quick-select.zh/:5:0","series":null,"tags":["data structure and algorithms"],"title":"快速选择算法","uri":"/quick-select.zh/#参考"},{"categories":null,"content":" 1 Description851. Loud and Rich (Medium) There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness. You are given an array richer where richer[i] = [aᵢ, bᵢ] indicates that aᵢ has more money than bᵢ and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time). Return an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x. Example 1: text Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation: answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0. answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7. The other answers can be filled out with similar reasoning. Example 2: text Input: richer = [], quiet = [0] Output: [0] Constraints: n == quiet.length 1 \u003c= n \u003c= 500 0 \u003c= quiet[i] \u003c n All the values of quiet are unique. 0 \u003c= richer.length \u003c= n * (n - 1) / 2 0 \u003c= aᵢ, bᵢ \u003c n aᵢ != bᵢ All the pairs of richer are unique. The observations in richer are all logically consistent. ","date":"2023-04-10","objectID":"/851.loud-and-rich/:1:0","series":null,"tags":["topo sort","bfs"],"title":"851.喧闹和富有 (Medium)","uri":"/851.loud-and-rich/#description"},{"categories":null,"content":" 2 SolutionUpdate ans when doing topo sort ","date":"2023-04-10","objectID":"/851.loud-and-rich/:2:0","series":null,"tags":["topo sort","bfs"],"title":"851.喧闹和富有 (Medium)","uri":"/851.loud-and-rich/#solution"},{"categories":null,"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e loudAndRich(vector\u003cvector\u003cint\u003e\u003e\u0026 richer, vector\u003cint\u003e\u0026 quiet) { int n = quiet.size(); vector\u003cvector\u003cint\u003e\u003e graph(n); vector\u003cint\u003e in(n); for (auto \u0026vec : richer) { graph[vec[0]].push_back(vec[1]); ++in[vec[1]]; } std::queue\u003cint\u003e in0; vector\u003cint\u003e res(n); for (int i = 0; i \u003c n; ++i) { if (in[i] == 0) { in0.push(i); } res[i] = i; } while (!in0.empty()) { auto idx = in0.front(); in0.pop(); for (auto v : graph[idx]) { if (quiet[res[idx]] \u003c quiet[res[v]]) { res[v] = res[idx]; } if (--in[v] == 0) { in0.push(v); } } } return res; } }; ","date":"2023-04-10","objectID":"/851.loud-and-rich/:3:0","series":null,"tags":["topo sort","bfs"],"title":"851.喧闹和富有 (Medium)","uri":"/851.loud-and-rich/#code"},{"categories":["leetcode"],"content":" 1 问题描述851. 喧闹和富有 (Medium) 有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 “person x “。 给你一个数组 richer ，其中 richer[i] = [aᵢ, bᵢ] 表示 person aᵢ 比 person bᵢ 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。 richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。 现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。 示例 1： text 输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] 输出：[5,5,2,5,4,5,6,7] 解释： answer[0] = 5， person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。 唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7， 但是目前还不清楚他是否比 person 0 更有钱。 answer[7] = 7， 在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7）， 最安静（有较低安静值 quiet[x]）的人是 person 7。 其他的答案也可以用类似的推理来解释。 示例 2： text 输入：richer = [], quiet = [0] 输出：[0] 提示： n == quiet.length 1 \u003c= n \u003c= 500 0 \u003c= quiet[i] \u003c n quiet 的所有值 互不相同 0 \u003c= richer.length \u003c= n * (n - 1) / 2 0 \u003c= aᵢ, bᵢ \u003c n aᵢ != bᵢ richer 中的所有数对 互不相同 对 richer 的观察在逻辑上是一致的 ","date":"2023-04-10","objectID":"/851.loud-and-rich.zh/:1:0","series":null,"tags":["topo sort","bfs"],"title":"851.喧闹和富有 (Medium)","uri":"/851.loud-and-rich.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题依旧是拓扑排序，在执行拓扑排序的时候，更新对应的ans，因此我们需要让富有的指向不富有的。 ","date":"2023-04-10","objectID":"/851.loud-and-rich.zh/:2:0","series":null,"tags":["topo sort","bfs"],"title":"851.喧闹和富有 (Medium)","uri":"/851.loud-and-rich.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e loudAndRich(vector\u003cvector\u003cint\u003e\u003e\u0026 richer, vector\u003cint\u003e\u0026 quiet) { int n = quiet.size(); vector\u003cvector\u003cint\u003e\u003e graph(n); vector\u003cint\u003e in(n); for (auto \u0026vec : richer) { graph[vec[0]].push_back(vec[1]); ++in[vec[1]]; } std::queue\u003cint\u003e in0; vector\u003cint\u003e res(n); for (int i = 0; i \u003c n; ++i) { if (in[i] == 0) { in0.push(i); } res[i] = i; } while (!in0.empty()) { auto idx = in0.front(); in0.pop(); for (auto v : graph[idx]) { if (quiet[res[idx]] \u003c quiet[res[v]]) { res[v] = res[idx]; } if (--in[v] == 0) { in0.push(v); } } } return res; } }; ","date":"2023-04-10","objectID":"/851.loud-and-rich.zh/:3:0","series":null,"tags":["topo sort","bfs"],"title":"851.喧闹和富有 (Medium)","uri":"/851.loud-and-rich.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description802. Find Eventual Safe States (Medium) There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i]. A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node). Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order. Example 1: text Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Explanation: The given graph is shown above. Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them. Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6. Example 2: text Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] Output: [4] Explanation: Only node 4 is a terminal node, and every path starting at node 4 leads to node 4. Constraints: n == graph.length 1 \u003c= n \u003c= 10⁴ 0 \u003c= graph[i].length \u003c= n 0 \u003c= graph[i][j] \u003c= n - 1 graph[i] is sorted in a strictly increasing order. The graph may contain self-loops. The number of edges in the graph will be in the range [1, 4 * 10⁴]. ","date":"2023-04-10","objectID":"/802.find-eventual-safe-states/:1:0","series":null,"tags":["bfs","topo sort"],"title":"802.Find Eventual Safe States (Medium)","uri":"/802.find-eventual-safe-states/#description"},{"categories":["leetcode"],"content":" 2 SolutionReferring to topo sort, but we need to consider out-degree rather than in-degree. ","date":"2023-04-10","objectID":"/802.find-eventual-safe-states/:2:0","series":null,"tags":["bfs","topo sort"],"title":"802.Find Eventual Safe States (Medium)","uri":"/802.find-eventual-safe-states/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e eventualSafeNodes(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { int n = graph.size(); vector\u003cint\u003e in_arr(n); for (int i = 0; i \u003c n; ++i) { for (int v : graph[i]) { in_arr[v]++; } } std::queue\u003cint\u003e in0; for (int i = 0; i \u003c n; ++i) { if (in_arr[i] == 0) { in0.push(i); } } vector\u003cint\u003e res; while (!in0.empty()) { int idx = in0.front(); res.push_back(idx); in0.pop(); for (auto v : graph[idx]) { if (--in_arr[v] == 0) { in0.push(v); } } } return res; } }; ","date":"2023-04-10","objectID":"/802.find-eventual-safe-states/:3:0","series":null,"tags":["bfs","topo sort"],"title":"802.Find Eventual Safe States (Medium)","uri":"/802.find-eventual-safe-states/#code"},{"categories":["leetcode"],"content":" 1 问题描述802. 找到最终的安全状态 (Medium) 有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph 表示， graph[i] 是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i] 中的每个节点都有一条边。 如果一个节点没有连出的有向边，则它是 终端节点 。如果没有出边，则节点为终端节点。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。 返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。 示例 1： text 输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]] 输出：[2,4,5,6] 解释：示意图如上。 节点 5 和节点 6 是终端节点，因为它们都没有出边。 从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。 示例 2： text 输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] 输出：[4] 解释: 只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。 提示： n == graph.length 1 \u003c= n \u003c= 10⁴ 0 \u003c= graph[i].length \u003c= n 0 \u003c= graph[i][j] \u003c= n - 1 graph[i] 按严格递增顺序排列。 图中可能包含自环。 ","date":"2023-04-10","objectID":"/802.find-eventual-safe-states.zh/:1:0","series":null,"tags":["bfs","topo sort"],"title":"802.找到最终的安全状态 (Medium)","uri":"/802.find-eventual-safe-states.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路典型的拓扑排序题，但一般的拓扑排序是考虑节点的入度，这里我们需要改为考虑节点的出度，对应的res即为所求。 ","date":"2023-04-10","objectID":"/802.find-eventual-safe-states.zh/:2:0","series":null,"tags":["bfs","topo sort"],"title":"802.找到最终的安全状态 (Medium)","uri":"/802.find-eventual-safe-states.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e eventualSafeNodes(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { // 拓扑排序，bfs int n = graph.size(); vector\u003cint\u003e in_arr(n); for (int i = 0; i \u003c n; ++i) { for (int v : graph[i]) { in_arr[v]++; } } std::queue\u003cint\u003e in0; for (int i = 0; i \u003c n; ++i) { // 将入度为0的点放入in0 if (in_arr[i] == 0) { in0.push(i); } } vector\u003cint\u003e res; while (!in0.empty()) { int idx = in0.front(); // 从in0中取一个点放入res res.push_back(idx); in0.pop(); for (auto v : graph[idx]) { if (--in_arr[v] == 0) { in0.push(v); } } } return res; } }; ","date":"2023-04-10","objectID":"/802.find-eventual-safe-states.zh/:3:0","series":null,"tags":["bfs","topo sort"],"title":"802.找到最终的安全状态 (Medium)","uri":"/802.find-eventual-safe-states.zh/#代码"},{"categories":["notes"],"content":" 1 定义拓扑排序（Topological sorting）要解决的问题是给一个有向图的所有节点排序。 这里直接使用OI-Wiki中举的例子来说明： 我们可以拿大学选课的例子来描述这个过程，比如学习大学课程中有：单变量微积分，线性代数，离散数学概述，概率论与统计学概述，语言基础，算法导论，机器学习。当我们想要学习 算法导论 的时候，就必须先学会 离散数学概述 和 概率论与统计学概述，不然在课堂就会听的一脸懵逼。当然还有一个更加前的课程 单变量微积分。 这些课程就相当于几个顶点$u$, 顶点之间的有向边$(u,v)$就相当于学习课程的顺序。显然拓扑排序不是那么的麻烦，不然你是如何选出合适的学习顺序。下面将介绍如何将这个过程抽象出来，用算法来实现。 但是如果某一天排课的老师打瞌睡了，说想要学习 算法导论，还得先学 机器学习，而 机器学习 的前置课程又是 算法导论，然后你就一万脸懵逼了，我到底应该先学哪一个？当然我们在这里不考虑什么同时学几个课程的情况。在这里，算法导论 和 机器学习 间就出现了一个环，显然你现在没办法弄清楚你需要学什么了，于是你也没办法进行拓扑排序了。因而如果有向图中存在环路，那么我们就没办法进行拓扑排序了。 因此我们可以说在一个[[DAG（有向无环图）]]中，我们将图中顶点以线性方式排序，使得对于任意顶点$u$到$v$的有向边$(u, v)$，都有$u$在$v$的前面。 或者说给定一个DAG，如果$i$到$j$有边，则认为$j$依赖于$i$，如果$i$到$j$有路径，则称$j$间接依赖于$i$； 拓扑排序的目标是将所有节点排序，使得在前面的节点不能依赖于排在后面的节点。 ","date":"2023-04-10","objectID":"/topo-sort.zh/:1:0","series":null,"tags":["graph","data structure and algorithms","topo sort"],"title":"拓扑排序","uri":"/topo-sort.zh/#定义"},{"categories":["notes"],"content":" 2 bfs拓扑排序有广度优先搜索（bfs）和深度优先搜索（dfs）两种实现方式，这里我们先讨论bfs。 利用bfs实现拓扑排序需要根据节点的入度： 入度：有多少条边直接指向该节点 ","date":"2023-04-10","objectID":"/topo-sort.zh/:2:0","series":null,"tags":["graph","data structure and algorithms","topo sort"],"title":"拓扑排序","uri":"/topo-sort.zh/#bfs"},{"categories":["notes"],"content":" 2.1 思路 起始时，将所有入度为$0$的点放入队列q_in0； 将队首元素出队，出队序列就是我们要求的拓扑序，对当前弹出的节点u，res.push_back(u)，遍历u的所有出度，即遍历所有由u直接指向的节点v，递减节点v的入度； 如果节点v的入度变为0，将节点v入队； 循环2、3流程直到队列为空； 如果res最后恰好有$n$个节点，说明原图为DAG，res中的节点序列即要求的拓扑序；否则说明图中存在环。 ","date":"2023-04-10","objectID":"/topo-sort.zh/:2:1","series":null,"tags":["graph","data structure and algorithms","topo sort"],"title":"拓扑排序","uri":"/topo-sort.zh/#思路"},{"categories":["notes"],"content":" 2.2 代码实现 cpp vector\u003cvector\u003cint\u003e\u003e graph; int n = graph.size(); int in[n]; // 存储每个节点的入度 bool toposrot() { vector\u003cint\u003e res; queue\u003cint\u003e q_in0; for (int i = 0; i \u003c n; ++i) { if (in[i] == 0) { q_in0.push(i); } } while (!q_in0.empty()) { int u = q_in0.front(); q_in0.pop(); res.push_back(u); for (auto v : graph[u]) { if (--in[v] == 0) { q_in0.push(v); } } } if (res.size() == n) { for (auto i : res) { cout \u003c\u003c i \u003c\u003c \" \"; } return true; } return false; } ","date":"2023-04-10","objectID":"/topo-sort.zh/:2:2","series":null,"tags":["graph","data structure and algorithms","topo sort"],"title":"拓扑排序","uri":"/topo-sort.zh/#代码实现"},{"categories":["notes"],"content":" 3 dfstodo ","date":"2023-04-10","objectID":"/topo-sort.zh/:3:0","series":null,"tags":["graph","data structure and algorithms","topo sort"],"title":"拓扑排序","uri":"/topo-sort.zh/#dfs"},{"categories":["tutorial"],"content":" 1 配置frp","date":"2023-04-02","objectID":"/frp_ssh.zh/:1:0","series":null,"tags":["geek","ssh","tips"],"title":"通过 frp 使用 ssh 连接内网服务器","uri":"/frp_ssh.zh/#配置frp"},{"categories":["tutorial"],"content":" 1.1 安装frp~/Prog目录下执行wget https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz下载压缩包，然后执行tar -zxvf file.path来解压，将解压生成的文件夹重命名为frp。 ","date":"2023-04-02","objectID":"/frp_ssh.zh/:1:1","series":null,"tags":["geek","ssh","tips"],"title":"通过 frp 使用 ssh 连接内网服务器","uri":"/frp_ssh.zh/#安装frp"},{"categories":["tutorial"],"content":" 1.2 设置frpc.toml修改frpc.toml文件为以下内容: text serverAddr = \"nj1.mossfrp.cn\" serverPort = 51960 token = \"3nj117667696278235715\" tls_enable = true use_encryption = true [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22333 remotePort = 51962 [[vscode]] name = \"vsc\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 5433 remotePort = 51963 [[qbit]] name = \"qbit\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 28080 remotePort = 51968 [[qbit]] name = \"iyuu\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 8787 remotePort = 51967 ","date":"2023-04-02","objectID":"/frp_ssh.zh/:1:2","series":null,"tags":["geek","ssh","tips"],"title":"通过 frp 使用 ssh 连接内网服务器","uri":"/frp_ssh.zh/#设置frpctoml"},{"categories":["tutorial"],"content":" 2 利用systemctl实现frp自启动执行sudo touch /etc/systemd/system/frp.service，修改文件内容为 text [Unit] Description=frp client After=network-online.target [Service] Type=notify Restart=always RestartSec=60 ExecStart=/home/zwyyy/Prog/frp/frpc -c /home/zwyyy/Prog/frp/frpc.ini # 注意这里不能使用~为路径 [Install] WantedBy=multi-user.target 然后执行 sudo systemctl enable frp.service 和 sudo systemctl start frp.service。 以下说明来自ChatGPT！ “[Install]”部分提供了有关如何安装此系统服务的信息。 在Install部分中，“WantedBy”属性确定了哪个级别的目标(或多个级别的目标)应用于此服务。多个级别的目标可以在逗号分隔列表中指定。 通常，系统管理员会将服务添加到“multi-user.target”，这将确保在系统启动时服务自动启动，并在用户登录时保持运行。 “WantedBy=multi-user.target”表示此服务应该在系统启动时启动，并与多个用户有关的目标相关联，这样就可以在多个用户登录时持续运行服务。 此外，[Install]部分还提供了以下命令，可以用来启动和停止服务： sudo systemctl start frp.service：启动服务 sudo systemctl stop frp.service：停止服务 ","date":"2023-04-02","objectID":"/frp_ssh.zh/:2:0","series":null,"tags":["geek","ssh","tips"],"title":"通过 frp 使用 ssh 连接内网服务器","uri":"/frp_ssh.zh/#利用systemctl实现frp自启动"},{"categories":["leetcode"],"content":" 1 Description442. Find All Duplicates in an Array (Medium) Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice. You must write an algorithm that runs in O(n) time and uses only constant extra space. Example 1: text Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Example 2: text Input: nums = [1,1,2] Output: [1] Example 3: text Input: nums = [1] Output: [] Constraints: n == nums.length 1 \u003c= n \u003c= 10⁵ 1 \u003c= nums[i] \u003c= n Each element in nums appears once or twice. ","date":"2023-03-28","objectID":"/442.find-all-duplicates-in-an-array/:1:0","series":null,"tags":["hash table"],"title":"442.Find All Duplicates in an Array (Medium)","uri":"/442.find-all-duplicates-in-an-array/#description"},{"categories":["leetcode"],"content":" 2 SolutionIt’s similar to 41.First Missing Positive (Hard), if nums[num - 1] is negative, we make nums[num - 1] -= nums.size(). ","date":"2023-03-28","objectID":"/442.find-all-duplicates-in-an-array/:2:0","series":null,"tags":["hash table"],"title":"442.Find All Duplicates in an Array (Medium)","uri":"/442.find-all-duplicates-in-an-array/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e findDuplicates(vector\u003cint\u003e\u0026 nums) { for (int i = 0; i \u003c nums.size(); ++i) { int num = abs(nums[i]); if (num \u003e nums.size()) { num -= nums.size(); } if (nums[num - 1] \u003e 0) { nums[num - 1] = -nums[num - 1]; } else { nums[num - 1] -= nums.size(); } } vector\u003cint\u003e res; for (int i = 0; i \u003c nums.size(); ++i) { if (nums[i] \u003c -static_cast\u003cint\u003e(nums.size())) { res.push_back(i); } } return res; } }; ","date":"2023-03-28","objectID":"/442.find-all-duplicates-in-an-array/:3:0","series":null,"tags":["hash table"],"title":"442.Find All Duplicates in an Array (Medium)","uri":"/442.find-all-duplicates-in-an-array/#code"},{"categories":["leetcode"],"content":" 1 问题描述442. 数组中重复的数据 (Medium) 给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。 你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。 示例 1： text 输入：nums = [4,3,2,7,8,2,3,1] 输出：[2,3] 示例 2： text 输入：nums = [1,1,2] 输出：[1] 示例 3： text 输入：nums = [1] 输出：[] 提示： n == nums.length 1 \u003c= n \u003c= 10⁵ 1 \u003c= nums[i] \u003c= n nums 中的每个元素出现 一次 或 两次 ","date":"2023-03-28","objectID":"/442.find-all-duplicates-in-an-array.zh/:1:0","series":null,"tags":["hash table"],"title":"442.数组中重复的数据 (Medium)","uri":"/442.find-all-duplicates-in-an-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路参照41.缺失的第一个正数 (Hard)，将数置反，如果已经是负数了，再减去nums.size()。 这里要注意nums.size()是无符号整数，直接加上负号结果也不是负数。 ","date":"2023-03-28","objectID":"/442.find-all-duplicates-in-an-array.zh/:2:0","series":null,"tags":["hash table"],"title":"442.数组中重复的数据 (Medium)","uri":"/442.find-all-duplicates-in-an-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e findDuplicates(vector\u003cint\u003e\u0026 nums) { for (int i = 0; i \u003c nums.size(); ++i) { int num = abs(nums[i]); if (num \u003e nums.size()) { num -= nums.size(); } if (nums[num - 1] \u003e 0) { nums[num - 1] = -nums[num - 1]; } else { nums[num - 1] -= nums.size(); } } vector\u003cint\u003e res; for (int i = 0; i \u003c nums.size(); ++i) { if (nums[i] \u003c -static_cast\u003cint\u003e(nums.size())) { res.push_back(i); } } return res; } }; ","date":"2023-03-28","objectID":"/442.find-all-duplicates-in-an-array.zh/:3:0","series":null,"tags":["hash table"],"title":"442.数组中重复的数据 (Medium)","uri":"/442.find-all-duplicates-in-an-array.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description41. First Missing Positive (Hard) Given an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space. Example 1: text Input: nums = [1,2,0] Output: 3 Explanation: The numbers in the range [1,2] are all in the array. Example 2: text Input: nums = [3,4,-1,1] Output: 2 Explanation: 1 is in the array but 2 is missing. Example 3: text Input: nums = [7,8,9,11,12] Output: 1 Explanation: The smallest positive integer 1 is missing. Constraints: 1 \u003c= nums.length \u003c= 10⁵ -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 ","date":"2023-03-28","objectID":"/41.first-missing-positive/:1:0","series":null,"tags":["hash table"],"title":"41.First Missing Positive (Hard)","uri":"/41.first-missing-positive/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can mark nums[i]，we set the negative elements in nums as n + 1, and num = abs(nums[i]), ans set nums[num - 1] = -nums[num - 1]. Or we can swap. ","date":"2023-03-28","objectID":"/41.first-missing-positive/:2:0","series":null,"tags":["hash table"],"title":"41.First Missing Positive (Hard)","uri":"/41.first-missing-positive/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int firstMissingPositive(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); for (int\u0026 num: nums) { if (num \u003c= 0) { num = n + 1; } } for (int i = 0; i \u003c n; ++i) { int num = abs(nums[i]); if (num \u003c= n) { nums[num - 1] = -abs(nums[num - 1]); } } for (int i = 0; i \u003c n; ++i) { if (nums[i] \u003e 0) { return i + 1; } } return n + 1; } }; // @lc code=end ","date":"2023-03-28","objectID":"/41.first-missing-positive/:3:0","series":null,"tags":["hash table"],"title":"41.First Missing Positive (Hard)","uri":"/41.first-missing-positive/#code"},{"categories":["leetcode"],"content":" 1 问题描述41. 缺失的第一个正数 (Hard) 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 示例 1： text 输入：nums = [1,2,0] 输出：3 示例 2： text 输入：nums = [3,4,-1,1] 输出：2 示例 3： text 输入：nums = [7,8,9,11,12] 输出：1 提示： 1 \u003c= nums.length \u003c= 5 * 10⁵ -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 ","date":"2023-03-28","objectID":"/41.first-missing-positive.zh/:1:0","series":null,"tags":["hash table"],"title":"41.缺失的第一个正数 (Hard)","uri":"/41.first-missing-positive.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-28","objectID":"/41.first-missing-positive.zh/:2:0","series":null,"tags":["hash table"],"title":"41.缺失的第一个正数 (Hard)","uri":"/41.first-missing-positive.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 标记在nums[i]数组上做标记，我们可以将nums数组中的负数都设为n + 1，令num = abs(nums[i])，然后将nums[num - 1]取反，最后遍历修改后的nums[i]，如果都是负数，返回n + 1，否则返回碰到的第一个非负数的索引加一； ","date":"2023-03-28","objectID":"/41.first-missing-positive.zh/:2:1","series":null,"tags":["hash table"],"title":"41.缺失的第一个正数 (Hard)","uri":"/41.first-missing-positive.zh/#标记"},{"categories":["leetcode"],"content":" 2.2 置换如果nums[i] \u003c= nums.size() \u0026\u0026 nums[i] \u003e 0，那么就将它与nums[num[i] - 1]置换，为了防止死循环，还要判断nums[i] != nums[nums[i] - 1] ","date":"2023-03-28","objectID":"/41.first-missing-positive.zh/:2:2","series":null,"tags":["hash table"],"title":"41.缺失的第一个正数 (Hard)","uri":"/41.first-missing-positive.zh/#置换"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-03-28","objectID":"/41.first-missing-positive.zh/:3:0","series":null,"tags":["hash table"],"title":"41.缺失的第一个正数 (Hard)","uri":"/41.first-missing-positive.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 标记 cpp class Solution { public: int firstMissingPositive(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); for (int\u0026 num: nums) { if (num \u003c= 0) { num = n + 1; } } for (int i = 0; i \u003c n; ++i) { int num = abs(nums[i]); if (num \u003c= n) { nums[num - 1] = -abs(nums[num - 1]); } } for (int i = 0; i \u003c n; ++i) { if (nums[i] \u003e 0) { return i + 1; } } return n + 1; } }; // @lc code=end ","date":"2023-03-28","objectID":"/41.first-missing-positive.zh/:3:1","series":null,"tags":["hash table"],"title":"41.缺失的第一个正数 (Hard)","uri":"/41.first-missing-positive.zh/#标记-1"},{"categories":["leetcode"],"content":" 3.2 置换 cpp class Solution { public: int firstMissingPositive(vector\u003cint\u003e\u0026 nums) { for (int i = 0; i \u003c nums.size(); ++i) { while (nums[i] \u003e 0 \u0026\u0026 nums[i] \u003c= nums.size() \u0026\u0026 nums[i] != i + 1 \u0026\u0026 nums[i] != nums[nums[i] - 1]) { std::swap(nums[i], nums[nums[i] - 1]); } } for (int i = 0; i \u003c nums.size(); ++i) { if (nums[i] != i + 1) { return i + 1; } } return nums.size() + 1; } }; ","date":"2023-03-28","objectID":"/41.first-missing-positive.zh/:3:2","series":null,"tags":["hash table"],"title":"41.缺失的第一个正数 (Hard)","uri":"/41.first-missing-positive.zh/#置换-1"},{"categories":[""],"content":" 1 Description686. Repeated String Match (Medium) Given two strings a and b, return the minimum number of times you should repeat string a so that string bis a substring of it. If it is impossible for b to be a substring of a after repeating it, return -1. Notice: string \"abc\" repeated 0 times is \"\", repeated 1 time is \"abc\" and repeated 2 times is \"abcabc\". Example 1: text Input: a = \"abcd\", b = \"cdabcdab\" Output: 3 Explanation: We return 3 because by repeating a three times \"abcdabcdabcd\", b is a substring of it. Example 2: text Input: a = \"a\", b = \"aa\" Output: 2 Constraints: 1 \u003c= a.length, b.length \u003c= 10⁴ a and b consist of lowercase English letters. ","date":"2023-03-27","objectID":"/686-repeated-string-match/:1:0","series":null,"tags":[""],"title":"686 Repeated String Match","uri":"/686-repeated-string-match/#description"},{"categories":[""],"content":" 2 Solutionkmp, make s = x * a, $x$ is a number. ","date":"2023-03-27","objectID":"/686-repeated-string-match/:2:0","series":null,"tags":[""],"title":"686 Repeated String Match","uri":"/686-repeated-string-match/#solution"},{"categories":[""],"content":" 3 Code cpp class Solution { public: bool check(string \u0026s, string b) { vector\u003cint\u003e next(b.size()); int x = 1, now = 0; while (x \u003c b.size()) { if (b[x] == b[now]) { next[x++] = ++now; } else if (now == 0) { next[x++] = 0; } else { now = next[now - 1]; } } int i = 0, j = 0; while (i \u003c s.size() \u0026\u0026 j \u003c b.size()) { if (s[i] == b[j]) { ++i; ++j; } else { if (j \u003e 0) { j = next[j - 1]; } else { ++i; } } } return j \u003e= b.size(); } int repeatedStringMatch(string a, string b) { int left = (b.size() - 1) / a.size(); string s; if (left == 0) { s = a; } else { for (int i = 0; i \u003c left; ++i) { s += a; } } for (int i = 0; i \u003c 3; ++i) { if (check(s, b)) { return s.size() / a.size(); } else { s += a; } } return -1; } }; ","date":"2023-03-27","objectID":"/686-repeated-string-match/:3:0","series":null,"tags":[""],"title":"686 Repeated String Match","uri":"/686-repeated-string-match/#code"},{"categories":["leetcode"],"content":" 1 问题描述686. 重复叠加字符串匹配 (Medium) 给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。 注意： 字符串 \"abc\" 重复叠加 0 次是 \"\"，重复叠加 1 次是 \"abc\"，重复叠加 2 次是 \"abcabc\"。 示例 1： text 输入：a = \"abcd\", b = \"cdabcdab\" 输出：3 解释：a 重复叠加三遍后为 \"abcdabcdabcd\", 此时 b 是其子串。 示例 2： text 输入：a = \"a\", b = \"aa\" 输出：2 示例 3： text 输入：a = \"a\", b = \"a\" 输出：1 示例 4： text 输入：a = \"abc\", b = \"wxyz\" 输出：-1 提示： 1 \u003c= a.length \u003c= 10⁴ 1 \u003c= b.length \u003c= 10⁴ a 和 b 由小写英文字母组成 ","date":"2023-03-27","objectID":"/686-repeated-string-match.zh/:1:0","series":null,"tags":["kmp"],"title":"686.重复叠加字符串匹配 (Medium)","uri":"/686-repeated-string-match.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路对a，叠加至少(b.size() - 1) / a.size()，最多(b.size() - 1) / a.size() + 2次，然后利用kmp算法来匹配b和新的a。 ","date":"2023-03-27","objectID":"/686-repeated-string-match.zh/:2:0","series":null,"tags":["kmp"],"title":"686.重复叠加字符串匹配 (Medium)","uri":"/686-repeated-string-match.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool check(string \u0026s, string b) { vector\u003cint\u003e next(b.size()); int x = 1, now = 0; while (x \u003c b.size()) { if (b[x] == b[now]) { next[x++] = ++now; } else if (now == 0) { next[x++] = 0; } else { now = next[now - 1]; } } int i = 0, j = 0; while (i \u003c s.size() \u0026\u0026 j \u003c b.size()) { if (s[i] == b[j]) { ++i; ++j; } else { if (j \u003e 0) { j = next[j - 1]; } else { ++i; } } } return j \u003e= b.size(); } int repeatedStringMatch(string a, string b) { int left = (b.size() - 1) / a.size(); string s; if (left == 0) { s = a; } else { for (int i = 0; i \u003c left; ++i) { s += a; } } for (int i = 0; i \u003c 3; ++i) { if (check(s, b)) { return s.size() / a.size(); } else { s += a; } } return -1; } }; ","date":"2023-03-27","objectID":"/686-repeated-string-match.zh/:3:0","series":null,"tags":["kmp"],"title":"686.重复叠加字符串匹配 (Medium)","uri":"/686-repeated-string-match.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description28. Find the Index of the First Occurrence in a String (Easy) Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: text Input: haystack = \"sadbutsad\", needle = \"sad\" Output: 0 Explanation: \"sad\" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2: text Input: haystack = \"leetcode\", needle = \"leeto\" Output: -1 Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1. Constraints: 1 \u003c= haystack.length, needle.length \u003c= 10⁴ haystack and needle consist of only lowercase English characters. ","date":"2023-03-27","objectID":"/28.find-the-index-of-the-first-occurrence-in-a-string/:1:0","series":null,"tags":["kmp"],"title":"28.Find the Index of the First Occurrence in a String (Easy)","uri":"/28.find-the-index-of-the-first-occurrence-in-a-string/#description"},{"categories":["leetcode"],"content":" 2 Solutionkmp ","date":"2023-03-27","objectID":"/28.find-the-index-of-the-first-occurrence-in-a-string/:2:0","series":null,"tags":["kmp"],"title":"28.Find the Index of the First Occurrence in a String (Easy)","uri":"/28.find-the-index-of-the-first-occurrence-in-a-string/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: void SetNext(vector\u003cint\u003e \u0026next, string needle) { int x = 1, now = 0; while (x \u003c needle.size()) { if (needle[x] == needle[now]) { next[x++] = ++now; } else if (now != 0) { now = next[now - 1]; } else { next[x] = 0; x += 1; } } } int strStr(string haystack, string needle) { int m = needle.size(), n = haystack.size(); vector\u003cint\u003e next(m); SetNext(next, needle); int i = 0, j = 0; while (i \u003c n \u0026\u0026 j \u003c m) { if (haystack[i] == needle[j]) { ++i; ++j; } else { if (j \u003e 0) { j = next[j - 1]; } else { ++i; } } } if (j \u003e= m) { return i - m; } return -1; } }; ","date":"2023-03-27","objectID":"/28.find-the-index-of-the-first-occurrence-in-a-string/:3:0","series":null,"tags":["kmp"],"title":"28.Find the Index of the First Occurrence in a String (Easy)","uri":"/28.find-the-index-of-the-first-occurrence-in-a-string/#code"},{"categories":["leetcode"],"content":" 1 问题描述28. 找出字符串中第一个匹配项的下标 (Medium) 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1。 示例 1： text 输入：haystack = \"sadbutsad\", needle = \"sad\" 输出：0 解释：\"sad\" 在下标 0 和 6 处匹配。 第一个匹配项的下标是 0 ，所以返回 0 。 示例 2： text 输入：haystack = \"leetcode\", needle = \"leeto\" 输出：-1 解释：\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。 提示： 1 \u003c= haystack.length, needle.length \u003c= 10⁴ haystack 和 needle 仅由小写英文字符组成 ","date":"2023-03-27","objectID":"/28.find-the-index-of-the-first-occurrence-in-a-string.zh/:1:0","series":null,"tags":["kmp"],"title":"28.找出字符串中第一个匹配项的下标 (Medium)","uri":"/28.find-the-index-of-the-first-occurrence-in-a-string.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路标准的kmp算法模板题。 ","date":"2023-03-27","objectID":"/28.find-the-index-of-the-first-occurrence-in-a-string.zh/:2:0","series":null,"tags":["kmp"],"title":"28.找出字符串中第一个匹配项的下标 (Medium)","uri":"/28.find-the-index-of-the-first-occurrence-in-a-string.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: void SetNext(vector\u003cint\u003e \u0026next, string needle) { int x = 1, now = 0; while (x \u003c needle.size()) { if (needle[x] == needle[now]) { next[x++] = ++now; } else if (now != 0) { now = next[now - 1]; } else { next[x] = 0; x += 1; } } } int strStr(string haystack, string needle) { int m = needle.size(), n = haystack.size(); vector\u003cint\u003e next(m); SetNext(next, needle); int i = 0, j = 0; while (i \u003c n \u0026\u0026 j \u003c m) { if (haystack[i] == needle[j]) { ++i; ++j; } else { if (j \u003e 0) { j = next[j - 1]; } else { ++i; } } } if (j \u003e= m) { return i - m; } return -1; } }; ","date":"2023-03-27","objectID":"/28.find-the-index-of-the-first-occurrence-in-a-string.zh/:3:0","series":null,"tags":["kmp"],"title":"28.找出字符串中第一个匹配项的下标 (Medium)","uri":"/28.find-the-index-of-the-first-occurrence-in-a-string.zh/#代码"},{"categories":["notes"],"content":" 1 问题描述kmp算法解决的是字符串匹配问题，即:字符串P是否是字符串S的子串？如果是，它出现在s的哪些位置？这里我们称 S 为主串，P 为模式串。 ","date":"2023-03-27","objectID":"/kmp.zh/:1:0","series":null,"tags":["kmp","data structure and algorithms"],"title":"kmp 算法","uri":"/kmp.zh/#问题描述"},{"categories":["notes"],"content":" 2 思路首先是暴力匹配算法（Brute-Force算法），代码如下： cpp void BruteForce(string s, string p) { int len_s = s.size(), len_p = p.size(); for (int i = 0; i \u003c= len_s - len_p; ++i) { int flag = true; for (int j = 0; j \u003c len_p; ++j) { if (s[i + j] != p[j]) { flag = false; break; } } if (flag) { printf(\"pos = %d\\n\", i); } } } 易得时间复杂度的最坏情况是$O(mn)$的，其中$n$为s的长度，$m$为p的长度。 为了降低字符串比较的复杂度，我们就必须降低比较的趟数，kmp算法的主要思想就是尽可能利用残余信息，即字符串如果在 j = r 处匹配失败了，那么前r个字符一定匹配成功了，暴力算法中，我们每次不匹配的情况下，都让j = 0，即模式串又从头开始匹配，这就完全没有利用比较带来的信息。 这里，我们可以找模式串的前缀子串和后缀子串，并得到对前r个字符组成的字符串，相等的前缀子串和后缀子串的最大长度，例如 p = \"aabaac\"，那么对前$5$个字符，这个最大长度为2，所以对模式串 p 应该从 j = 2 处开始继续匹配，主串的 i 保持不变 因此，我们建立一个 next 数组，next[0] = 0，next[k - 1] 表示前$k$个字符组成的字符串中，相等的前缀子串和后缀子串的最大长度，当 s[i] != p[j] 时，j = next[j - 1]。 下一步就是求 next 数组，假设遍历到 j = x 时，这个最大长度为 now ，即 next[x - 1] = now，那么当 p[x] == p[now]，next[x++] = ++now，如果 p[x] != p[now]，那么 now = next[now - 1]。 ","date":"2023-03-27","objectID":"/kmp.zh/:2:0","series":null,"tags":["kmp","data structure and algorithms"],"title":"kmp 算法","uri":"/kmp.zh/#思路"},{"categories":["notes"],"content":" 3 代码快速计算next数组的代码: cpp void SetNext(vector\u003cint\u003e \u0026next, string needle) { int x = 1, now = 0; while (x \u003c needle.size()) { if (needle[x] == needle[now]) { next[x++] = ++now; } else if (now != 0) { now = next[now - 1]; } else { next[x] = 0; x += 1; } } } 基于next数组进行比较的代码 cpp int strStr(string s, string p) { int m = p.size(), n = s.size(); vector\u003cint\u003e next(m); SetNext(next, p); int i = 0, j = 0; while (i \u003c n \u0026\u0026 j \u003c m) { if (s[i] == p[j]) { ++i; ++j; } else { if (j \u003e 0) { j = next[j - 1]; } else { ++i; } } } if (j \u003e= m) { return i - m; } return -1; } ","date":"2023-03-27","objectID":"/kmp.zh/:3:0","series":null,"tags":["kmp","data structure and algorithms"],"title":"kmp 算法","uri":"/kmp.zh/#代码"},{"categories":["notes"],"content":" 4 参考kmp算法-阮行止 ","date":"2023-03-27","objectID":"/kmp.zh/:4:0","series":null,"tags":["kmp","data structure and algorithms"],"title":"kmp 算法","uri":"/kmp.zh/#参考"},{"categories":["tutorial"],"content":" 1 环境要求使用 wsl 或者 macOS，Linux 下同理，暂时不考虑纯 winodws。 以 wsl 为例，执行以下指令 bash sudo apt install clang clangd lldb cmake macOS如果安装过xcode工具包，就附带了Apple Clang编译器，否则执行brew install llvm，然后输入以下指令添加环境变量 sh echo 'export PATH=\"/opt/homebrew/opt/llvm/bin:$PATH\"' \u003e\u003e ~/.zshrc echo 'export LDFLAGS=\"-L/opt/homebrew/opt/llvm/lib\"' \u003e\u003e ~/.zshrc echo 'export CPPFLAGS=\"-I/opt/homebrew/opt/llvm/include\"' \u003e\u003e ~/.zshrc 以上是针对默认 shell 为 zsh 的配置，如果你像我一样，mac 的默认 shell 是 fish，那么需要修改 ~/.config/fish/config.fish，添加环境变量，添加下方法为追加以下内容： sh set -gx PATH /opt/homebrew/opt/llvm/bin $PATH set -gx LDFLAGS -L/opt/homebrew/opt/llvm/lib set -gx CPPFLAGS -I/opt/homebrew/opt/llvm/include 然后在vscode中安装 CodeLLDB、clangd、Cmake、Xmake、Cmake Tools 这几个插件，其中除了Xmake之外都必须安装。 ","date":"2023-03-23","objectID":"/clangd_vscode.zh/:1:0","series":null,"tags":["geek","clangd","vscode","tips"],"title":"vscode 使用 clangd","uri":"/clangd_vscode.zh/#环境要求"},{"categories":["tutorial"],"content":" 2 开始随便找一个空文件打开，然后Ctrl+shift+p（macOS下为cmd+shift_p）打开下拉菜单，搜索camke，选择Quick start： 之后给项目起个名字，如webserver，输出类型选Executable而不是lib，Kit选择Clangxxxxx-gnu。 macOS 必须选择 homebrew 安装的 clang kit，否则会出现无法找到 ninja 的问题。 这里的话其实是 Cmake 插件给你默认生成了 CMakeLists.txt 并生成了对应的 compile_commands.json 文件，建议根据自己的项目结构（便于 include 等）自己写 CMakeLists.txt。 然后需要让clangd识别项目的编译数据库，在vscode设置中搜索clangd，在Arguments配置项中输入参数--compile-commands-dir=${workspaceFolder}/build，然后点击确定。 ","date":"2023-03-23","objectID":"/clangd_vscode.zh/:2:0","series":null,"tags":["geek","clangd","vscode","tips"],"title":"vscode 使用 clangd","uri":"/clangd_vscode.zh/#开始"},{"categories":["tutorial"],"content":" 3 运行与调试点击build生成的可执行文件就位于build目录下，按下F5开始调试，会报错并在项目根目录下生成.vscode目录以及.vscode/launch.json文件，编辑这个json文件，将program那一栏修改为\"program\": \"${workspaceFolder}/build/${workspaceFolderBasename}\"，之后就能按F5调试了。 注意cmake默认只会编译main.cpp这一源文件，修改了源文件或者添加断点，要重新执行cmake插件的build之后才能再调试。 或者参照vscode文档配置lauch.json文件。 ","date":"2023-03-23","objectID":"/clangd_vscode.zh/:3:0","series":null,"tags":["geek","clangd","vscode","tips"],"title":"vscode 使用 clangd","uri":"/clangd_vscode.zh/#运行与调试"},{"categories":["tutorial"],"content":" 4 代码格式化在项目根目录下创建.clang-format文件，编辑内容为 sh # 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto Language: Cpp # BasedOnStyle: LLVM # 访问说明符(public、private等)的偏移 AccessModifierOffset: -2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket: Align # 连续赋值时，对齐所有等号 AlignConsecutiveAssignments: false # 连续声明时，对齐所有声明的变量名 AlignConsecutiveDeclarations: false # 右对齐逃脱换行(使用反斜杠换行)的反斜杠 AlignEscapedNewlines: Right # 水平对齐二元和三元表达式的操作数 AlignOperands: true # 对齐连续的尾随的注释 AlignTrailingcomments: false # 不允许函数声明的所有参数在放在下一行 AllowAllParametersOfDeclarationOnNextLine: false # 不允许短的块放在同一行 AllowShortBlocksOnASingleLine: true # 允许短的case标签放在同一行 AllowShortCaseLabelsOnASingleLine: true # 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All AllowShortFunctionsOnASingleLine: None # 允许短的if语句保持在同一行 AllowShortIfStatementsOnASingleLine: true # 允许短的循环保持在同一行 AllowShortLoopsOnASingleLine: true # 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), # AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义) AlwaysBreakAfterReturnType: None # 总是在多行string字面量前换行 AlwaysBreakBeforeMultilineStrings: false # 总是在template声明后换行 AlwaysBreakTemplateDeclarations: true # false表示函数实参要么都在同一行，要么都各自一行 BinPackArguments: true # false表示所有形参要么都在同一行，要么都各自一行 BinPackParameters: true # 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效 BraceWrapping: # class定义后面 AfterClass: false # 控制语句后面 AfterControlStatement: false # enum定义后面 AfterEnum: false # 函数定义后面 AfterFunction: false # 命名空间定义后面 AfterNamespace: false # struct定义后面 AfterStruct: false # union定义后面 AfterUnion: false # extern之后 AfterExternBlock: false # catch之前 BeforeCatch: false # else之前 BeforeElse: false # 缩进大括号 IndentBraces: false # 分离空函数 SplitEmptyFunction: false # 分离空语句 SplitEmptyRecord: false # 分离空命名空间 SplitEmptyNamespace: false # 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行) BreakBeforeBinaryOperators: NonAssignment # 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), # Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), # Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom # 注：这里认为语句块也属于函数 BreakBeforeBraces: Custom # 在三元运算符前换行 BreakBeforeTernaryOperators: false # 在构造函数的初始化列表的冒号后换行 BreakConstructorInitializers: AfterColon #BreakInheritanceList: AfterColon BreakStringLiterals: false # 每行字符的限制，0表示没有限制 ColumnLimit: 0 CompactNamespaces: true # 构造函数的初始化列表要么都在同一行，要么都各自一行 ConstructorInitializerAllOnOneLineOrOnePerLine: false # 构造函数的初始化列表的缩进宽度 ConstructorInitializerIndentWidth: 4 # 延续的行的缩进宽度 ContinuationIndentWidth: 4 # 去除C++11的列表初始化的大括号{后和}前的空格 Cpp11BracedListStyle: true # 继承最常用的指针和引用的对齐方式 DerivePointerAlignment: false # 固定命名空间注释 FixNamespacecomments: false # 缩进case标签 IndentCaseLabels: false IndentPPDirectives: None # 缩进宽度 IndentWidth: 4 # 函数返回类型换行时，缩进函数声明或函数定义的函数名 IndentWrappedFunctionNames: false # 保留在块开始处的空行 KeepEmptyLinesAtTheStartOfBlocks: false # 连续空行的最大数量 MaxEmptyLinesToKeep: 1 # 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All NamespaceIndentation: None # 指针和引用的对齐: Left, Right, Middle PointerAlignment: Right # 允许重新排版注释 Reflowcomments: false # 允许排序#include SortIncludes: false # 允许排序 using 声明 SortUsingDeclarations: false # 在C风格类型转换后添加空格 SpaceAfterCStyleCast: false # 在Template 关键字后面添加空格 SpaceAfterTemplateKeyword: true # 在赋值运算符之前添加空格 SpaceBeforeAssignmentOperators: true # SpaceBeforeCpp11BracedList: true # SpaceBeforeCtorInitializerColon: true # SpaceBeforeInheritanceColon: true # 开圆括号之前添加一个空格: Never, ControlStatements, Always SpaceBeforeParens: ControlStatements # SpaceBeforeRangeBasedForLoopColon: true # 在空的圆括号中添加空格 SpaceInEmptyParentheses: false # 在尾随的评论前添加的空格数(只适用于//) SpacesBeforeTrailingComments: 1 # 在尖括号的\u003c后和\u003e前添加空格 SpacesInAngles: false # 在C风格类型转换的括号中添加空格 SpacesInCStyleCastParentheses: false # 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格 SpacesInContainerLiterals: true # 在圆括号的(后和)前添加空格 SpacesInParentheses: false # 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响 SpacesInSquareBrackets: false # 标准: Cpp03, Cpp11, Auto Standard: C","date":"2023-03-23","objectID":"/clangd_vscode.zh/:4:0","series":null,"tags":["geek","clangd","vscode","tips"],"title":"vscode 使用 clangd","uri":"/clangd_vscode.zh/#代码格式化"},{"categories":["tutorial"],"content":" 5 clang-tidy在项目根目录下创建.clang-tidy文件，内容修改为 text Checks: \"bugprone-*,\\ google-*,\\ misc-*,\\ modernize-*,\\ performance-*,\\ readability-*,\\ portability-*,\\ \" HeaderFilterRegex: 'Source/cm[^/]*\\.(h|hxx|cxx)$' CheckOptions: - key: modernize-use-default-member-init.UseAssignment value: '1' - key: modernize-use-equals-default.IgnoreMacros value: '0' - key: modernize-use-auto.MinTypeNameLength value: '80' ","date":"2023-03-23","objectID":"/clangd_vscode.zh/:5:0","series":null,"tags":["geek","clangd","vscode","tips"],"title":"vscode 使用 clangd","uri":"/clangd_vscode.zh/#clang-tidy"},{"categories":["tutorial"],"content":" 6 参考内容 几乎无痛的VSCode+clangd+lldb+cmake配置C/C++开发环境指南 配置sublime text4为C++编辑器 ","date":"2023-03-23","objectID":"/clangd_vscode.zh/:6:0","series":null,"tags":["geek","clangd","vscode","tips"],"title":"vscode 使用 clangd","uri":"/clangd_vscode.zh/#参考内容"},{"categories":["tutorial"],"content":" 1 安装starshipMacOS下执行curl -sS https://starship.rs/install.sh | sh即可，Linux下（如Debian），执行curl -sS https://starship.rs/install.sh | sh即可，然后执行starship preset pure-preset \u003e ~/.config/starship.toml将预设主题设置为pure。 ","date":"2023-03-23","objectID":"/zsh_configuration.zh/:1:0","series":null,"tags":["zsh","tips"],"title":"Zsh 的简单配置与使用","uri":"/zsh_configuration.zh/#安装starship"},{"categories":["tutorial"],"content":" 2 安装zinit插件执行bash -c \"$(curl --fail --show-error --silent --location https://raw.githubusercontent.com/zdharma-continuum/zinit/HEAD/scripts/install.sh)\"以自动安装**zinit。 修改~/.zshrc为以下内容 sh ## 启用starship eval \"$(starship init zsh)\" ### Added by Zinit's installer if [[ ! -f $HOME/.local/share/zinit/zinit.git/zinit.zsh ]]; then print -P \"%F{33} %F{220}Installing %F{33}ZDHARMA-CONTINUUM%F{220} Initiative Plugin Manager (%F{33}zdharma-continuum/zinit%F{220})…%f\" command mkdir -p \"$HOME/.local/share/zinit\" \u0026\u0026 command chmod g-rwX \"$HOME/.local/share/zinit\" command git clone https://github.com/zdharma-continuum/zinit \"$HOME/.local/share/zinit/zinit.git\" \u0026\u0026 \\ print -P \"%F{33} %F{34}Installation successful.%f%b\" || \\ print -P \"%F{160} The clone has failed.%f%b\" fi source \"$HOME/.local/share/zinit/zinit.git/zinit.zsh\" autoload -Uz _zinit (( ${+_comps} )) \u0026\u0026 _comps[zinit]=_zinit # Load a few important annexes, without Turbo # (this is currently required for annexes) zinit light-mode for \\ zdharma-continuum/zinit-annex-as-monitor \\ zdharma-continuum/zinit-annex-bin-gem-node \\ zdharma-continuum/zinit-annex-patch-dl \\ zdharma-continuum/zinit-annex-rust ### End of Zinit's installer chunk # 快速目录跳转 zinit ice lucid wait='1' zinit light skywind3000/z.lua # 语法高亮 zinit ice lucid wait='0' atinit='zpcompinit' zinit light zdharma/fast-syntax-highlighting # 自动建议 zinit ice lucid wait=\"0\" atload='_zsh_autosuggest_start' zinit light zsh-users/zsh-autosuggestions # 补全 zinit ice lucid wait='0' zinit light zsh-users/zsh-completions # 加载 OMZ 框架及部分插件 # zinit snippet OMZ::lib/completion.zsh zinit snippet OMZ::lib/history.zsh zinit snippet OMZ::lib/key-bindings.zsh zinit snippet OMZ::lib/theme-and-appearance.zsh zinit snippet OMZ::plugins/colored-man-pages/colored-man-pages.plugin.zsh zinit snippet OMZ::plugins/git/git.plugin.zsh # zinit snippet OMZ::themes/robbyrussell/robbyrussell.zsh-theme # zinit snippet OMZ::plugins/z/z.plugin.zhs # zinit snippet OMZ::plugins/sudo/sudo.plugin.zsh # zinit ice svn zinit snippet OMZ::plugins/extract/extract.plugin.zsh zinit ice lucid wait='1' zinit snippet OMZ::plugins/git/git.plugin.zsh # 加载 pure 主题 # zinit ice pick\"async.zsh\" src\"pure.zsh\" # zinit light sindresorhus/pure # eval \"$(starship init zsh)\" # 设置 zsh-autosuggestions 的提示配色以适配 Mariana 配色 ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=white' # llvm 配置 export PATH=\"/usr/local/opt/llvm/bin:$PATH\" export LDFLAGS=\"-L/usr/local/opt/llvm/lib\" export CPPFLAGS=\"-I/usr/local/opt/llvm/include\" ","date":"2023-03-23","objectID":"/zsh_configuration.zh/:2:0","series":null,"tags":["zsh","tips"],"title":"Zsh 的简单配置与使用","uri":"/zsh_configuration.zh/#安装zinit插件"},{"categories":["leetcode"],"content":" 1 问题描述297. 二叉树的序列化与反序列化 (Hard) 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 示例 1： text 输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2： text 输入：root = [] 输出：[] 示例 3： text 输入：root = [1] 输出：[1] 示例 4： text 输入：root = [1,2] 输出：[1,2] 提示： 树中结点数在范围 [0, 10⁴] 内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2023-03-23","objectID":"/297.serialize-and-deserialize-binary-tree.zh/:1:0","series":null,"tags":["dfs","tree"],"title":"297.二叉树的序列化与反序列化 (Hard)","uri":"/297.serialize-and-deserialize-binary-tree.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先利用前序遍历的dfs，将节点的值存放到字符串中，如果遇到空节点，则str += \"null_\"，然后return。 反序列化时，首先将字符串转化为字符串链表，然后递归地进行反序列化，如果链表首元素为null，则为当前子树的root节点，然后先反序列化左子树，然后反序列化又子树，如果首元素为null，则直接返回。 可以注意到与前序遍历是相对应的的。 ","date":"2023-03-23","objectID":"/297.serialize-and-deserialize-binary-tree.zh/:2:0","series":null,"tags":["dfs","tree"],"title":"297.二叉树的序列化与反序列化 (Hard)","uri":"/297.serialize-and-deserialize-binary-tree.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Codec { public: void rserialize(TreeNode* root, string\u0026 str) { if (root == nullptr) { str += \"None,\"; } else { str += to_string(root-\u003eval) + \",\"; rserialize(root-\u003eleft, str); rserialize(root-\u003eright, str); } } string serialize(TreeNode* root) { string ret; rserialize(root, ret); return ret; } TreeNode* rdeserialize(list\u003cstring\u003e\u0026 dataArray) { if (dataArray.front() == \"None\") { dataArray.erase(dataArray.begin()); return nullptr; } TreeNode* root = new TreeNode(stoi(dataArray.front())); dataArray.erase(dataArray.begin()); root-\u003eleft = rdeserialize(dataArray); root-\u003eright = rdeserialize(dataArray); return root; } TreeNode* deserialize(string data) { list\u003cstring\u003e dataArray; string str; for (auto\u0026 ch : data) { if (ch == ',') { dataArray.push_back(str); str.clear(); } else { str.push_back(ch); } } if (!str.empty()) { dataArray.push_back(str); str.clear(); } return rdeserialize(dataArray); } }; ","date":"2023-03-23","objectID":"/297.serialize-and-deserialize-binary-tree.zh/:3:0","series":null,"tags":["dfs","tree"],"title":"297.二叉树的序列化与反序列化 (Hard)","uri":"/297.serialize-and-deserialize-binary-tree.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description Maximum Number of Tasks You Can Assign (Hard) You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task’s strength requirement (i.e., workers[j] \u003e= tasks[i]). Additionally, you have pills magical pills that will increase a worker’s strength by strength. You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill. Given the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed. Example 1: text Input: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1 Output: 3 Explanation: We can assign the magical pill and tasks as follows: - Give the magical pill to worker 0. - Assign worker 0 to task 2 (0 + 1 \u003e= 1) - Assign worker 1 to task 1 (3 \u003e= 2) - Assign worker 2 to task 0 (3 \u003e= 3) Example 2: text Input: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5 Output: 1 Explanation: We can assign the magical pill and tasks as follows: - Give the magical pill to worker 0. - Assign worker 0 to task 0 (0 + 5 \u003e= 5) Example 3: text Input: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10 Output: 2 Explanation: We can assign the magical pills and tasks as follows: - Give the magical pill to worker 0 and worker 1. - Assign worker 0 to task 0 (0 + 10 \u003e= 10) - Assign worker 1 to task 1 (10 + 10 \u003e= 15) The last pill is not given because it will not make any worker strong enough for the last task. Constraints: n == tasks.length m == workers.length 1 \u003c= n, m \u003c= 5 * 10⁴ 0 \u003c= pills \u003c= m 0 \u003c= tasks[i], workers[j], strength \u003c= 10⁹ ","date":"2023-03-22","objectID":"/2071.maximum-number-of-tasks-you-can-assign/:1:0","series":null,"tags":["greedy algorithm","binary search","map"],"title":"2071.Maximum Number of Tasks You Can Assign (Hard)","uri":"/2071.maximum-number-of-tasks-you-can-assign/#description"},{"categories":["leetcode"],"content":" 2 SolutionBinary search the answer. ","date":"2023-03-22","objectID":"/2071.maximum-number-of-tasks-you-can-assign/:2:0","series":null,"tags":["greedy algorithm","binary search","map"],"title":"2071.Maximum Number of Tasks You Can Assign (Hard)","uri":"/2071.maximum-number-of-tasks-you-can-assign/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool check(int num, vector\u003cint\u003e \u0026tasks, vector\u003cint\u003e \u0026workers, int pills, map\u003cint, int\u003e mp, int strength) { for (int i = 0, j = workers.size() - num; i \u003c tasks.size() \u0026\u0026 j \u003c workers.size(); ++i, ++j) { if (mp.begin()-\u003efirst \u003e workers[j]) { if (pills \u003c= 0) { return false; } else { if (mp.begin()-\u003efirst \u003e strength + workers[j]) { return false; } else { auto iter = mp.lower_bound(strength + workers[j]); if (iter-\u003efirst == strength + workers[j]) { --iter-\u003esecond; if (iter-\u003esecond == 0) { mp.erase(iter); } } else { --iter; --iter-\u003esecond; if (iter-\u003esecond == 0) { mp.erase(iter); } } --pills; } } } else { mp.begin()-\u003esecond--; if (mp.begin()-\u003esecond == 0) { mp.erase(mp.begin()); } } } return true; } int maxTaskAssign(vector\u003cint\u003e \u0026tasks, vector\u003cint\u003e \u0026workers, int pills, int strength) { int m = std::min(workers.size(), tasks.size()); std::sort(tasks.begin(), tasks.end()); std::sort(workers.begin(), workers.end()); map\u003cint, int\u003e mp; for (int i = 0; i \u003c tasks.size(); i++) { mp[tasks[i]]++; } int left = 0, right = m; while (left \u003c right) { int mid = left + (right - left) / 2; if (check(mid, tasks, workers, pills, mp, strength)) { left = mid + 1; } else { right = mid; } } if (check(left, tasks, workers, pills, mp, strength)) return left; return left - 1; } }; ","date":"2023-03-22","objectID":"/2071.maximum-number-of-tasks-you-can-assign/:3:0","series":null,"tags":["greedy algorithm","binary search","map"],"title":"2071.Maximum Number of Tasks You Can Assign (Hard)","uri":"/2071.maximum-number-of-tasks-you-can-assign/#code"},{"categories":["leetcode"],"content":" 1 问题描述2071. 你可以安排的最多任务数目 (Hard) 给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] \u003e= tasks[i] ）。 除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。 给你下标从 0 开始的整数数组 tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。 示例 1： text 输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1 输出：3 解释： 我们可以按照如下方案安排药丸： - 给 0 号工人药丸。 - 0 号工人完成任务 2（0 + 1 \u003e= 1） - 1 号工人完成任务 1（3 \u003e= 2） - 2 号工人完成任务 0（3 \u003e= 3） 示例 2： text 输入：tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5 输出：1 解释： 我们可以按照如下方案安排药丸： - 给 0 号工人药丸。 - 0 号工人完成任务 0（0 + 5 \u003e= 5） 示例 3： text 输入：tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10 输出：2 解释： 我们可以按照如下方案安排药丸： - 给 0 号和 1 号工人药丸。 - 0 号工人完成任务 0（0 + 10 \u003e= 10） - 1 号工人完成任务 1（10 + 10 \u003e= 15） 示例 4： text 输入：tasks = [5,9,8,5,9], workers = [1,6,4,2,6], pills = 1, strength = 5 输出：3 解释： 我们可以按照如下方案安排药丸： - 给 2 号工人药丸。 - 1 号工人完成任务 0（6 \u003e= 5） - 2 号工人完成任务 2（4 + 5 \u003e= 8） - 4 号工人完成任务 3（6 \u003e= 5） 提示： n == tasks.length m == workers.length 1 \u003c= n, m \u003c= 5 * 10⁴ 0 \u003c= pills \u003c= m 0 \u003c= tasks[i], workers[j], strength \u003c= 10⁹ ","date":"2023-03-22","objectID":"/2071.maximum-number-of-tasks-you-can-assign.zh/:1:0","series":null,"tags":["greedy algorithm","binary search","map"],"title":"2071.你可以安排的最多任务数目 (Hard)","uri":"/2071.maximum-number-of-tasks-you-can-assign.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路二分答案+贪心。 我们假设答案为ans，那么一定是前ans个消耗精力最小的任务被后ans个力量最大的工人完成了。 将工人按力量值从小到大排序，将task用map来存储，二分答案进行判断时，遍历工人，先与map.begin()-\u003efirst比较，如果大于等于，更新map，否则需要吃药，吃药之后必须选择小于等于当前力量的消耗精力最大的任务来处理，如果还是小于map.bein()-\u003efirst，则return false，说明mid \u003e ans。 建议使用左闭右闭。 ","date":"2023-03-22","objectID":"/2071.maximum-number-of-tasks-you-can-assign.zh/:2:0","series":null,"tags":["greedy algorithm","binary search","map"],"title":"2071.你可以安排的最多任务数目 (Hard)","uri":"/2071.maximum-number-of-tasks-you-can-assign.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool check(int num, vector\u003cint\u003e \u0026tasks, vector\u003cint\u003e \u0026workers, int pills, map\u003cint, int\u003e mp, int strength) { for (int i = 0, j = workers.size() - num; i \u003c tasks.size() \u0026\u0026 j \u003c workers.size(); ++i, ++j) { if (mp.begin()-\u003efirst \u003e workers[j]) { if (pills \u003c= 0) { return false; } else { if (mp.begin()-\u003efirst \u003e strength + workers[j]) { return false; } else { auto iter = mp.lower_bound(strength + workers[j]); if (iter-\u003efirst == strength + workers[j]) { --iter-\u003esecond; if (iter-\u003esecond == 0) { mp.erase(iter); } } else { --iter; --iter-\u003esecond; if (iter-\u003esecond == 0) { mp.erase(iter); } } --pills; } } } else { mp.begin()-\u003esecond--; if (mp.begin()-\u003esecond == 0) { mp.erase(mp.begin()); } } } return true; } int maxTaskAssign(vector\u003cint\u003e \u0026tasks, vector\u003cint\u003e \u0026workers, int pills, int strength) { // 对工人的力量值从小到大排序 // 对任务的所需力量值从小到大排序 // 二分+贪心 int m = std::min(workers.size(), tasks.size()); std::sort(tasks.begin(), tasks.end()); std::sort(workers.begin(), workers.end()); map\u003cint, int\u003e mp; for (int i = 0; i \u003c tasks.size(); i++) { mp[tasks[i]]++; } int left = 0, right = m; while (left \u003c right) { int mid = left + (right - left) / 2; if (check(mid, tasks, workers, pills, mp, strength)) { left = mid + 1; } else { right = mid; } } if (check(left, tasks, workers, pills, mp, strength)) return left; return left - 1; } }; ","date":"2023-03-22","objectID":"/2071.maximum-number-of-tasks-you-can-assign.zh/:3:0","series":null,"tags":["greedy algorithm","binary search","map"],"title":"2071.你可以安排的最多任务数目 (Hard)","uri":"/2071.maximum-number-of-tasks-you-can-assign.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description952. Largest Component Size by Common Factor (Hard) You are given an integer array of unique positive integers nums. Consider the following graph: There are nums.length nodes, labeled nums[0] to nums[nums.length - 1], There is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph. Example 1: text Input: nums = [4,6,15,35] Output: 4 Example 2: text Input: nums = [20,50,9,63] Output: 2 Example 3: text Input: nums = [2,3,6,7,4,12,21,39] Output: 8 Constraints: 1 \u003c= nums.length \u003c= 2 * 10⁴ 1 \u003c= nums[i] \u003c= 10⁵ All the values of nums are unique. ","date":"2023-03-22","objectID":"/952.largest-component-size-by-common-factor/:1:0","series":null,"tags":["dsu"],"title":"952.Largest Component Size by Common Factor (Hard)","uri":"/952.largest-component-size-by-common-factor/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use Dsu to solve the problem. ","date":"2023-03-22","objectID":"/952.largest-component-size-by-common-factor/:2:0","series":null,"tags":["dsu"],"title":"952.Largest Component Size by Common Factor (Hard)","uri":"/952.largest-component-size-by-common-factor/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Dsu { public: vector\u003cint\u003e parent_; vector\u003cint\u003e size_; // 每棵树的节点数量 int res; public: Dsu(int n) : parent_(n), size_(n, 0), res(0) { iota(parent_.begin(), parent_.end(), 0); // parent[0] = 0, parent[1] = [1] ... } int find(int idx) { return parent_[idx] == idx ? idx : parent_[idx] = find(parent_[idx]); } void unite(int idx, int idy) { idx = find(idx); idy = find(idy); if (idx == idy) { return; } if (size_[idx] \u003c size_[idy]) { std::swap(idx, idy); } parent_[idy] = idx; size_[idx] += size_[idy]; } }; class Solution { public: void factor(int num, Dsu *dsu) { int tmp = num; for (int i = 2; i * i \u003c= num; ++i) { if (num % i == 0) { while (num % i == 0) { num /= i; } dsu-\u003eunite(i, tmp); } } if (num != 1) { dsu-\u003eunite(num, tmp); } dsu-\u003eres = std::max(dsu-\u003eres, dsu-\u003esize_[dsu-\u003efind(tmp)]); } int largestComponentSize(vector\u003cint\u003e \u0026nums) { int n = nums.size(); Dsu *dsu = new Dsu(100000 + 1); for (int i = 0; i \u003c n; ++i) { dsu-\u003esize_[nums[i]] = 1; } for (int i = 0; i \u003c n; ++i) { factor(nums[i], dsu); } return dsu-\u003eres; } }; ","date":"2023-03-22","objectID":"/952.largest-component-size-by-common-factor/:3:0","series":null,"tags":["dsu"],"title":"952.Largest Component Size by Common Factor (Hard)","uri":"/952.largest-component-size-by-common-factor/#code"},{"categories":["leetcode"],"content":" 1 问题描述952. 按公因数计算最大组件大小 (Hard) 给定一个由不同正整数的组成的非空数组 nums ，考虑下面的图： 有 nums.length 个节点，按从 nums[0] 到 nums[nums.length - 1] 标记； 只有当 nums[i] 和 nums[j] 共用一个大于 1 的公因数时， nums[i] 和 nums[j] 之间才有一条边。 返回 图中最大连通组件的大小 。 示例 1： text 输入：nums = [4,6,15,35] 输出：4 示例 2： text 输入：nums = [20,50,9,63] 输出：2 示例 3： text 输入：nums = [2,3,6,7,4,12,21,39] 输出：8 提示： 1 \u003c= nums.length \u003c= 2 * 10⁴ 1 \u003c= nums[i] \u003c= 10⁵ nums 中所有值都 不同 ","date":"2023-03-22","objectID":"/952.largest-component-size-by-common-factor.zh/:1:0","series":null,"tags":["dsu"],"title":"952.按公因数计算最大组件大小 (Hard)","uri":"/952.largest-component-size-by-common-factor.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路使用并查集，并注意质因数分解的求法。 由于nums[i] \u003c= 100000，因此我们设置初始的并查集的节点为$100001$个，遍历数组中的每个元素，将每个元素和他的质因数连接起来，我们只将size_[nums[i]]初始化为1，其余均为0，这样不属于nums[i]的质因数的个数就不会被统计到树的数量中，遍历数组的元素时，更新ans即可。 注意，由于时间复杂度的要求，我们需要压缩路径并且使用启发式合并。 ","date":"2023-03-22","objectID":"/952.largest-component-size-by-common-factor.zh/:2:0","series":null,"tags":["dsu"],"title":"952.按公因数计算最大组件大小 (Hard)","uri":"/952.largest-component-size-by-common-factor.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Dsu { public: vector\u003cint\u003e parent_; vector\u003cint\u003e size_; // 每棵树的节点数量 int res; public: Dsu(int n) : parent_(n), size_(n, 0), res(0) { iota(parent_.begin(), parent_.end(), 0); // parent[0] = 0, parent[1] = 1, 依次类推 } int find(int idx) { return parent_[idx] == idx ? idx : parent_[idx] = find(parent_[idx]); } void unite(int idx, int idy) { idx = find(idx); idy = find(idy); if (idx == idy) { return; } if (size_[idx] \u003c size_[idy]) { std::swap(idx, idy); } parent_[idy] = idx; size_[idx] += size_[idy]; } }; class Solution { public: void factor(int num, Dsu *dsu) { int tmp = num; for (int i = 2; i * i \u003c= num; ++i) { if (num % i == 0) { while (num % i == 0) { num /= i; } dsu-\u003eunite(i, tmp); } } if (num != 1) { dsu-\u003eunite(num, tmp); } dsu-\u003eres = std::max(dsu-\u003eres, dsu-\u003esize_[dsu-\u003efind(tmp)]); } int largestComponentSize(vector\u003cint\u003e \u0026nums) { int n = nums.size(); Dsu *dsu = new Dsu(100000 + 1); for (int i = 0; i \u003c n; ++i) { dsu-\u003esize_[nums[i]] = 1; } for (int i = 0; i \u003c n; ++i) { factor(nums[i], dsu); } return dsu-\u003eres; } }; ","date":"2023-03-22","objectID":"/952.largest-component-size-by-common-factor.zh/:3:0","series":null,"tags":["dsu"],"title":"952.按公因数计算最大组件大小 (Hard)","uri":"/952.largest-component-size-by-common-factor.zh/#代码"},{"categories":["notes"],"content":" 1 引入并查集是一种用于管理元素所属的集合的数据结构，其实现或者说表现为一片森林，其中，每棵树表示了一个集合，树中的节点表示对应的集合中的元素： 顾名思义，并查集支持两种操作： 合并（Union）：合并两个元素所属的集合（合并对应的树）； 查询（Find）：查询某个元素所属的集合（即查询对应的树的根节点），这可以用于判断两个元素是否属于同一个集合； 并查集在经过修改后还可以支持单个元素的移动、删除；使用动态开点线段树还可以实现可持久化并查集； ","date":"2023-03-22","objectID":"/dsu-oi-wiki.zh/:1:0","series":null,"tags":["dsu","data structure and algorithms"],"title":"并查集","uri":"/dsu-oi-wiki.zh/#引入"},{"categories":["notes"],"content":" 2 初始化初始时，我们设置每个元素都属于一个单独的集合，表示为一棵只有根节点的树，每个根节点的父亲都设置为自己。 cpp class Dsu { vector\u003csize_t\u003e parent_; // 表示每个节点的父节点 vector\u003csize_t\u003e size_; // 表示每棵树有多少节点 Dsu(size_t size) : parent_(size), size_(size, 1) { iota(parent_.begin(), parent_.end()); } } ","date":"2023-03-22","objectID":"/dsu-oi-wiki.zh/:2:0","series":null,"tags":["dsu","data structure and algorithms"],"title":"并查集","uri":"/dsu-oi-wiki.zh/#初始化"},{"categories":["notes"],"content":" 3 查询我们只需要沿着树向上移动，直到找到根节点 cpp size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x]; } ","date":"2023-03-22","objectID":"/dsu-oi-wiki.zh/:3:0","series":null,"tags":["dsu","data structure and algorithms"],"title":"并查集","uri":"/dsu-oi-wiki.zh/#查询"},{"categories":["notes"],"content":" 4 查询时进行路径压缩查询过程中，经过的每个元素都属于该集合，因此我们可以直接将其连接到根节点，以加快后续查询。 cpp size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x] = find(parent_[x]); } ","date":"2023-03-22","objectID":"/dsu-oi-wiki.zh/:4:0","series":null,"tags":["dsu","data structure and algorithms"],"title":"并查集","uri":"/dsu-oi-wiki.zh/#查询时进行路径压缩"},{"categories":["notes"],"content":" 5 合并要合并两棵树，我们只需要将一棵树的根节点连接到另一棵树的根节点。 cpp void Dsu::Unite(size_t x, size_t y) { parent_(find(x)) = find(y); } ","date":"2023-03-22","objectID":"/dsu-oi-wiki.zh/:5:0","series":null,"tags":["dsu","data structure and algorithms"],"title":"并查集","uri":"/dsu-oi-wiki.zh/#合并"},{"categories":["notes"],"content":" 6 启发式合并即将节点较小或者深度较小的树连接到另一棵，这里以按节点数合并的实现作为参考: cpp void Unite(size_t x, size_t y) { x = find(x), y = find(y); if (x == y) { return ; } if (size_[x] \u003c size_[y]) { swap(x, y); } parent_[y] = x; size_[x] += size_[y]; } ","date":"2023-03-22","objectID":"/dsu-oi-wiki.zh/:6:0","series":null,"tags":["dsu","data structure and algorithms"],"title":"并查集","uri":"/dsu-oi-wiki.zh/#启发式合并"},{"categories":["notes"],"content":" 7 参考文献并查集-OI WIKI ","date":"2023-03-22","objectID":"/dsu-oi-wiki.zh/:7:0","series":null,"tags":["dsu","data structure and algorithms"],"title":"并查集","uri":"/dsu-oi-wiki.zh/#参考文献"},{"categories":["tutorial"],"content":" 1 设置默认编辑器为 vim text git config --global core.editor vim ","date":"2023-03-22","objectID":"/git_tutorial.zh/:1:0","series":null,"tags":["git","geek","utility","tips"],"title":"git 使用技巧","uri":"/git_tutorial.zh/#设置默认编辑器为-vim"},{"categories":["tutorial"],"content":" 2 问题fatal: in unpopulated submodule 'xxx'的解决出现这个问题的原因clone的别人的项目之后，删除项目里的.git文件就直接添加到了自己的版本控制里面，解决方案，执行 git rm --cached . -rf，再添加文件和提交。 ","date":"2023-03-22","objectID":"/git_tutorial.zh/:2:0","series":null,"tags":["git","geek","utility","tips"],"title":"git 使用技巧","uri":"/git_tutorial.zh/#问题fatal-in-unpopulated-submodule-xxx的解决"},{"categories":["tutorial"],"content":" 3 “merge conflict” 解决对于纯文本文件的冲突解决，可以参考该文章，没什么太多好说的。 对于二进制文件，编辑二进制文件来解决冲突是不现实的，要么选择对方的修改，要么选择自己的修改，可以使用git checkout的--theirs或者--ours选项： sh git pull git checkout --theirs YOUR_BINARY_FILE // git checkout --ours YOUR_BINARY_FILE git add YOUR_BINARY_FILE git commit -m 'merged with the remote repos.' git push ","date":"2023-03-22","objectID":"/git_tutorial.zh/:3:0","series":null,"tags":["git","geek","utility","tips"],"title":"git 使用技巧","uri":"/git_tutorial.zh/#merge-conflict-解决"},{"categories":["leetcode"],"content":" 1 Description654. Maximum Binary Tree (Medium) You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm: Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value. Return the maximum binary tree built from nums. Example 1: text Input: nums = [3,2,1,6,0,5] Output: [6,3,5,null,2,0,null,null,1] Explanation: The recursive calls are as follow: - The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5]. - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1]. - Empty array, so no child. - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1]. - Empty array, so no child. - Only one element, so child is a node with value 1. - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is []. - Only one element, so child is a node with value 0. - Empty array, so no child. Example 2: text Input: nums = [3,2,1] Output: [3,null,2,null,1] Constraints: 1 \u003c= nums.length \u003c= 1000 0 \u003c= nums[i] \u003c= 1000 All integers in nums are unique. ","date":"2023-03-19","objectID":"/654.maximum-binary-tree/:1:0","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.Maximum Binary Tree (Medium)","uri":"/654.maximum-binary-tree/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-03-19","objectID":"/654.maximum-binary-tree/:2:0","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.Maximum Binary Tree (Medium)","uri":"/654.maximum-binary-tree/#solution"},{"categories":["leetcode"],"content":" 2.1 divide and conquer","date":"2023-03-19","objectID":"/654.maximum-binary-tree/:2:1","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.Maximum Binary Tree (Medium)","uri":"/654.maximum-binary-tree/#divide-and-conquer"},{"categories":["leetcode"],"content":" 2.2 monotone stack","date":"2023-03-19","objectID":"/654.maximum-binary-tree/:2:2","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.Maximum Binary Tree (Medium)","uri":"/654.maximum-binary-tree/#monotone-stack"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-03-19","objectID":"/654.maximum-binary-tree/:3:0","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.Maximum Binary Tree (Medium)","uri":"/654.maximum-binary-tree/#code"},{"categories":["leetcode"],"content":" 3.1 divide and conquer cpp class Solution { public: TreeNode *dfs(vector\u003cint\u003e \u0026nums, int l, int r) { if (l \u003e= r) { return nullptr; } int val = nums[l], idx = l; for (int i = l; i \u003c r; ++i) { if (nums[i] \u003e val) { val = nums[i]; idx = i; } } TreeNode *root = new TreeNode(val, dfs(nums, l, idx), dfs(nums, idx + 1, r)); return root; } TreeNode* constructMaximumBinaryTree(vector\u003cint\u003e\u0026 nums) { return dfs(nums, 0, nums.size()); } }; ","date":"2023-03-19","objectID":"/654.maximum-binary-tree/:3:1","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.Maximum Binary Tree (Medium)","uri":"/654.maximum-binary-tree/#divide-and-conquer-1"},{"categories":["leetcode"],"content":" 3.2 monotone stack cpp class Solution { public: TreeNode *constructMaximumBinaryTree(vector\u003cint\u003e \u0026nums) { // 尝试使用单调栈 stack\u003cTreeNode *\u003e stk; stack\u003cTreeNode *\u003e tmp; for (int i = 0; i \u003c nums.size(); ++i) { while (!stk.empty() \u0026\u0026 nums[i] \u003e stk.top()-\u003eval) { tmp.push(stk.top()); stk.pop(); } TreeNode *node = new TreeNode(nums[i]); TreeNode *p = node; int flag = 0; while (!tmp.empty()) { if (flag == 0) { p-\u003eleft = tmp.top(); p = p-\u003eleft; } else { p-\u003eright = tmp.top(); p = p-\u003eright; } ++flag; tmp.pop(); } stk.push(node); } TreeNode *root; while (!stk.empty()) { tmp.push(stk.top()); stk.pop(); if (!stk.empty()) { stk.top()-\u003eright = tmp.top(); } } return tmp.top(); } }; ","date":"2023-03-19","objectID":"/654.maximum-binary-tree/:3:2","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.Maximum Binary Tree (Medium)","uri":"/654.maximum-binary-tree/#monotone-stack-1"},{"categories":["leetcode"],"content":" 1 问题描述654. 最大二叉树 (Medium) 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树。 示例 1： text 输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2： text 输入：nums = [3,2,1] 输出：[3,null,2,null,1] 提示： 1 \u003c= nums.length \u003c= 1000 0 \u003c= nums[i] \u003c= 1000 nums 中的所有整数 互不相同 ","date":"2023-03-19","objectID":"/654.maximum-binary-tree.zh/:1:0","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.最大二叉树 (Medium)","uri":"/654.maximum-binary-tree.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-19","objectID":"/654.maximum-binary-tree.zh/:2:0","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.最大二叉树 (Medium)","uri":"/654.maximum-binary-tree.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 递归+分治采取左开右闭区间， 递归终止的边界条件：l \u003e= r； 递归的返回值，当前区间形成的最大子树的根节点； 当前递归的处理，我们可以用分治法来解决，找到当前区间的最大值，则TreeNode *root = new TreeNode(val_max)，然后区间$[l, idx)$形成的子树的根节点即root-\u003eleft，root-\u003eright即区间$[idx + 1, r)$形成的子树的根节点。 ","date":"2023-03-19","objectID":"/654.maximum-binary-tree.zh/:2:1","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.最大二叉树 (Medium)","uri":"/654.maximum-binary-tree.zh/#递归分治"},{"categories":["leetcode"],"content":" 2.2 单调栈从左到右遍历，如果当前值比栈顶的节点的值要大，说明栈顶节点是当前节点的左子节点，栈底到栈顶递减。 ","date":"2023-03-19","objectID":"/654.maximum-binary-tree.zh/:2:2","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.最大二叉树 (Medium)","uri":"/654.maximum-binary-tree.zh/#单调栈"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-03-19","objectID":"/654.maximum-binary-tree.zh/:3:0","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.最大二叉树 (Medium)","uri":"/654.maximum-binary-tree.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 递归+分治 cpp class Solution { public: TreeNode *dfs(vector\u003cint\u003e \u0026nums, int l, int r) { if (l \u003e= r) { return nullptr; } int val = nums[l], idx = l; for (int i = l; i \u003c r; ++i) { if (nums[i] \u003e val) { val = nums[i]; idx = i; } } TreeNode *root = new TreeNode(val, dfs(nums, l, idx), dfs(nums, idx + 1, r)); return root; } TreeNode* constructMaximumBinaryTree(vector\u003cint\u003e\u0026 nums) { return dfs(nums, 0, nums.size()); } }; ","date":"2023-03-19","objectID":"/654.maximum-binary-tree.zh/:3:1","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.最大二叉树 (Medium)","uri":"/654.maximum-binary-tree.zh/#递归分治-1"},{"categories":["leetcode"],"content":" 3.2 单调栈 cpp class Solution { public: TreeNode *constructMaximumBinaryTree(vector\u003cint\u003e \u0026nums) { // 尝试使用单调栈 stack\u003cTreeNode *\u003e stk; stack\u003cTreeNode *\u003e tmp; for (int i = 0; i \u003c nums.size(); ++i) { while (!stk.empty() \u0026\u0026 nums[i] \u003e stk.top()-\u003eval) { tmp.push(stk.top()); stk.pop(); } TreeNode *node = new TreeNode(nums[i]); TreeNode *p = node; int flag = 0; while (!tmp.empty()) { if (flag == 0) { p-\u003eleft = tmp.top(); p = p-\u003eleft; } else { p-\u003eright = tmp.top(); p = p-\u003eright; } ++flag; tmp.pop(); } stk.push(node); } TreeNode *root; while (!stk.empty()) { tmp.push(stk.top()); stk.pop(); if (!stk.empty()) { stk.top()-\u003eright = tmp.top(); } } return tmp.top(); } }; ","date":"2023-03-19","objectID":"/654.maximum-binary-tree.zh/:3:2","series":null,"tags":["tree","monotone stack","dfs"],"title":"654.最大二叉树 (Medium)","uri":"/654.maximum-binary-tree.zh/#单调栈-1"},{"categories":["tutorial\""],"content":" 1 前言Nerd Fonts 是一个使用大量字体图标来解决程序员在开发过程中缺少合适字体的问题的项目。它可以从流行的字体图标库中将大量外部字体引入待开发的项目中。 Nerd Fonts官方提供的Fura Mono字体将r修改成了Fira Mono的变种形式，个人不太喜欢，于是考虑自行打包。 同时，由于版权原因，未提供monaco字体的Nerd Fonts，因此也需要自行打包。 ","date":"2023-03-18","objectID":"/patch_my_own_nerd_font.zh/:1:0","series":null,"tags":["tips","geek"],"title":"自行制作 nerd font","uri":"/patch_my_own_nerd_font.zh/#前言"},{"categories":["tutorial\""],"content":" 2 patch Fira Mono参照Option 9: Patch Your Own Font,下载font patcher并解压，保证待打包字体位于解压之后的文件夹，然后执行 sh ./font-patcher FiraMono-Regular.ttf -s -c --also-windows -ext otf ","date":"2023-03-18","objectID":"/patch_my_own_nerd_font.zh/:2:0","series":null,"tags":["tips","geek"],"title":"自行制作 nerd font","uri":"/patch_my_own_nerd_font.zh/#patch-fira-mono"},{"categories":["tutorial\""],"content":" 3 patch Monaco与Fira Mono类似，从此处下载Monaco字体，然后执行： sh ./font-patcher Monaco.ttf -s -c --also-windows -ext otf ","date":"2023-03-18","objectID":"/patch_my_own_nerd_font.zh/:3:0","series":null,"tags":["tips","geek"],"title":"自行制作 nerd font","uri":"/patch_my_own_nerd_font.zh/#patch-monaco"},{"categories":["leetcode"],"content":" 1 Description2389. Longest Subsequence With Limited Sum (Easy) You are given an integer array nums of length n, and an integer array queries of length m. Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i]. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. Example 1: text Input: nums = [4,5,2,1], queries = [3,10,21] Output: [2,3,4] Explanation: We answer the queries as follows: - The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2. - The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3. - The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4. Example 2: text Input: nums = [2,3,4,5], queries = [1] Output: [0] Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0. Constraints: n == nums.length m == queries.length 1 \u003c= n, m \u003c= 1000 1 \u003c= nums[i], queries[i] \u003c= 10⁶ ","date":"2023-03-17","objectID":"/2389.longest-subsequence-with-limited-sum/:1:0","series":null,"tags":["prefix sum","binary search"],"title":"2389.Longest Subsequence With Limited Sum (Easy)","uri":"/2389.longest-subsequence-with-limited-sum/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can sort the array first, it doesn’t affect the sum of the subsequence. Then we can calculate the prefix sum of the sorted array, then we can get the minimum sum of the subsequence whose length is l. Then for each queries[i], we can use binary search to get the maximum length of the subsequence. ","date":"2023-03-17","objectID":"/2389.longest-subsequence-with-limited-sum/:2:0","series":null,"tags":["prefix sum","binary search"],"title":"2389.Longest Subsequence With Limited Sum (Easy)","uri":"/2389.longest-subsequence-with-limited-sum/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int Bfind(vector\u003cint\u003e \u0026prefix, int target) { int left = 0, right = prefix.size(); while (left \u003c right) { int mid = left + (right - left) / 2; if (prefix[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return left; } vector\u003cint\u003e answerQueries(vector\u003cint\u003e \u0026nums, vector\u003cint\u003e \u0026queries) { std::sort(nums.begin(), nums.end()); int n = nums.size(); vector\u003cint\u003e prefix(n + 1); for (int i = 1; i \u003c= n; ++i) { prefix[i] = prefix[i - 1] + nums[i - 1]; } vector\u003cint\u003e res(queries.size()); for (int i = 0; i \u003c queries.size(); ++i) { res[i] = Bfind(prefix, queries[i] + 1) - 1; } return res; } }; ","date":"2023-03-17","objectID":"/2389.longest-subsequence-with-limited-sum/:3:0","series":null,"tags":["prefix sum","binary search"],"title":"2389.Longest Subsequence With Limited Sum (Easy)","uri":"/2389.longest-subsequence-with-limited-sum/#code"},{"categories":["leetcode"],"content":" 1 问题描述 和有限的最长子序列 (Easy) 给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。 返回一个长度为 m 的数组 answer，其中 answer[i] 是 nums 中元素之和小于等于 queries[i] 的 子序列 的 最大 长度。 子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。 示例 1： text 输入：nums = [4,5,2,1], queries = [3,10,21] 输出：[2,3,4] 解释：queries 对应的 answer 如下： - 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。 - 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。 - 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。 示例 2： text 输入：nums = [2,3,4,5], queries = [1] 输出：[0] 解释：空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。 提示： n == nums.length m == queries.length 1 \u003c= n, m \u003c= 1000 1 \u003c= nums[i], queries[i] \u003c= 10⁶ ","date":"2023-03-17","objectID":"/2389.longest-subsequence-with-limited-sum.zh/:1:0","series":null,"tags":["prefix sum","binary search"],"title":"2389.和有限的最长子序列 (Easy)","uri":"/2389.longest-subsequence-with-limited-sum.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路由于子序列是删除任意元素得到的，因此我们可以对数组排序，不会对子序列的和产生影响； 然后求排序后的数组的前缀和，就能得到长为l的子序列的最小和； 然后遍历queries数组，对每个queries[i]，使用二分查找来找到最大的子序列长度。 ","date":"2023-03-17","objectID":"/2389.longest-subsequence-with-limited-sum.zh/:2:0","series":null,"tags":["prefix sum","binary search"],"title":"2389.和有限的最长子序列 (Easy)","uri":"/2389.longest-subsequence-with-limited-sum.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int Bfind(vector\u003cint\u003e \u0026prefix, int target) { int left = 0, right = prefix.size(); // 左闭右开 while (left \u003c right) { int mid = left + (right - left) / 2; if (prefix[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return left; } vector\u003cint\u003e answerQueries(vector\u003cint\u003e \u0026nums, vector\u003cint\u003e \u0026queries) { std::sort(nums.begin(), nums.end()); int n = nums.size(); vector\u003cint\u003e prefix(n + 1); for (int i = 1; i \u003c= n; ++i) { prefix[i] = prefix[i - 1] + nums[i - 1]; } vector\u003cint\u003e res(queries.size()); for (int i = 0; i \u003c queries.size(); ++i) { res[i] = Bfind(prefix, queries[i] + 1) - 1; } return res; } }; ","date":"2023-03-17","objectID":"/2389.longest-subsequence-with-limited-sum.zh/:3:0","series":null,"tags":["prefix sum","binary search"],"title":"2389.和有限的最长子序列 (Easy)","uri":"/2389.longest-subsequence-with-limited-sum.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description778. Swim in Rising Water (Hard) You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j). The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim. Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0). Example 1: text Input: grid = [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0. You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid. Example 2: text Input: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation: The final route is shown. We need to wait until time 16 so that (0, 0) and (4, 4) are connected. Constraints: n == grid.length n == grid[i].length 1 \u003c= n \u003c= 50 0 \u003c= grid[i][j] \u003c n² Each value grid[i][j] is unique. ","date":"2023-03-17","objectID":"/778.swim-in-rising-water/:1:0","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.Swim in Rising Water (Hard)","uri":"/778.swim-in-rising-water/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-03-17","objectID":"/778.swim-in-rising-water/:2:0","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.Swim in Rising Water (Hard)","uri":"/778.swim-in-rising-water/#solution"},{"categories":["leetcode"],"content":" 2.1 binary search + bfsWe can use binary search to find the answer. We will wait mid time first: if we can reach the destination, it means mid \u003e= ans, then right = mid; otherwise, mid \u003c ans, then left = mid + 1 ","date":"2023-03-17","objectID":"/778.swim-in-rising-water/:2:1","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.Swim in Rising Water (Hard)","uri":"/778.swim-in-rising-water/#binary-search--bfs"},{"categories":["leetcode"],"content":" 2.2 dijkstraWe push std::max(time, grid[i][j]) into the pq. ","date":"2023-03-17","objectID":"/778.swim-in-rising-water/:2:2","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.Swim in Rising Water (Hard)","uri":"/778.swim-in-rising-water/#dijkstra"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-03-17","objectID":"/778.swim-in-rising-water/:3:0","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.Swim in Rising Water (Hard)","uri":"/778.swim-in-rising-water/#code"},{"categories":["leetcode"],"content":" 3.1 binary search + bfs cpp class Solution { public: bool bfs(vector\u003cvector\u003cint\u003e\u003e \u0026grid, int mid) { int n = grid.size(); vector\u003cvector\u003cint\u003e\u003e vis(n, vector\u003cint\u003e(n, 0)); queue\u003cvector\u003cint\u003e\u003e q; q.push({0, 0}); vis[0][0] = 1; vector\u003cvector\u003cint\u003e\u003e mov{{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; while (!q.empty()) { auto vec = q.front(); if (vec[0] == n - 1 \u0026\u0026 vec[1] == n - 1) { return true; } q.pop(); for (int i = 0; i \u003c 4; ++i) { int x_new = vec[0] + mov[i][0], y_new = vec[1] + mov[i][1]; if (x_new \u003e= 0 \u0026\u0026 x_new \u003c n \u0026\u0026 y_new \u003e= 0 \u0026\u0026 y_new \u003c n \u0026\u0026 vis[x_new][y_new] == 0 \u0026\u0026 mid \u003e= grid[x_new][y_new]) { q.push({x_new, y_new}); vis[x_new][y_new] = 1; } } } return false; } int swimInWater(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { int left = 0, right = 2500; while (left \u003c right) { int mid = left + (right - left) / 2; if (bfs(grid, mid)) { right = mid; } else { left = mid + 1; } } return std::max(left, grid[0][0]); } }; ","date":"2023-03-17","objectID":"/778.swim-in-rising-water/:3:1","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.Swim in Rising Water (Hard)","uri":"/778.swim-in-rising-water/#binary-search--bfs-1"},{"categories":["leetcode"],"content":" 3.2 dijkstra cpp class Solution { public: int swimInWater(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int n = grid.size(); auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { return v1[2] \u003e v2[2]; }; priority_queue\u003cvector\u003cint\u003e , vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); pq.push({0, 0, grid[0][0]}); vector\u003cvector\u003cint\u003e\u003e dis(n, vector\u003cint\u003e(n, -1)); vector\u003cvector\u003cint\u003e\u003e mov{{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; while (!pq.empty()) { auto vec = pq.top(); int x = vec[0], y = vec[1], time = vec[2]; pq.pop(); if (dis[x][y] != -1) { continue; } dis[x][y] = time; for (int i = 0; i \u003c 4; ++i) { int new_x = x + mov[i][0], new_y = y + mov[i][1]; if (new_x \u003e= 0 \u0026\u0026 new_x \u003c n \u0026\u0026 new_y \u003e= 0 \u0026\u0026 new_y \u003c n) { if (dis[new_x][new_y] == -1) { if (time \u003e= grid[new_x][new_y]) { pq.push({new_x, new_y, time}); } else { pq.push({new_x, new_y, grid[new_x][new_y]}); } } } } } return dis[n - 1][n - 1]; } }; ","date":"2023-03-17","objectID":"/778.swim-in-rising-water/:3:2","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.Swim in Rising Water (Hard)","uri":"/778.swim-in-rising-water/#dijkstra-1"},{"categories":["leetcode"],"content":" 1 问题描述778. 水位上升的泳池中游泳 (Hard) 在一个 n x n 的整数矩阵 grid 中，每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。 当开始下雨时，在时间为 t 时，水池中的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。 你从坐标方格的左上平台 (0，0) 出发。返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间 。 示例 1: text 输入: grid = [[0,2],[1,3]] 输出: 3 解释: 时间为0时，你位于坐标方格的位置为 (0, 0)。 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。 等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置 示例 2: text 输入: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] 输出: 16 解释: 最终的路线用加粗进行了标记。 我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的 提示: n == grid.length n == grid[i].length 1 \u003c= n \u003c= 50 0 \u003c= grid[i][j] \u003c n² grid[i][j] 中每个值 均无重复 ","date":"2023-03-17","objectID":"/778.swim-in-rising-water.zh/:1:0","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.水位上升的泳池中游泳 (Hard)","uri":"/778.swim-in-rising-water.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-17","objectID":"/778.swim-in-rising-water.zh/:2:0","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.水位上升的泳池中游泳 (Hard)","uri":"/778.swim-in-rising-water.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 二分+bfs二分答案，然后利用bfs判断这个等待时间下，能否到达终点： 无法到达终点，说明mid \u003c ans，则left = mid + 1； 可以到达终点，说明mid \u003e= ans，则right = mid； ","date":"2023-03-17","objectID":"/778.swim-in-rising-water.zh/:2:1","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.水位上升的泳池中游泳 (Hard)","uri":"/778.swim-in-rising-water.zh/#二分bfs"},{"categories":["leetcode"],"content":" 2.2 dijkstra堆优化的dijkstra，使用小顶堆，每次入队的是当前时间与grid[i][j]的最大值。 ","date":"2023-03-17","objectID":"/778.swim-in-rising-water.zh/:2:2","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.水位上升的泳池中游泳 (Hard)","uri":"/778.swim-in-rising-water.zh/#dijkstra"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-03-17","objectID":"/778.swim-in-rising-water.zh/:3:0","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.水位上升的泳池中游泳 (Hard)","uri":"/778.swim-in-rising-water.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 二分+bfd cpp class Solution { public: bool bfs(vector\u003cvector\u003cint\u003e\u003e \u0026grid, int mid) { int n = grid.size(); vector\u003cvector\u003cint\u003e\u003e vis(n, vector\u003cint\u003e(n, 0)); queue\u003cvector\u003cint\u003e\u003e q; q.push({0, 0}); vis[0][0] = 1; vector\u003cvector\u003cint\u003e\u003e mov{{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; while (!q.empty()) { auto vec = q.front(); if (vec[0] == n - 1 \u0026\u0026 vec[1] == n - 1) { return true; } q.pop(); for (int i = 0; i \u003c 4; ++i) { int x_new = vec[0] + mov[i][0], y_new = vec[1] + mov[i][1]; if (x_new \u003e= 0 \u0026\u0026 x_new \u003c n \u0026\u0026 y_new \u003e= 0 \u0026\u0026 y_new \u003c n \u0026\u0026 vis[x_new][y_new] == 0 \u0026\u0026 mid \u003e= grid[x_new][y_new]) { q.push({x_new, y_new}); vis[x_new][y_new] = 1; } } } return false; } int swimInWater(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { // 二分答案，如果ans \u003c target，那么无法到达，左闭右开 int left = 0, right = 2500; while (left \u003c right) { int mid = left + (right - left) / 2; if (bfs(grid, mid)) { right = mid; } else { left = mid + 1; } } return std::max(left, grid[0][0]); } }; ","date":"2023-03-17","objectID":"/778.swim-in-rising-water.zh/:3:1","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.水位上升的泳池中游泳 (Hard)","uri":"/778.swim-in-rising-water.zh/#二分bfd"},{"categories":["leetcode"],"content":" 3.2 dijsktra cpp class Solution { public: int swimInWater(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { // Dijkstra算法 int n = grid.size(); auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { return v1[2] \u003e v2[2]; }; priority_queue\u003cvector\u003cint\u003e , vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); pq.push({0, 0, grid[0][0]}); // 从0时刻出发，0，0坐标出发 vector\u003cvector\u003cint\u003e\u003e dis(n, vector\u003cint\u003e(n, -1)); vector\u003cvector\u003cint\u003e\u003e mov{{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; while (!pq.empty()) { auto vec = pq.top(); int x = vec[0], y = vec[1], time = vec[2]; pq.pop(); if (dis[x][y] != -1) { continue; } dis[x][y] = time; for (int i = 0; i \u003c 4; ++i) { int new_x = x + mov[i][0], new_y = y + mov[i][1]; if (new_x \u003e= 0 \u0026\u0026 new_x \u003c n \u0026\u0026 new_y \u003e= 0 \u0026\u0026 new_y \u003c n) { if (dis[new_x][new_y] == -1) { if (time \u003e= grid[new_x][new_y]) { pq.push({new_x, new_y, time}); } else { pq.push({new_x, new_y, grid[new_x][new_y]}); } } } } } return dis[n - 1][n - 1]; } }; ","date":"2023-03-17","objectID":"/778.swim-in-rising-water.zh/:3:2","series":null,"tags":["bfs","dijkstra","binary search"],"title":"778.水位上升的泳池中游泳 (Hard)","uri":"/778.swim-in-rising-water.zh/#dijsktra"},{"categories":["tutorial"],"content":" 1 安装 LazyVim参考 Lazyvim 的官方安装教程即可安装，要求系统已经安装好了 npm。 实际上就是 clone folke 的适用于 LazyVim 的初始 配置文件 到 Neovim 的配置文件所处的目录，Linux 和 macOS 都是 ~/.config，Windows 比较特殊，位于 ~/AppData/Local/。 由于我对初始配置文件做了一定的修改，因此我这里直接 clone 我自己的 配置文件 It is recommended to run :checkhealth after installation 值得注意的是，LazyVim 会安装 nvim-treesitter 插件，而 nvim-treesitter 插件会自动编译安装 C/C++ 等语言的解析器，而编译安装是需要 C/C++ 的运行环境的，对安装了 Command Line Tool 的 Mac 或者 Linux 而言，这一步一般不会存在问题，Windows 则是容易出现问题，我在重装 Windows 系统后尝试过只通过 scoop 安装了 llvm，尽管命令行中执行 clang --version 是有正常输出的，即 C/C++ 运行环境已经正常安装好了，但是 nvim-treesitter 始终无法正常编译解释器，不得已，我又通过 scoop install mingw 安装了 mingw（gcc），安装好 mingw 之后，解释器就能正常被编译安装了，此后执行 scoop uninstall mingw 卸载掉 mingw 也还是能正常使用。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:1:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#安装-lazyvim"},{"categories":["tutorial"],"content":" 2 keymap配置Insert模式下按下jk退出Insert模式，将nvim/lua/config/keymap.lua中文件内容修改为: lua local keymap = vim.keymap keymap.set(\"i\", \"jk\", \"\u003cESC\u003e\") ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:2:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#keymap配置"},{"categories":["tutorial"],"content":" 3 同步系统剪贴板neovim 自带的拷贝文字功能被称为 yank，yank 的结果存放在 neovim 自己的缓冲区，要让这个缓冲区与操作系统的剪贴板同步，即 yank 的结果会存放在操作系统剪贴板，而 paste 的时候会从操作系统剪贴板粘贴，那么需要修改 nvim/lua/config/options.lua，追加内容： lua local opt = vim.opt opt.clipboard = \"unnamedplus\" -- Sync with system clipboard 并执行 sudo apt install xclip 以安装 xclip 从而让系统拥有剪贴板功能。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:3:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#同步系统剪贴板"},{"categories":["tutorial"],"content":" 4 利用 lazy.nvim 安装并管理插件nvim 的配置文件目录结构如下： txt ├── comment.lua ├── init.lua ├── lazy-lock.json ├── lazyvim.json ├── LICENSE ├── lua │ ├── config │ │ ├── autocmds.lua │ │ ├── keymaps.lua │ │ ├── lazy.lua │ │ └── options.lua │ ├── plugins │ │ ├── colorscheme.lua │ │ ├── disabled.lua │ │ └── example.lua │ └── vscode │ ├── config │ │ ├── keymaps.lua │ │ ├── lazy.lua │ │ └── options.lua │ └── plugins │ ├── comment.lua │ ├── disabled.lua │ └── mini.lua ├── README.md └── stylua.toml 以 nvim-osc52 插件为例，我们首先在 nvim/lua/plugins/ 目录下创建文件 osc52.lua，内容修改为 lua return { { \"ojroques/nvim-osc52\", lazy = false, opts = {tmux_passthrough = true}, }, } 由于 nvim/lua/config/lazy.lua 中内容如下 lua local lazypath = vim.fn.stdpath(\"data\") .. \"/lazy/lazy.nvim\" if not vim.loop.fs_stat(lazypath) then -- bootstrap lazy.nvim -- stylua: ignore vim.fn.system({ \"git\", \"clone\", \"--filter=blob:none\", \"https://github.com/folke/lazy.nvim.git\", \"--branch=stable\", lazypath }) end vim.opt.rtp:prepend(vim.env.LAZY or lazypath) require(\"lazy\").setup({ spec = { -- add LazyVim and import its plugins { \"LazyVim/LazyVim\", import = \"lazyvim.plugins\" }, -- import any extras modules here -- { import = \"lazyvim.plugins.extras.lang.typescript\" }, -- { import = \"lazyvim.plugins.extras.lang.json\" }, -- { import = \"lazyvim.plugins.extras.ui.mini-animate\" }, -- import/override with your plugins { import = \"plugins\" }, }, defaults = { -- By default, only LazyVim plugins will be lazy-loaded. Your custom plugins will load during startup. -- If you know what you're doing, you can set this to `true` to have all your custom plugins lazy-loaded by default. lazy = false, -- It's recommended to leave version=false for now, since a lot the plugin that support versioning, -- have outdated releases, which may break your Neovim install. version = false, -- always use the latest git commit -- version = \"*\", -- try installing the latest stable version for plugins that support semver }, install = { colorscheme = { \"tokyonight\", \"habamax\" } }, checker = { enabled = true }, -- automatically check for plugin updates performance = { rtp = { -- disable some rtp plugins disabled_plugins = { \"gzip\", -- \"matchit\", -- \"matchparen\", -- \"netrwPlugin\", \"tarPlugin\", \"tohtml\", \"tutor\", \"zipPlugin\", }, }, }, }) 其中前 8 行是用于安装 lazy.nvim 插件本身的，而第 9 行 require(\"lazy\").setup({spec = {{import = \"plugins\"},},})（省略掉了其他语句），会安装并运行 lua/plugins/ 目录下的所有插件。 如果不安装 LazyVim，只是安装 lazy.nvim 插件，那么 nvim/lua/config/lazy.lua 的内容应该如下： lua local lazypath = vim.fn.stdpath(\"data\") .. \"/lazy/lazy.nvim\" if not vim.loop.fs_stat(lazypath) then vim.fn.system({ \"git\", \"clone\", \"--filter=blob:none\", \"https://github.com/folke/lazy.nvim.git\", \"--branch=stable\", -- latest stable release lazypath, }) end vim.opt.rtp:prepend(lazypath) require(\"lazy\").setup(\"plugins\") 最后一行 require(\"lazy\").setup(\"plugins\") 的功能也是安装并加载 lua/plugins/ 目录下的所有插件。 要安装 Comment.nvim 插件，只需要在 nvim/lua/plugins/ 目录下新建 comment.lua 插件，内容修改为： lua return { { \"numToStr/Comment.nvim\", lazy = false, }, } 即可。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:4:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#利用-lazynvim-安装并管理插件"},{"categories":["tutorial"],"content":" 5 ssh 下剪贴板同步即要求 ssh 连接到远程服务器，在远程服务器打开 nvim 时，nvim 复制的内容会自动同步到本地电脑的剪贴板。 在配置文件 nvim/lua/config/ 中创建文件：osc52.lua，追加内容为： lua local function copy(lines, _) require('osc52').copy(table.concat(lines, '\\n')) end local function paste() return {vim.fn.split(vim.fn.getreg(''), '\\n'), vim.fn.getregtype('')} end vim.g.clipboard = { name = 'osc52', copy = {['+'] = copy, ['*'] = copy}, paste = {['+'] = paste, ['*'] = paste}, } -- Now the '+' register will copy to system clipboard using OSC52 vim.keymap.set('n', '\u003cleader\u003ec', '\"+y') vim.keymap.set('n', '\u003cleader\u003ecc', '\"+yy') 使用 lazy.nvim 插件安装 nvim-osc52 插件。 最后，在 init.lua 中，添加内容：require(\"vscode.config.lazy\")，故 init.lua 内容如下： lua if vim.g.vscode then -- if true then -- Vscoe extension require(\"vscode.config.options\") require(\"vscode.config.keymaps\") -- require(\"vscode.init\") require(\"vscode.config.lazy\") -- require(\"vscode.plugins.disabled\") else -- bootstrap lazy.nvim, LazyVim and your plugins require(\"config.lazy\") require(\"config.osc52\") end 这里的 if, else 是为了兼容 scode-neovim 插件。 Lazyvim 插件会自动加载 nvim/lua/config/ 目录下的 autocmds.lua、keymaps.lua、lazy.lua、options.lua 这几个文件，目录下的其他配置文件的内容需要我们手动在 init.lua 中选择加载。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:5:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#ssh-下剪贴板同步"},{"categories":["tutorial"],"content":" 6 ssh + tmux 的剪贴板同步如果远程服务器打开了 tmux，并在 tmux 中打开 neovim，那么还需要做一点额外配置，使得 neovim yank 的内容能同步到本地机器的剪贴板。 首先，编辑 ~/.tmux.conf，追加内容 set -g allow-passthrough on，在安装 osc52 插件时，配置需要设置为 tmux_passthrough = true，对应 “利用 lazy.nvim 安装并管理插件” 部分的 opts = {tmux_passthrough = true},。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:6:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#ssh--tmux-的剪贴板同步"},{"categories":["tutorial"],"content":" 7 设置tab-size为4修改~/.config/nvim/lua/config/optionas.lua，追加内容 lua opt.tabstop = 4 opt.shiftwidth = 4 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:7:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#设置tab-size为4"},{"categories":["tutorial"],"content":" 8 LSP 设置进入 neovim 之后输入 :Mason，即可像使用 LazyVim 一样安装 LSP 所需的插件，我安装了以下这几个插件： ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:8:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#lsp-设置"},{"categories":["tutorial"],"content":" 9 Neovim 插件介绍","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:9:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#neovim-插件介绍"},{"categories":["tutorial"],"content":" 9.1 mini.ai没搞懂干嘛的。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:9:1","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#miniai"},{"categories":["tutorial"],"content":" 9.2 mini.surround没搞懂，待续。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:9:2","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#minisurround"},{"categories":["tutorial"],"content":" 9.3 flash.nvim功能有点像浏览器 vimium 插件按下 f 的时候，例如我按下 /，再按下 tr，表示我要搜索 tr，这时屏幕上会显示一系列的 label（字母），表示 tr 所处的不同位置，按下对应的字母，即可跳转到对应的位置。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:9:3","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#flashnvim"},{"categories":["tutorial"],"content":" 9.4 mini.pairs括号，引号等的自动补全，即输入 ( 会显示 ()。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:9:4","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#minipairs"},{"categories":["tutorial"],"content":" 10 Neovim 快捷键gi，跳转到上次 insert 的地方并进入 insert 模式。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:10:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#neovim-快捷键"},{"categories":["tutorial"],"content":" 11 vim.repeat","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:11:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#vimrepeat"},{"categories":["tutorial"],"content":" 12 杂项\u003cS-Tab\u003e已经被lazyvim设置于为Go to left windows 见 github 讨论 切换tab ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:12:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#杂项"},{"categories":["tutorial"],"content":" 13 备份文件存档于github-nvim-config，理论上安装lazyvim之后pull即可。 ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:13:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#备份"},{"categories":["tutorial"],"content":" 参考NeoVintageous-clipboard NeoVintageous-jk Vscode.neovim Vscode.neovim-gc-comment ","date":"2023-03-17","objectID":"/neovim_tutorial.zh/:0:0","series":null,"tags":["vim","neovim","geek","tips"],"title":"Neovim 的配置与使用","uri":"/neovim_tutorial.zh/#参考"},{"categories":["leetcode"],"content":" 1 Solution1631. Path With Minimum Effort (Medium) You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort. A route’s effort is the maximum absolute difference in heights between two consecutive cells of the route. Return the minimum effort required to travel from the top-left cell to the bottom-right cell. Example 1: text Input: heights = [[1,2,2],[3,8,2],[5,3,5]] Output: 2 Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells. This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3. Example 2: text Input: heights = [[1,2,3],[3,8,4],[5,3,5]] Output: 1 Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5]. Example 3: text Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]] Output: 0 Explanation: This route does not require any effort. Constraints: rows == heights.length columns == heights[i].length 1 \u003c= rows, columns \u003c= 100 1 \u003c= heights[i][j] \u003c= 10⁶ ","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort/:1:0","series":null,"tags":["dijkstra","binary search"],"title":"1631.Path With Minimum Effort (Medium)","uri":"/1631.path-with-minimum-effort/#solution"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort/:2:0","series":null,"tags":["dijkstra","binary search"],"title":"1631.Path With Minimum Effort (Medium)","uri":"/1631.path-with-minimum-effort/#solution-1"},{"categories":["leetcode"],"content":" 2.1 Dijkstra algorithmWe can use Dijkstra algorithm to find the answer. ","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort/:2:1","series":null,"tags":["dijkstra","binary search"],"title":"1631.Path With Minimum Effort (Medium)","uri":"/1631.path-with-minimum-effort/#dijkstra-algorithm"},{"categories":["leetcode"],"content":" 2.2 binary search","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort/:2:2","series":null,"tags":["dijkstra","binary search"],"title":"1631.Path With Minimum Effort (Medium)","uri":"/1631.path-with-minimum-effort/#binary-search"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minimumEffortPath(vector\u003cvector\u003cint\u003e\u003e \u0026heights) { int m = heights.size(), n = heights[0].size(); // Dijkstra auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { return v1[2] \u003e v2[2]; }; priority_queue\u003cvector\u003cint\u003e, vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); vector\u003cvector\u003cint\u003e\u003e dis(m, vector\u003cint\u003e(n, -1)); vector\u003cvector\u003cint\u003e\u003e move{{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; pq.push({0, 0, 0}); while (!pq.empty()) { auto vec = pq.top(); pq.pop(); int x = vec[0], y = vec[1], cost = vec[2]; if (dis[x][y] != -1) { continue; } dis[x][y] = cost; for (int i = 0; i \u003c 4; ++i) { int new_x = x + move[i][0]; int new_y = y + move[i][1]; if (new_x \u003e= 0 \u0026\u0026 new_x \u003c m \u0026\u0026 new_y \u003e= 0 \u0026\u0026 new_y \u003c n) { if (dis[new_x][new_y] == -1) { pq.push({new_x, new_y, std::max(cost, abs(heights[x][y] - heights[new_x][new_y]))}); } } } } return dis[m - 1][n - 1]; } }; ","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort/:3:0","series":null,"tags":["dijkstra","binary search"],"title":"1631.Path With Minimum Effort (Medium)","uri":"/1631.path-with-minimum-effort/#code"},{"categories":["leetcode"],"content":" 1 问题描述1631. 最小体力消耗路径 (Medium) 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上， 下， 左， 右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。 一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。 请你返回从左上角走到右下角的最小 体力消耗值 。 示例 1： text 输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。 示例 2： text 输入：heights = [[1,2,3],[3,8,4],[5,3,5]] 输出：1 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3： text 输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]] 输出：0 解释：上图所示路径不需要消耗任何体力。 提示： rows == heights.length columns == heights[i].length 1 \u003c= rows, columns \u003c= 100 1 \u003c= heights[i][j] \u003c= 10⁶ ","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort.zh/:1:0","series":null,"tags":["dijkstra","binary search"],"title":"1631.最小体力消耗路径 (Medium)","uri":"/1631.path-with-minimum-effort.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort.zh/:2:0","series":null,"tags":["dijkstra","binary search"],"title":"1631.最小体力消耗路径 (Medium)","uri":"/1631.path-with-minimum-effort.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 Dijkstra算法可以使用Dijkstra算法来求解，使用小顶堆。 常规的的Dijkstra算法，一般是pq.push({idx, len + len[idx]})，这里则是pq.push({idx, std::max(len, len[idx])})。 ","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort.zh/:2:1","series":null,"tags":["dijkstra","binary search"],"title":"1631.最小体力消耗路径 (Medium)","uri":"/1631.path-with-minimum-effort.zh/#dijkstra算法"},{"categories":["leetcode"],"content":" 2.2 二分二分答案+广度优先搜索 ","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort.zh/:2:2","series":null,"tags":["dijkstra","binary search"],"title":"1631.最小体力消耗路径 (Medium)","uri":"/1631.path-with-minimum-effort.zh/#二分"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort.zh/:3:0","series":null,"tags":["dijkstra","binary search"],"title":"1631.最小体力消耗路径 (Medium)","uri":"/1631.path-with-minimum-effort.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 Dijkstra算法 cpp class Solution { public: int minimumEffortPath(vector\u003cvector\u003cint\u003e\u003e \u0026heights) { int m = heights.size(), n = heights[0].size(); // Dijkstra auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { return v1[2] \u003e v2[2]; }; priority_queue\u003cvector\u003cint\u003e, vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); vector\u003cvector\u003cint\u003e\u003e dis(m, vector\u003cint\u003e(n, -1)); vector\u003cvector\u003cint\u003e\u003e move{{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; pq.push({0, 0, 0}); while (!pq.empty()) { auto vec = pq.top(); pq.pop(); int x = vec[0], y = vec[1], cost = vec[2]; if (dis[x][y] != -1) { continue; } dis[x][y] = cost; for (int i = 0; i \u003c 4; ++i) { int new_x = x + move[i][0]; int new_y = y + move[i][1]; if (new_x \u003e= 0 \u0026\u0026 new_x \u003c m \u0026\u0026 new_y \u003e= 0 \u0026\u0026 new_y \u003c n) { if (dis[new_x][new_y] == -1) { pq.push({new_x, new_y, std::max(cost, abs(heights[x][y] - heights[new_x][new_y]))}); } } } } return dis[m - 1][n - 1]; } }; ","date":"2023-03-16","objectID":"/1631.path-with-minimum-effort.zh/:3:1","series":null,"tags":["dijkstra","binary search"],"title":"1631.最小体力消耗路径 (Medium)","uri":"/1631.path-with-minimum-effort.zh/#dijkstra算法-1"},{"categories":["leetcode"],"content":" 1 Description407. Trapping Rain Water II (Hard) Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining. Example 1: text Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] Output: 4 Explanation: After the rain, water is trapped between the blocks. We have two small ponds 1 and 3 units trapped. The total volume of water trapped is 4. Example 2: text Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] Output: 10 Constraints: m == heightMap.length n == heightMap[i].length 1 \u003c= m, n \u003c= 200 0 \u003c= heightMap[i][j] \u003c= 2 * 10⁴ ","date":"2023-03-15","objectID":"/407.trapping-rain-water-ii/:1:0","series":null,"tags":["dijkstra"],"title":"407.Trapping Rain Water II (Hard)","uri":"/407.trapping-rain-water-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use the Dijkstra algorithm to find the maximum height $h_xy$ in the path from the point $(x, y)$ in the edge to the point $(i, j)$. The volume of water of each cell is $\\min(h_{x, y})^{i, j} - heightMap[i][j]$ ","date":"2023-03-15","objectID":"/407.trapping-rain-water-ii/:2:0","series":null,"tags":["dijkstra"],"title":"407.Trapping Rain Water II (Hard)","uri":"/407.trapping-rain-water-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int trapRainWater(vector\u003cvector\u003cint\u003e\u003e \u0026heightMap) { int m = heightMap.size(); int n = heightMap[0].size(); auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { return v1[2] \u003e v2[2]; }; priority_queue\u003cvector\u003cint\u003e, vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); for (int i = 0; i \u003c n; ++i) { pq.push({0, i, heightMap[0][i]}); pq.push({m - 1, i, heightMap[m - 1][i]}); } for (int i = 1; i \u003c m - 1; ++i) { pq.push({i, 0, heightMap[i][0]}); pq.push({i, n - 1, heightMap[i][n - 1]}); } vector\u003cvector\u003cint\u003e\u003e dis(m, vector\u003cint\u003e(n)); vector\u003cvector\u003cint\u003e\u003e vis(m, vector\u003cint\u003e(n)); vector\u003cvector\u003cint\u003e\u003e neighbor{{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; while (!pq.empty()) { auto vec = pq.top(); int x = vec[0], y = vec[1], height = vec[2]; pq.pop(); if (vis[x][y] != 0) { continue; } vis[x][y] = 1; dis[x][y] = height; for (int i = 0; i \u003c 4; ++i) { int new_x = x + neighbor[i][0]; int new_y = y + neighbor[i][1]; if (new_x \u003c m \u0026\u0026 new_x \u003e= 0 \u0026\u0026 new_y \u003c n \u0026\u0026 new_y \u003e= 0) { pq.push({new_x, new_y, std::max(height, heightMap[new_x][new_y])}); } } } int res = 0; for (int i = 1; i \u003c m - 1; ++i) { for (int j = 1; j \u003c n - 1; ++j) { res += dis[i][j] - heightMap[i][j]; } } return res; } }; ","date":"2023-03-15","objectID":"/407.trapping-rain-water-ii/:3:0","series":null,"tags":["dijkstra"],"title":"407.Trapping Rain Water II (Hard)","uri":"/407.trapping-rain-water-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述407. 接雨水 II (Hard) 给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。 示例 1: text 输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] 输出: 4 解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。 示例 2: text 输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] 输出: 10 提示: m == heightMap.length n == heightMap[i].length 1 \u003c= m, n \u003c= 200 0 \u003c= heightMap[i][j] \u003c= 2 * 10⁴ ","date":"2023-03-15","objectID":"/407.trapping-rain-water-ii.zh/:1:0","series":null,"tags":["dijkstra"],"title":"407.接雨水 II (Hard)","uri":"/407.trapping-rain-water-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路设方格$(i, j)$到边界上的点$(x, y)$的路径的最大高度为$h_{x,y}$，那么方格$(i, j)$所能存放的雨水就是$h_xy$的最小值减去height[i][j]； $h_{x,y}$也可以转化成边界上的点$(x, y)$到方格$(i, j)$的路径的上的方格的最大高度，那么就可以使用Dijkstra算法来解决，初始时将边界上所有的点都加入优先队列中，即可求边界上所有方格到$(i, j)$的最大高度的最小值，还是使用小顶堆。 ","date":"2023-03-15","objectID":"/407.trapping-rain-water-ii.zh/:2:0","series":null,"tags":["dijkstra"],"title":"407.接雨水 II (Hard)","uri":"/407.trapping-rain-water-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int trapRainWater(vector\u003cvector\u003cint\u003e\u003e \u0026heightMap) { // 找边界上所有点，到x,y的路径上的最大高度的最小值（不包括x,y） // (x,y)处的存放的雨水即这个高度h-heightMap[x][y]; int m = heightMap.size(); int n = heightMap[0].size(); auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { return v1[2] \u003e v2[2]; }; priority_queue\u003cvector\u003cint\u003e, vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); for (int i = 0; i \u003c n; ++i) { pq.push({0, i, heightMap[0][i]}); pq.push({m - 1, i, heightMap[m - 1][i]}); } for (int i = 1; i \u003c m - 1; ++i) { pq.push({i, 0, heightMap[i][0]}); pq.push({i, n - 1, heightMap[i][n - 1]}); } vector\u003cvector\u003cint\u003e\u003e dis(m, vector\u003cint\u003e(n)); vector\u003cvector\u003cint\u003e\u003e vis(m, vector\u003cint\u003e(n)); vector\u003cvector\u003cint\u003e\u003e neighbor{{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; while (!pq.empty()) { auto vec = pq.top(); int x = vec[0], y = vec[1], height = vec[2]; pq.pop(); if (vis[x][y] != 0) { continue; } vis[x][y] = 1; dis[x][y] = height; for (int i = 0; i \u003c 4; ++i) { int new_x = x + neighbor[i][0]; int new_y = y + neighbor[i][1]; if (new_x \u003c m \u0026\u0026 new_x \u003e= 0 \u0026\u0026 new_y \u003c n \u0026\u0026 new_y \u003e= 0) { pq.push({new_x, new_y, std::max(height, heightMap[new_x][new_y])}); } } } int res = 0; for (int i = 1; i \u003c m - 1; ++i) { for (int j = 1; j \u003c n - 1; ++j) { res += dis[i][j] - heightMap[i][j]; } } return res; } }; ","date":"2023-03-15","objectID":"/407.trapping-rain-water-ii.zh/:3:0","series":null,"tags":["dijkstra"],"title":"407.接雨水 II (Hard)","uri":"/407.trapping-rain-water-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1615. Maximal Network Rank (Medium) There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [aᵢ, bᵢ] indicates that there is a bidirectional road between cities aᵢ and bᵢ. The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once. The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities. Given the integer n and the array roads, return the maximal network rank of the entire infrastructure. Example 1: text Input: n = 4, roads = [[0,1],[0,3],[1,2],[1,3]] Output: 4 Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once. Example 2: text Input: n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] Output: 5 Explanation: There are 5 roads that are connected to cities 1 or 2. Example 3: text Input: n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] Output: 5 Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected. Constraints: 2 \u003c= n \u003c= 100 0 \u003c= roads.length \u003c= n * (n - 1) / 2 roads[i].length == 2 0 \u003c= aᵢ, bᵢ \u003c= n-1 aᵢ != bᵢ Each pair of cities has at most one road connecting them. ","date":"2023-03-15","objectID":"/1615.maximal-network-rank/:1:0","series":null,"tags":["graph"],"title":"1615.Maximal Network Rank (Medium)","uri":"/1615.maximal-network-rank/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use a adjacent matrix to store the graph, to determine whether two points are connected directly. When creating the adjacent matrix, we need to record the number of points which are directly connected with the current point. And then traverse the points. ","date":"2023-03-15","objectID":"/1615.maximal-network-rank/:2:0","series":null,"tags":["graph"],"title":"1615.Maximal Network Rank (Medium)","uri":"/1615.maximal-network-rank/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maximalNetworkRank(int n, vector\u003cvector\u003cint\u003e\u003e \u0026roads) { vector\u003cvector\u003cint\u003e\u003e graph(n, vector\u003cint\u003e(n)); vector\u003cint\u003e cnt(n); for (auto \u0026vec : roads) { graph[vec[0]][vec[1]] = 1; cnt[vec[0]]++; graph[vec[1]][vec[0]] = 1; cnt[vec[1]]++; } int num = 0; for (int i = 0; i \u003c n - 1; ++i) { for (int j = i + 1; j \u003c n; ++j) { if (graph[i][j] == 1) { num = std::max(num, cnt[i] + cnt[j] - 1); } else { num = std::max(num, cnt[i] + cnt[j]); } } } return num; } }; ","date":"2023-03-15","objectID":"/1615.maximal-network-rank/:3:0","series":null,"tags":["graph"],"title":"1615.Maximal Network Rank (Medium)","uri":"/1615.maximal-network-rank/#code"},{"categories":["leetcode"],"content":" 1 问题描述1615. 最大网络秩 (Medium) n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [aᵢ, bᵢ] 都表示在城市 aᵢ 和 bᵢ 之间有一条双向道路。 两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。 整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。 给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。 示例 1： text 输入：n = 4, roads = [[0,1],[0,3],[1,2],[1,3]] 输出：4 解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。 示例 2： text 输入：n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] 输出：5 解释：共有 5 条道路与城市 1 或 2 相连。 示例 3： text 输入：n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] 输出：5 解释：2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。 提示： 2 \u003c= n \u003c= 100 0 \u003c= roads.length \u003c= n * (n - 1) / 2 roads[i].length == 2 0 \u003c= aᵢ, bᵢ \u003c= n-1 aᵢ != bᵢ 每对城市之间 最多只有一条 道路相连 ","date":"2023-03-15","objectID":"/1615.maximal-network-rank.zh/:1:0","series":null,"tags":["graph"],"title":"1615.最大网络秩 (Medium)","uri":"/1615.maximal-network-rank.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用邻接矩阵存图，来判断两点之间是否相连，建立邻接矩阵的时候记录与当前点直接相连的点的数量，然后遍历点集。 ","date":"2023-03-15","objectID":"/1615.maximal-network-rank.zh/:2:0","series":null,"tags":["graph"],"title":"1615.最大网络秩 (Medium)","uri":"/1615.maximal-network-rank.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maximalNetworkRank(int n, vector\u003cvector\u003cint\u003e\u003e \u0026roads) { vector\u003cvector\u003cint\u003e\u003e graph(n, vector\u003cint\u003e(n)); vector\u003cint\u003e cnt(n); // 统计每个点有多少个点与它相连 for (auto \u0026vec : roads) { graph[vec[0]][vec[1]] = 1; cnt[vec[0]]++; graph[vec[1]][vec[0]] = 1; cnt[vec[1]]++; } int num = 0; for (int i = 0; i \u003c n - 1; ++i) { for (int j = i + 1; j \u003c n; ++j) { if (graph[i][j] == 1) { num = std::max(num, cnt[i] + cnt[j] - 1); } else { num = std::max(num, cnt[i] + cnt[j]); } } } return num; } }; ","date":"2023-03-15","objectID":"/1615.maximal-network-rank.zh/:3:0","series":null,"tags":["graph"],"title":"1615.最大网络秩 (Medium)","uri":"/1615.maximal-network-rank.zh/#代码"},{"categories":["notes"],"content":" 1 问题描述C++在使用模板(template)类的时候，如果将类的成员函数的声明和实现分别放在.h头文件和.cpp源文件中，编译时会报错undefined reference xxx，找不到对应成员函数。 ","date":"2023-03-14","objectID":"/cpp_templdate_undefined.zh/:1:0","series":null,"tags":["cpp"],"title":"C++ 模板类编译过程中出现“undefined reference to”问题","uri":"/cpp_templdate_undefined.zh/#问题描述"},{"categories":["notes"],"content":" 2 起因.h文件中类的声明为： cpp // 线程池，定义成模板类，为了代码的复用 template \u003ctypename T\u003e class ThreadPool { ... public: bool append(T *request); ... }; .cpp文件中成员函数的实现为： cpp template \u003ctypename T\u003e bool ThreadPool\u003cT\u003e::append(T *request) { // 操作工作队列时一定要加锁，因为它被所有线程共享 queue_locker_.lock(); if (work_queue_.size() \u003e max_requests_) { queue_locker_.unlock(); return false; } work_queue_.push_back(request); queue_locker_.unlock(); queue_sta_.post(); return true; } 直接使用g++编译，会报错： ","date":"2023-03-14","objectID":"/cpp_templdate_undefined.zh/:2:0","series":null,"tags":["cpp"],"title":"C++ 模板类编译过程中出现“undefined reference to”问题","uri":"/cpp_templdate_undefined.zh/#起因"},{"categories":["notes"],"content":" 3 原因分析template其实是一种类似语法糖的东西，C++中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道，模板类中使用模板类型的对象的所占用的空间的大小的。只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。这也就是模板类为什么只是称之为模板，而不是泛型的缘故。 即ThreadPool\u003cint\u003e和Thread\u003cHttpConn\u003e是两个不同的类型，其成员函数也是两个不同的成员函数。 在编译thread_pool.cpp时，编译器会去查找对类Thread\u003cHttpConn\u003e的声明，如果找不到这个声明，那么就报错了。 ","date":"2023-03-14","objectID":"/cpp_templdate_undefined.zh/:3:0","series":null,"tags":["cpp"],"title":"C++ 模板类编译过程中出现“undefined reference to”问题","uri":"/cpp_templdate_undefined.zh/#原因分析"},{"categories":["notes"],"content":" 4 解决方案在成员函数的实现的代码所在的源文件的开头，声明该类，即添加： cpp template class ThreadPool\u003cHttpConn\u003e; 或者将函数的实现也写在头文件中（不推荐）。 ","date":"2023-03-14","objectID":"/cpp_templdate_undefined.zh/:4:0","series":null,"tags":["cpp"],"title":"C++ 模板类编译过程中出现“undefined reference to”问题","uri":"/cpp_templdate_undefined.zh/#解决方案"},{"categories":["tutorial"],"content":" 1 ssh配置免密码登录服务器","date":"2023-03-14","objectID":"/ssh_tips.zh/:1:0","series":null,"tags":["geek","ssh"],"title":"ssh 简单教程","uri":"/ssh_tips.zh/#ssh配置免密码登录服务器"},{"categories":["tutorial"],"content":" 1.1 生成密钥对执行ssh-keygen -t ed25519 -C \"zwyyy456@hotmail.com\"以生成密钥对，存放在~/.ssh文件夹下，id_ed25519.pub为公钥，id_ed25519为私钥。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:1:1","series":null,"tags":["geek","ssh"],"title":"ssh 简单教程","uri":"/ssh_tips.zh/#生成密钥对"},{"categories":["tutorial"],"content":" 1.2 上传公钥到服务器这里以我的N1为例，执行ssh-copy-id -i ~/.ssh/id_ed25519.pub root@192.168.6.217和ssh-copy-id -i ~/.ssh/id_ed25519.pub zwyyy@192.168.6.217，将公钥上传到服务器，root和zwyyy分别是两个用户。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:1:2","series":null,"tags":["geek","ssh"],"title":"ssh 简单教程","uri":"/ssh_tips.zh/#上传公钥到服务器"},{"categories":["tutorial"],"content":" 2 配置局域网ssh连接到wsl","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:0","series":null,"tags":["geek","ssh"],"title":"ssh 简单教程","uri":"/ssh_tips.zh/#配置局域网ssh连接到wsl"},{"categories":["tutorial"],"content":" 2.1 hyper-v创建虚拟交换机打开hyper-v管理器，选择虚拟交换机管理器，选择创建外部类型的虚拟交换机，这里命名为wsl_ssh。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:1","series":null,"tags":["geek","ssh"],"title":"ssh 简单教程","uri":"/ssh_tips.zh/#hyper-v创建虚拟交换机"},{"categories":["tutorial"],"content":" 2.2 win11上新建wsl配置文件 sh cd ~ New-Item .wslconfig nvim .wslconfig 修改配置文件内容为 toml [wsl2] networkingMode=bridged vmSwitch=wsl_ssh # 这里为你创建的虚拟交换机名称 ipv6=true 之后执行wsl --shutdown再启动wsl，就会发现ip地址为电脑本身的ip了。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:2","series":null,"tags":["geek","ssh"],"title":"ssh 简单教程","uri":"/ssh_tips.zh/#win11上新建wsl配置文件"},{"categories":["tutorial"],"content":" 2.3 openwrt上固定电脑的ip进入openwrt的管理界面，点击网络-\u003eDHCP/DNS，选择静态地址分配，固定windows笔记本的ip ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:3","series":null,"tags":["geek","ssh"],"title":"ssh 简单教程","uri":"/ssh_tips.zh/#openwrt上固定电脑的ip"},{"categories":["tutorial"],"content":" 2.4 启用wsl上的ssh执行sudo nvim /etc/ssh/sshd_config，将#port 22修改为port 2222，取消注释#PasswordAuthentication yes和#PubekyAuthentcation yes，重启ssh服务，执行sudo service ssh restart。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:4","series":null,"tags":["geek","ssh"],"title":"ssh 简单教程","uri":"/ssh_tips.zh/#启用wsl上的ssh"},{"categories":["tutorial"],"content":" 2.5 win11设置端口转发参照该链接 之后同一局域网的mac执行ssh -p 2222 zwyyy456@192.168.6.209，即可连接到wsl。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:5","series":null,"tags":["geek","ssh"],"title":"ssh 简单教程","uri":"/ssh_tips.zh/#win11设置端口转发"},{"categories":["tutorial"],"content":" 1 ssh配置免密码登录服务器","date":"2023-03-14","objectID":"/ssh_tips.zh/:1:0","series":null,"tags":["geek","ssh"],"title":"ssh简单教程","uri":"/ssh_tips.zh/#ssh配置免密码登录服务器"},{"categories":["tutorial"],"content":" 1.1 生成密钥对执行ssh-keygen -t ed25519 -C \"zwyyy456@hotmail.com\"以生成密钥对，存放在~/.ssh文件夹下，id_ed25519.pub为公钥，id_ed25519为私钥。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:1:1","series":null,"tags":["geek","ssh"],"title":"ssh简单教程","uri":"/ssh_tips.zh/#生成密钥对"},{"categories":["tutorial"],"content":" 1.2 上传公钥到服务器这里以我的N1为例，执行ssh-copy-id -i ~/.ssh/id_ed25519.pub root@192.168.6.217和ssh-copy-id -i ~/.ssh/id_ed25519.pub zwyyy@192.168.6.217，将公钥上传到服务器，root和zwyyy分别是两个用户。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:1:2","series":null,"tags":["geek","ssh"],"title":"ssh简单教程","uri":"/ssh_tips.zh/#上传公钥到服务器"},{"categories":["tutorial"],"content":" 2 配置局域网ssh连接到wsl","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:0","series":null,"tags":["geek","ssh"],"title":"ssh简单教程","uri":"/ssh_tips.zh/#配置局域网ssh连接到wsl"},{"categories":["tutorial"],"content":" 2.1 hyper-v创建虚拟交换机打开hyper-v管理器，选择虚拟交换机管理器，选择创建外部类型的虚拟交换机，这里命名为wsl_ssh。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:1","series":null,"tags":["geek","ssh"],"title":"ssh简单教程","uri":"/ssh_tips.zh/#hyper-v创建虚拟交换机"},{"categories":["tutorial"],"content":" 2.2 win11上新建wsl配置文件 sh cd ~ New-Item .wslconfig nvim .wslconfig 修改配置文件内容为 toml [wsl2] networkingMode=bridged vmSwitch=wsl_ssh # 这里为你创建的虚拟交换机名称 ipv6=true 之后执行wsl --shutdown再启动wsl，就会发现ip地址为电脑本身的ip了。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:2","series":null,"tags":["geek","ssh"],"title":"ssh简单教程","uri":"/ssh_tips.zh/#win11上新建wsl配置文件"},{"categories":["tutorial"],"content":" 2.3 openwrt上固定电脑的ip进入openwrt的管理界面，点击网络-\u003eDHCP/DNS，选择静态地址分配，固定windows笔记本的ip ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:3","series":null,"tags":["geek","ssh"],"title":"ssh简单教程","uri":"/ssh_tips.zh/#openwrt上固定电脑的ip"},{"categories":["tutorial"],"content":" 2.4 启用wsl上的ssh执行sudo nvim /etc/ssh/sshd_config，将#port 22修改为port 2222，取消注释#PasswordAuthentication yes和#PubekyAuthentcation yes，重启ssh服务，执行sudo service ssh restart。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:4","series":null,"tags":["geek","ssh"],"title":"ssh简单教程","uri":"/ssh_tips.zh/#启用wsl上的ssh"},{"categories":["tutorial"],"content":" 2.5 win11设置端口转发参照该链接 之后同一局域网的mac执行ssh -p 2222 zwyyy456@192.168.6.209，即可连接到wsl。 ","date":"2023-03-14","objectID":"/ssh_tips.zh/:2:5","series":null,"tags":["geek","ssh"],"title":"ssh简单教程","uri":"/ssh_tips.zh/#win11设置端口转发"},{"categories":["leetcode"],"content":" 1 Description1976. Number of Ways to Arrive at Destination (Medium) You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections. You are given an integer n and a 2D integer array roads where roads[i] = [uᵢ, vᵢ, timeᵢ] means that there is a road between intersections uᵢ and vᵢ that takes timeᵢ minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time. Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 10⁹ + 7. Example 1: text Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]] Output: 4 Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes. The four ways to get there in 7 minutes are: - 0 ➝ 6 - 0 ➝ 4 ➝ 6 - 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6 - 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6 Example 2: text Input: n = 2, roads = [[1,0,10]] Output: 1 Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes. Constraints: 1 \u003c= n \u003c= 200 n - 1 \u003c= roads.length \u003c= n * (n - 1) / 2 roads[i].length == 3 0 \u003c= uᵢ, vᵢ \u003c= n - 1 1 \u003c= timeᵢ \u003c= 10⁹ uᵢ != vᵢ There is at most one road connecting any two intersections. You can reach any intersection from any other intersection. ","date":"2023-03-14","objectID":"/1976.number-of-ways-to-arrive-at-destination/:1:0","series":null,"tags":["dijkstra","memorized search"],"title":"1976.Number of Ways to Arrive at Destination (Medium)","uri":"/1976.number-of-ways-to-arrive-at-destination/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirst, we can use the Dijkstra algorithm to find the minimum distance from $n-1$ to each point, and then use memorized search to find the answer. If the distance of any two neighboring points is the minimum, then the distance of the path is the minimum. ","date":"2023-03-14","objectID":"/1976.number-of-ways-to-arrive-at-destination/:2:0","series":null,"tags":["dijkstra","memorized search"],"title":"1976.Number of Ways to Arrive at Destination (Medium)","uri":"/1976.number-of-ways-to-arrive-at-destination/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int mod = 1000000007; void Dijkstra(vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, vector\u003clong\u003e \u0026dis, int start_idx, vector\u003cint\u003e \u0026is_min) { auto cmp = [\u0026](pair\u003cint, long\u003e \u0026p1, pair\u003cint, long\u003e \u0026p2) { return p1.second \u003e p2.second; }; priority_queue\u003cpair\u003cint, long\u003e, vector\u003cpair\u003cint, long\u003e\u003e, decltype(cmp)\u003e pq(cmp); pq.push({start_idx, 0}); while (!pq.empty()) { auto [idx, len] = pq.top(); pq.pop(); if (is_min[idx] == 1) { continue; } dis[idx] = len; // update the minimum distance is_min[idx] = 1; // the minimum distance is found for (auto \u0026vec : graph[idx]) { if (is_min[vec[0]] == 0) { pq.push({vec[0], len + vec[1]}); } } } } int dfs(vector\u003cint\u003e \u0026used, vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, int idx, vector\u003clong\u003e \u0026disn, vector\u003cint\u003e \u0026cach) { if (idx == 0) { return 1; } if (cach[idx] != -1) { return cach[idx]; } int res = 0; for (auto \u0026vec : graph[idx]) { // if (dis0[vec[0]] + disn[vec[0]] == disn[0] \u0026\u0026 dis0[idx] \u003e dis0[vec[0]] \u0026\u0026 vec[1] + disn[idx] == disn[vec[0]]) { if (vec[1] + disn[idx] == disn[vec[0]]) { res = (res + dfs(used, graph, vec[0], disn, cach)) % mod; } } cach[idx] = res; return cach[idx]; } int countPaths(int n, vector\u003cvector\u003cint\u003e\u003e \u0026roads) { vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n); for (auto \u0026road : roads) { graph[road[0]].push_back({road[1], road[2]}); graph[road[1]].push_back({road[0], road[2]}); } vector\u003clong\u003e disn(n); vector\u003cint\u003e is_minn(n); // Dijkstra(graph, dis0, 0, is_min0); Dijkstra(graph, disn, n - 1, is_minn); vector\u003cint\u003e used(n); vector\u003cint\u003e cach(n, -1); return dfs(used, graph, n - 1, disn, cach); } }; ","date":"2023-03-14","objectID":"/1976.number-of-ways-to-arrive-at-destination/:3:0","series":null,"tags":["dijkstra","memorized search"],"title":"1976.Number of Ways to Arrive at Destination (Medium)","uri":"/1976.number-of-ways-to-arrive-at-destination/#code"},{"categories":["leetcode"],"content":" 1 问题描述1976. 到达目的地的方案数 (Medium) 你在一个城市里，城市由 n 个路口组成，路口编号为 0 到 n - 1 ，某些路口之间有 双向 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。 给你一个整数 n 和二维整数数组 roads ，其中 roads[i] = [uᵢ, vᵢ, timeᵢ] 表示在路口 uᵢ 和 vᵢ 之间有一条需要花费 timeᵢ 时间才能通过的道路。你想知道花费 最少时间 从路口 0 出发到达路口 n - 1 的方案数。 请返回花费 最少时间 到达目的地的 路径数目 。由于答案可能很大，将结果对 10⁹ + 7 取余 后返回。 示例 1： text 输入：n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]] 输出：4 解释：从路口 0 出发到路口 6 花费的最少时间是 7 分钟。 四条花费 7 分钟的路径分别为： - 0 ➝ 6 - 0 ➝ 4 ➝ 6 - 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6 - 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6 示例 2： text 输入：n = 2, roads = [[1,0,10]] 输出：1 解释：只有一条从路口 0 到路口 1 的路，花费 10 分钟。 提示： 1 \u003c= n \u003c= 200 n - 1 \u003c= roads.length \u003c= n * (n - 1) / 2 roads[i].length == 3 0 \u003c= uᵢ, vᵢ \u003c= n - 1 1 \u003c= timeᵢ \u003c= 10⁹ uᵢ != vᵢ 任意两个路口之间至多有一条路。 从任意路口出发，你能够到达其他任意路口。 ","date":"2023-03-14","objectID":"/1976.number-of-ways-to-arrive-at-destination.zh/:1:0","series":null,"tags":["dijkstra","memorized search"],"title":"1976.到达目的地的方案数 (Medium)","uri":"/1976.number-of-ways-to-arrive-at-destination.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，利用Dijkstra算法求得点$n-1$到各点的最短距离，然后使用记忆化搜索来计算路径数量； 由于路径数限制需要花费最短时间，那么经过中间的点花费的时间也一定是最短的，最短路径上相邻两点之间的距离也一定是最短的，反过来也成立，路径上相邻两点之间的距离都是最短的，那么最终路径所花的时间也是最短的。 ","date":"2023-03-14","objectID":"/1976.number-of-ways-to-arrive-at-destination.zh/:2:0","series":null,"tags":["dijkstra","memorized search"],"title":"1976.到达目的地的方案数 (Medium)","uri":"/1976.number-of-ways-to-arrive-at-destination.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int mod = 1000000007; void Dijkstra(vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, vector\u003clong\u003e \u0026dis, int start_idx, vector\u003cint\u003e \u0026is_min) { auto cmp = [\u0026](pair\u003cint, long\u003e \u0026p1, pair\u003cint, long\u003e \u0026p2) { return p1.second \u003e p2.second; }; priority_queue\u003cpair\u003cint, long\u003e, vector\u003cpair\u003cint, long\u003e\u003e, decltype(cmp)\u003e pq(cmp); pq.push({start_idx, 0}); while (!pq.empty()) { auto [idx, len] = pq.top(); pq.pop(); if (is_min[idx] == 1) { continue; } dis[idx] = len; // 更新最短路 is_min[idx] = 1; // 已找到最短路 for (auto \u0026vec : graph[idx]) { if (is_min[vec[0]] == 0) { pq.push({vec[0], len + vec[1]}); } } } } int dfs(vector\u003cint\u003e \u0026used, vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, int idx, vector\u003clong\u003e \u0026disn, vector\u003cint\u003e \u0026cach) { if (idx == 0) { return 1; } if (cach[idx] != -1) { return cach[idx]; } int res = 0; for (auto \u0026vec : graph[idx]) { // 这个条件判断是关键，第一个表示下一个点也是最短的（可以忽略），第二个表示不会走回路，第三个表示每次走最短路径 // if (dis0[vec[0]] + disn[vec[0]] == disn[0] \u0026\u0026 dis0[idx] \u003e dis0[vec[0]] \u0026\u0026 vec[1] + disn[idx] == disn[vec[0]]) { if (vec[1] + disn[idx] == disn[vec[0]]) { res = (res + dfs(used, graph, vec[0], disn, cach)) % mod; } } cach[idx] = res; return cach[idx]; } int countPaths(int n, vector\u003cvector\u003cint\u003e\u003e \u0026roads) { vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n); for (auto \u0026road : roads) { graph[road[0]].push_back({road[1], road[2]}); graph[road[1]].push_back({road[0], road[2]}); } vector\u003clong\u003e disn(n); // 用于存储从n - 1开始的最短路径 vector\u003cint\u003e is_minn(n); // 表示是否已经找到最短路径 // Dijkstra(graph, dis0, 0, is_min0); Dijkstra(graph, disn, n - 1, is_minn); vector\u003cint\u003e used(n); vector\u003cint\u003e cach(n, -1); return dfs(used, graph, n - 1, disn, cach); } }; ","date":"2023-03-14","objectID":"/1976.number-of-ways-to-arrive-at-destination.zh/:3:0","series":null,"tags":["dijkstra","memorized search"],"title":"1976.到达目的地的方案数 (Medium)","uri":"/1976.number-of-ways-to-arrive-at-destination.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description787. Cheapest Flights Within K Stops (Medium) There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromᵢ, toᵢ, priceᵢ] indicates that there is a flight from city fromᵢ to city toᵢ with cost priceᵢ. You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1. Example 1: text Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1 Output: 700 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700. Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops. Example 2: text Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1 Output: 200 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200. Example 3: text Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0 Output: 500 Explanation: The graph is shown above. The optimal path with no stops from city 0 to 2 is marked in red and has cost 500. Constraints: 1 \u003c= n \u003c= 100 0 \u003c= flights.length \u003c= (n * (n - 1) / 2) flights[i].length == 3 0 \u003c= fromᵢ, toᵢ \u003c n fromᵢ != toᵢ 1 \u003c= priceᵢ \u003c= 10⁴ There will not be any multiple flights between two cities. 0 \u003c= src, dst, k \u003c n src != dst ","date":"2023-03-13","objectID":"/787.cheapest-flights-within-k-stops/:1:0","series":null,"tags":["memorized search","graph"],"title":"787.Cheapest Flights Within K Stops (Medium)","uri":"/787.cheapest-flights-within-k-stops/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use an adjacent table to store the graph, and then use memorized search. We only need consider the current node and the number of nodes that are passed through. If we are at the cntth node, then dfs(cnt, src) = min(INT_MAX, dfs(cnt + 1, new_src)). ","date":"2023-03-13","objectID":"/787.cheapest-flights-within-k-stops/:2:0","series":null,"tags":["memorized search","graph"],"title":"787.Cheapest Flights Within K Stops (Medium)","uri":"/787.cheapest-flights-within-k-stops/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: const int ubd = 20000000; int dfs(int cnt, vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, int src, int dst, int k, vector\u003cvector\u003cint\u003e\u003e \u0026cach) { if (cnt \u003e k + 1) { return ubd; } if (src == dst) { return 0; } if (cach[cnt][src] \u003e= 0) { return cach[cnt][src]; } int res = ubd; for (auto \u0026vec : graph[src]) { res = std::min(res, vec[1] + dfs(cnt + 1, graph, vec[0], dst, k, cach)); } cach[cnt][src] = res; return cach[cnt][src]; } int findCheapestPrice(int n, vector\u003cvector\u003cint\u003e\u003e \u0026flights, int src, int dst, int k) { vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n + 1); for (auto \u0026time : flights) { graph[time[0]].push_back({time[1], time[2]}); // graph[time[1]].push_back({time[0], time[2]}); } vector\u003cvector\u003cint\u003e\u003e cach(k + 3, vector\u003cint\u003e(n, -1)); int res = dfs(0, graph, src, dst, k, cach); if (res \u003e= ubd) { return -1; } return res; } }; ","date":"2023-03-13","objectID":"/787.cheapest-flights-within-k-stops/:3:0","series":null,"tags":["memorized search","graph"],"title":"787.Cheapest Flights Within K Stops (Medium)","uri":"/787.cheapest-flights-within-k-stops/#code"},{"categories":["leetcode"],"content":" 1 问题描述787. K 站中转内最便宜的航班 (Medium) 有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromᵢ, toᵢ, priceᵢ] ，表示该航班都从城市 fromᵢ 开始，以价格 priceᵢ 抵达 toᵢ。 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。 示例 1： text 输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 输出: 200 解释: 城市航班图如下 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 示例 2： text 输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 输出: 500 解释: 城市航班图如下 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。 提示： 1 \u003c= n \u003c= 100 0 \u003c= flights.length \u003c= (n * (n - 1) / 2) flights[i].length == 3 0 \u003c= fromᵢ, toᵢ \u003c n fromᵢ != toᵢ 1 \u003c= priceᵢ \u003c= 10⁴ 航班没有重复，且不存在自环 0 \u003c= src, dst, k \u003c n src != dst ","date":"2023-03-13","objectID":"/787.cheapest-flights-within-k-stops.zh/:1:0","series":null,"tags":["memorized search","graph"],"title":"787.K 站中转内最便宜的航班 (Medium)","uri":"/787.cheapest-flights-within-k-stops.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路邻接表存储图，然后使用记忆化搜索。 我们只需要关注当前是第多少个点（不能超过k + 1），假设是第cnt个点，那么dfs(cnt, src) = min(INT_MAX, dfs(cnt + 1, new_src))，其中new_src是以当前点为弧尾的所有点。 ","date":"2023-03-13","objectID":"/787.cheapest-flights-within-k-stops.zh/:2:0","series":null,"tags":["memorized search","graph"],"title":"787.K 站中转内最便宜的航班 (Medium)","uri":"/787.cheapest-flights-within-k-stops.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: const int ubd = 20000000; int dfs(int cnt, vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, int src, int dst, int k, vector\u003cvector\u003cint\u003e\u003e \u0026cach) { if (cnt \u003e k + 1) { return ubd; } if (src == dst) { return 0; } if (cach[cnt][src] \u003e= 0) { return cach[cnt][src]; } int res = ubd; for (auto \u0026vec : graph[src]) { res = std::min(res, vec[1] + dfs(cnt + 1, graph, vec[0], dst, k, cach)); } cach[cnt][src] = res; return cach[cnt][src]; } int findCheapestPrice(int n, vector\u003cvector\u003cint\u003e\u003e \u0026flights, int src, int dst, int k) { vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n + 1); for (auto \u0026time : flights) { graph[time[0]].push_back({time[1], time[2]}); // graph[time[1]].push_back({time[0], time[2]}); } vector\u003cvector\u003cint\u003e\u003e cach(k + 3, vector\u003cint\u003e(n, -1)); int res = dfs(0, graph, src, dst, k, cach); if (res \u003e= ubd) { return -1; } return res; } }; ","date":"2023-03-13","objectID":"/787.cheapest-flights-within-k-stops.zh/:3:0","series":null,"tags":["memorized search","graph"],"title":"787.K 站中转内最便宜的航班 (Medium)","uri":"/787.cheapest-flights-within-k-stops.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description Number of Restricted Paths From First to Last Node (Medium) There is an undirected weighted connected graph. You are given a positive integer n which denotes that the graph has n nodes labeled from 1 to n, and an array edges where each edges[i] = [uᵢ, vᵢ, weightᵢ] denotes that there is an edge between nodes uᵢ and vᵢ with weight equal to weightᵢ. A path from node start to node end is a sequence of nodes [z₀, z₁,z₂, ..., zₖ] such that z₀ = start and zₖ = end and there is an edge between zᵢ and zᵢ+₁ where 0 \u003c= i \u003c= k-1. The distance of a path is the sum of the weights on the edges of the path. Let distanceToLastNode(x) denote the shortest distance of a path between node n and node x. A restricted path is a path that also satisfies that distanceToLastNode(zᵢ) \u003e distanceToLastNode(zᵢ+₁) where 0 \u003c= i \u003c= k-1. Return the number of restricted paths from node 1to node n. Since that number may be too large, return it modulo 10⁹ + 7. Example 1: text Input: n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]] Output: 3 Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The three restricted paths are: 1) 1 --\u003e 2 --\u003e 5 2) 1 --\u003e 2 --\u003e 3 --\u003e 5 3) 1 --\u003e 3 --\u003e 5 Example 2: text Input: n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]] Output: 1 Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The only restricted path is 1 --\u003e 3 --\u003e 7. Constraints: 1 \u003c= n \u003c= 2 * 10⁴ n - 1 \u003c= edges.length \u003c= 4 * 10⁴ edges[i].length == 3 1 \u003c= uᵢ, vᵢ \u003c= n uᵢ != vᵢ 1 \u003c= weightᵢ \u003c= 10⁵ There is at most one edge between any two nodes. There is at least one path between any two nodes. ","date":"2023-03-13","objectID":"/1786.number-of-restricted-paths-from-first-to-last-node/:1:0","series":null,"tags":["dijkstra","memorized search"],"title":"1786.Number of Restricted Paths From First to Last Node (Medium)","uri":"/1786.number-of-restricted-paths-from-first-to-last-node/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirst, we use Dijkstra algorithm to get the minimum distance from each point to n. When creating an adjacent table, note that the graph is an undirected graph, so: cpp vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n + 1); for (auto \u0026vec : edges) { graph[vec[0]].push_back({vec[1], vec[2]}); graph[vec[1]].push_back({vec[0], vec[2]}); } Then we can use memorized search to solve the problem. ","date":"2023-03-13","objectID":"/1786.number-of-restricted-paths-from-first-to-last-node/:2:0","series":null,"tags":["dijkstra","memorized search"],"title":"1786.Number of Restricted Paths From First to Last Node (Medium)","uri":"/1786.number-of-restricted-paths-from-first-to-last-node/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int mod = 1000000007; void Dijkstra(vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, int n, vector\u003cint\u003e \u0026dis, vector\u003cint\u003e \u0026is_min) { auto cmp = [\u0026](pair\u003cint, int\u003e \u0026p1, pair\u003cint, int\u003e \u0026p2) { return p1.second \u003e p2.second; }; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq(cmp); pq.push({n, 0}); while (!pq.empty()) { auto [idx, len] = pq.top(); // cout \u003c\u003c idx \u003c\u003c \" \" \u003c\u003c len \u003c\u003c endl; pq.pop(); if (is_min[idx] == 1) { continue; } is_min[idx] = 1; dis[idx] = len; for (auto \u0026tmp : graph[idx]) { if (is_min[tmp[0]] == 0) { pq.push({tmp[0], len + tmp[1]}); } } } } int dfs(int idx, vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, int n, vector\u003cint\u003e \u0026dis, vector\u003cint\u003e \u0026is_min, vector\u003cint\u003e \u0026cach) { if (idx == n) { return 1; } if (cach[idx] != -1) { return cach[idx]; } int res = 0; for (auto \u0026vec : graph[idx]) { if (is_min[idx] == 1 \u0026\u0026 dis[idx] \u003e dis[vec[0]]) { res = (res + dfs(vec[0], graph, n, dis, is_min, cach)) % mod; } } cach[idx] = res; return cach[idx]; } int countRestrictedPaths(int n, vector\u003cvector\u003cint\u003e\u003e \u0026edges) { vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n + 1); for (auto \u0026vec : edges) { graph[vec[0]].push_back({vec[1], vec[2]}); graph[vec[1]].push_back({vec[0], vec[2]}); } vector\u003cint\u003e dis(n + 1); vector\u003cint\u003e is_min(n + 1); vector\u003cint\u003e cach(n + 1, -1); Dijkstra(graph, n, dis, is_min); return dfs(1, graph, n, dis, is_min, cach); } }; ","date":"2023-03-13","objectID":"/1786.number-of-restricted-paths-from-first-to-last-node/:3:0","series":null,"tags":["dijkstra","memorized search"],"title":"1786.Number of Restricted Paths From First to Last Node (Medium)","uri":"/1786.number-of-restricted-paths-from-first-to-last-node/#code"},{"categories":["leetcode"],"content":" 1 问题描述1786. 从第一个节点出发到最后一个节点的受限路径数 (Medium) 现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [uᵢ, vᵢ, weightᵢ] 表示存在一条位于节点 uᵢ 和 vᵢ 之间的边，这条边的权重为 weightᵢ 。 从节点 start 出发到节点 end 的路径是一个形如 [z₀, z₁,z₂, ..., zₖ] 的节点序列，满足 z₀ = start 、 zₖ = end 且在所有符合 0 \u003c= i \u003c= k-1 的节点 zᵢ 和 zᵢ+₁ 之间存在一条边。 路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。 受限路径 为满足 distanceToLastNode(zᵢ) \u003e distanceToLastNode(zᵢ+₁) 的一条路径，其中 0 \u003c= i \u003c= k-1 。 返回从节点 1 出发到节点 n 的 受限路径数 。由于数字可能很大，请返回对 10⁹ + 7 取余 的结果。 示例 1： text 输入：n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]] 输出：3 解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是： 1) 1 --\u003e 2 --\u003e 5 2) 1 --\u003e 2 --\u003e 3 --\u003e 5 3) 1 --\u003e 3 --\u003e 5 示例 2： text 输入：n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]] 输出：1 解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：1 --\u003e 3 --\u003e 7 。 提示： 1 \u003c= n \u003c= 2 * 10⁴ n - 1 \u003c= edges.length \u003c= 4 * 10⁴ edges[i].length == 3 1 \u003c= uᵢ, vᵢ \u003c= n uᵢ != vᵢ 1 \u003c= weightᵢ \u003c= 10⁵ 任意两个节点之间至多存在一条边 任意两个节点之间至少存在一条路径 ","date":"2023-03-13","objectID":"/1786.number-of-restricted-paths-from-first-to-last-node.zh/:1:0","series":null,"tags":["dijkstra","memorized search"],"title":"1786. 从第一个节点出发到最后一个节点的受限路径数 (Medium)","uri":"/1786.number-of-restricted-paths-from-first-to-last-node.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先利用Dijkstra算法来计算各点到点n的最短距离，建立邻接表的时候，要注意本题的图是无向图，所以应该是： cpp vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n + 1); for (auto \u0026vec : edges) { graph[vec[0]].push_back({vec[1], vec[2]}); graph[vec[1]].push_back({vec[0], vec[2]}); } 得到各点到n的最短距离之后，即可采用记忆化搜索来解决，从点i到点n的路径数即与i相连且满足条件的点到n的路径数之和。 ","date":"2023-03-13","objectID":"/1786.number-of-restricted-paths-from-first-to-last-node.zh/:2:0","series":null,"tags":["dijkstra","memorized search"],"title":"1786. 从第一个节点出发到最后一个节点的受限路径数 (Medium)","uri":"/1786.number-of-restricted-paths-from-first-to-last-node.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int mod = 1000000007; void Dijkstra(vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, int n, vector\u003cint\u003e \u0026dis, vector\u003cint\u003e \u0026is_min) { auto cmp = [\u0026](pair\u003cint, int\u003e \u0026p1, pair\u003cint, int\u003e \u0026p2) { return p1.second \u003e p2.second; }; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq(cmp); pq.push({n, 0}); while (!pq.empty()) { auto [idx, len] = pq.top(); // vec[0]表示坐标，vec[1]表示距离 // cout \u003c\u003c idx \u003c\u003c \" \" \u003c\u003c len \u003c\u003c endl; pq.pop(); if (is_min[idx] == 1) { // 说明已经找到最短路 continue; } is_min[idx] = 1; dis[idx] = len; for (auto \u0026tmp : graph[idx]) { // 遍历已经找到最短路的这个点的相邻边 if (is_min[tmp[0]] == 0) { pq.push({tmp[0], len + tmp[1]}); } } } } int dfs(int idx, vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026graph, int n, vector\u003cint\u003e \u0026dis, vector\u003cint\u003e \u0026is_min, vector\u003cint\u003e \u0026cach) { if (idx == n) { return 1; } if (cach[idx] != -1) { return cach[idx]; } int res = 0; for (auto \u0026vec : graph[idx]) { if (is_min[idx] == 1 \u0026\u0026 dis[idx] \u003e dis[vec[0]]) { res = (res + dfs(vec[0], graph, n, dis, is_min, cach)) % mod; } } cach[idx] = res; return cach[idx]; } int countRestrictedPaths(int n, vector\u003cvector\u003cint\u003e\u003e \u0026edges) { vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n + 1); for (auto \u0026vec : edges) { graph[vec[0]].push_back({vec[1], vec[2]}); graph[vec[1]].push_back({vec[0], vec[2]}); } vector\u003cint\u003e dis(n + 1); vector\u003cint\u003e is_min(n + 1); vector\u003cint\u003e cach(n + 1, -1); Dijkstra(graph, n, dis, is_min); // 找到最短路径 return dfs(1, graph, n, dis, is_min, cach); } }; ","date":"2023-03-13","objectID":"/1786.number-of-restricted-paths-from-first-to-last-node.zh/:3:0","series":null,"tags":["dijkstra","memorized search"],"title":"1786. 从第一个节点出发到最后一个节点的受限路径数 (Medium)","uri":"/1786.number-of-restricted-paths-from-first-to-last-node.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description Minimum Hours of Training to Win a Competition (Easy) You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively. You are also given two 0-indexed integer arrays energy and experience, both of length n. You will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available. Defeating the ith opponent increases your experience by experience[i], but decreases your energy by energy[i]. Before starting the competition, you can train for some number of hours. After each hour of training, you can either choose to increase your initial experience by one, or increase your initial energy by one. Return the minimum number of training hours required to defeat all n opponents. Example 1: text Input: initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1] Output: 8 Explanation: You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training. You face the opponents in the following order: - You have more energy and experience than the 0th opponent so you win. Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7. - You have more energy and experience than the 1st opponent so you win. Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13. - You have more energy and experience than the 2ⁿd opponent so you win. Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16. - You have more energy and experience than the 3rd opponent so you win. Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17. You did a total of 6 + 2 = 8 hours of training before the competition, so we return 8. It can be proven that no smaller answer exists. Example 2: text Input: initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3] Output: 0 Explanation: You do not need any additional energy or experience to win the competition, so we return 0. Constraints: n == energy.length == experience.length 1 \u003c= n \u003c= 100 1 \u003c= initialEnergy, initialExperience, energy[i], experience[i] \u003c= 100 ","date":"2023-03-13","objectID":"/2383.minimum-hours-of-training-to-win-a-competition/:1:0","series":null,"tags":["greedy algorithm","analog"],"title":"2383. Minimum Hours of Training to Win a Competition (Easy)","uri":"/2383.minimum-hours-of-training-to-win-a-competition/#description"},{"categories":["leetcode"],"content":" 2 SolutionActually, training when meeting competitors is also feasible. ","date":"2023-03-13","objectID":"/2383.minimum-hours-of-training-to-win-a-competition/:2:0","series":null,"tags":["greedy algorithm","analog"],"title":"2383. Minimum Hours of Training to Win a Competition (Easy)","uri":"/2383.minimum-hours-of-training-to-win-a-competition/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minNumberOfHours(int initialEnergy, int initialExperience, vector\u003cint\u003e \u0026energy, vector\u003cint\u003e \u0026experience) { int res = 0; int n = energy.size(); for (int i = 0; i \u003c n; ++i) { initialEnergy -= energy[i]; // initialExperience -= experience[i]; if (initialEnergy \u003c= 0) { res += 1 - initialEnergy; initialEnergy = 1; } if (initialExperience \u003c= experience[i]) { res += 1 + experience[i] - initialExperience; initialExperience = experience[i] + 1; } initialExperience += experience[i]; } return res; } }; ","date":"2023-03-13","objectID":"/2383.minimum-hours-of-training-to-win-a-competition/:3:0","series":null,"tags":["greedy algorithm","analog"],"title":"2383. Minimum Hours of Training to Win a Competition (Easy)","uri":"/2383.minimum-hours-of-training-to-win-a-competition/#code"},{"categories":["leetcode"],"content":" 1 问题描述2383. 赢得比赛需要的最少训练时长 (Easy) 你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。 另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。 你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。 击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少 energy[i] 。 在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。 返回击败全部 n 个对手需要训练的 最少 小时数目。 示例 1： text 输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1] 输出：8 解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。 按以下顺序与对手比赛： - 你的精力与经验都超过第 0 个对手，所以获胜。 精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。 - 你的精力与经验都超过第 1 个对手，所以获胜。 精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。 - 你的精力与经验都超过第 2 个对手，所以获胜。 精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。 - 你的精力与经验都超过第 3 个对手，所以获胜。 精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。 在比赛前进行了 8 小时训练，所以返回 8 。 可以证明不存在更小的答案。 示例 2： text 输入：initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3] 输出：0 解释：你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。 提示： n == energy.length == experience.length 1 \u003c= n \u003c= 100 1 \u003c= initialEnergy, initialExperience, energy[i], experience[i] \u003c= 100 ","date":"2023-03-13","objectID":"/2383.minimum-hours-of-training-to-win-a-competition.zh/:1:0","series":null,"tags":["greedy algorithm","analog"],"title":"2383.赢得比赛需要的最少训练时长 (Easy)","uri":"/2383.minimum-hours-of-training-to-win-a-competition.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心+模拟，比赛开始前训练，和碰上对手再训练的效果是一样的。 ","date":"2023-03-13","objectID":"/2383.minimum-hours-of-training-to-win-a-competition.zh/:2:0","series":null,"tags":["greedy algorithm","analog"],"title":"2383.赢得比赛需要的最少训练时长 (Easy)","uri":"/2383.minimum-hours-of-training-to-win-a-competition.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minNumberOfHours(int initialEnergy, int initialExperience, vector\u003cint\u003e \u0026energy, vector\u003cint\u003e \u0026experience) { int res = 0; int n = energy.size(); for (int i = 0; i \u003c n; ++i) { initialEnergy -= energy[i]; // initialExperience -= experience[i]; if (initialEnergy \u003c= 0) { res += 1 - initialEnergy; initialEnergy = 1; } if (initialExperience \u003c= experience[i]) { res += 1 + experience[i] - initialExperience; initialExperience = experience[i] + 1; } initialExperience += experience[i]; } return res; } }; ","date":"2023-03-13","objectID":"/2383.minimum-hours-of-training-to-win-a-competition.zh/:3:0","series":null,"tags":["greedy algorithm","analog"],"title":"2383.赢得比赛需要的最少训练时长 (Easy)","uri":"/2383.minimum-hours-of-training-to-win-a-competition.zh/#代码"},{"categories":["leetcode"],"content":"743. Network Delay Time (Medium) You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (uᵢ, vᵢ, wᵢ), where uᵢ is the source node, vᵢ is the target node, and wᵢ is the time it takes for a signal to travel from source to target. We will send a signal from a given node k. Return the minimum time it takes for all the nnodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1. Example 1: text Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 Output: 2 Example 2: text Input: times = [[1,2,1]], n = 2, k = 1 Output: 1 Example 3: text Input: times = [[1,2,1]], n = 2, k = 2 Output: -1 Constraints: 1 \u003c= k \u003c= n \u003c= 100 1 \u003c= times.length \u003c= 6000 times[i].length == 3 1 \u003c= uᵢ, vᵢ \u003c= n uᵢ != vᵢ 0 \u003c= wᵢ \u003c= 100 All the pairs (uᵢ, vᵢ) are unique. (i.e., no multiple edges.) ","date":"2023-03-12","objectID":"/743.network-delay-time/:0:0","series":null,"tags":["dijkstra","priority queue"],"title":"743. Network Delay Time (Medium)","uri":"/743.network-delay-time/#"},{"categories":["leetcode"],"content":" 1 解题思路Dijkstra + priority queue ","date":"2023-03-12","objectID":"/743.network-delay-time/:1:0","series":null,"tags":["dijkstra","priority queue"],"title":"743. Network Delay Time (Medium)","uri":"/743.network-delay-time/#解题思路"},{"categories":["leetcode"],"content":" 2 Code cpp class Solution { public: int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e \u0026times, int n, int k) { vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n + 1); for (auto \u0026vec : times) { graph[vec[0]].push_back({vec[1], vec[2]}); // vec1表示目标节点,vec[2]表示距离 } // Dijkstra算法 vector\u003cint\u003e dis(n + 1, -1); // 表示从k到各点的最短距离, -1表示这个点还没有到达 vector\u003cint\u003e min_dis(n + 1, 0); //为0表示还没找到该该点的最短距离 auto cmp = [\u0026](pair\u003cint, int\u003e \u0026p1, pair\u003cint, int\u003e \u0026p2) { return p1.second \u003e p2.second; }; // 小顶堆，pair.first为点坐标，pair.second为时间 priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq(cmp); pq.push({k, 0}); dis[k] = 0; while (!pq.empty()) { auto [idx, len] = pq.top(); pq.pop(); if (min_dis[idx] == 1) // 如果已经找到最短距离，直接进行下一次循环 continue; dis[idx] = len; // 用最短距离更新dis[idx] min_dis[idx] = 1; // 说明该点已经找到最短距离 for (auto \u0026v : graph[idx]) { if (min_dis[v[0]] == 0) { pq.push({v[0], len + v[1]}); } } } int res = 0; for (int i = 1; i \u003c= n; ++i) { if (min_dis[i] == 0) { return -1; } res = std::max(res, dis[i]); } return res; } }; ","date":"2023-03-12","objectID":"/743.network-delay-time/:2:0","series":null,"tags":["dijkstra","priority queue"],"title":"743. Network Delay Time (Medium)","uri":"/743.network-delay-time/#code"},{"categories":["leetcode"],"content":" 1 问题描述743. 网络延迟时间 (Medium) 有 n 个网络节点，标记为 1 到 n。 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (uᵢ, vᵢ, wᵢ)，其中 uᵢ 是源节点， vᵢ 是目标节点， wᵢ 是一个信号从源节点传递到目标节点的时间。 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。 示例 1： text 输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 输出：2 示例 2： text 输入：times = [[1,2,1]], n = 2, k = 1 输出：1 示例 3： text 输入：times = [[1,2,1]], n = 2, k = 2 输出：-1 提示： 1 \u003c= k \u003c= n \u003c= 100 1 \u003c= times.length \u003c= 6000 times[i].length == 3 1 \u003c= uᵢ, vᵢ \u003c= n uᵢ != vᵢ 0 \u003c= wᵢ \u003c= 100 所有 (uᵢ, vᵢ) 对都 互不相同（即，不含重复边） ","date":"2023-03-12","objectID":"/743.network-delay-time.zh/:1:0","series":null,"tags":["dijkstra","priority queue"],"title":"743. 网络延迟时间 (Medium)","uri":"/743.network-delay-time.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路Dijkstra算法，堆优化。 使用一个三维数组vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e dp，dp[i]存储了与点i相连的点及其权值； 将所有节点分成两类：已确定从起点到当前点的最短路长度的节点，以及未确定从起点到当前点的最短路长度的节点（下面简称「未确定节点」和「已确定节点」）。 每次从「未确定节点」中取一个与起点距离最短的点，将它归类为「已确定节点」，并用它「更新」从起点到其他所有「未确定节点」的距离。直到所有点都被归类为「已确定节点」。 用节点 AAA「更新」节点 BBB 的意思是，用起点到节点 AAA 的最短路长度加上从节点 AAA 到节点 BBB 的边的长度，去比较起点到节点 BBB 的最短路长度，如果前者小于后者，就用前者更新后者。这种操作也被叫做「松弛」。 这里暗含的信息是：每次选择「未确定节点」时，起点到它的最短路径的长度可以被确定。 我们利用一个优先队列（小顶堆）来维护该过程。 ","date":"2023-03-12","objectID":"/743.network-delay-time.zh/:2:0","series":null,"tags":["dijkstra","priority queue"],"title":"743. 网络延迟时间 (Medium)","uri":"/743.network-delay-time.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int networkDelayTime(vector\u003cvector\u003cint\u003e\u003e \u0026times, int n, int k) { vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e graph(n + 1); for (auto \u0026vec : times) { graph[vec[0]].push_back({vec[1], vec[2]}); // vec1表示目标节点,vec[2]表示距离 } // Dijkstra算法 vector\u003cint\u003e dis(n + 1, -1); // 表示从k到各点的最短距离, -1表示这个点还没有到达 vector\u003cint\u003e min_dis(n + 1, 0); //为0表示还没找到该该点的最短距离 auto cmp = [\u0026](pair\u003cint, int\u003e \u0026p1, pair\u003cint, int\u003e \u0026p2) { return p1.second \u003e p2.second; }; // 小顶堆，pair.first为点坐标，pair.second为时间 priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq(cmp); pq.push({k, 0}); dis[k] = 0; while (!pq.empty()) { auto [idx, len] = pq.top(); pq.pop(); if (min_dis[idx] == 1) // 如果已经找到最短距离，直接进行下一次循环 continue; dis[idx] = len; // 用最短距离更新dis[idx] min_dis[idx] = 1; // 说明该点已经找到最短距离 for (auto \u0026v : graph[idx]) { if (min_dis[v[0]] == 0) { pq.push({v[0], len + v[1]}); } } } int res = 0; for (int i = 1; i \u003c= n; ++i) { if (min_dis[i] == 0) { return -1; } res = std::max(res, dis[i]); } return res; } }; ","date":"2023-03-12","objectID":"/743.network-delay-time.zh/:3:0","series":null,"tags":["dijkstra","priority queue"],"title":"743. 网络延迟时间 (Medium)","uri":"/743.network-delay-time.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述面试题 17.05. 字母与数字 (Medium) 给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。 返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。 示例 1: text 输入: [\"A\",\"1\",\"B\",\"C\",\"D\",\"2\",\"3\",\"4\",\"E\",\"5\",\"F\",\"G\",\"6\",\"7\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\"] 输出: [\"A\",\"1\",\"B\",\"C\",\"D\",\"2\",\"3\",\"4\",\"E\",\"5\",\"F\",\"G\",\"6\",\"7\"] 示例 2: text 输入: [\"A\",\"A\"] 输出: [] 提示： array.length \u003c= 100000 ","date":"2023-03-11","objectID":"/interview-17.05.zh/:1:0","series":null,"tags":["daily","hash table","prefix sum"],"title":"面试题 17.05.  字母与数字 (Medium)","uri":"/interview-17.05.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先使用一个前缀和数组prefix，prefix[i]表示前i个数里，数字的数量减去字母的数量，遍历array，更新prefix，同时在哈希表中查找key-\u003eprefix[i]是否存在： 如果存在，比较记录的最长长度len，如果大于len，则更新idx = ump[prefix[i]]，并更新len = i - ump[prefix[i]]； 否则，更新哈希表，即ump[prefix[i]] = i； ","date":"2023-03-11","objectID":"/interview-17.05.zh/:2:0","series":null,"tags":["daily","hash table","prefix sum"],"title":"面试题 17.05.  字母与数字 (Medium)","uri":"/interview-17.05.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cstring\u003e findLongestSubarray(vector\u003cstring\u003e \u0026array) { int n = array.size(); vector\u003cstring\u003e res; if (n \u003c 2) { return res; } unordered_set\u003cstring\u003e ust; for (char c = 'a'; c \u003c= 'z'; c++) { // 统计所有的字母 string s(1, c); ust.insert(s); } for (char c = 'A'; c \u003c= 'Z'; c++) { string s(1, c); ust.insert(s); } unordered_map\u003cint, int\u003e ump; ump[0] = 0; int len = 0; int idx = 0; vector\u003cint\u003e prefix(n + 1); // prefix[i]表示前i个数里，数字的数量减去字母的数量 for (int i = 1; i \u003c= n; ++i) { if (ust.find(array[i - 1]) == ust.end()) { prefix[i] = prefix[i - 1] + 1; } else { prefix[i] = prefix[i - 1] - 1; } if (ump.find(prefix[i]) != ump.end()) { // 说明存在以i - 1为右端点的子数组 if (len \u003c i - ump[prefix[i]]) { len = i - ump[prefix[i]]; idx = ump[prefix[i]]; } } else { ump[prefix[i]] = i; } } res.resize(len); for (int i = idx; i \u003c idx + len; ++i) { res[i - idx] = array[i]; } return res; } }; ","date":"2023-03-11","objectID":"/interview-17.05.zh/:3:0","series":null,"tags":["daily","hash table","prefix sum"],"title":"面试题 17.05.  字母与数字 (Medium)","uri":"/interview-17.05.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1590. Make Sum Divisible by P (Medium) Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array. Return the length of the smallest subarray that you need to remove, or -1 if it’s impossible. A subarray is defined as a contiguous block of elements in the array. Example 1: text Input: nums = [3,1,4,2], p = 6 Output: 1 Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6. Example 2: text Input: nums = [6,3,5,2], p = 9 Output: 2 Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9. Example 3: text Input: nums = [1,2,3], p = 3 Output: 0 Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything. Constraints: 1 \u003c= nums.length \u003c= 10⁵ 1 \u003c= nums[i] \u003c= 10⁹ 1 \u003c= p \u003c= 10⁹ ","date":"2023-03-10","objectID":"/1590.make-sum-divisible-by-p/:1:0","series":null,"tags":["prefix sum","hash table","daily"],"title":"1590. Make Sum Divisible by P (Medium)","uri":"/1590.make-sum-divisible-by-p/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use a prefix sum array to store the remainder of the sum of the first ith elements. We denote mod as the remainder of the sum of all the elements. Then we need to find a subarray whose sum mod p is mod too. We can use a hash table to solve the problem. The key is the remainder of prefix[i], value is i. We traverse the prefix sum array, and update the hash table. If prefix[i] % p == tmp_mod, then we need to find if key (tmp_mod - mod + p) % p is in the hash table. If it is, res = std::min(res, ump[tmp_mod] - ump[(tmp_mod - mod + p) % p]). ","date":"2023-03-10","objectID":"/1590.make-sum-divisible-by-p/:2:0","series":null,"tags":["prefix sum","hash table","daily"],"title":"1590. Make Sum Divisible by P (Medium)","uri":"/1590.make-sum-divisible-by-p/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minSubarray(vector\u003cint\u003e \u0026nums, int p) { int n = nums.size(); vector\u003cint\u003e prefix(n + 1); for (int i = 1; i \u003c= n; ++i) { prefix[i] = (prefix[i - 1] + nums[i - 1]) % p; } int mod = prefix[n] % p; if (mod == 0) { return 0; } unordered_map\u003cint, int\u003e ump; ump[0] = 0; int res = n; for (int i = 1; i \u003c= n; ++i) { int tmp_mod = prefix[i] % p; ump[tmp_mod] = i; if (ump.find((tmp_mod - mod + p) % p) != ump.end()) { res = std::min(res, i - ump[(tmp_mod - mod + p) % p]); } } if (res == n) { return -1; } return res; } }; ","date":"2023-03-10","objectID":"/1590.make-sum-divisible-by-p/:3:0","series":null,"tags":["prefix sum","hash table","daily"],"title":"1590. Make Sum Divisible by P (Medium)","uri":"/1590.make-sum-divisible-by-p/#code"},{"categories":["leetcode"],"content":" 1 问题描述1590. 使数组和能被 P 整除 (Medium) 给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。 请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。 子数组 定义为原数组中连续的一组元素。 示例 1： text 输入：nums = [3,1,4,2], p = 6 输出：1 解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。 示例 2： text 输入：nums = [6,3,5,2], p = 9 输出：2 解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。 示例 3： text 输入：nums = [1,2,3], p = 3 输出：0 解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。 示例 4： text 输入：nums = [1,2,3], p = 7 输出：-1 解释：没有任何方案使得移除子数组后剩余元素的和被 7 整除。 示例 5： text 输入：nums = [1000000000,1000000000,1000000000], p = 3 输出：0 提示： 1 \u003c= nums.length \u003c= 10⁵ 1 \u003c= nums[i] \u003c= 10⁹ 1 \u003c= p \u003c= 10⁹ ","date":"2023-03-10","objectID":"/1590.make-sum-divisible-by-p.zh/:1:0","series":null,"tags":["prefix sum","hash table"],"title":"1590.使数组和能被 P 整除 (Medium)","uri":"/1590.make-sum-divisible-by-p.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先维护一个前缀和数组，数组中的元素为前缀和对p的模，记数组所有元素对p的模为mod，那么，我们要找的就是和的模也为mod的子数组； 同时，我们维护一个哈希表，哈希表的key为前i个数对p的模，value为i；遍历前缀和数组，并更新哈希表，假设当前前缀和对p的模为tmp_mod，则查找哈希表中是否存在(tmp_mod - mod + p) % p的元素，res = std::min(res, ump[tmp_mod] - ump[(tmp_mod - mod + p) % p])。 哈希表的值是遍历前缀和数组过程中，相同模的过程中的最大的i。 ","date":"2023-03-10","objectID":"/1590.make-sum-divisible-by-p.zh/:2:0","series":null,"tags":["prefix sum","hash table"],"title":"1590.使数组和能被 P 整除 (Medium)","uri":"/1590.make-sum-divisible-by-p.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minSubarray(vector\u003cint\u003e \u0026nums, int p) { int n = nums.size(); vector\u003cint\u003e prefix(n + 1); for (int i = 1; i \u003c= n; ++i) { prefix[i] = (prefix[i - 1] + nums[i - 1]) % p; // 防止爆int } int mod = prefix[n] % p; if (mod == 0) { return 0; } unordered_map\u003cint, int\u003e ump; ump[0] = 0; int res = n; for (int i = 1; i \u003c= n; ++i) { int tmp_mod = prefix[i] % p; ump[tmp_mod] = i; if (ump.find((tmp_mod - mod + p) % p) != ump.end()) { res = std::min(res, i - ump[(tmp_mod - mod + p) % p]); } } if (res == n) { return -1; } return res; } }; ","date":"2023-03-10","objectID":"/1590.make-sum-divisible-by-p.zh/:3:0","series":null,"tags":["prefix sum","hash table"],"title":"1590.使数组和能被 P 整除 (Medium)","uri":"/1590.make-sum-divisible-by-p.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1310. XOR Queries of a Subarray (Medium) You are given an array arr of positive integers. You are also given the array queries where queries[i] = [leftᵢ, rightᵢ]. For each query i compute the XOR of elements from leftᵢ to rightᵢ (that is, arr[leftᵢ] XOR arr[leftᵢ + 1] XOR ... XOR arr[rightᵢ] ). Return an array answer where answer[i] is the answer to the ith query. Example 1: text Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] Output: [2,7,14,8] Explanation: The binary representation of the elements in the array are: 1 = 0001 3 = 0011 4 = 0100 8 = 1000 The XOR values for queries are: [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 Example 2: text Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]] Output: [8,0,4,4] Constraints: 1 \u003c= arr.length, queries.length \u003c= 3 * 10⁴ 1 \u003c= arr[i] \u003c= 10⁹ queries[i].length == 2 0 \u003c= leftᵢ \u003c= rightᵢ \u003c arr.length ","date":"2023-03-09","objectID":"/1310.xor-queries-of-a-subarray/:1:0","series":null,"tags":["prefix sum"],"title":"1310.XOR Queries of a Subarray (Medium)","uri":"/1310.xor-queries-of-a-subarray/#description"},{"categories":["leetcode"],"content":" 2 SolutionAccording to the range of the data of the problem, we need an algorithm with $O(n)$ or $O(n\\log_2 n)$ time complexity. Consuming the property of xor: $A \\oplus B\\oplus A = B$, it’s similar to the property $A + B - A = B$ of prefix sum. So we can use a prefix xor array to reduce the time complexity. ","date":"2023-03-09","objectID":"/1310.xor-queries-of-a-subarray/:2:0","series":null,"tags":["prefix sum"],"title":"1310.XOR Queries of a Subarray (Medium)","uri":"/1310.xor-queries-of-a-subarray/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e xorQueries(vector\u003cint\u003e \u0026arr, vector\u003cvector\u003cint\u003e\u003e \u0026queries) { int n = arr.size(); vector\u003cint\u003e prefix(n + 1); for (int i = 1; i \u003c= n; ++i) { prefix[i] = (prefix[i - 1] ^ arr[i - 1]); } vector\u003cint\u003e res(queries.size()); for (int i = 0; i \u003c queries.size(); ++i) { res[i] = (prefix[queries[i][1] + 1] ^ prefix[queries[i][0]]); } return res; } }; ","date":"2023-03-09","objectID":"/1310.xor-queries-of-a-subarray/:3:0","series":null,"tags":["prefix sum"],"title":"1310.XOR Queries of a Subarray (Medium)","uri":"/1310.xor-queries-of-a-subarray/#code"},{"categories":["leetcode"],"content":" 1 问题描述1310. 子数组异或查询 (Medium) 有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Lᵢ, Rᵢ]。 对于每个查询 i，请你计算从 Lᵢ 到 Rᵢ 的 XOR 值（即 arr[Lᵢ] xor arr[Lᵢ+1] xor ... xor arr[Rᵢ]）作为本次查询的结果。 并返回一个包含给定查询 queries 所有结果的数组。 示例 1： text 输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] 输出：[2,7,14,8] 解释： 数组中元素的二进制表示形式是： 1 = 0001 3 = 0011 4 = 0100 8 = 1000 查询的 XOR 值为： [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 示例 2： text 输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]] 输出：[8,0,4,4] 提示： 1 \u003c= arr.length \u003c= 3 * 10^4 1 \u003c= arr[i] \u003c= 10^9 1 \u003c= queries.length \u003c= 3 * 10^4 queries[i].length == 2 0 \u003c= queries[i][0] \u003c= queries[i][1] \u003c arr.length ","date":"2023-03-09","objectID":"/1310.xor-queries-of-a-subarray.zh/:1:0","series":null,"tags":["prefix sum"],"title":"1310. 子数组异或查询 (Medium)","uri":"/1310.xor-queries-of-a-subarray.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路从本题的数据范围可知，我们需要时间复杂度为$O(n)$或者$O(n\\log_2 n)$的算法，考虑异或的性质：$A\\oplus B\\oplus A = B$，类似于前缀和的$A + B - A = B$，因此我们可以考虑使用前缀异或数组来降低时间复杂度。 ","date":"2023-03-09","objectID":"/1310.xor-queries-of-a-subarray.zh/:2:0","series":null,"tags":["prefix sum"],"title":"1310. 子数组异或查询 (Medium)","uri":"/1310.xor-queries-of-a-subarray.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e xorQueries(vector\u003cint\u003e \u0026arr, vector\u003cvector\u003cint\u003e\u003e \u0026queries) { int n = arr.size(); vector\u003cint\u003e prefix(n + 1); for (int i = 1; i \u003c= n; ++i) { prefix[i] = (prefix[i - 1] ^ arr[i - 1]); } vector\u003cint\u003e res(queries.size()); for (int i = 0; i \u003c queries.size(); ++i) { res[i] = (prefix[queries[i][1] + 1] ^ prefix[queries[i][0]]); } return res; } }; ","date":"2023-03-09","objectID":"/1310.xor-queries-of-a-subarray.zh/:3:0","series":null,"tags":["prefix sum"],"title":"1310. 子数组异或查询 (Medium)","uri":"/1310.xor-queries-of-a-subarray.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description K Inverse Pairs Array (Hard) For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 \u003c= i \u003c j \u003c nums.length and nums[i] \u003e nums[j]. Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 10⁹ + 7. Example 1: text Input: n = 3, k = 0 Output: 1 Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs. Example 2: text Input: n = 3, k = 1 Output: 2 Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair. Constraints: 1 \u003c= n \u003c= 1000 0 \u003c= k \u003c= 1000 ","date":"2023-03-08","objectID":"/629.k-inverse-pairs-array/:1:0","series":null,"tags":["dynamic programming"],"title":"629. K Inverse Pairs Array (Hard)","uri":"/629.k-inverse-pairs-array/#description"},{"categories":["leetcode"],"content":" 2 Solutiondynamic programming ","date":"2023-03-08","objectID":"/629.k-inverse-pairs-array/:2:0","series":null,"tags":["dynamic programming"],"title":"629. K Inverse Pairs Array (Hard)","uri":"/629.k-inverse-pairs-array/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int kInversePairs(int n, int k) { vector\u003cvector\u003clong\u003e\u003e dp(n + 1, vector\u003clong\u003e(k + 1, 0)); for (int i = 1; i \u003c= n; ++i) { dp[i][0] = 1; } int mod = 1000000007; if (k \u003e n * (n - 1) / 2) { return 0; } for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= k \u0026\u0026 j \u003c= (i * (i - 1) / 2); ++j) { if (j \u003c= i - 1) { dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod; } else { dp[i][j] = (dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - i] + mod) % mod; } } } return dp[n][k]; } }; ","date":"2023-03-08","objectID":"/629.k-inverse-pairs-array/:3:0","series":null,"tags":["dynamic programming"],"title":"629. K Inverse Pairs Array (Hard)","uri":"/629.k-inverse-pairs-array/#code"},{"categories":["leetcode"],"content":" 1 问题描述629. K个逆序对数组 (Hard) 给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。 逆序对的定义如下：对于数组的第 i 个和第 j 个元素，如果满 i \u003c j 且 a[i] \u003e a[j]，则其为一个逆序对；否则不是。 由于答案可能很大，只需要返回 答案 mod 10 + 7 的值。 示例 1: text 输入: n = 3, k = 0 输出: 1 解释: 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。 示例 2: text 输入: n = 3, k = 1 输出: 2 解释: 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。 说明: n 的范围是 \\[1, 1000\\] 并且 k 的范围是 \\[0, 1000\\]。 ","date":"2023-03-08","objectID":"/629.k-inverse-pairs-array.zh/:1:0","series":null,"tags":["dynamic programming"],"title":"629.K个逆序对数组 (Hard)","uri":"/629.k-inverse-pairs-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路像这种答案需要取模的题，解题思路一般都是动态规划； 以dp[n][k]表示考虑前$n$个数时，逆序对刚好为$k$个的方案数，为了找到递推关系，我们需要考虑数$n$的位置，假设数$n$位于第$n$个位置，那么dp[n][k] = dp[n - 1][k]（因为没有数能与$n$组成逆序对，相当于不用考虑数$n$），假设数$n$位于第$n - 1$个位置，那么dp[n][k] = dp[n - 1][k - 1]，所以，我们可以求得递推关系： 当k \u003e= n - 1时，$dp[n][k] = \\sum\\limits_{i=0}^{n-1}dp[n-1][k-i]$ 当k \u003c n - 1时，$dp[n][k] = \\sum\\limits_{i=0}^{k}dp[n][i]$ 但是直接用这个递推关系式，时间复杂度为$O(nk^2)$，可能会超时，我们考虑用$dp[n][k] - dp[n][k - 1]$，可以发现新的递推关系式： 如果k \u003c= n - 1，$dp[n][k] = dp[n][k - 1] + dp[n - 1][k]$ 如果k \u003e n - 1，$dp[n][k] = dp[n][k - 1] + dp[n - 1][k] - dp[n - 1][k - n]$ ","date":"2023-03-08","objectID":"/629.k-inverse-pairs-array.zh/:2:0","series":null,"tags":["dynamic programming"],"title":"629.K个逆序对数组 (Hard)","uri":"/629.k-inverse-pairs-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int kInversePairs(int n, int k) { vector\u003cvector\u003clong\u003e\u003e dp(n + 1, vector\u003clong\u003e(k + 1, 0)); for (int i = 1; i \u003c= n; ++i) { dp[i][0] = 1; } int mod = 1000000007; if (k \u003e n * (n - 1) / 2) { return 0; } for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= k \u0026\u0026 j \u003c= (i * (i - 1) / 2); ++j) { if (j \u003c= i - 1) { dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod; } else { dp[i][j] = (dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - i] + mod) % mod; } } } return dp[n][k]; } }; ","date":"2023-03-08","objectID":"/629.k-inverse-pairs-array.zh/:3:0","series":null,"tags":["dynamic programming"],"title":"629.K个逆序对数组 (Hard)","uri":"/629.k-inverse-pairs-array.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description560. Subarray Sum Equals K (Medium) Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. A subarray is a contiguous non-empty sequence of elements within an array. Example 1: text Input: nums = [1,1,1], k = 2 Output: 2 Example 2: text Input: nums = [1,2,3], k = 3 Output: 2 Constraints: 1 \u003c= nums.length \u003c= 2 * 10⁴ -1000 \u003c= nums[i] \u003c= 1000 -10⁷ \u003c= k \u003c= 10⁷ ","date":"2023-03-07","objectID":"/560.subarray-sum-equals-k/:1:0","series":null,"tags":["prefix sum","hash table"],"title":"560. Subarray Sum Equals K (Medium)","uri":"/560.subarray-sum-equals-k/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe only need traverse once. We compute the prefix sum of the array, and check whether the key prefix[i] - target is in ump. If it is, res += ump[prefix[i] - k]. ++ump[prefix[i]]. ","date":"2023-03-07","objectID":"/560.subarray-sum-equals-k/:2:0","series":null,"tags":["prefix sum","hash table"],"title":"560. Subarray Sum Equals K (Medium)","uri":"/560.subarray-sum-equals-k/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int subarraySum(vector\u003cint\u003e \u0026nums, int k) { vector\u003cint\u003e prefix(nums.size() + 1); std::unordered_map\u003cint, int\u003e ump; ump[0] = 1; int res = 0; for (int i = 1; i \u003c= nums.size(); ++i) { prefix[i] = prefix[i - 1] + nums[i - 1]; if (ump.find(prefix[i] - k) != ump.end()) { res += ump[prefix[i] - k]; } ++ump[prefix[i]]; } return res; } }; ","date":"2023-03-07","objectID":"/560.subarray-sum-equals-k/:3:0","series":null,"tags":["prefix sum","hash table"],"title":"560. Subarray Sum Equals K (Medium)","uri":"/560.subarray-sum-equals-k/#code"},{"categories":["leetcode"],"content":" 1 问题描述560. 和为 K 的子数组 (Medium) 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。 示例 1： text 输入：nums = [1,1,1], k = 2 输出：2 示例 2： text 输入：nums = [1,2,3], k = 3 输出：2 提示： 1 \u003c= nums.length \u003c= 2 * 10⁴ -1000 \u003c= nums[i] \u003c= 1000 -10⁷ \u003c= k \u003c= 10⁷ ","date":"2023-03-07","objectID":"/560.subarray-sum-equals-k.zh/:1:0","series":null,"tags":["prefix sum","hash table"],"title":"560. 和为 K 的子数组 (Medium)","uri":"/560.subarray-sum-equals-k.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路一次遍历，记录数组的前缀和prefix[i]，然后在ump中查找key为prefix[i] - target的元素是否存在，如果存在res += ump[prefix[i] - k]，++ump[prefix[i]]。 ","date":"2023-03-07","objectID":"/560.subarray-sum-equals-k.zh/:2:0","series":null,"tags":["prefix sum","hash table"],"title":"560. 和为 K 的子数组 (Medium)","uri":"/560.subarray-sum-equals-k.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int subarraySum(vector\u003cint\u003e \u0026nums, int k) { vector\u003cint\u003e prefix(nums.size() + 1); std::unordered_map\u003cint, int\u003e ump; ump[0] = 1; int res = 0; for (int i = 1; i \u003c= nums.size(); ++i) { prefix[i] = prefix[i - 1] + nums[i - 1]; if (ump.find(prefix[i] - k) != ump.end()) { res += ump[prefix[i] - k]; } ++ump[prefix[i]]; } return res; } }; ","date":"2023-03-07","objectID":"/560.subarray-sum-equals-k.zh/:3:0","series":null,"tags":["prefix sum","hash table"],"title":"560. 和为 K 的子数组 (Medium)","uri":"/560.subarray-sum-equals-k.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description497. Random Point in Non-overlapping Rectangles (Medium) You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [aᵢ, bᵢ, xᵢ, yᵢ] indicates that (aᵢ, bᵢ) is the bottom-left corner point of the ith rectangle and (xᵢ, yᵢ) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle. Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned. Note that an integer point is a point that has integer coordinates. Implement the Solution class: Solution(int[][] rects) Initializes the object with the given rectangles rects. int[] pick() Returns a random integer point [u, v] inside the space covered by one of the given rectangles. Example 1: text Input [\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"] [[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []] Output [null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]] Explanation Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]); solution.pick(); // return [1, -2] solution.pick(); // return [1, -1] solution.pick(); // return [-1, -2] solution.pick(); // return [-2, -2] solution.pick(); // return [0, 0] Constraints: 1 \u003c= rects.length \u003c= 100 rects[i].length == 4 -10⁹ \u003c= aᵢ \u003c xᵢ \u003c= 10⁹ -10⁹ \u003c= bᵢ \u003c yᵢ \u003c= 10⁹ xᵢ - aᵢ \u003c= 2000 yᵢ - bᵢ \u003c= 2000 All the rectangles do not overlap. At most 10⁴ calls will be made to pick. ","date":"2023-03-07","objectID":"/497.random-point-in-non-overlapping-rectangles/:1:0","series":null,"tags":["prefix sum"],"title":"497.Random Point in Non-overlapping Rectangles (Medium)","uri":"/497.random-point-in-non-overlapping-rectangles/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use a prefix sum array to record the number of points in the first kth rectangles, then we can use binary search to determine which rectangle the current pick_num should be in. idx = BSearch(pick_num + 1) - 1, so we have pick_num \u003e= prefix[idx]. So the index of the target rectangle is idx, the pick_num - prefix[idx]th point.(index is from $0$). ","date":"2023-03-07","objectID":"/497.random-point-in-non-overlapping-rectangles/:2:0","series":null,"tags":["prefix sum"],"title":"497.Random Point in Non-overlapping Rectangles (Medium)","uri":"/497.random-point-in-non-overlapping-rectangles/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { private: int total_num = 0; int pick_num = 0; vector\u003cvector\u003cint\u003e\u003e rectangles; vector\u003cint\u003e points_num; int BSearch(int target) { int left = 0, right = points_num.size(); while (left \u003c right) { int mid = left + (right - left) / 2; if (points_num[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return left; } public: Solution(vector\u003cvector\u003cint\u003e\u003e\u0026 rects) { points_num.push_back(0); for (auto \u0026vec : rects) { rectangles.push_back(vec); total_num += (vec[2] - vec[0] + 1) * (vec[3] - vec[1] + 1); points_num.push_back(total_num); } } vector\u003cint\u003e pick() { int choose = pick_num % total_num; int idx = BSearch(choose + 1) - 1; // the rectangle of index `idx` choose -= points_num[idx]; int x_idx = choose % (rectangles[idx][2] - rectangles[idx][0] + 1); int y_idx = choose / (rectangles[idx][2] - rectangles[idx][0] + 1); pick_num++; return {x_idx + rectangles[idx][0], y_idx + rectangles[idx][1]}; } }; ","date":"2023-03-07","objectID":"/497.random-point-in-non-overlapping-rectangles/:3:0","series":null,"tags":["prefix sum"],"title":"497.Random Point in Non-overlapping Rectangles (Medium)","uri":"/497.random-point-in-non-overlapping-rectangles/#code"},{"categories":["leetcode"],"content":" 1 问题描述497. 非重叠矩形中的随机点 (Medium) 给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点， (xi, yi) 是第 i 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。 在给定的矩形覆盖的空间内的任何整数点都有可能被返回。 请注意，整数点是具有整数坐标的点。 实现 Solution 类: Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。 int[] pick() 返回一个随机的整数点 [u, v] 在给定的矩形所覆盖的空间内。 示例 1： text 输入: [\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"] [[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []] 输出: [null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]] 解释： Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]); solution.pick(); // 返回 [1, -2] solution.pick(); // 返回 [1, -1] solution.pick(); // 返回 [-1, -2] solution.pick(); // 返回 [-2, -2] solution.pick(); // 返回 [0, 0] 提示： 1 \u003c= rects.length \u003c= 100 rects[i].length == 4 -10⁹ \u003c= aᵢ \u003c xᵢ \u003c= 10⁹ -10⁹ \u003c= bᵢ \u003c yᵢ \u003c= 10⁹ xᵢ - aᵢ \u003c= 2000 yᵢ - bᵢ \u003c= 2000 所有的矩形不重叠。 pick 最多被调用 10⁴ 次。 ","date":"2023-03-07","objectID":"/497.random-point-in-non-overlapping-rectangles.zh/:1:0","series":null,"tags":["prefix sum"],"title":"497.非重叠矩形中的随机点 (Medium)","uri":"/497.random-point-in-non-overlapping-rectangles.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路前缀和+二分 前缀和用来存储前面$k$个矩形里面一共有多少个点，然后利用二分查找来确定当前的pick_num应该选在哪个矩形里面: idx = BSearch(pick_num + 1) - 1，这里有prefix[idx] \u003c= pick_num，所以应该是在索引为idx的矩形的第pick_num - prefix[idx]个点处（索引从零开始） ","date":"2023-03-07","objectID":"/497.random-point-in-non-overlapping-rectangles.zh/:2:0","series":null,"tags":["prefix sum"],"title":"497.非重叠矩形中的随机点 (Medium)","uri":"/497.random-point-in-non-overlapping-rectangles.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { private: int total_num = 0; int pick_num = 0; vector\u003cvector\u003cint\u003e\u003e rectangles; vector\u003cint\u003e points_num; int BSearch(int target) { int left = 0, right = points_num.size(); while (left \u003c right) { int mid = left + (right - left) / 2; if (points_num[mid] \u003c target) { left = mid + 1; } else { right = mid; } } return left; } public: Solution(vector\u003cvector\u003cint\u003e\u003e\u0026 rects) { points_num.push_back(0); for (auto \u0026vec : rects) { rectangles.push_back(vec); total_num += (vec[2] - vec[0] + 1) * (vec[3] - vec[1] + 1); points_num.push_back(total_num); } } vector\u003cint\u003e pick() { int choose = pick_num % total_num; int idx = BSearch(choose + 1) - 1; // 选择索引为idx的矩形 choose -= points_num[idx]; // 从索引为idx的矩形的索引为choose的点 int x_idx = choose % (rectangles[idx][2] - rectangles[idx][0] + 1); // 对矩形的长取模 int y_idx = choose / (rectangles[idx][2] - rectangles[idx][0] + 1); pick_num++; return {x_idx + rectangles[idx][0], y_idx + rectangles[idx][1]}; } }; ","date":"2023-03-07","objectID":"/497.random-point-in-non-overlapping-rectangles.zh/:3:0","series":null,"tags":["prefix sum"],"title":"497.非重叠矩形中的随机点 (Medium)","uri":"/497.random-point-in-non-overlapping-rectangles.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description162. Find Peak Element (Medium) A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time. Example 1: text Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: text Input: nums = [1,2,1,3,5,6,4] Output: 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Constraints: 1 \u003c= nums.length \u003c= 1000 -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 nums[i] != nums[i + 1] for all valid i. ","date":"2023-03-06","objectID":"/162.find-peak-element/:1:0","series":null,"tags":["binary search"],"title":"162.Find Peak Element (Medium)","uri":"/162.find-peak-element/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use binary search to solve this problem. Binary search doesn’t require monotonicity, actually it only requires dichotomy. ","date":"2023-03-06","objectID":"/162.find-peak-element/:2:0","series":null,"tags":["binary search"],"title":"162.Find Peak Element (Medium)","uri":"/162.find-peak-element/#solution"},{"categories":["leetcode"],"content":" 1 问题描述162. 寻找峰值 (Medium) 峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞ 。 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。 示例 1： text 输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2： text 输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示： 1 \u003c= nums.length \u003c= 1000 -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1] ","date":"2023-03-06","objectID":"/162.find-peak-element.zh/:1:0","series":null,"tags":["binary search"],"title":"162.寻找峰值 (Medium)","uri":"/162.find-peak-element.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题要求实现时间复杂度为$O(\\log n)$的算法来解决问题，因此我们很容易想到二分，二分本质上并不要求单调性，而是要求二段性。 ","date":"2023-03-06","objectID":"/162.find-peak-element.zh/:2:0","series":null,"tags":["binary search"],"title":"162.寻找峰值 (Medium)","uri":"/162.find-peak-element.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int findPeakElement(vector\u003cint\u003e\u0026 nums) { if (nums.size() == 1) { return 0; } int left = 0, right = nums.size() - 1; while (left \u003c right \u0026\u0026 nums[left] \u003c nums[left + 1] \u0026\u0026 nums[right] \u003c nums[right - 1]) { int mid = left + (right - left) / 2; if (nums[mid] \u003e nums[mid - 1] \u0026\u0026 nums[mid] \u003e nums[mid + 1]) { return mid; } else if (nums[mid] \u003c nums[mid - 1]) { right = mid - 1;; } else if ( nums[mid] \u003c nums[mid + 1]) { left = mid + 1; } } if (nums[left] \u003e nums[left + 1]) { return left; } return right; } }; ","date":"2023-03-06","objectID":"/162.find-peak-element.zh/:3:0","series":null,"tags":["binary search"],"title":"162.寻找峰值 (Medium)","uri":"/162.find-peak-element.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1599. Maximum Profit of Operating a Centennial Wheel (Medium) You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars. You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again. You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation. Return the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1. Example 1: text Input: customers = [8,3], boardingCost = 5, runningCost = 6 Output: 3 Explanation: The numbers written on the gondolas are the number of people currently there. 1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14. 2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28. 3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37. The highest profit was $37 after rotating the wheel 3 times. Example 2: text Input: customers = [10,9,6], boardingCost = 6, runningCost = 4 Output: 7 Explanation: 1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20. 2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40. 3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60. 4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80. 5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100. 6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120. 7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122. The highest profit was $122 after rotating the wheel 7 times. Example 3: text Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92 Output: -1 Explanation: 1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89. 2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177. 3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269. 4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357. 5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447. The profit was never positive, so return -1. Constraints: n == customers.length 1 \u003c= n \u003c= 10⁵ 0 \u003c= customers[i] \u003c= 50 1 \u003c= boardingCost, runningCost \u003c= 100 ","date":"2023-03-06","objectID":"/1599.maximum-profit-of-operating-a-centennial-wheel/:1:0","series":null,"tags":["analog"],"title":"1599.Maximum Profit of Operating a Centennial Wheel (Medium)","uri":"/1599.maximum-profit-of-operating-a-centennial-wheel/#description"},{"categories":["leetcode"],"content":" 2 SolutionAnalog ","date":"2023-03-06","objectID":"/1599.maximum-profit-of-operating-a-centennial-wheel/:2:0","series":null,"tags":["analog"],"title":"1599.Maximum Profit of Operating a Centennial Wheel (Medium)","uri":"/1599.maximum-profit-of-operating-a-centennial-wheel/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minOperationsMaxProfit(vector\u003cint\u003e \u0026customers, int boardingCost, int runningCost) { if (boardingCost * 4 \u003c= runningCost) { return -1; } int total_cost = 0; int total_get = 0, people = 0; int max_profit = INT_MIN; int max_idx = 0; for (int i = 0; i \u003c customers.size() || people \u003e 0; i++) { if (i \u003c customers.size()) { if (people + customers[i] \u003c= 4) { total_cost += runningCost; total_get += boardingCost * (people + customers[i]); if (total_get - total_cost \u003e max_profit) { max_profit = total_get - total_cost; max_idx = i; } people = 0; } else { total_cost += runningCost; total_get += boardingCost * 4; if (total_get - total_cost \u003e max_profit) { max_profit = total_get - total_cost; max_idx = i; } people = people + customers[i] - 4; } } else { if (people \u003e 4) { total_cost += runningCost; total_get += boardingCost * 4; if (total_get - total_cost \u003e max_profit) { max_profit = total_get - total_cost; max_idx = i; } people -= 4; } else { total_cost += runningCost; total_get += boardingCost * people; if (total_get - total_cost \u003e max_profit) { max_profit = total_get - total_cost; max_idx = i; } people = 0; } } } if (max_profit \u003c= 0) { return -1; } return max_idx + 1; } }; ","date":"2023-03-06","objectID":"/1599.maximum-profit-of-operating-a-centennial-wheel/:3:0","series":null,"tags":["analog"],"title":"1599.Maximum Profit of Operating a Centennial Wheel (Medium)","uri":"/1599.maximum-profit-of-operating-a-centennial-wheel/#code"},{"categories":["leetcode"],"content":" 1 问题描述1599. 经营摩天轮的最大利润 (Medium) 你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。 给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。 你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆， 将免费进行 所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。 返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。 示例 1： text 输入：customers = [8,3], boardingCost = 5, runningCost = 6 输出：3 解释：座舱上标注的数字是该座舱的当前游客数。 1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。 2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。 3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。 轮转 3 次得到最大利润，最大利润为 $37 。 示例 2： text 输入：customers = [10,9,6], boardingCost = 6, runningCost = 4 输出：7 解释： 1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。 2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。 3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。 4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。 5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。 6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。 7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。 轮转 7 次得到最大利润，最大利润为$122 。 示例 3： text 输入：customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92 输出：-1 解释： 1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。 2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。 3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。 4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。 5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。 利润永不为正，所以返回 -1 。 提示： n == customers.length 1 \u003c= n \u003c= 10⁵ 0 \u003c= customers[i] \u003c= 50 1 \u003c= boardingCost, runningCost \u003c= 100 ","date":"2023-03-06","objectID":"/1599.maximum-profit-of-operating-a-centennial-wheel.zh/:1:0","series":null,"tags":["analog"],"title":"1599.经营摩天轮的最大利润 (Medium)","uri":"/1599.maximum-profit-of-operating-a-centennial-wheel.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路模拟 ","date":"2023-03-06","objectID":"/1599.maximum-profit-of-operating-a-centennial-wheel.zh/:2:0","series":null,"tags":["analog"],"title":"1599.经营摩天轮的最大利润 (Medium)","uri":"/1599.maximum-profit-of-operating-a-centennial-wheel.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minOperationsMaxProfit(vector\u003cint\u003e \u0026customers, int boardingCost, int runningCost) { if (boardingCost * 4 \u003c= runningCost) { return -1; } int total_cost = 0; int total_get = 0, people = 0; int max_profit = INT_MIN; int max_idx = 0; for (int i = 0; i \u003c customers.size() || people \u003e 0; i++) { if (i \u003c customers.size()) { if (people + customers[i] \u003c= 4) { total_cost += runningCost; total_get += boardingCost * (people + customers[i]); if (total_get - total_cost \u003e max_profit) { max_profit = total_get - total_cost; max_idx = i; } people = 0; } else { total_cost += runningCost; total_get += boardingCost * 4; if (total_get - total_cost \u003e max_profit) { max_profit = total_get - total_cost; max_idx = i; } people = people + customers[i] - 4; } } else { if (people \u003e 4) { total_cost += runningCost; total_get += boardingCost * 4; if (total_get - total_cost \u003e max_profit) { max_profit = total_get - total_cost; max_idx = i; } people -= 4; } else { total_cost += runningCost; total_get += boardingCost * people; if (total_get - total_cost \u003e max_profit) { max_profit = total_get - total_cost; max_idx = i; } people = 0; } } } if (max_profit \u003c= 0) { return -1; } return max_idx + 1; } }; ","date":"2023-03-06","objectID":"/1599.maximum-profit-of-operating-a-centennial-wheel.zh/:3:0","series":null,"tags":["analog"],"title":"1599.经营摩天轮的最大利润 (Medium)","uri":"/1599.maximum-profit-of-operating-a-centennial-wheel.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description209. Minimum Size Subarray Sum (Medium) Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example 1: text Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. Example 2: text Input: target = 4, nums = [1,4,4] Output: 1 Example 3: text Input: target = 11, nums = [1,1,1,1,1,1,1,1] Output: 0 Constraints: 1 \u003c= target \u003c= 10⁹ 1 \u003c= nums.length \u003c= 10⁵ 1 \u003c= nums[i] \u003c= 10⁴ Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)). ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum/:1:0","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.Minimum Size Subarray Sum (Medium)","uri":"/209.minimum-size-subarray-sum/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum/:2:0","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.Minimum Size Subarray Sum (Medium)","uri":"/209.minimum-size-subarray-sum/#solution"},{"categories":["leetcode"],"content":" 2.1 sliding windowIf sum \u003c target, then we let right pointer moves to the right, sum += nums[right++], we enlarge the window; Otherwise, we update min_len, make left pointer moves to the right, sum -= nums[left], narrow the window. ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum/:2:1","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.Minimum Size Subarray Sum (Medium)","uri":"/209.minimum-size-subarray-sum/#sliding-window"},{"categories":["leetcode"],"content":" 2.2 prefix sum + binary searchSince we need consider the sum of the subarrays, we can use prefix sum, which is monotonically increasing. So we can use binary search to find the maximum i that satisfies prefix[j] - prefix[i] \u003e= target. The answer to the problem is $(j - i)_{\\min}$. ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum/:2:2","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.Minimum Size Subarray Sum (Medium)","uri":"/209.minimum-size-subarray-sum/#prefix-sum--binary-search"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum/:3:0","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.Minimum Size Subarray Sum (Medium)","uri":"/209.minimum-size-subarray-sum/#code"},{"categories":["leetcode"],"content":" 3.1 sliding window cpp class Solution { public: int minSubArrayLen(int target, vector\u003cint\u003e\u0026 nums) { int left = 0, right = 0; int sum = 0; int min_len = nums.size() + 1; while (right \u003c nums.size()) { while (sum \u003c target \u0026\u0026 right \u003c nums.size()) { sum += nums[right++]; } while (sum \u003e= target \u0026\u0026 left \u003c= right) { if (sum \u003e= target) { min_len = min(min_len, right - left); } sum -= nums[left]; left++; } } if (min_len \u003e nums.size()) { return 0; } return min_len; } }; ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum/:3:1","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.Minimum Size Subarray Sum (Medium)","uri":"/209.minimum-size-subarray-sum/#sliding-window-1"},{"categories":["leetcode"],"content":" 3.2 prefix sum + binary search cpp class Solution { public: int BSearch(int idx, int target, vector\u003cint\u003e \u0026prefix) { int left = 0, right = idx; while (left \u003c right) { int mid = left + (right - left) / 2; if (prefix[mid] \u003c prefix[idx] - target) { left = mid + 1; } else { right = mid; } } return left; } int minSubArrayLen(int target, vector\u003cint\u003e \u0026nums) { int n = nums.size(); vector\u003cint\u003e prefix(n + 1, 0); for (int i = 1; i \u003c= nums.size(); i++) { prefix[i] = prefix[i - 1] + nums[i - 1]; } int res = n + 1; for (int i = 1; i \u003c= n; i++) { int j = BSearch(i, target - 1, prefix); if (prefix[i] \u003e= target) { res = std::min(i - j + 1, res); } } if (res == n + 1) { return 0; } return res; } }; ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum/:3:2","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.Minimum Size Subarray Sum (Medium)","uri":"/209.minimum-size-subarray-sum/#prefix-sum--binary-search-1"},{"categories":["leetcode"],"content":" 1 问题描述209. 长度最小的子数组 (Medium) 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsₗ, numsₗ+₁, ..., numsr-₁, numsr] ，并返回其长度 。 如果不存在符合条件的子数组，返回 0 。 示例 1： text 输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： text 输入：target = 4, nums = [1,4,4] 输出：1 示例 3： text 输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示： 1 \u003c= target \u003c= 10⁹ 1 \u003c= nums.length \u003c= 10⁵ 1 \u003c= nums[i] \u003c= 10⁵ 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum.zh/:1:0","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.长度最小的子数组 (Medium)","uri":"/209.minimum-size-subarray-sum.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum.zh/:2:0","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.长度最小的子数组 (Medium)","uri":"/209.minimum-size-subarray-sum.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 滑动窗口如果sum \u003c target，sum += nums[right++]，即右指针右移，扩大窗口；否则更新min_len，sum -= nums[left]，左指针右移，缩小窗口 ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum.zh/:2:1","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.长度最小的子数组 (Medium)","uri":"/209.minimum-size-subarray-sum.zh/#滑动窗口"},{"categories":["leetcode"],"content":" 2.2 前缀和+二分因为这里要考虑的是连续子数组的和，因此很容易想到前缀和，这里数组中的数都大于0，所以前缀和数组单调递增，因此可以考虑使用二分查找，来找到小于或等于prefix[j] - target的最大的prefix[i]，所求即为$(j - i)_{\\min}$ ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum.zh/:2:2","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.长度最小的子数组 (Medium)","uri":"/209.minimum-size-subarray-sum.zh/#前缀和二分"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum.zh/:3:0","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.长度最小的子数组 (Medium)","uri":"/209.minimum-size-subarray-sum.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 滑动窗口 cpp class Solution { public: int minSubArrayLen(int target, vector\u003cint\u003e\u0026 nums) { int left = 0, right = 0; int sum = 0; int min_len = nums.size() + 1; while (right \u003c nums.size()) { while (sum \u003c target \u0026\u0026 right \u003c nums.size()) { sum += nums[right++]; } while (sum \u003e= target \u0026\u0026 left \u003c= right) { if (sum \u003e= target) { min_len = min(min_len, right - left); } sum -= nums[left]; left++; } } if (min_len \u003e nums.size()) { return 0; } return min_len; } }; ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum.zh/:3:1","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.长度最小的子数组 (Medium)","uri":"/209.minimum-size-subarray-sum.zh/#滑动窗口-1"},{"categories":["leetcode"],"content":" 3.2 前缀和+二分 cpp class Solution { public: int BSearch(int idx, int target, vector\u003cint\u003e \u0026prefix) { int left = 0, right = idx; // 左闭右开 while (left \u003c right) { int mid = left + (right - left) / 2; if (prefix[mid] \u003c prefix[idx] - target) { left = mid + 1; } else { right = mid; } } return left; } int minSubArrayLen(int target, vector\u003cint\u003e \u0026nums) { // 前缀和 int n = nums.size(); vector\u003cint\u003e prefix(n + 1, 0); for (int i = 1; i \u003c= nums.size(); i++) { prefix[i] = prefix[i - 1] + nums[i - 1]; } // 二分查找 int res = n + 1; for (int i = 1; i \u003c= n; i++) { int j = BSearch(i, target - 1, prefix); if (prefix[i] \u003e= target) { res = std::min(i - j + 1, res); } } if (res == n + 1) { return 0; } return res; } }; ","date":"2023-03-06","objectID":"/209.minimum-size-subarray-sum.zh/:3:2","series":null,"tags":["prefix sum","sliding window","binary search"],"title":"209.长度最小的子数组 (Medium)","uri":"/209.minimum-size-subarray-sum.zh/#前缀和二分-1"},{"categories":[""],"content":" 1 Description2584. Split the Array to Make Coprime Products (Hard) You are given a 0-indexed integer array nums of length n. A split at an index i where 0 \u003c= i \u003c= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime. For example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime. A split at the index i = 2 is not valid because i == n - 1. Return the smallest index i at which the array can be split validly or -1 if there is no such split. Two values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2. Example 1: text Input: nums = [4,7,8,15,3,5] Output: 2 Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i. The only valid split is at index 2. Example 2: text Input: nums = [4,7,15,8,3,5] Output: -1 Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i. There is no valid split. Constraints: n == nums.length 1 \u003c= n \u003c= 10⁴ 1 \u003c= nums[i] \u003c= 10⁶ ","date":"2023-03-06","objectID":"/2584.split-the-array-to-make-coprime-products/:1:0","series":null,"tags":[""],"title":"2584.split the Array to Make Coprime Products","uri":"/2584.split-the-array-to-make-coprime-products/#description"},{"categories":[""],"content":" 2 SolutionPartitioning the array so that the products are mutually prime is essentially letting the numbers on the left and right halves contain different prime factors from each other. Consider the prime factor $i$, i.e., find the indexes of the leftmost and rightmost numbers whose prime factors contain $i$, which then translates into the interval overlap problem. ","date":"2023-03-06","objectID":"/2584.split-the-array-to-make-coprime-products/:2:0","series":null,"tags":[""],"title":"2584.split the Array to Make Coprime Products","uri":"/2584.split-the-array-to-make-coprime-products/#solution"},{"categories":[""],"content":" 3 Code cpp class Solution { public: void get_range(int fac, int idx, unordered_map\u003cint, pair\u003cint, int\u003e\u003e \u0026factor_range) { if (factor_range.find(fac) != factor_range.end()) { factor_range[fac].second = idx; } else { factor_range[fac] = {idx, idx}; } } int findValidSplit(vector\u003cint\u003e \u0026nums) { if (nums.size() \u003c 2) return -1; unordered_map\u003cint, pair\u003cint, int\u003e\u003e factor_range; for (int i = 0; i \u003c nums.size(); ++i) { for (int fac = 2; fac * fac \u003c= nums[i]; fac++) { if (nums[i] % fac == 0) { while (nums[i] % fac == 0) { nums[i] /= fac; } get_range(fac, i, factor_range); } } if (nums[i] \u003e 1) { // 说明nums[i]本身是质数 get_range(nums[i], i, factor_range); } } vector\u003cpair\u003cint, int\u003e\u003e factors; factors.reserve(factor_range.size()); for (auto \u0026range : factor_range) { factors.push_back(range.second); } std::sort(factors.begin(), factors.end()); int left = factors[0].first; int right = factors[0].second; for (int i = 1; i \u003c factors.size(); i++) { if (factors[i].first \u003e right) { return factors[i].first - 1; } else { right = std::max(factors[i].second, right); } } return -1; } }; ","date":"2023-03-06","objectID":"/2584.split-the-array-to-make-coprime-products/:3:0","series":null,"tags":[""],"title":"2584.split the Array to Make Coprime Products","uri":"/2584.split-the-array-to-make-coprime-products/#code"},{"categories":["leetcode"],"content":" 1 问题描述2584. 分割数组使乘积互质 (Medium) 给你一个长度为 n 的整数数组 nums ，下标从 0 开始。 如果在下标 i 处 分割 数组，其中 0 \u003c= i \u003c= n - 2 ，使前 i + 1 个元素的乘积和剩余元素的乘积互质，则认为该分割 有效 。 例如，如果 nums = [2, 3, 3] ，那么在下标 i = 0 处的分割有效，因为 2 和 9 互质，而在下标 i = 1 处的分割无效，因为 6 和 3 不互质。在下标 i = 2 处的分割也无效，因为 i == n - 1 。 返回可以有效分割数组的最小下标 i ，如果不存在有效分割，则返回 -1 。 当且仅当 gcd(val1, val2) == 1 成立时， val1 和 val2 这两个值才是互质的，其中 gcd(val1, val2) 表示 val1 和 val2 的最大公约数。 示例 1： text 输入：nums = [4,7,8,15,3,5] 输出：2 解释：上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。 唯一一个有效分割位于下标 2 。 示例 2： text 输入：nums = [4,7,15,8,3,5] 输出：-1 解释：上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。 不存在有效分割。 提示： n == nums.length 1 \u003c= n \u003c= 10⁴ 1 \u003c= nums[i] \u003c= 10⁶ ","date":"2023-03-06","objectID":"/2584.split-the-array-to-make-coprime-products.zh/:1:0","series":null,"tags":["math","hash table"],"title":"2584.分割数组使乘积互质 (Medium)","uri":"/2584.split-the-array-to-make-coprime-products.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路分割数组使乘积互质，本质上是让左半边和右半边的数所包含的质因子互不相同。考虑质因子$i$，即求质因子包含$i$的最左边的数和最右边的数的索引，然后转化为区间重叠问题； 这里要注意质因子的$O(\\log n)$求法，可参照C++质因子分解 ","date":"2023-03-06","objectID":"/2584.split-the-array-to-make-coprime-products.zh/:2:0","series":null,"tags":["math","hash table"],"title":"2584.分割数组使乘积互质 (Medium)","uri":"/2584.split-the-array-to-make-coprime-products.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: void get_range(int fac, int idx, unordered_map\u003cint, pair\u003cint, int\u003e\u003e \u0026factor_range) { if (factor_range.find(fac) != factor_range.end()) { factor_range[fac].second = idx; } else { factor_range[fac] = {idx, idx}; } } int findValidSplit(vector\u003cint\u003e \u0026nums) { if (nums.size() \u003c 2) return -1; unordered_map\u003cint, pair\u003cint, int\u003e\u003e factor_range; for (int i = 0; i \u003c nums.size(); ++i) { for (int fac = 2; fac * fac \u003c= nums[i]; fac++) { if (nums[i] % fac == 0) { while (nums[i] % fac == 0) { nums[i] /= fac; } get_range(fac, i, factor_range); } } if (nums[i] \u003e 1) { // 说明nums[i]本身是质数 get_range(nums[i], i, factor_range); } } vector\u003cpair\u003cint, int\u003e\u003e factors; factors.reserve(factor_range.size()); for (auto \u0026range : factor_range) { factors.push_back(range.second); } std::sort(factors.begin(), factors.end()); int left = factors[0].first; int right = factors[0].second; for (int i = 1; i \u003c factors.size(); i++) { if (factors[i].first \u003e right) { return factors[i].first - 1; } else { right = std::max(factors[i].second, right); } } return -1; } }; ","date":"2023-03-06","objectID":"/2584.split-the-array-to-make-coprime-products.zh/:3:0","series":null,"tags":["math","hash table"],"title":"2584.分割数组使乘积互质 (Medium)","uri":"/2584.split-the-array-to-make-coprime-products.zh/#代码"},{"categories":["notes"],"content":" 1 朴素算法从$[2, \\sqrt(N)]$进行遍历 cpp vector\u003cint\u003e GetFactor(int N) { vector\u003cint\u003e res; for (int i = 2; i * i \u003c= N; ++i) { if (N % i == 0) { while (N % i == 0) { N /= i; } res.push_back(i); } } if (N != 1) { res.push_back(N); } return res; } ","date":"2023-03-06","objectID":"/prime_factorization.zh/:1:0","series":null,"tags":["math"],"title":"质因数分解","uri":"/prime_factorization.zh/#朴素算法"},{"categories":["notes"],"content":" 2 朴素算法的证明首先证明元素均为 $N$ 的素因数：因为当且仅当 N % i == 0 满足时，result 发生变化：储存 $i$，说明此时 $i$ 能整除 $\\frac{N}{A}$，说明了存在一个数 $p$ 使得 $pi=\\frac{N}{A}$，即 $piA = N$（其中，$A$ 为 $N$ 自身发生变化后遇到 $i$ 时所除的数。我们注意到 result 若在 push $i$ 之前就已经有数了，为 $R_1,,R_2,,\\ldots,,R_n$，那么有 N $=\\frac{N}{R_1^{q_1}\\cdot R_2^{q_2}\\cdot \\cdots \\cdot R_n^{q_n}}$，被除的乘积即为 $A$）。所以 $i$ 为 $N$ 的因子。 其次证明 result 中均为素数。我们假设存在一个在 result 中的合数 $K$，并根据整数基本定理，分解为一个素数序列 $K = K_1^{e_1}\\cdot K_2^{e_2}\\cdot\\cdots\\cdot K_3^{e_3}$，而因为 $K_1 \u003c K$，所以它一定会在 $K$ 之前被遍历到，并令 while(N % k1 == 0) N /= k1，即让 N 没有了素因子 $K_1$，故遍历到 $K$ 时，N 和 $K$ 已经没有了整除关系了。 ","date":"2023-03-06","objectID":"/prime_factorization.zh/:2:0","series":null,"tags":["math"],"title":"质因数分解","uri":"/prime_factorization.zh/#朴素算法的证明"},{"categories":["notes"],"content":" 3 参考1. OI-WIKI 分解质因数 ","date":"2023-03-06","objectID":"/prime_factorization.zh/:3:0","series":null,"tags":["math"],"title":"质因数分解","uri":"/prime_factorization.zh/#参考"},{"categories":["leetcode"],"content":" 1 Description1744. Can You Eat Your Favorite Candy on Your Favorite Day? (Medium) You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. You are also given a 2D array queries where queries[i] = [favoriteTypeᵢ, favoriteDayᵢ, dailyCapᵢ]. You play a game with the following rules: You start eating candies on day 0. You cannot eat any candy of type i unless you have eaten all candies of type i - 1. You must eat at least one candy per day until you have eaten all the candies. Construct a boolean array answer such that answer.length == queries.length and answer[i] is true if you can eat a candy of type favoriteTypeᵢ on day favoriteDayᵢ without eating more than dailyCapᵢ candies on any day, and false otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2. Return the constructed array answer. Example 1: text Input: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]] Output: [true,false,true] Explanation: 1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2. 2- You can eat at most 4 candies each day. If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1. On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2. 3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13. Example 2: text Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] Output: [false,true,true,false,false] Constraints: 1 \u003c= candiesCount.length \u003c= 10⁵ 1 \u003c= candiesCount[i] \u003c= 10⁵ 1 \u003c= queries.length \u003c= 10⁵ queries[i].length == 3 0 \u003c= favoriteTypeᵢ \u003c candiesCount.length 0 \u003c= favoriteDayᵢ \u003c= 10⁹ 1 \u003c= dailyCapᵢ \u003c= 10⁹ ","date":"2023-03-06","objectID":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/:1:0","series":null,"tags":["analog"],"title":"1744.can You Eat Your Favorite Candy on Your Favorite Day","uri":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/#description"},{"categories":["leetcode"],"content":" 2 Solutionanalog ","date":"2023-03-06","objectID":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/:2:0","series":null,"tags":["analog"],"title":"1744.can You Eat Your Favorite Candy on Your Favorite Day","uri":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cbool\u003e canEat(vector\u003cint\u003e \u0026candiesCount, vector\u003cvector\u003cint\u003e\u003e \u0026queries) { vector\u003clong\u003e prefix(candiesCount.size() + 1, 0); vector\u003cbool\u003e ans(queries.size(), 0); for (int i = 1; i \u003c= candiesCount.size(); ++i) { prefix[i] = prefix[i - 1] + candiesCount[i - 1]; } for (int i = 0; i \u003c queries.size(); ++i) { int type = queries[i][0]; int fday = queries[i][1]; int cap = queries[i][2]; if ((long)(fday + 1) * cap \u003c= prefix[type]) { ans[i] = false; } else if (prefix[type + 1] \u003c= fday) { ans[i] = false; } else { ans[i] = true; } } return ans; } }; ","date":"2023-03-06","objectID":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/:3:0","series":null,"tags":["analog"],"title":"1744.can You Eat Your Favorite Candy on Your Favorite Day","uri":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/#code"},{"categories":["leetcode"],"content":" 1 问题描述1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ (Medium) 给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypeᵢ, favoriteDayᵢ, dailyCapᵢ] 。 你按照如下规则进行一场游戏： 你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前， 不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。 请你构建一个布尔型数组 answer ，用以给出 queries 中每一项的对应答案。此数组满足： answer.length == queries.length 。 answer[i] 是 queries[i] 的答案。 answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapᵢ 颗糖果的前提下，你可以在第 favoriteDayᵢ 天吃到第 favoriteTypeᵢ 类糖果；否则 answer[i] 为 false 。 注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。 请你返回得到的数组 answer 。 示例 1： text 输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]] 输出：[true,false,true] 提示： 1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。 2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。 3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。 示例 2： text 输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] 输出：[false,true,true,false,false] 提示： 1 \u003c= candiesCount.length \u003c= 10⁵ 1 \u003c= candiesCount[i] \u003c= 10⁵ 1 \u003c= queries.length \u003c= 10⁵ queries[i].length == 3 0 \u003c= favoriteTypeᵢ \u003c candiesCount.length 0 \u003c= favoriteDayᵢ \u003c= 10⁹ 1 \u003c= dailyCapᵢ \u003c= 10⁹ ","date":"2023-03-06","objectID":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/:1:0","series":null,"tags":["analog"],"title":"1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？ (Medium)","uri":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路见代码注释 ","date":"2023-03-06","objectID":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/:2:0","series":null,"tags":["analog"],"title":"1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？ (Medium)","uri":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cbool\u003e canEat(vector\u003cint\u003e \u0026candiesCount, vector\u003cvector\u003cint\u003e\u003e \u0026queries) { vector\u003clong\u003e prefix(candiesCount.size() + 1, 0); vector\u003cbool\u003e ans(queries.size(), 0); for (int i = 1; i \u003c= candiesCount.size(); ++i) { prefix[i] = prefix[i - 1] + candiesCount[i - 1]; } for (int i = 0; i \u003c queries.size(); ++i) { int type = queries[i][0]; int fday = queries[i][1]; int cap = queries[i][2]; // 要求fday天吃到type， 考虑吃不到的情况 // fday天，就算吃最多，也吃不到type // 假设fday = 6，前面0，1，2，...，5已经吃了6天，type = 4，那么在第六天，一共七天，必须要能吃到type = 4的糖果，说明这七天能吃的糖果要大于prefix[4]（前4种糖果的数量） if ((long)(fday + 1) * cap \u003c= prefix[type]) { ans[i] = false; } else if (prefix[type + 1] \u003c= fday) { // 假设每天只吃1颗，也会提前吃完 // 假设fday=6,type=4，那么前面吃了fday=6个，如果prefix[type+1] \u003c= 6，此时0，1，2，3，4种都吃掉了 // 第6天只能吃type=5了 ans[i] = false; } else { ans[i] = true; } } return ans; } }; ","date":"2023-03-06","objectID":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/:3:0","series":null,"tags":["analog"],"title":"1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？ (Medium)","uri":"/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1653. Minimum Deletions to Make String Balanced (Medium) You are given a string s consisting only of characters 'a' and 'b' . You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i \u003c j and s[i] = 'b' and s[j]= 'a'. Return the minimum number of deletions needed to make sbalanced. Example 1: text Input: s = \"aababbab\" Output: 2 Explanation: You can either: Delete the characters at 0-indexed positions 2 and 6 (\"aababbab\" -\u003e \"aaabbb\"), or Delete the characters at 0-indexed positions 3 and 6 (\"aababbab\" -\u003e \"aabbbb\"). Example 2: text Input: s = \"bbaaaaabb\" Output: 2 Explanation: The only solution is to delete the first two characters. Constraints: 1 \u003c= s.length \u003c= 10⁵ s[i] is 'a' or 'b' . ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced/:1:0","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.minimum deletions to make string balanced","uri":"/1653.minimum-deletions-to-make-string-balanced/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced/:2:0","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.minimum deletions to make string balanced","uri":"/1653.minimum-deletions-to-make-string-balanced/#solution"},{"categories":["leetcode"],"content":" 2.1 enumerating deviding lineWe can enumerate the separator line from $0$ to $n$(the nubmer shows the number of characters of the left hand of the separator line). We can delete the ‘b’ in the left hand of the split line and the ‘a’ in the right hand of the split line. The minimum value of times of deleting characters is the result. ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced/:2:1","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.minimum deletions to make string balanced","uri":"/1653.minimum-deletions-to-make-string-balanced/#enumerating-deviding-line"},{"categories":["leetcode"],"content":" 2.2 dynamic programmingWe denote cnt[i] as the number of ‘b’ of first ith characters, dp[i] as the minimum operations to balance the first ith characters: if s[i - 1] == 'a', cnt[i] = cnt[i - 1], to balance the first i characters, we can delete the ‘a’, then dp[i] = dp[i - 1] + 1 or delete all the ‘b’ in the first ith characters, then dp[i] = cnt[i]. So, dp[i] = min(dp[i - 1] + 1, cnt[i]); if s[i - 1] == 'b', cnt[i] = cnt[i - 1] + 1，dp[i] = dp[i - 1]; ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced/:2:2","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.minimum deletions to make string balanced","uri":"/1653.minimum-deletions-to-make-string-balanced/#dynamic-programming"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced/:3:0","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.minimum deletions to make string balanced","uri":"/1653.minimum-deletions-to-make-string-balanced/#code"},{"categories":["leetcode"],"content":" 3.1 enumerating deviding line cpp class Solution { public: int minimumDeletions(string s) { vector\u003cvector\u003cint\u003e\u003e cnt(s.size() + 1, vector\u003cint\u003e(2, 0)); for (int i = 1; i \u003c= s.size(); ++i) { if (s[i - 1] == 'a') { cnt[i][0] = cnt[i - 1][0] + 1; cnt[i][1] = cnt[i - 1][1]; } else { cnt[i][0] = cnt[i - 1][0]; cnt[i][1] = cnt[i - 1][1] + 1; } } int res = s.size(); for (int i = 0; i \u003c= s.size(); ++i) { res = std::min(res, i - cnt[i][0] + cnt[s.size()][0] - cnt[i][0]); } return res; } }; ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced/:3:1","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.minimum deletions to make string balanced","uri":"/1653.minimum-deletions-to-make-string-balanced/#enumerating-deviding-line-1"},{"categories":["leetcode"],"content":" 3.2 dynamic programming cpp class Solution { public: int minimumDeletions(string s) { int n = s.size(); vector\u003cint\u003e dp(n + 1, 0); vector\u003cint\u003e cnt(n + 1, 0); for (int i = 1; i \u003c= n; ++i) { if (s[i - 1] == 'b') { cnt[i] = cnt[i - 1] + 1; dp[i] = dp[i - 1]; } else { cnt[i] = cnt[i - 1]; dp[i] = std::min(dp[i - 1] + 1, cnt[i]); } } return dp[n]; } }; ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced/:3:2","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.minimum deletions to make string balanced","uri":"/1653.minimum-deletions-to-make-string-balanced/#dynamic-programming-1"},{"categories":["leetcode"],"content":" 1 问题描述1653. 使字符串平衡的最少删除次数 (Medium) 给你一个字符串 s ，它仅包含字符 'a' 和 'b' 。 你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i \u003c j ，且 s[i] = 'b' 的同时 s[j]= 'a' ，此时认为 s 是 平衡 的。 请你返回使 s 平衡 的 最少 删除次数。 示例 1： text 输入：s = \"aababbab\" 输出：2 解释：你可以选择以下任意一种方案： 下标从 0 开始，删除第 2 和第 6 个字符（\"aababbab\" -\u003e \"aaabbb\"）， 下标从 0 开始，删除第 3 和第 6 个字符（\"aababbab\" -\u003e \"aabbbb\"）。 示例 2： text 输入：s = \"bbaaaaabb\" 输出：2 解释：唯一的最优解是删除最前面两个字符。 提示： 1 \u003c= s.length \u003c= 10⁵ s[i] 要么是 'a' 要么是 'b' 。 ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced.zh/:1:0","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.使字符串平衡的最少删除次数 (Medium)","uri":"/1653.minimum-deletions-to-make-string-balanced.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced.zh/:2:0","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.使字符串平衡的最少删除次数 (Medium)","uri":"/1653.minimum-deletions-to-make-string-balanced.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 枚举分割线分割线从0枚举到n(数字表示分割线左侧有多少个字符)，删除分割线左侧的’b’和右侧的’a’，删除次数的最小值即为答案。 ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced.zh/:2:1","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.使字符串平衡的最少删除次数 (Medium)","uri":"/1653.minimum-deletions-to-make-string-balanced.zh/#枚举分割线"},{"categories":["leetcode"],"content":" 2.2 动态规划考虑cnt[i]为前i个字符中’b’的数量，dp[i]为使前i个字符平衡的最小操作数： 当s[i - 1] == 'a'时，cnt[i] = cnt[i - 1]，为了让前i个字符平衡，要么将这个’a’删掉，此时dp[i] = dp[i - 1] + 1，要么直接将前i个字符的的’b’全都删掉，此时dp[i] = cnt[i]；因此有dp[i] = min(dp[i - 1] + 1, cnt[i])； 当s[i - 1] == 'b'时，cnt[i] = cnt[i - 1] + 1，dp[i] = dp[i - 1]； ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced.zh/:2:2","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.使字符串平衡的最少删除次数 (Medium)","uri":"/1653.minimum-deletions-to-make-string-balanced.zh/#动态规划"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced.zh/:3:0","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.使字符串平衡的最少删除次数 (Medium)","uri":"/1653.minimum-deletions-to-make-string-balanced.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 枚举分割线 cpp class Solution { public: int minimumDeletions(string s) { // 两种选择，删掉不符合条件的'a'和删掉不符合条件的'b' // cnt[i][0]表示前i个字符中'a'的数目 vector\u003cvector\u003cint\u003e\u003e cnt(s.size() + 1, vector\u003cint\u003e(2, 0)); for (int i = 1; i \u003c= s.size(); ++i) { if (s[i - 1] == 'a') { cnt[i][0] = cnt[i - 1][0] + 1; cnt[i][1] = cnt[i - 1][1]; } else { cnt[i][0] = cnt[i - 1][0]; cnt[i][1] = cnt[i - 1][1] + 1; } } int res = s.size(); for (int i = 0; i \u003c= s.size(); ++i) { res = std::min(res, i - cnt[i][0] + cnt[s.size()][0] - cnt[i][0]); // 枚举分割线，分割线左侧的'b'全删掉，分割线右侧的'a'全删掉 } return res; } }; ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced.zh/:3:1","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.使字符串平衡的最少删除次数 (Medium)","uri":"/1653.minimum-deletions-to-make-string-balanced.zh/#枚举分割线-1"},{"categories":["leetcode"],"content":" 3.2 动态规划 cpp class Solution { public: int minimumDeletions(string s) { int n = s.size(); vector\u003cint\u003e dp(n + 1, 0); vector\u003cint\u003e cnt(n + 1, 0); // 前n个字符中'b'的数目 for (int i = 1; i \u003c= n; ++i) { if (s[i - 1] == 'b') { cnt[i] = cnt[i - 1] + 1; dp[i] = dp[i - 1]; } else { cnt[i] = cnt[i - 1]; dp[i] = std::min(dp[i - 1] + 1, cnt[i]); } } return dp[n]; } }; ","date":"2023-03-06","objectID":"/1653.minimum-deletions-to-make-string-balanced.zh/:3:2","series":null,"tags":["dynamic programming","prefix sum"],"title":"1653.使字符串平衡的最少删除次数 (Medium)","uri":"/1653.minimum-deletions-to-make-string-balanced.zh/#动态规划-1"},{"categories":["leetcode"],"content":" 1 问题描述154. 寻找旋转排序数组中的最小值 II (Hard) 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 你必须尽可能减少整个过程的操作步骤。 示例 1： text 输入：nums = [1,3,5] 输出：1 示例 2： text 输入：nums = [2,2,2,0,1] 输出：0 提示： n == nums.length 1 \u003c= n \u003c= 5000 -5000 \u003c= nums[i] \u003c= 5000 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶： 这道题与 寻找旋转排序数组中的最小值 类似，但 nums 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？ ","date":"2023-03-04","objectID":"/154.find-minimum-in-rotated-sorted-array-ii.zh/:1:0","series":null,"tags":["binary search"],"title":"154.寻找旋转排序数组中的最小值 II (Hard)","uri":"/154.find-minimum-in-rotated-sorted-array-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路相比153.寻找旋转排序数组中的最小值 (Medium)，这个题多了可能包含重复元素的限制，其实我们要做的只是nums[mid] = nums[r]时，将r--即可； 要明确，左闭右闭的情况下，nums[right + 1] \u003e= target才始终成立，而不是nums[right] \u003e target，nums[left - 1] \u003c target始终成立。 ","date":"2023-03-04","objectID":"/154.find-minimum-in-rotated-sorted-array-ii.zh/:2:0","series":null,"tags":["binary search"],"title":"154.寻找旋转排序数组中的最小值 II (Hard)","uri":"/154.find-minimum-in-rotated-sorted-array-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int findMin(vector\u003cint\u003e \u0026nums) { int n = nums.size(); int left = 0, right = n - 2; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c nums[right + 1]) { // 说明mid \u003e= k right = mid - 1; } else if (nums[mid] == nums[right + 1]) { --right; } else { // 说明mid \u003c k left = mid + 1; } } return nums[left % n]; } }; ","date":"2023-03-04","objectID":"/154.find-minimum-in-rotated-sorted-array-ii.zh/:3:0","series":null,"tags":["binary search"],"title":"154.寻找旋转排序数组中的最小值 II (Hard)","uri":"/154.find-minimum-in-rotated-sorted-array-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description153. Find Minimum in Rotated Sorted Array (Medium) Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. Example 1: text Input: nums = [3,4,5,1,2] Output: 1 Explanation: The original array was [1,2,3,4,5] rotated 3 times. Example 2: text Input: nums = [4,5,6,7,0,1,2] Output: 0 Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times. Example 3: text Input: nums = [11,13,15,17] Output: 11 Explanation: The original array was [11,13,15,17] and it was rotated 4 times. Constraints: n == nums.length 1 \u003c= n \u003c= 5000 -5000 \u003c= nums[i] \u003c= 5000 All the integers of nums are unique. nums is sorted and rotated between 1 and n times. ","date":"2023-03-04","objectID":"/153.find-minimum-in-rotated-sorted-array/:1:0","series":null,"tags":["binary search"],"title":"153.Find Minimum in Rotated Sorted Array (Medium)","uri":"/153.find-minimum-in-rotated-sorted-array/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe array after rotating is like the follow picture: We can use binary search ,int left = 0, right = nums.size(), n = nums.size(), if nusm[mid] \u003c= nums[n - 1], mid \u003e= k; otherwise, mid \u003c k. It also works for special cases. ","date":"2023-03-04","objectID":"/153.find-minimum-in-rotated-sorted-array/:2:0","series":null,"tags":["binary search"],"title":"153.Find Minimum in Rotated Sorted Array (Medium)","uri":"/153.find-minimum-in-rotated-sorted-array/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int findMin(vector\u003cint\u003e \u0026nums) { int n = nums.size(); int left = 0, right = nums.size(); while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c= nums[n - 1]) { // it means `mid \u003e= k` right = mid; } else { // it means `mid \u003c k` left = mid + 1; } } return nums[left % n]; } }; ","date":"2023-03-04","objectID":"/153.find-minimum-in-rotated-sorted-array/:3:0","series":null,"tags":["binary search"],"title":"153.Find Minimum in Rotated Sorted Array (Medium)","uri":"/153.find-minimum-in-rotated-sorted-array/#code"},{"categories":["leetcode"],"content":" 1 问题描述153. 寻找旋转排序数组中的最小值 (Medium) 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 示例 1： text 输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2： text 输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3： text 输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 提示： n == nums.length 1 \u003c= n \u003c= 5000 -5000 \u003c= nums[i] \u003c= 5000 nums 中的所有整数 互不相同 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 ","date":"2023-03-04","objectID":"/153.find-minimum-in-rotated-sorted-array.zh/:1:0","series":null,"tags":["binary search"],"title":"153.寻找旋转排序数组中的最小值 (Medium)","uri":"/153.find-minimum-in-rotated-sorted-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路旋转之后的数组，其形式如下图所示： 考虑使用二分法，int left = 0, right = nums.size(), n = nums.size()，如果nums[mid] \u003c= nums[n - 1]，那就说明mid \u003e= k，否则说明mid \u003c k，因此可以写出二分查找。 特殊情况依然有效。 ","date":"2023-03-04","objectID":"/153.find-minimum-in-rotated-sorted-array.zh/:2:0","series":null,"tags":["binary search"],"title":"153.寻找旋转排序数组中的最小值 (Medium)","uri":"/153.find-minimum-in-rotated-sorted-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int findMin(vector\u003cint\u003e \u0026nums) { int n = nums.size(); int left = 0, right = nums.size(); while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c= nums[n - 1]) { // 说明mid \u003e= k right = mid; } else { // 说明mid \u003c k left = mid + 1; } } return nums[left % n]; } }; ","date":"2023-03-04","objectID":"/153.find-minimum-in-rotated-sorted-array.zh/:3:0","series":null,"tags":["binary search"],"title":"153.寻找旋转排序数组中的最小值 (Medium)","uri":"/153.find-minimum-in-rotated-sorted-array.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description982. Triples with Bitwise AND Equal To Zero (Hard) Given an integer array nums, return the number of AND triples. An AND triple is a triple of indices (i, j, k) such that: 0 \u003c= i \u003c nums.length 0 \u003c= j \u003c nums.length 0 \u003c= k \u003c nums.length nums[i] \u0026 nums[j] \u0026 nums[k] == 0, where \u0026 represents the bitwise-AND operator. Example 1: text Input: nums = [2,1,3] Output: 12 Explanation: We could choose the following i, j, k triples: (i=0, j=0, k=1) : 2 \u0026 2 \u0026 1 (i=0, j=1, k=0) : 2 \u0026 1 \u0026 2 (i=0, j=1, k=1) : 2 \u0026 1 \u0026 1 (i=0, j=1, k=2) : 2 \u0026 1 \u0026 3 (i=0, j=2, k=1) : 2 \u0026 3 \u0026 1 (i=1, j=0, k=0) : 1 \u0026 2 \u0026 2 (i=1, j=0, k=1) : 1 \u0026 2 \u0026 1 (i=1, j=0, k=2) : 1 \u0026 2 \u0026 3 (i=1, j=1, k=0) : 1 \u0026 1 \u0026 2 (i=1, j=2, k=0) : 1 \u0026 3 \u0026 2 (i=2, j=0, k=1) : 3 \u0026 2 \u0026 1 (i=2, j=1, k=0) : 3 \u0026 1 \u0026 2 Example 2: text Input: nums = [0,0,0] Output: 27 Constraints: 1 \u003c= nums.length \u003c= 1000 0 \u003c= nums[i] \u003c 2¹⁶ ","date":"2023-03-04","objectID":"/982.triples-with-bitwise-and-equal-to-zero/:1:0","series":null,"tags":["hash table","daily"],"title":"982.Triples with Bitwise AND Equal To Zero (Hard)","uri":"/982.triples-with-bitwise-and-equal-to-zero/#description"},{"categories":["leetcode"],"content":" 2 SolutionYou can first use the hash table ump to store the result of nums[i] \u0026 nums[j], then with nums[k] by bit, if the result is 0, res += ump[nums[i] \u0026 nums[j]]. Optimization, we view binary as a set, and the ith bit in binary from low to high is 1 to indicate that i is in the set and 0 to indicate that i is not in the set, e.g. $a = 1101_{(2)}$ means that the set $A={0,2,3}$. Then, $a \u0026 b = 0$ i.e., the set $A$ and the set $B$ do not intersect, or $B$ is the set $\\complement_U A$, where $U={0,1,2,… ,15}$, the corresponding number i.e. $0xffff$, and a number isomorphic to $0xffff$ gives the complement of this number. So, the code can be optimized to enumerate the subsets of $m = nums[k]\\oplus 0xffff$. (b) To enumerate the subset $s$ of $m$, one can keep subtracting $s$ from $m$ all the way to 0. If $s \u0026 m = s$, it means that $s$ is a subset of $m$. A more efficient approach is to “jump” directly to the next subset, i.e., $s$ is updated to $(s - 1)\u0026 m$. The correctness of this is that $s-1$ only changes the lowest $1$ of $s$ to $0$ (consider the set corresponding to $s$), and all $0$ lower than this $1$ become $1$, so the next subset, which must be a subset of $s-1$, is obtained by directly $\u0026m$. Finally, when $s=0$, since the binary of $-1$ is all $1$, all $(s-1)\u0026m = m$, so we can determine whether the next subset is back to $m$ to determine whether to exit the loop. Note: This technique is often used in subset state compression DP ","date":"2023-03-04","objectID":"/982.triples-with-bitwise-and-equal-to-zero/:2:0","series":null,"tags":["hash table","daily"],"title":"982.Triples with Bitwise AND Equal To Zero (Hard)","uri":"/982.triples-with-bitwise-and-equal-to-zero/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int countTriplets(vector\u003cint\u003e \u0026nums) { int cnt[1 \u003c\u003c 16]{}; for (int x : nums) for (int y : nums) ++cnt[x \u0026 y]; int ans = 0; for (int m : nums) { m ^= 0xffff; int s = m; do { // including null-\u003e0 ans += cnt[s]; s = (s - 1) \u0026 m; } while (s != m); } return ans; } }; ","date":"2023-03-04","objectID":"/982.triples-with-bitwise-and-equal-to-zero/:3:0","series":null,"tags":["hash table","daily"],"title":"982.Triples with Bitwise AND Equal To Zero (Hard)","uri":"/982.triples-with-bitwise-and-equal-to-zero/#code"},{"categories":["leetcode"],"content":" 1 问题描述982. 按位与为零的三元组 (Hard) 给你一个整数数组 nums ，返回其中 按位与三元组 的数目。 按位与三元组 是由下标 (i, j, k) 组成的三元组，并满足下述全部条件： 0 \u003c= i \u003c nums.length 0 \u003c= j \u003c nums.length 0 \u003c= k \u003c nums.length nums[i] \u0026 nums[j] \u0026 nums[k] == 0 ，其中 \u0026 表示按位与运算符。 示例 1： text 输入：nums = [2,1,3] 输出：12 解释：可以选出如下 i, j, k 三元组： (i=0, j=0, k=1) : 2 \u0026 2 \u0026 1 (i=0, j=1, k=0) : 2 \u0026 1 \u0026 2 (i=0, j=1, k=1) : 2 \u0026 1 \u0026 1 (i=0, j=1, k=2) : 2 \u0026 1 \u0026 3 (i=0, j=2, k=1) : 2 \u0026 3 \u0026 1 (i=1, j=0, k=0) : 1 \u0026 2 \u0026 2 (i=1, j=0, k=1) : 1 \u0026 2 \u0026 1 (i=1, j=0, k=2) : 1 \u0026 2 \u0026 3 (i=1, j=1, k=0) : 1 \u0026 1 \u0026 2 (i=1, j=2, k=0) : 1 \u0026 3 \u0026 2 (i=2, j=0, k=1) : 3 \u0026 2 \u0026 1 (i=2, j=1, k=0) : 3 \u0026 1 \u0026 2 示例 2： text 输入：nums = [0,0,0] 输出：27 提示： 1 \u003c= nums.length \u003c= 1000 0 \u003c= nums[i] \u003c 2¹⁶ ","date":"2023-03-04","objectID":"/982.triples-with-bitwise-and-equal-to-zero.zh/:1:0","series":null,"tags":["hash table","daily"],"title":"982.按位与为零的三元组 (Hard)","uri":"/982.triples-with-bitwise-and-equal-to-zero.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路可以先用哈希表ump存储nums[i] \u0026 nums[j]的结果，再与nums[k]按位与，如果结果为0，res += ump[nums[i] \u0026 nums[j]]。 优化，我们把二进制看成集合，二进制从低到高第i位为1表示i在集合中，为0表示i不在集合中，例如$a = 1101_{(2)}$表示集合$A={0,2,3}$； 那么，$a \u0026 b = 0$即集合$A$和集合$B$没有交集，或者说$B$是集合$\\complement_U A$，这里$U={0,1,2,…,15}$，对应的数字即$0xffff$，一个数异或$0xffff$就能得到这个数的补集； 所以，代码可以优化成枚举$m = nums[k]\\oplus 0xffff$的子集； 要枚举$m$的子集$s$，可以将$s$从$m$不断减一直到0，如果$s \u0026 m = s$，说明$s$是$m$的子集； 更高效的做法是直接“跳到”下一个子集，即$s$更新为$(s - 1)\u0026 m$，这样做的正确性在于，$s-1$只把$s$最低位的$1$改成了$0$（考虑$s$对应的集合），比这个$1$更低的$0$全都变成了$1$，因此下一个子集，一定是$s-1$的子集，直接$\u0026m$，就能得到下一个子集； 最后，当$s=0$时，由于$-1$的二进制全为$1$，所有$(s-1)\u0026m = m$，所以我们可以判断下一个子集是否又回到$m$，来判断是否要退出循环。 注：这一技巧常用于子集状态压缩DP中 ","date":"2023-03-04","objectID":"/982.triples-with-bitwise-and-equal-to-zero.zh/:2:0","series":null,"tags":["hash table","daily"],"title":"982.按位与为零的三元组 (Hard)","uri":"/982.triples-with-bitwise-and-equal-to-zero.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int countTriplets(vector\u003cint\u003e \u0026nums) { int cnt[1 \u003c\u003c 16]{}; for (int x : nums) for (int y : nums) ++cnt[x \u0026 y]; int ans = 0; for (int m : nums) { m ^= 0xffff; int s = m; do { // 枚举 m 的子集（包括空集） ans += cnt[s]; s = (s - 1) \u0026 m; } while (s != m); } return ans; } }; ","date":"2023-03-04","objectID":"/982.triples-with-bitwise-and-equal-to-zero.zh/:3:0","series":null,"tags":["hash table","daily"],"title":"982.按位与为零的三元组 (Hard)","uri":"/982.triples-with-bitwise-and-equal-to-zero.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1223. Dice Roll Simulation (Hard) A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] ( 1-indexed) consecutive times. Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 10⁹ + 7. Two sequences are considered different if at least one element differs from each other. Example 1: text Input: n = 2, rollMax = [1,1,2,2,2,3] Output: 34 Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34. Example 2: text Input: n = 2, rollMax = [1,1,1,1,1,1] Output: 30 Example 3: text Input: n = 3, rollMax = [1,1,1,2,2,3] Output: 181 Constraints: 1 \u003c= n \u003c= 5000 rollMax.length == 6 1 \u003c= rollMax[i] \u003c= 15 ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation/:1:0","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.Dice Roll Simulation (Hard)","uri":"/1223.dice-roll-simulation/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-03-03","objectID":"/1223.dice-roll-simulation/:2:0","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.Dice Roll Simulation (Hard)","uri":"/1223.dice-roll-simulation/#solution"},{"categories":["leetcode"],"content":" 2.1 DPThis problem is obviously a problem of dynamic programming. We denote dp[i][j] as the number of distinct sequences after rolling i times dice and the result of last rolling is j + 1. Obviously, we only need remove the case that last rollMax[j] + 1 rolls are all j. The state transition equation is: if i \u003c= rollMax[j]: $dp[i][j] = \\sum\\limits_{k = 0}^{5} dp[i - 1][k]$ else if i == rollMax[j] + 1: $dp[i][j] = \\sum\\limits_{k = 0}^{5} dp[i - 1][k] - 1$ else: $dp[i][j] = \\sum\\limits_{k = 0}^{5}dp[i - 1][k] - \\sum\\limits_{k = 0, k\\neq j}^{5}dp[i - rollMax[j] - 1][j]$ ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation/:2:1","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.Dice Roll Simulation (Hard)","uri":"/1223.dice-roll-simulation/#dp"},{"categories":["leetcode"],"content":" 2.2 memorized searchHere we consider it backwards from the nth time towards the first, then we have several variables to focus on. idx, the number of dice currently thrown. the number of dice currently thrown minus one, noted as last_num. The maximum number of consecutive numbers after the current number, noted as max_len, for example, $623166$, consider idx = 5, then the maximum number of consecutive is $2$. Here max_len should be divided into equal to rollMax[last_num] and less than rollMax[last_num] to discuss the case, less than then you can continue to choose last_num, and the max_len of the inner recursion is max_len + 1; otherwise, you must choose another number, and the max_len of the inner recursion is set to 1. The result of the current recursion should be taken as the sum of the results of the inner recursion. Boundary condition, when idx == 0, should return 1; The three dimensions of the cache array i.e. idx, last_num, max_len, where max_len \u003c= 15, so the cache array is vector\u003cvector\u003cvector\u003clong\u003e\u003e\u003e cache(n + 1, vector\u003cvector\u003clong\u003e\u003e( 16, vector\u003cvector\u003clong\u003e(6, -1))); ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation/:2:2","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.Dice Roll Simulation (Hard)","uri":"/1223.dice-roll-simulation/#memorized-search"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-03-03","objectID":"/1223.dice-roll-simulation/:3:0","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.Dice Roll Simulation (Hard)","uri":"/1223.dice-roll-simulation/#code"},{"categories":["leetcode"],"content":" 3.1 DP cpp class Solution { public: int dieSimulator(int n, vector\u003cint\u003e \u0026rollMax) { int mod = 1000000007; if (n == 1) return 6; vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(6, 0)); for (int i = 0; i \u003c 6; i++) { dp[0][i] = 1; dp[1][i] = 1; } for (int i = 2; i \u003c= n; i++) { for (int j = 0; j \u003c 6; j++) { if (i \u003c= rollMax[j]) { dp[i][j] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][5]) % mod; } else if (i == rollMax[j] + 1) { int tmp_sum = 0; for (int k = 0; k \u003c 6; k++) { tmp_sum = (tmp_sum + dp[i - 1][k]) % mod; } dp[i][j] = (tmp_sum - 1) % mod; } else { int tmp_sum = 0; int tmp_minus = 0; for (int k = 0; k \u003c 6; k++) { tmp_sum = (tmp_sum + dp[i - 1][k]) % mod; if (k == j) { continue; } tmp_minus = (tmp_minus + dp[i - rollMax[j] - 1][k]) % mod; } dp[i][j] = (tmp_sum - tmp_minus + mod) % mod; } } } int res = 0; for (int j = 0; j \u003c 6; j++) { res = (res + dp[n][j]) % mod; } return res; } }; ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation/:3:1","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.Dice Roll Simulation (Hard)","uri":"/1223.dice-roll-simulation/#dp-1"},{"categories":["leetcode"],"content":" 3.2 memorized search cpp class Solution { public: long dfs(int idx, vector\u003cint\u003e \u0026rollMax, int max_len, int last_num, vector\u003cvector\u003cvector\u003clong\u003e\u003e\u003e \u0026cache, int mod) { if (idx == 0) { return 1; } if (cache[idx][max_len][last_num] \u003e= 0) { return cache[idx][max_len][last_num] % mod; } long res = 0; if (max_len \u003c rollMax[last_num]) { for (int i = 0; i \u003c 6; ++i) { if (i == last_num) { res += dfs(idx - 1, rollMax, max_len + 1, i, cache, mod); res %= mod; } else { res += dfs(idx - 1, rollMax, 1, i, cache, mod); res %= mod; } } } else { for (int i = 0; i \u003c 6; ++i) { if (i != last_num) { res += dfs(idx - 1, rollMax, 1, i, cache, mod); res %= mod; } } } cache[idx][max_len][last_num] = res % mod; return cache[idx][max_len][last_num]; } int dieSimulator(int n, vector\u003cint\u003e \u0026rollMax) { vector\u003cvector\u003cvector\u003clong\u003e\u003e\u003e cache(n + 1, vector\u003cvector\u003clong\u003e\u003e(16, vector\u003clong\u003e(6, -1))); int mod = 1000000007; return dfs(n, rollMax, 0, 6, cache, mod); } }; ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation/:3:2","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.Dice Roll Simulation (Hard)","uri":"/1223.dice-roll-simulation/#memorized-search-1"},{"categories":["leetcode"],"content":" 1 问题描述1223. 掷骰子模拟 (Hard) 有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。 不过我们在使用它时有个约束，就是使得投掷骰子时， 连续 掷出数字 i 的次数不能超过 rollMax[i]（ i 从 1 开始编号）。 现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。 假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。 示例 1： text 输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。 示例 2： text 输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30 示例 3： text 输入：n = 3, rollMax = [1,1,1,2,2,3] 输出：181 提示： 1 \u003c= n \u003c= 5000 rollMax.length == 6 1 \u003c= rollMax[i] \u003c= 15 ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation.zh/:1:0","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.掷骰子模拟 (Hard)","uri":"/1223.dice-roll-simulation.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-03","objectID":"/1223.dice-roll-simulation.zh/:2:0","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.掷骰子模拟 (Hard)","uri":"/1223.dice-roll-simulation.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 动态规划这一题是很明显的动态规划思路，状态定义很好想，状态转移方程也不难确定： 记dp[i][j]为掷i次骰子，最后一次结果为j + 1的可能的组合，要求的答案即dp[n][0] + ... + dp[n][5]，显然，我们只需排除最后rollMax[j] + 1次都是j的情况； 状态转移方程为： if i \u003c= rollMax[j]: $dp[i][j] = \\sum\\limits_{k = 0}^{5} dp[i - 1][k]$ else if i == rollMax[j] + 1: $dp[i][j] = \\sum\\limits_{k = 0}^{5} dp[i - 1][k] - 1$ else: $dp[i][j] = \\sum\\limits_{k = 0}^{5}dp[i - 1][k] - \\sum\\limits_{k = 0, k\\neq j}^{5}dp[i - rollMax[j] - 1][j]$ ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation.zh/:2:1","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.掷骰子模拟 (Hard)","uri":"/1223.dice-roll-simulation.zh/#动态规划"},{"categories":["leetcode"],"content":" 2.2 记忆化搜索这里我们从第n次向第一次倒着考虑，那么我们要关注的几个变量： 当前投掷骰子的次数idx； 当前投掷的骰子数字减一，记为last_num； 当前数字往后的最大连续数量，记为max_len，例如$623166$，考虑idx = 5，那么最大连续数量就是$2$，这里的max_len要分等于rollMax[last_num]和小于rollMax[last_num]的情况来讨论，小于则可以继续选last_num，内层递归的max_len为max_len + 1；否则必须选其他的数，同时内层递归的max_len置1； 当前递归的结果应该取下一层递归的结果之和； 边界条件，当idx == 0时，应该return 1; cache数组的三个维度即idx，last_num，max_len，其中max_len \u003c= 15，所以cache数组为vector\u003cvector\u003cvector\u003clong\u003e\u003e\u003e cache(n + 1, vector\u003cvector\u003clong\u003e\u003e(16, vector\u003clong\u003e(6, -1))); ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation.zh/:2:2","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.掷骰子模拟 (Hard)","uri":"/1223.dice-roll-simulation.zh/#记忆化搜索"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-03-03","objectID":"/1223.dice-roll-simulation.zh/:3:0","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.掷骰子模拟 (Hard)","uri":"/1223.dice-roll-simulation.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 动态规划 cpp class Solution { public: int dieSimulator(int n, vector\u003cint\u003e \u0026rollMax) { int mod = 1000000007; if (n == 1) return 6; vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(6, 0)); for (int i = 0; i \u003c 6; i++) { dp[0][i] = 1; dp[1][i] = 1; } for (int i = 2; i \u003c= n; i++) { for (int j = 0; j \u003c 6; j++) { if (i \u003c= rollMax[j]) { dp[i][j] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][5]) % mod; } else if (i == rollMax[j] + 1) { int tmp_sum = 0; for (int k = 0; k \u003c 6; k++) { tmp_sum = (tmp_sum + dp[i - 1][k]) % mod; } dp[i][j] = (tmp_sum - 1) % mod; } else { int tmp_sum = 0; int tmp_minus = 0; for (int k = 0; k \u003c 6; k++) { tmp_sum = (tmp_sum + dp[i - 1][k]) % mod; if (k == j) { continue; } tmp_minus = (tmp_minus + dp[i - rollMax[j] - 1][k]) % mod; } dp[i][j] = (tmp_sum - tmp_minus + mod) % mod; } } } int res = 0; for (int j = 0; j \u003c 6; j++) { res = (res + dp[n][j]) % mod; } return res; } }; ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation.zh/:3:1","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.掷骰子模拟 (Hard)","uri":"/1223.dice-roll-simulation.zh/#动态规划-1"},{"categories":["leetcode"],"content":" 3.2 记忆化搜索 cpp class Solution { public: long dfs(int idx, vector\u003cint\u003e \u0026rollMax, int max_len, int last_num, vector\u003cvector\u003cvector\u003clong\u003e\u003e\u003e \u0026cache, int mod) { if (idx == 0) { return 1; } if (cache[idx][max_len][last_num] \u003e= 0) { return cache[idx][max_len][last_num] % mod; } long res = 0; if (max_len \u003c rollMax[last_num]) { for (int i = 0; i \u003c 6; ++i) { if (i == last_num) { res += dfs(idx - 1, rollMax, max_len + 1, i, cache, mod); res %= mod; } else { res += dfs(idx - 1, rollMax, 1, i, cache, mod); res %= mod; } } } else { for (int i = 0; i \u003c 6; ++i) { if (i != last_num) { res += dfs(idx - 1, rollMax, 1, i, cache, mod); res %= mod; } } } cache[idx][max_len][last_num] = res % mod; return cache[idx][max_len][last_num]; } int dieSimulator(int n, vector\u003cint\u003e \u0026rollMax) { // 尝试记忆化搜索 vector\u003cvector\u003cvector\u003clong\u003e\u003e\u003e cache(n + 1, vector\u003cvector\u003clong\u003e\u003e(16, vector\u003clong\u003e(6, -1))); int mod = 1000000007; return dfs(n, rollMax, 0, 6, cache, mod); } }; ","date":"2023-03-03","objectID":"/1223.dice-roll-simulation.zh/:3:2","series":null,"tags":["memorized search","dynamic programming"],"title":"1223.掷骰子模拟 (Hard)","uri":"/1223.dice-roll-simulation.zh/#记忆化搜索-1"},{"categories":["leetcode"],"content":" 1 Description552. Student Attendance Record II (Hard) An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: 'A': Absent. 'L': Late. 'P': Present. Any student is eligible for an attendance award if they meet both of the following criteria: The student was absent ( 'A') for strictly fewer than 2 days total. The student was never late ( 'L') for 3 or more consecutive days. Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo `10⁹ 7`. Example 1: text Input: n = 2 Output: 8 Explanation: There are 8 records with length 2 that are eligible for an award: \"PP\", \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\" Only \"AA\" is not eligible because there are 2 absences (there need to be fewer than 2). Example 2: text Input: n = 1 Output: 3 Example 3: text Input: n = 10101 Output: 183236316 Constraints: 1 \u003c= n \u003c= 10⁵ ","date":"2023-03-03","objectID":"/552.student-attendance-record-ii/:1:0","series":null,"tags":["dynamic programming"],"title":"552.Student Attendance Record II (Hard)","uri":"/552.student-attendance-record-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe denote dp2[i][0] as the number of cases of Late on the i + 1th day, dp2[i][1] as the number of cases of Late on the i + 1th day, when there are only two cases: Late and Present. dp2[i][1] = dp2[i - 1][0] + dp2[i - 1][1]; dp2[i][0] = dp2[i - 1][1] + dp2[i - 1][0] - dp2[n - 3][1]; We denote dp[i][0] as the number of cases of Late on the i + 1th day, dp[i][1] as the number of cases of Late on the i + 1th day, dp[i][2] as the number of cases of Absent on the i + 1th day. dp[i][1] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]; dp[i][2] = dp2[i - 1][0] + dp2[i - 1][1]; dp[i][0] = dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][0] - (dp[i - 3][1] + dp[i - 3][2]); ","date":"2023-03-03","objectID":"/552.student-attendance-record-ii/:2:0","series":null,"tags":["dynamic programming"],"title":"552.Student Attendance Record II (Hard)","uri":"/552.student-attendance-record-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int checkRecord(int n) { if (n == 1) return 3; if (n == 2) return 8; if (n == 3) return 19; vector\u003cvector\u003clong long\u003e\u003e dp3(n + 1, vector\u003clong long\u003e(3, 0)); vector\u003cvector\u003clong long\u003e\u003e dp2(n, vector\u003clong long\u003e(2, 0)); int mod = 1000000007; dp2[0][0] = dp2[0][1] = 1; dp2[1][0] = dp2[1][1] = 2; dp2[2][0] = 3; dp2[2][1] = 4; for (int i = 3; i \u003c n; i++) { dp2[i][1] = (dp2[i - 1][0] % mod + dp2[i - 1][1] % mod) % mod; dp2[i][0] = (dp2[i - 1][1] % mod + (dp2[i - 1][0] - dp2[i - 3][1] + mod) % mod) % mod; } dp3[0][1] = dp3[0][0] = dp3[0][2] = 1; dp3[1][0] = 3, dp3[1][1] = 3, dp3[1][2] = 2; dp3[2][0] = 3 + 2 + 3 - 1, dp3[2][1] = 8, dp3[2][2] = 4; for (int i = 1; i \u003c n; i++) { dp3[i][2] = (dp2[i - 1][0] % mod + dp2[i - 1][1] % mod) % mod; } for (int i = 3; i \u003c n; i++) { dp3[i][0] = (dp3[i - 1][1] % mod + dp3[i - 1][2] % mod + (dp3[i - 1][0] - (dp3[i - 3][1] + dp3[i - 3][2]) + mod) % mod) % mod; dp3[i][1] = (dp3[i - 1][1] % mod + dp3[i - 1][0] % mod + dp3[i - 1][2] % mod) % mod; } return (dp3[n - 1][0] + dp3[n - 1][1] + dp3[n - 1][2]) % mod; } }; ","date":"2023-03-03","objectID":"/552.student-attendance-record-ii/:3:0","series":null,"tags":["dynamic programming"],"title":"552.Student Attendance Record II (Hard)","uri":"/552.student-attendance-record-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述552. 学生出勤记录 II (Hard) 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： 'A'：Absent，缺勤 'L'：Late，迟到 'P'：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： 按 总出勤 计，学生缺勤（ 'A'） 严格 少于两天。 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（ 'L'）记录。 给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 10⁹ + 7 取余 的结果。 示例 1： text 输入：n = 2 输出：8 解释： 有 8 种长度为 2 的记录将被视为可奖励： \"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\" 只有\"AA\"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。 示例 2： text 输入：n = 1 输出：3 示例 3： text 输入：n = 10101 输出：183236316 提示： 1 \u003c= n \u003c= 10⁵ ","date":"2023-03-03","objectID":"/552.student-attendance-record-ii.zh/:1:0","series":null,"tags":["dynamic programming"],"title":"552.学生出勤记录 II (Hard)","uri":"/552.student-attendance-record-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-03","objectID":"/552.student-attendance-record-ii.zh/:2:0","series":null,"tags":["dynamic programming"],"title":"552.学生出勤记录 II (Hard)","uri":"/552.student-attendance-record-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 dp思路1考虑dp2[i][0]为只有迟到和到场两种情况下，第i + 1天迟到的情况数，dp2[i][1]为第i + 1天到场的情况数，则递推关系为: dp2[i][1] = dp2[i - 1][0] + dp2[i - 1][1]; dp2[i][0] = dp2[i - 1][1] + dp2[i - 1][0] - dp2[n - 3][1]; 考虑dp[i][0]为第i + 1天迟到的情况数，dp[i][1]为第i + 1天到场的情况数，dp[i][2]为第i + 1天缺席的情况数，则递推关系有： dp[i][1] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]; dp[i][2] = dp2[i - 1][0] + dp2[i - 1][1]; dp[i][0] = dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][0] - (dp[i - 3][1] + dp[i - 3][2]); 注意取模 ","date":"2023-03-03","objectID":"/552.student-attendance-record-ii.zh/:2:1","series":null,"tags":["dynamic programming"],"title":"552.学生出勤记录 II (Hard)","uri":"/552.student-attendance-record-ii.zh/#dp思路1"},{"categories":["leetcode"],"content":" 2.2 dp思路2","date":"2023-03-03","objectID":"/552.student-attendance-record-ii.zh/:2:2","series":null,"tags":["dynamic programming"],"title":"552.学生出勤记录 II (Hard)","uri":"/552.student-attendance-record-ii.zh/#dp思路2"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int checkRecord(int n) { if (n == 1) return 3; if (n == 2) return 8; if (n == 3) return 19; vector\u003cvector\u003clong long\u003e\u003e dp3(n + 1, vector\u003clong long\u003e(3, 0)); vector\u003cvector\u003clong long\u003e\u003e dp2(n, vector\u003clong long\u003e(2, 0)); int mod = 1000000007; // 0表示迟到，1表示到场，2表示缺勤 dp2[0][0] = dp2[0][1] = 1; dp2[1][0] = dp2[1][1] = 2; dp2[2][0] = 3; dp2[2][1] = 4; for (int i = 3; i \u003c n; i++) { dp2[i][1] = (dp2[i - 1][0] % mod + dp2[i - 1][1] % mod) % mod; dp2[i][0] = (dp2[i - 1][1] % mod + (dp2[i - 1][0] - dp2[i - 3][1] + mod) % mod) % mod; } dp3[0][1] = dp3[0][0] = dp3[0][2] = 1; dp3[1][0] = 3, dp3[1][1] = 3, dp3[1][2] = 2; dp3[2][0] = 3 + 2 + 3 - 1, dp3[2][1] = 8, dp3[2][2] = 4; for (int i = 1; i \u003c n; i++) { dp3[i][2] = (dp2[i - 1][0] % mod + dp2[i - 1][1] % mod) % mod; } for (int i = 3; i \u003c n; i++) { dp3[i][0] = (dp3[i - 1][1] % mod + dp3[i - 1][2] % mod + (dp3[i - 1][0] - (dp3[i - 3][1] + dp3[i - 3][2]) + mod) % mod) % mod; dp3[i][1] = (dp3[i - 1][1] % mod + dp3[i - 1][0] % mod + dp3[i - 1][2] % mod) % mod; } return (dp3[n - 1][0] + dp3[n - 1][1] + dp3[n - 1][2]) % mod; } }; ","date":"2023-03-03","objectID":"/552.student-attendance-record-ii.zh/:3:0","series":null,"tags":["dynamic programming"],"title":"552.学生出勤记录 II (Hard)","uri":"/552.student-attendance-record-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1137. N-th Tribonacci Number (Easy) The Tribonacci sequence T is defined as follows: T = 0, T = 1, T = 1, and T = T + T + T for n \u003e= 0. Given n, return the value of T. Example 1: text Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2: text Input: n = 25 Output: 1389537 Constraints: 0 \u003c= n \u003c= 37 The answer is guaranteed to fit within a 32-bit integer, ie. answer \u003c= 2^31 - 1. ","date":"2023-03-03","objectID":"/1137.n-th-tribonacci-number/:1:0","series":null,"tags":["dynamic programming"],"title":"N Th Tribonacci Number","uri":"/1137.n-th-tribonacci-number/#description"},{"categories":["leetcode"],"content":" 2 SolutionDynamic programming, easy ","date":"2023-03-03","objectID":"/1137.n-th-tribonacci-number/:2:0","series":null,"tags":["dynamic programming"],"title":"N Th Tribonacci Number","uri":"/1137.n-th-tribonacci-number/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int tribonacci(int n) { int num0 = 0, num1 = 1, num2 = 1; if (n == 0) { return num0; } if (n == 1) { return num1; } if (n == 2) { return num2; } for (int i = 2; i \u003c= n; i++) { int tmp2 = num2; int tmp = num1; num2 += num0 + num1; num1 = tmp2; num0 = tmp; } return num1; } }; ","date":"2023-03-03","objectID":"/1137.n-th-tribonacci-number/:3:0","series":null,"tags":["dynamic programming"],"title":"N Th Tribonacci Number","uri":"/1137.n-th-tribonacci-number/#code"},{"categories":["leetcode"],"content":" 1 问题描述1137. 第 N 个泰波那契数 (Easy) 泰波那契序列 T 定义如下： T = 0, T = 1, T = 1, 且在 n \u003e= 0 的条件下 T = T + T + T 给你整数 n，请返回第 n 个泰波那契数 T的值。 示例 1： text 输入：n = 4 输出：4 解释： T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 示例 2： text 输入：n = 25 输出：1389537 提示： 0 \u003c= n \u003c= 37 答案保证是一个 32 位整数，即 answer \u003c= 2^31 - 1。 ","date":"2023-03-03","objectID":"/1137.n-th-tribonacci-number.zh/:1:0","series":null,"tags":["dynamic programming"],"title":"第 N 个泰波那契数 (Easy)","uri":"/1137.n-th-tribonacci-number.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路非常简单的动态规划 ","date":"2023-03-03","objectID":"/1137.n-th-tribonacci-number.zh/:2:0","series":null,"tags":["dynamic programming"],"title":"第 N 个泰波那契数 (Easy)","uri":"/1137.n-th-tribonacci-number.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int tribonacci(int n) { int num0 = 0, num1 = 1, num2 = 1; if (n == 0) { return num0; } if (n == 1) { return num1; } if (n == 2) { return num2; } for (int i = 2; i \u003c= n; i++) { int tmp2 = num2; int tmp = num1; num2 += num0 + num1; num1 = tmp2; num0 = tmp; } return num1; } }; ","date":"2023-03-03","objectID":"/1137.n-th-tribonacci-number.zh/:3:0","series":null,"tags":["dynamic programming"],"title":"第 N 个泰波那契数 (Easy)","uri":"/1137.n-th-tribonacci-number.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1487. Making File Names Unique (Medium) Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i]. Since two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique. Return an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it. Example 1: text Input: names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] Output: [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] Explanation: Let's see how the file system creates folder names: \"pes\" --\u003e not assigned before, remains \"pes\" \"fifa\" --\u003e not assigned before, remains \"fifa\" \"gta\" --\u003e not assigned before, remains \"gta\" \"pes(2019)\" --\u003e not assigned before, remains \"pes(2019)\" Example 2: text Input: names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"] Output: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"] Explanation: Let's see how the file system creates folder names: \"gta\" --\u003e not assigned before, remains \"gta\" \"gta(1)\" --\u003e not assigned before, remains \"gta(1)\" \"gta\" --\u003e the name is reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k = 2. it becomes \"gta(2)\" \"avalon\" --\u003e not assigned before, remains \"avalon\" Example 3: text Input: names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"] Output: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"] Explanation: When the last folder is created, the smallest positive valid k is 4, and it becomes \"onepiece(4)\". Constraints: 1 \u003c= names.length \u003c= 5 * 10⁴ 1 \u003c= names[i].length \u003c= 20 names[i] consists of lowercase English letters, digits, and/or round brackets. ","date":"2023-03-03","objectID":"/1487.making-file-names-unique/:1:0","series":null,"tags":["hash table","daily"],"title":"1487.Making File Names Unique (Medium)","uri":"/1487.making-file-names-unique/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use a hash table for processing. unordered_map\u003cstring, int\u003e ump, ump[name] shows the occurrences of the string name. ","date":"2023-03-03","objectID":"/1487.making-file-names-unique/:2:0","series":null,"tags":["hash table","daily"],"title":"1487.Making File Names Unique (Medium)","uri":"/1487.making-file-names-unique/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cstring\u003e getFolderNames(vector\u003cstring\u003e \u0026names) { unordered_map\u003cstring, int\u003e ump; for (auto \u0026name : names) { if (ump.find(name) == ump.end()) { ump[name] = 0; } else { int i = ump[name] + 1; while (ump.find(name + \"(\" + std::to_string(i) + \")\") != ump.end()) { ++i; } ump[name] = i; name += \"(\" + std::to_string(i) + \")\"; ump[name] = 0; } } return names; } }; ","date":"2023-03-03","objectID":"/1487.making-file-names-unique/:3:0","series":null,"tags":["hash table","daily"],"title":"1487.Making File Names Unique (Medium)","uri":"/1487.making-file-names-unique/#code"},{"categories":["leetcode"],"content":" 1 问题描述1487. 保证文件名唯一 (Medium) 给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。 由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。 返回长度为n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。 示例 1： text 输入：names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] 输出：[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] 解释：文件系统将会这样创建文件名： \"pes\" --\u003e 之前未分配，仍为 \"pes\" \"fifa\" --\u003e 之前未分配，仍为 \"fifa\" \"gta\" --\u003e 之前未分配，仍为 \"gta\" \"pes(2019)\" --\u003e 之前未分配，仍为 \"pes(2019)\" 示例 2： text 输入：names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"] 输出：[\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"] 解释：文件系统将会这样创建文件名： \"gta\" --\u003e 之前未分配，仍为 \"gta\" \"gta(1)\" --\u003e 之前未分配，仍为 \"gta(1)\" \"gta\" --\u003e 文件名被占用，系统为该名称添加后缀 (k)，由于 \"gta(1)\" 也被占用，所以 k = 2 。实际创建的文件名为 \"gta(2)\" 。 \"avalon\" --\u003e 之前未分配，仍为 \"avalon\" 示例 3： text 输入：names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"] 输出：[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"] 解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 \"onepiece(4)\"。 示例 4： text 输入：names = [\"wano\",\"wano\",\"wano\",\"wano\"] 输出：[\"wano\",\"wano(1)\",\"wano(2)\",\"wano(3)\"] 解释：每次创建文件夹 \"wano\" 时，只需增加后缀中 k 的值即可。 示例 5： text 输入：names = [\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\"] 输出：[\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\"] 解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。 提示： 1 \u003c= names.length \u003c= 5 * 10^4 1 \u003c= names[i].length \u003c= 20 names[i] 由小写英文字母、数字和/或圆括号组成。 ","date":"2023-03-03","objectID":"/1487.making-file-names-unique.zh/:1:0","series":null,"tags":["hash table","daily"],"title":"1487.保证文件名唯一 (Medium)","uri":"/1487.making-file-names-unique.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用哈希表来处理这个过程，unordered_map\u003cstring, int\u003e ump，ump[name]表示该字符串之前已经出现了ump[name] + 1次。 ","date":"2023-03-03","objectID":"/1487.making-file-names-unique.zh/:2:0","series":null,"tags":["hash table","daily"],"title":"1487.保证文件名唯一 (Medium)","uri":"/1487.making-file-names-unique.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cstring\u003e getFolderNames(vector\u003cstring\u003e \u0026names) { unordered_map\u003cstring, int\u003e ump; for (auto \u0026name : names) { if (ump.find(name) == ump.end()) { ump[name] = 0; } else { int i = ump[name] + 1; while (ump.find(name + \"(\" + std::to_string(i) + \")\") != ump.end()) { ++i; } ump[name] = i; name += \"(\" + std::to_string(i) + \")\"; ump[name] = 0; } } return names; } }; ","date":"2023-03-03","objectID":"/1487.making-file-names-unique.zh/:3:0","series":null,"tags":["hash table","daily"],"title":"1487.保证文件名唯一 (Medium)","uri":"/1487.making-file-names-unique.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description464. Can I Win (Medium) In the “100 game” two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins. What if we change the game so that players cannot re-use integers? For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total \u003e= 100. Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally. Example 1: text Input: maxChoosableInteger = 10, desiredTotal = 11 Output: false Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is \u003e= desiredTotal. Same with other integers chosen by the first player, the second player will always win. Example 2: text Input: maxChoosableInteger = 10, desiredTotal = 0 Output: true Example 3: text Input: maxChoosableInteger = 10, desiredTotal = 1 Output: true Constraints: 1 \u003c= maxChoosableInteger \u003c= 20 0 \u003c= desiredTotal \u003c= 300 ","date":"2023-03-02","objectID":"/464.can-i-win/:1:0","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.Can I Win (Medium)","uri":"/464.can-i-win/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-03-02","objectID":"/464.can-i-win/:2:0","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.Can I Win (Medium)","uri":"/464.can-i-win/#solution"},{"categories":["leetcode"],"content":" 2.1 dfsFirst, let’s think in dfs, if the first player chooses x, for the next player, the desiredTotal becomes desiredTotal - x, and if the second player wins, the first player loses. ","date":"2023-03-02","objectID":"/464.can-i-win/:2:1","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.Can I Win (Medium)","uri":"/464.can-i-win/#dfs"},{"categories":["leetcode"],"content":" 2.2 bitmask + memorized searchSince maxChoosableInteger \u003c= 20, we can use a bit number mask to show the process of choosing numbers. If the ith digit of mask is 1, it means that number i hasn’t been chosen; And we should note that the value of desired_total entirely depends on mask, so the cache vector is cache[mask], not cache[mask][desired_total]. Note the priority of the bit operation, the brackets are required. ","date":"2023-03-02","objectID":"/464.can-i-win/:2:2","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.Can I Win (Medium)","uri":"/464.can-i-win/#bitmask--memorized-search"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool dfs(int desired_total, int cur_total, int bit20, int max_int, unordered_map\u003cint, int\u003e \u0026ump) { if (desired_total \u003c= 0) { return false; } if (bit20 == 0) { return true; } if (ump.find(bit20) != ump.end()) { return ump[bit20]; } bool tmp = false; int cnt = 1; for (int i = max_int - 1; i \u003e= 0; --i) { if ((bit20 \u0026 (1 \u003c\u003c i)) != 0) { // it means `i + 1` hasn't been chosen int mask = (bit20 ^ (1 \u003c\u003c i)); tmp = tmp || (!dfs(desired_total - i - 1, cur_total + i + 1, mask, max_int, ump)); } if (tmp) { ump[bit20] = true; return ump[bit20]; } } ump[bit20] = false; return ump[bit20]; } bool canIWin(int maxChoosableInteger, int desiredTotal) { if (desiredTotal \u003c= maxChoosableInteger) { return true; } if ((maxChoosableInteger + 1) * maxChoosableInteger / 2 \u003c desiredTotal) return false; unordered_map\u003cint, int\u003e ump; int bit20 = (1 \u003c\u003c maxChoosableInteger) - 1; return dfs(desiredTotal, 0, bit20, maxChoosableInteger, ump); } }; ","date":"2023-03-02","objectID":"/464.can-i-win/:3:0","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.Can I Win (Medium)","uri":"/464.can-i-win/#code"},{"categories":["leetcode"],"content":" 1 问题描述464. 我能赢吗 (Medium) 在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过 100 的玩家，即为胜者。 如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？ 例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 \u003e= 100。 给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。 示例 1： text 输入：maxChoosableInteger = 10, desiredTotal = 11 输出：false 解释： 无论第一个玩家选择哪个整数，他都会失败。 第一个玩家可以选择从 1 到 10 的整数。 如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。 第二个玩家可以通过选择整数 10（那么累积和为 11 \u003e= desiredTotal），从而取得胜利. 同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。 示例 2: text 输入：maxChoosableInteger = 10, desiredTotal = 0 输出：true 示例 3: text 输入：maxChoosableInteger = 10, desiredTotal = 1 输出：true 提示: 1 \u003c= maxChoosableInteger \u003c= 20 0 \u003c= desiredTotal \u003c= 300 ","date":"2023-03-02","objectID":"/464.can-i-win.zh/:1:0","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.我能赢吗 (Medium)","uri":"/464.can-i-win.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-02","objectID":"/464.can-i-win.zh/:2:0","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.我能赢吗 (Medium)","uri":"/464.can-i-win.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 dfs首先从递归的角度来思考，（事实上这里博弈的角度并没有那么强），第一个玩家选了x，那么对下一个玩家而言，他的desiredTotal就变成了desiredTotal - x，而如果下一个玩家赢了，那么第一个玩家就输了。 ","date":"2023-03-02","objectID":"/464.can-i-win.zh/:2:1","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.我能赢吗 (Medium)","uri":"/464.can-i-win.zh/#dfs"},{"categories":["leetcode"],"content":" 2.2 状态压缩 + 记忆化搜索首先注意到，这个题中maxChoosableInteger \u003c= 20，因此我们可以用一个最长不超过20位的二进制数mask来表示数的选择过程，如果mask的第i位为1，说明i还没有被选择过，即还能选； 同时我们可以注意到，desired_total的值直接由mask来决定，因为mask的初始值为2^n - 1，所以写cache数组的时候无需加上desired_total的维度； 注意位运算的优先级是很低的，建议加括号。 ","date":"2023-03-02","objectID":"/464.can-i-win.zh/:2:2","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.我能赢吗 (Medium)","uri":"/464.can-i-win.zh/#状态压缩--记忆化搜索"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: // 改写成位运算的形式 bool dfs(int desired_total, int cur_total, int bit20, int max_int, unordered_map\u003cint, int\u003e \u0026ump) { if (desired_total \u003c= 0) { return false; } if (bit20 == 0) { return true; } if (ump.find(bit20) != ump.end()) { return ump[bit20]; } bool tmp = false; int cnt = 1; for (int i = max_int - 1; i \u003e= 0; --i) { if ((bit20 \u0026 (1 \u003c\u003c i)) != 0) { // 说明数i + 1还没有被选 int mask = (bit20 ^ (1 \u003c\u003c i)); tmp = tmp || (!dfs(desired_total - i - 1, cur_total + i + 1, mask, max_int, ump)); } if (tmp) { ump[bit20] = true; return ump[bit20]; } } ump[bit20] = false; return ump[bit20]; } bool canIWin(int maxChoosableInteger, int desiredTotal) { if (desiredTotal \u003c= maxChoosableInteger) { return true; } if ((maxChoosableInteger + 1) * maxChoosableInteger / 2 \u003c desiredTotal) return false; unordered_map\u003cint, int\u003e ump; int bit20 = (1 \u003c\u003c maxChoosableInteger) - 1; return dfs(desiredTotal, 0, bit20, maxChoosableInteger, ump); } }; ","date":"2023-03-02","objectID":"/464.can-i-win.zh/:3:0","series":null,"tags":["dfs","memorized search","bitmask"],"title":"464.我能赢吗 (Medium)","uri":"/464.can-i-win.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description Largest Local Values in a Matrix (Easy) You are given an n x n integer matrix grid. Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that: maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1. In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid. Return the generated matrix. Example 1: text Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] Output: [[9,9],[8,6]] Explanation: The diagram above shows the original matrix and the generated matrix. Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid. Example 2: text Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] Output: [[2,2,2],[2,2,2],[2,2,2]] Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid. Constraints: n == grid.length == grid[i].length 3 \u003c= n \u003c= 100 1 \u003c= grid[i][j] \u003c= 100 ","date":"2023-03-01","objectID":"/2373.largest-local-values-in-a-matrix/:1:0","series":null,"tags":["analog","daily"],"title":"2373.largest local values in a matrix","uri":"/2373.largest-local-values-in-a-matrix/#description"},{"categories":["leetcode"],"content":" 2 SolutionAnalog ","date":"2023-03-01","objectID":"/2373.largest-local-values-in-a-matrix/:2:0","series":null,"tags":["analog","daily"],"title":"2373.largest local values in a matrix","uri":"/2373.largest-local-values-in-a-matrix/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e largestLocal(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { vector\u003cvector\u003cint\u003e\u003e move{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}}; int n = grid.size(); vector\u003cvector\u003cint\u003e\u003e res(n - 2); int max_num = 0; for (int i = 1; i \u003c n - 1; ++i) { for (int j = 1; j \u003c n - 1; ++j) { max_num = grid[i][j]; for (int k = 0; k \u003c 8; k++) { max_num = std::max(max_num, grid[i + move[k][0]][j + move[k][1]]); } res[i - 1].push_back(max_num); } } return res; } }; ","date":"2023-03-01","objectID":"/2373.largest-local-values-in-a-matrix/:3:0","series":null,"tags":["analog","daily"],"title":"2373.largest local values in a matrix","uri":"/2373.largest-local-values-in-a-matrix/#code"},{"categories":["leetcode"],"content":" 1 问题描述2373. 矩阵中的局部最大值 (Easy) 给你一个大小为 n x n 的整数矩阵 grid 。 生成一个大小为 (n - 2) x (n - 2) 的整数矩阵 maxLocal ，并满足： maxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。 换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。 返回生成的矩阵。 示例 1： text 输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] 输出：[[9,9],[8,6]] 解释：原矩阵和生成的矩阵如上图所示。 注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。 示例 2： text 输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] 输出：[[2,2,2],[2,2,2],[2,2,2]] 解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。 提示： n == grid.length == grid[i].length 3 \u003c= n \u003c= 100 1 \u003c= grid[i][j] \u003c= 100 ","date":"2023-03-01","objectID":"/2373.largest-local-values-in-a-matrix.zh/:1:0","series":null,"tags":["analog","daily"],"title":"2373.矩阵中的局部最大值","uri":"/2373.largest-local-values-in-a-matrix.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路模拟即可 ","date":"2023-03-01","objectID":"/2373.largest-local-values-in-a-matrix.zh/:2:0","series":null,"tags":["analog","daily"],"title":"2373.矩阵中的局部最大值","uri":"/2373.largest-local-values-in-a-matrix.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e largestLocal(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { vector\u003cvector\u003cint\u003e\u003e move{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}}; int n = grid.size(); vector\u003cvector\u003cint\u003e\u003e res(n - 2); int max_num = 0; for (int i = 1; i \u003c n - 1; ++i) { for (int j = 1; j \u003c n - 1; ++j) { max_num = grid[i][j]; for (int k = 0; k \u003c 8; k++) { max_num = std::max(max_num, grid[i + move[k][0]][j + move[k][1]]); } res[i - 1].push_back(max_num); } } return res; } }; ","date":"2023-03-01","objectID":"/2373.largest-local-values-in-a-matrix.zh/:3:0","series":null,"tags":["analog","daily"],"title":"2373.矩阵中的局部最大值","uri":"/2373.largest-local-values-in-a-matrix.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1405. Longest Happy String (Medium) A string s is called happy if it satisfies the following conditions: s only contains the letters 'a', 'b', and 'c'. s does not contain any of \"aaa\", \"bbb\", or \"ccc\" as a substring. s contains at most a occurrences of the letter 'a'. s contains at most b occurrences of the letter 'b'. s contains at most c occurrences of the letter 'c'. Given three integers a, b, and c, return the longest possible happy string. If there are multiple longest happy strings, return any of them. If there is no such string, return the empty string \"\". A substring is a contiguous sequence of characters within a string. Example 1: text Input: a = 1, b = 1, c = 7 Output: \"ccaccbcc\" Explanation: \"ccbccacc\" would also be a correct answer. Example 2: text Input: a = 7, b = 1, c = 0 Output: \"aabaa\" Explanation: It is the only correct answer in this case. Constraints: 0 \u003c= a, b, c \u003c= 100 a + b + c \u003e 0 ","date":"2023-03-01","objectID":"/1405.longest-happy-string/:1:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1405.longest happy string","uri":"/1405.longest-happy-string/#description"},{"categories":["leetcode"],"content":" 2 SolutionEach time, we should append the character with the largest amount to s. If the last two characters of s are the same and the character with the largest amount is the same with them, we choose the character with the second largest amount. Note how to set the value of cnt. ","date":"2023-03-01","objectID":"/1405.longest-happy-string/:2:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1405.longest happy string","uri":"/1405.longest-happy-string/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: string longestDiverseString(int a, int b, int c) { pair\u003cchar, int\u003e a_num{'a', a}; pair\u003cchar, int\u003e b_num{'b', b}; pair\u003cchar, int\u003e c_num{'c', c}; auto cmp = [\u0026](pair\u003cchar, int\u003e \u0026p1, pair\u003cchar, int\u003e \u0026p2) { if (p1.second == p2.second) { return p1.first \u003c p2.first; } return p1.second \u003c p2.second; }; priority_queue\u003cpair\u003cchar, int\u003e, vector\u003cpair\u003cchar, int\u003e\u003e, decltype(cmp)\u003e pq(cmp); if (a \u003e 0) pq.push(a_num); if (b \u003e 0) pq.push(b_num); if (c \u003e 0) pq.push(c_num); string res; int cnt = 0; while (!pq.empty() \u0026\u0026 cnt \u003c 3) { auto [letter, num] = pq.top(); pq.pop(); if (cnt == 2 \u0026\u0026 res[res.size() - 1] == letter) { if (pq.empty()) { return res; } auto [letter1, num1] = pq.top(); pq.pop(); res.push_back(letter1); cnt = 1; --num1; if (num1 \u003e 0) { pq.push({letter1, num1}); } pq.push({letter, num}); } else { if (!res.empty() \u0026\u0026 res[res.size() - 1] != letter) { cnt = 1; } else { ++cnt; } res.push_back(letter); --num; if (num \u003e 0) { pq.push({letter, num}); } } } return res; } }; ","date":"2023-03-01","objectID":"/1405.longest-happy-string/:3:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1405.longest happy string","uri":"/1405.longest-happy-string/#code"},{"categories":["leetcode"],"content":" 1 问题描述1405. 最长快乐字符串 (Medium) 如果字符串中不含有任何 'aaa'， 'bbb' 或 'ccc' 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。 给你三个整数 a， b ， c，请你返回 任意一个 满足下列全部条件的字符串 s： s 是一个尽可能长的快乐字符串。 s 中 最多 有 a 个字母 'a'、 b 个字母 'b'、 c 个字母 'c' 。 s 中只含有 'a'、 'b' 、 'c' 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串 \"\"。 示例 1： text 输入：a = 1, b = 1, c = 7 输出：\"ccaccbcc\" 解释：\"ccbccacc\" 也是一种正确答案。 示例 2： text 输入：a = 2, b = 2, c = 1 输出：\"aabbc\" 示例 3： text 输入：a = 7, b = 1, c = 0 输出：\"aabaa\" 解释：这是该测试用例的唯一正确答案。 提示： 0 \u003c= a, b, c \u003c= 100 a + b + c \u003e 0 ","date":"2023-03-01","objectID":"/1405.longest-happy-string.zh/:1:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1405.最长快乐字符串","uri":"/1405.longest-happy-string.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心，即每次选择剩余数量最多的字符加入到字符串中，如果s中最后两个字符都相同，且剩余数量最多的字符与该字符相同，就选择数量次多的那个字符； 注意细节的处理，尤其是cnt的变化。 ","date":"2023-03-01","objectID":"/1405.longest-happy-string.zh/:2:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1405.最长快乐字符串","uri":"/1405.longest-happy-string.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: string longestDiverseString(int a, int b, int c) { pair\u003cchar, int\u003e a_num{'a', a}; pair\u003cchar, int\u003e b_num{'b', b}; pair\u003cchar, int\u003e c_num{'c', c}; auto cmp = [\u0026](pair\u003cchar, int\u003e \u0026p1, pair\u003cchar, int\u003e \u0026p2) { if (p1.second == p2.second) { return p1.first \u003c p2.first; } return p1.second \u003c p2.second; }; priority_queue\u003cpair\u003cchar, int\u003e, vector\u003cpair\u003cchar, int\u003e\u003e, decltype(cmp)\u003e pq(cmp); if (a \u003e 0) pq.push(a_num); if (b \u003e 0) pq.push(b_num); if (c \u003e 0) pq.push(c_num); string res; int cnt = 0; while (!pq.empty() \u0026\u0026 cnt \u003c 3) { auto [letter, num] = pq.top(); pq.pop(); if (cnt == 2 \u0026\u0026 res[res.size() - 1] == letter) { if (pq.empty()) { return res; } auto [letter1, num1] = pq.top(); pq.pop(); res.push_back(letter1); cnt = 1; --num1; if (num1 \u003e 0) { pq.push({letter1, num1}); } pq.push({letter, num}); } else { if (!res.empty() \u0026\u0026 res[res.size() - 1] != letter) { cnt = 1; } else { ++cnt; } res.push_back(letter); --num; if (num \u003e 0) { pq.push({letter, num}); } } } return res; } }; ","date":"2023-03-01","objectID":"/1405.longest-happy-string.zh/:3:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1405.最长快乐字符串","uri":"/1405.longest-happy-string.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题1","date":"2023-03-01","objectID":"/leetcode_error.zh/:1:0","series":null,"tags":["attention","data structure and algorithms"],"title":"Leetcode 常见报错的原因分析","uri":"/leetcode_error.zh/#问题1"},{"categories":["leetcode"],"content":" 1.1 问题描述Line 522: Char 69: runtime error: applying non-zero offset 18446744073709551615 to null pointer (basic_string.h) ","date":"2023-03-01","objectID":"/leetcode_error.zh/:1:1","series":null,"tags":["attention","data structure and algorithms"],"title":"Leetcode 常见报错的原因分析","uri":"/leetcode_error.zh/#问题描述"},{"categories":["leetcode"],"content":" 1.2 报错原因string res = 0 ","date":"2023-03-01","objectID":"/leetcode_error.zh/:1:2","series":null,"tags":["attention","data structure and algorithms"],"title":"Leetcode 常见报错的原因分析","uri":"/leetcode_error.zh/#报错原因"},{"categories":["leetcode"],"content":" 1.3 报错分析这里报错的原因是因为使用了int整型变量来初始化string。 ","date":"2023-03-01","objectID":"/leetcode_error.zh/:1:3","series":null,"tags":["attention","data structure and algorithms"],"title":"Leetcode 常见报错的原因分析","uri":"/leetcode_error.zh/#报错分析"},{"categories":["leetcode"],"content":" 2 AddressSanitizer: stack-overflow栈溢出，通常是由于使用了缺少终止条件的递归调用。 ","date":"2023-03-01","objectID":"/leetcode_error.zh/:2:0","series":null,"tags":["attention","data structure and algorithms"],"title":"Leetcode 常见报错的原因分析","uri":"/leetcode_error.zh/#addresssanitizer-stack-overflow"},{"categories":["leetcode"],"content":" 1 Description403. Frog Jump (Hard) A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones’ positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit. If the frog’s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction. Example 1: text Input: stones = [0,1,3,5,6,8,12,17] Output: true Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone. Example 2: text Input: stones = [0,1,2,3,4,8,9,11] Output: false Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large. Constraints: 2 \u003c= stones.length \u003c= 2000 0 \u003c= stones[i] \u003c= 2³¹ - 1 stones[0] == 0 stones is sorted in a strictly increasing order. ","date":"2023-03-01","objectID":"/403.frog-jump/:1:0","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.frog jump","uri":"/403.frog-jump/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-03-01","objectID":"/403.frog-jump/:2:0","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.frog jump","uri":"/403.frog-jump/#solution"},{"categories":["leetcode"],"content":" 2.1 memorized searchWe use the resutl of dfs(i, k) to indicate whether the frog can arrived at the last stone after jumping k steps from the ith stone: if it can’t arrived at another stone by jumping k steps from the ith stone, return false; otherwise, we denote the index of new stone reached by jumping k steps from the ithe stone as new_idx, if the frog can reach the last stone by jumping k - 1 or k or k + 1 steps, then the result of dfs(i, k) is true. Boundary condition: if (idx == stones.size() - 1) return true;, andk must not be 0, or return false; ","date":"2023-03-01","objectID":"/403.frog-jump/:2:1","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.frog jump","uri":"/403.frog-jump/#memorized-search"},{"categories":["leetcode"],"content":" 2.2 dynamic programmingWe denote dp[i][k] as whether the ith can be reached by jumping k steps from the pre_idxth stone(pre_idx = ump[stones[i] - k]), the corresponding staet transfer equation is: dp[i] = dp[pre_idx][k] || dp[pre_idx][k - 1] || dp[pre_idx][k + 1]; dp[0][0] = true; ","date":"2023-03-01","objectID":"/403.frog-jump/:2:2","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.frog jump","uri":"/403.frog-jump/#dynamic-programming"},{"categories":["leetcode"],"content":" 2.3 bfsIt’s actually another form of memorized search. The visited array is vector\u003cvector\u003cbool\u003e\u003e visited(stones.size(), vector\u003cbool\u003e(stones.size() + 1, false)); Note update visited when pushing pair into q. ","date":"2023-03-01","objectID":"/403.frog-jump/:2:3","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.frog jump","uri":"/403.frog-jump/#bfs"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-03-01","objectID":"/403.frog-jump/:3:0","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.frog jump","uri":"/403.frog-jump/#code"},{"categories":["leetcode"],"content":" 3.1 memorized search cpp class Solution { public: bool dfs(int start_idx, int mv_step, vector\u003cint\u003e \u0026stones, unordered_map\u003cint, int\u003e \u0026ump, vector\u003cvector\u003cint\u003e\u003e \u0026cache) { if (start_idx == stones.size() - 1) { return true; } if (mv_step \u003c= 0) { return false; } if (ump.find(stones[start_idx] + mv_step) != ump.end()) { if (cache[start_idx][mv_step] \u003e -1) return cache[start_idx][mv_step]; int new_idx = ump[stones[start_idx] + mv_step]; cache[start_idx][mv_step] = dfs(new_idx, mv_step - 1, stones, ump, cache) || dfs(new_idx, mv_step, stones, ump, cache) || dfs(new_idx, mv_step + 1, stones, ump, cache); return cache[start_idx][mv_step]; } return false; } bool canCross(vector\u003cint\u003e \u0026stones) { unordered_map\u003cint, int\u003e ump; for (int i = 0; i \u003c stones.size(); ++i) { ump[stones[i]] = i; } vector\u003cvector\u003cint\u003e\u003e cache(stones.size(), vector\u003cint\u003e(stones.size() + 1, -1)); return dfs(0, 1, stones, ump, cache); } }; ","date":"2023-03-01","objectID":"/403.frog-jump/:3:1","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.frog jump","uri":"/403.frog-jump/#memorized-search-1"},{"categories":["leetcode"],"content":" 3.2 dynamic programming cpp class Solution { public: bool canCross(vector\u003cint\u003e \u0026stones) { unordered_map\u003cint, int\u003e ump; for (int i = 0; i \u003c stones.size(); ++i) { ump[stones[i]] = i; } vector\u003cvector\u003cbool\u003e\u003e dp(stones.size(), vector\u003cbool\u003e(stones.size() + 1, false)); dp[0][0] = true; for (int i = 1; i \u003c stones.size(); ++i) { for (int k = 1; k \u003c= i; ++k) { if (ump.find(stones[i] - k) != ump.end()) { int pre_idx = ump[stones[i] - k]; dp[i][k] = dp[pre_idx][k] || dp[pre_idx][k - 1] || dp[pre_idx][k + 1]; } } } for (int k = 1; k \u003c stones.size(); ++k) { if (dp[stones.size() - 1][k]) { return true; } } return false; } }; ","date":"2023-03-01","objectID":"/403.frog-jump/:3:2","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.frog jump","uri":"/403.frog-jump/#dynamic-programming-1"},{"categories":["leetcode"],"content":" 3.3 bfs cpp class Solution { public: bool canCross(vector\u003cint\u003e \u0026stones) { if (stones[1] \u003e 1) { return false; } vector\u003cvector\u003cbool\u003e\u003e visited(stones.size(), vector\u003cbool\u003e(stones.size() + 1, false)); visited[1][1] = true; unordered_map\u003cint, int\u003e ump; for (int i = 0; i \u003c stones.size(); ++i) { ump[stones[i]] = i; } queue\u003cpair\u003cint, int\u003e\u003e q; q.push({1, 1}); while (!q.empty()) { auto [idx, mv_step] = q.front(); q.pop(); if (idx == stones.size() - 1) return true; for (int i = mv_step + 1; i \u003e 0 \u0026\u0026 i \u003e= mv_step - 1; --i) { if (ump.find(stones[idx] + i) != ump.end()) { int new_idx = ump[stones[idx] + i]; if (visited[new_idx][i] == false) { visited[new_idx][i] = true; q.push({new_idx, i}); } } } } return false; } }; ","date":"2023-03-01","objectID":"/403.frog-jump/:3:3","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.frog jump","uri":"/403.frog-jump/#bfs-1"},{"categories":["leetcode"],"content":" 1 问题描述403. 青蛙过河 (Hard) 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。 给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、 k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。 示例 1： text 输入：stones = [0,1,3,5,6,8,12,17] 输出：true 解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。 示例 2： text 输入：stones = [0,1,2,3,4,8,9,11] 输出：false 解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。 提示： 2 \u003c= stones.length \u003c= 2000 0 \u003c= stones[i] \u003c= 2³¹ - 1 stones[0] == 0 stones 按严格升序排列 ","date":"2023-03-01","objectID":"/403.frog-jump.zh/:1:0","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-03-01","objectID":"/403.frog-jump.zh/:2:0","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 记忆化搜索我们考虑dfs(i, k)表示从第i个石子跳k步，之后能否到达终点； 如果从第i个石子跳k步，不能到达另一个石子，return false;； 否则，记从第i个石子跳k步到达的新石头的索引为new_idx，那么只要从new_idx跳k + 1, k, k - 1任意一步能到达终点，则dfs(i, k)返回的结果为true。 边界条件if (idx == stones.size() - 1) return true;，同时k不能为0， 为0则return false; ","date":"2023-03-01","objectID":"/403.frog-jump.zh/:2:1","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#记忆化搜索"},{"categories":["leetcode"],"content":" 2.2 动态规划记dp[i][k]为到达从上一个石子处跳k个单位到达第i个石子（注意这里的上一个石子并不一定是第i - 1石子，而是stones[i] - k位置对应的的石子，记该索引为pre_idx = ump[stones[i] - k]），对应的状态转移方程为： dp[i] = dp[pre_idx][k] || dp[pre_idx][k - 1] || dp[pre_idx][k + 1];，这里dp[i][k]应该初始化为false， 同时dp[0][0] = true; ","date":"2023-03-01","objectID":"/403.frog-jump.zh/:2:2","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#动态规划"},{"categories":["leetcode"],"content":" 2.3 bfs其实就是记忆化搜索的翻版，visited数组变成vector\u003cvector\u003cbool\u003e\u003e visited(stones.size(), vector\u003cbool\u003e(stones.size() + 1, false));，分别表示石子坐标和到达该坐标的步数； 注意pair入队时，要更新visited数组 ","date":"2023-03-01","objectID":"/403.frog-jump.zh/:2:3","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#bfs"},{"categories":["leetcode"],"content":" 2.4 bfs","date":"2023-03-01","objectID":"/403.frog-jump.zh/:2:4","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#bfs-1"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-03-01","objectID":"/403.frog-jump.zh/:3:0","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 记忆化搜索 cpp class Solution { public: bool dfs(int start_idx, int mv_step, vector\u003cint\u003e \u0026stones, unordered_map\u003cint, int\u003e \u0026ump, vector\u003cvector\u003cint\u003e\u003e \u0026cache) { if (start_idx == stones.size() - 1) { return true; // ?这里不确定 } if (mv_step \u003c= 0) { return false; } if (ump.find(stones[start_idx] + mv_step) != ump.end()) { if (cache[start_idx][mv_step] \u003e -1) return cache[start_idx][mv_step]; int new_idx = ump[stones[start_idx] + mv_step]; cache[start_idx][mv_step] = dfs(new_idx, mv_step - 1, stones, ump, cache) || dfs(new_idx, mv_step, stones, ump, cache) || dfs(new_idx, mv_step + 1, stones, ump, cache); return cache[start_idx][mv_step]; } return false; } bool canCross(vector\u003cint\u003e \u0026stones) { // 尝试记忆化搜索的写法 unordered_map\u003cint, int\u003e ump; for (int i = 0; i \u003c stones.size(); ++i) { ump[stones[i]] = i; } vector\u003cvector\u003cint\u003e\u003e cache(stones.size(), vector\u003cint\u003e(stones.size() + 1, -1)); return dfs(0, 1, stones, ump, cache); } }; ","date":"2023-03-01","objectID":"/403.frog-jump.zh/:3:1","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#记忆化搜索-1"},{"categories":["leetcode"],"content":" 3.2 动态规划 cpp class Solution { public: bool canCross(vector\u003cint\u003e \u0026stones) { unordered_map\u003cint, int\u003e ump; for (int i = 0; i \u003c stones.size(); ++i) { ump[stones[i]] = i; } // 跳了k步，到达stones[i], dp[i][k]; vector\u003cvector\u003cbool\u003e\u003e dp(stones.size(), vector\u003cbool\u003e(stones.size() + 1, false)); dp[0][0] = true; for (int i = 1; i \u003c stones.size(); ++i) { for (int k = 1; k \u003c= i; ++k) { if (ump.find(stones[i] - k) != ump.end()) { int pre_idx = ump[stones[i] - k]; dp[i][k] = dp[pre_idx][k] || dp[pre_idx][k - 1] || dp[pre_idx][k + 1]; } } } for (int k = 1; k \u003c stones.size(); ++k) { if (dp[stones.size() - 1][k]) { return true; } } return false; } }; ","date":"2023-03-01","objectID":"/403.frog-jump.zh/:3:2","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#动态规划-1"},{"categories":["leetcode"],"content":" 3.3 bfs cpp class Solution { public: bool canCross(vector\u003cint\u003e \u0026stones) { if (stones[1] \u003e 1) { return false; } vector\u003cvector\u003cbool\u003e\u003e visited(stones.size(), vector\u003cbool\u003e(stones.size() + 1, false)); visited[1][1] = true; unordered_map\u003cint, int\u003e ump; for (int i = 0; i \u003c stones.size(); ++i) { ump[stones[i]] = i; } queue\u003cpair\u003cint, int\u003e\u003e q; q.push({1, 1}); while (!q.empty()) { auto [idx, mv_step] = q.front(); q.pop(); if (idx == stones.size() - 1) return true; for (int i = mv_step + 1; i \u003e 0 \u0026\u0026 i \u003e= mv_step - 1; --i) { if (ump.find(stones[idx] + i) != ump.end()) { int new_idx = ump[stones[idx] + i]; if (visited[new_idx][i] == false) { // 说明这个点没有被访问过 visited[new_idx][i] = true; q.push({new_idx, i}); } } } } return false; } }; ","date":"2023-03-01","objectID":"/403.frog-jump.zh/:3:3","series":null,"tags":["bfs","memorized search","dynamic programming"],"title":"403.青蛙过河","uri":"/403.frog-jump.zh/#bfs-2"},{"categories":["leetcode"],"content":" 1 Description524. Longest Word in Dictionary through Deleting (Medium) Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. Example 1: text Input: s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"] Output: \"apple\" Example 2: text Input: s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"] Output: \"a\" Constraints: 1 \u003c= s.length \u003c= 1000 1 \u003c= dictionary.length \u003c= 1000 1 \u003c= dictionary[i].length \u003c= 1000 s and dictionary[i] consist of lowercase English letters. ","date":"2023-02-28","objectID":"/524.longest-word-in-dictionary-through-deleting/:1:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"524.longest word in dictionary through deleting","uri":"/524.longest-word-in-dictionary-through-deleting/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirst, we sort dictionary by the length of string from longest to shortest. For the strings with the same length, the one with the samller lexicographical order comes first. Determining whether the string in dictionary can be obtained by deleting some characters in s can be optimized using double pointers with time complexity $O(n)$, n being the length of s. ","date":"2023-02-28","objectID":"/524.longest-word-in-dictionary-through-deleting/:2:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"524.longest word in dictionary through deleting","uri":"/524.longest-word-in-dictionary-through-deleting/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool IsSub(string \u0026s, string \u0026word) { for (int i = 0, j = 0; j \u003c word.size();) { if (i == s.size()) { return false; } if (s[i] == word[j]) { i++; j++; } else { i++; } } return true; } string findLongestWord(string s, vector\u003cstring\u003e \u0026dictionary) { auto cmp = [\u0026](string \u0026s1, string \u0026s2) { if (s1.size() != s2.size()) { return s1.size() \u003e s2.size(); } return s1 \u003c s2; }; std::sort(dictionary.begin(), dictionary.end(), cmp); for (auto \u0026word : dictionary) { if (IsSub(s, word)) { return word; } } string res; return res; } }; ","date":"2023-02-28","objectID":"/524.longest-word-in-dictionary-through-deleting/:3:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"524.longest word in dictionary through deleting","uri":"/524.longest-word-in-dictionary-through-deleting/#code"},{"categories":["leetcode"],"content":" 1 问题描述524. 通过删除字母匹配到字典里最长单词 (Medium) 给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。 如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。 示例 1： text 输入：s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"] 输出：\"apple\" 示例 2： text 输入：s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"] 输出：\"a\" 提示： 1 \u003c= s.length \u003c= 1000 1 \u003c= dictionary.length \u003c= 1000 1 \u003c= dictionary[i].length \u003c= 1000 s 和 dictionary[i] 仅由小写英文字母组成 ","date":"2023-02-28","objectID":"/524.longest-word-in-dictionary-through-deleting.zh/:1:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"524.通过删除字母匹配到字典里最长单词","uri":"/524.longest-word-in-dictionary-through-deleting.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先将dictionary按长度从大到小排序，相同长度的字符串，字典序小的在前面； 判断dictionary中的字符串是否能通过删除s中的某些字符得到可以利用双指针优化时间复杂度为$O(n)$，n为s的长度。 ","date":"2023-02-28","objectID":"/524.longest-word-in-dictionary-through-deleting.zh/:2:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"524.通过删除字母匹配到字典里最长单词","uri":"/524.longest-word-in-dictionary-through-deleting.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool IsSub(string \u0026s, string \u0026word) { for (int i = 0, j = 0; j \u003c word.size();) { if (i == s.size()) { return false; } if (s[i] == word[j]) { i++; j++; } else { i++; } } return true; } string findLongestWord(string s, vector\u003cstring\u003e \u0026dictionary) { auto cmp = [\u0026](string \u0026s1, string \u0026s2) { if (s1.size() != s2.size()) { return s1.size() \u003e s2.size(); } return s1 \u003c s2; }; std::sort(dictionary.begin(), dictionary.end(), cmp); for (auto \u0026word : dictionary) { if (IsSub(s, word)) { return word; } } string res; return res; } }; ","date":"2023-02-28","objectID":"/524.longest-word-in-dictionary-through-deleting.zh/:3:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"524.通过删除字母匹配到字典里最长单词","uri":"/524.longest-word-in-dictionary-through-deleting.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description179. Largest Number (Medium) Given a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer. Example 1: text Input: nums = [10,2] Output: \"210\" Example 2: text Input: nums = [3,30,34,5,9] Output: \"9534330\" Constraints: 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 10⁹ ","date":"2023-02-28","objectID":"/179.largest-number/:1:0","series":null,"tags":["greedy algorithm"],"title":"179.largest number","uri":"/179.largest-number/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirst, we change the vector\u003cint\u003e to vector\u003cstring\u003e. Then if s1 + s2 \u003e= s2 + s1, make sure that s1 is in front of s2, we sort vector\u003cstring\u003e by the rule. Note the case that all the elements in the array is $0$. ","date":"2023-02-28","objectID":"/179.largest-number/:2:0","series":null,"tags":["greedy algorithm"],"title":"179.largest number","uri":"/179.largest-number/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: string largestNumber(vector\u003cint\u003e \u0026nums) { int sum = 0; for (int i = 0; i \u003c nums.size(); i++) { if (nums[i] != 0) { sum += nums[i]; break; } } if (sum == 0) { return \"0\"; } vector\u003cstring\u003e tmp; for (int \u0026num : nums) { tmp.push_back(std::to_string(num)); } auto cmp = [\u0026](string \u0026s1, string \u0026s2) { return s2 + s1 \u003c= s1 + s2; }; std::sort(tmp.begin(), tmp.end(), cmp); string res; for (auto \u0026s : tmp) { res += s; } return res; } }; ","date":"2023-02-28","objectID":"/179.largest-number/:3:0","series":null,"tags":["greedy algorithm"],"title":"179.largest number","uri":"/179.largest-number/#code"},{"categories":["leetcode"],"content":" 1 问题描述179. 最大数 (Medium) 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。 注意： 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 示例 1： text 输入：nums = [10,2] 输出：\"210\" 示例 2： text 输入：nums = [3,30,34,5,9] 输出：\"9534330\" 提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 10⁹ ","date":"2023-02-28","objectID":"/179.largest-number.zh/:1:0","series":null,"tags":["greedy algorithm"],"title":"179.最大数","uri":"/179.largest-number.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心，将数组转化为字符串数组，然后如果s1 + s2 \u003e= s2 + s1，那么就保证s1一定在s2的前面，利用该规则自定义排序，同时要注意对数组中元素全为0的特殊条件的判断。 ","date":"2023-02-28","objectID":"/179.largest-number.zh/:2:0","series":null,"tags":["greedy algorithm"],"title":"179.最大数","uri":"/179.largest-number.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: string largestNumber(vector\u003cint\u003e \u0026nums) { int sum = 0; for (int i = 0; i \u003c nums.size(); i++) { if (nums[i] != 0) { sum += nums[i]; break; } } // 对数组元素全为0的特殊情况的判断 if (sum == 0) { return \"0\"; } vector\u003cstring\u003e tmp; for (int \u0026num : nums) { tmp.push_back(std::to_string(num)); } // 自定义排序，确保如果s1 + s2 \u003e s2 + s1，那么s1一定在s2前面 auto cmp = [\u0026](string \u0026s1, string \u0026s2) { return s2 + s1 \u003c= s1 + s2; }; std::sort(tmp.begin(), tmp.end(), cmp); string res; for (auto \u0026s : tmp) { res += s; } return res; } }; ","date":"2023-02-28","objectID":"/179.largest-number.zh/:3:0","series":null,"tags":["greedy algorithm"],"title":"179.最大数","uri":"/179.largest-number.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2363. Merge Similar Items (Easy) You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties: items[i] = [valueᵢ, weightᵢ] where valueᵢ represents the value and weightᵢ represents the weight of the ith item. The value of each item in items is unique. Return a 2D integer array retwhere ret[i] = [valueᵢ, weightᵢ],with weightᵢbeing the sum of weights of all items with value valueᵢ. Note: ret should be returned in ascending order by value. Example 1: text Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] Output: [[1,6],[3,9],[4,5]] Explanation: The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6. The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9. The item with value = 4 occurs in items1 with weight = 5, total weight = 5. Therefore, we return [[1,6],[3,9],[4,5]]. Example 2: text Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]] Output: [[1,4],[2,4],[3,4]] Explanation: The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4. The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4. The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. Therefore, we return [[1,4],[2,4],[3,4]]. Example 3: text Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]] Output: [[1,7],[2,4],[7,1]] Explanation: The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. The item with value = 7 occurs in items2 with weight = 1, total weight = 1. Therefore, we return [[1,7],[2,4],[7,1]]. Constraints: 1 \u003c= items1.length, items2.length \u003c= 1000 items1[i].length == items2[i].length == 2 1 \u003c= valueᵢ, weightᵢ \u003c= 1000 Each valueᵢ in items1 is unique. Each valueᵢ in items2 is unique. ","date":"2023-02-28","objectID":"/2363.merge-similar-items/:1:0","series":null,"tags":["hash table","analog","daily"],"title":"2363.merge similar items","uri":"/2363.merge-similar-items/#description"},{"categories":["leetcode"],"content":" 2 SolutionHash table + analog ","date":"2023-02-28","objectID":"/2363.merge-similar-items/:2:0","series":null,"tags":["hash table","analog","daily"],"title":"2363.merge similar items","uri":"/2363.merge-similar-items/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e mergeSimilarItems(vector\u003cvector\u003cint\u003e\u003e \u0026items1, vector\u003cvector\u003cint\u003e\u003e \u0026items2) { unordered_map\u003cint, int\u003e ump; for (auto \u0026vec : items1) { ump[vec[0]] += vec[1]; } for (auto \u0026vec : items2) { ump[vec[0]] += vec[1]; } vector\u003cvector\u003cint\u003e\u003e ret; for (auto \u0026pair : ump) { ret.push_back({pair.first, pair.second}); } std::sort(ret.begin(), ret.end()); return ret; } }; ","date":"2023-02-28","objectID":"/2363.merge-similar-items/:3:0","series":null,"tags":["hash table","analog","daily"],"title":"2363.merge similar items","uri":"/2363.merge-similar-items/#code"},{"categories":["leetcode"],"content":" 1 问题描述2363. 合并相似的物品 (Easy) 给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质： items[i] = [valueᵢ, weightᵢ] 其中 valueᵢ 表示第 i 件物品的 价值 ， weightᵢ 表示第 i 件物品的 重量 。 items 中每件物品的价值都是 唯一的 。 请你返回一个二维数组 ret，其中 ret[i] = [valueᵢ, weightᵢ]， weightᵢ 是所有价值为 valueᵢ 物品的 重量之和 。 注意： ret 应该按价值 升序 排序后返回。 示例 1： text 输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] 输出：[[1,6],[3,9],[4,5]] 解释： value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。 value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。 value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。 所以，我们返回 [[1,6],[3,9],[4,5]] 。 示例 2： text 输入：items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]] 输出：[[1,4],[2,4],[3,4]] 解释： value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。 value = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。 value = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。 所以，我们返回 [[1,4],[2,4],[3,4]] 。 示例 3： text 输入：items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]] 输出：[[1,7],[2,4],[7,1]] 解释： value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。 value = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。 value = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。 所以，我们返回 [[1,7],[2,4],[7,1]] 。 提示： 1 \u003c= items1.length, items2.length \u003c= 1000 items1[i].length == items2[i].length == 2 1 \u003c= valueᵢ, weightᵢ \u003c= 1000 items1 中每个 valueᵢ 都是 唯一的 。 items2 中每个 valueᵢ 都是 唯一的 。 ","date":"2023-02-28","objectID":"/2363.merge-similar-items.zh/:1:0","series":null,"tags":["hash table","analog","daily"],"title":"2363.合并相似的物品","uri":"/2363.merge-similar-items.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路哈希表+模拟 ","date":"2023-02-28","objectID":"/2363.merge-similar-items.zh/:2:0","series":null,"tags":["hash table","analog","daily"],"title":"2363.合并相似的物品","uri":"/2363.merge-similar-items.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e mergeSimilarItems(vector\u003cvector\u003cint\u003e\u003e \u0026items1, vector\u003cvector\u003cint\u003e\u003e \u0026items2) { unordered_map\u003cint, int\u003e ump; for (auto \u0026vec : items1) { ump[vec[0]] += vec[1]; } for (auto \u0026vec : items2) { ump[vec[0]] += vec[1]; } vector\u003cvector\u003cint\u003e\u003e ret; for (auto \u0026pair : ump) { ret.push_back({pair.first, pair.second}); } std::sort(ret.begin(), ret.end()); return ret; } }; ","date":"2023-02-28","objectID":"/2363.merge-similar-items.zh/:3:0","series":null,"tags":["hash table","analog","daily"],"title":"2363.合并相似的物品","uri":"/2363.merge-similar-items.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description765. Couples Holding Hands (Hard) There are n couples sitting in 2n seats arranged in a row and want to hold hands. The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1). Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats. Example 1: text Input: row = [0,2,1,3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person. Example 2: text Input: row = [3,2,0,1] Output: 0 Explanation: All couples are already seated side by side. Constraints: 2n == row.length 2 \u003c= n \u003c= 30 n is even. 0 \u003c= row[i] \u003c 2n All the elements of row are unique. ","date":"2023-02-27","objectID":"/765.couples-holding-hands/:1:0","series":null,"tags":["greedy algorithm","hash table"],"title":"765.couples holding hands","uri":"/765.couples-holding-hands/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe just need traverse i = 0, 2, 4, 6, .... If row[i] is even, swap the index of row[i] + 1 and row[i + 1]; otherwise, swap the index of row[i] - 1 and row[i + 1]. We can use a hash table whose key is row[i] and value is i to analogize the process. ","date":"2023-02-27","objectID":"/765.couples-holding-hands/:2:0","series":null,"tags":["greedy algorithm","hash table"],"title":"765.couples holding hands","uri":"/765.couples-holding-hands/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minSwapsCouples(vector\u003cint\u003e \u0026row) { std::unordered_map\u003cint, int\u003e ump; // key-row[i], value-i for (int i = 0; i \u003c row.size(); i++) { ump[row[i]] = i; } int cnt = 0; for (int i = 0; i \u003c row.size(); i += 2) { if (row[i] % 2 == 0) { if (row[i + 1] != row[i] + 1) { cnt++; int tmp = ump[row[i] + 1]; // original index int tmp_per = row[i + 1]; row[i + 1] = row[i] + 1; row[tmp] = tmp_per; ump[row[i] + 1] = i + 1; ump[tmp_per] = tmp; } } else { if (row[i + 1] != row[i] - 1) { cnt++; int tmp = ump[row[i] - 1]; int tmp_per = row[i + 1]; row[i + 1] = row[i] - 1; row[tmp] = tmp_per; ump[row[i] - 1] = i + 1; ump[tmp_per] = tmp; } } } return cnt; } }; ","date":"2023-02-27","objectID":"/765.couples-holding-hands/:3:0","series":null,"tags":["greedy algorithm","hash table"],"title":"765.couples holding hands","uri":"/765.couples-holding-hands/#code"},{"categories":["leetcode"],"content":" 1 问题描述765. 情侣牵手 (Hard) n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。 人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。 返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次 交换可选择任意两人，让他们站起来交换座位。 示例 1: text 输入: row = [0,2,1,3] 输出: 1 解释: 只需要交换row[1]和row[2]的位置即可。 示例 2: text 输入: row = [3,2,0,1] 输出: 0 解释: 无需交换座位，所有的情侣都已经可以手牵手了。 提示: 2n == row.length 2 \u003c= n \u003c= 30 n 是偶数 0 \u003c= row[i] \u003c 2n row 中所有元素均 无重复 ","date":"2023-02-27","objectID":"/765.couples-holding-hands.zh/:1:0","series":null,"tags":["greedy algorithm","hash table"],"title":"765.情侣牵手","uri":"/765.couples-holding-hands.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路我们只需要遍历i = 0, 2, 4, 6, ...，如果row[i]为偶数，就把row[i] + 1换到row[i + 1]的位置；如果row[i]为奇数，就把row[i] - 1换到row[i + 1]的位置，利用一个row[i]为key，i为value的哈希表和原数组来模拟这个过程。 ","date":"2023-02-27","objectID":"/765.couples-holding-hands.zh/:2:0","series":null,"tags":["greedy algorithm","hash table"],"title":"765.情侣牵手","uri":"/765.couples-holding-hands.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minSwapsCouples(vector\u003cint\u003e \u0026row) { std::unordered_map\u003cint, int\u003e ump; // row[i]为键，i为值 for (int i = 0; i \u003c row.size(); i++) { ump[row[i]] = i; } int cnt = 0; for (int i = 0; i \u003c row.size(); i += 2) { // 应该还是要遍历row才对 if (row[i] % 2 == 0) { // 偶数 if (row[i + 1] != row[i] + 1) { cnt++; int tmp = ump[row[i] + 1]; // 原先的位置 int tmp_per = row[i + 1]; // i + 1座位上原先那个人的id // 交换了row row[i + 1] = row[i] + 1; row[tmp] = tmp_per; // 交换ump ump[row[i] + 1] = i + 1; ump[tmp_per] = tmp; } } else { if (row[i + 1] != row[i] - 1) { cnt++; int tmp = ump[row[i] - 1]; // 原先的位置 int tmp_per = row[i + 1]; // i + 1座位上原先那个人的id // 交换了row row[i + 1] = row[i] - 1; row[tmp] = tmp_per; // 交换ump ump[row[i] - 1] = i + 1; ump[tmp_per] = tmp; } } } return cnt; } }; ","date":"2023-02-27","objectID":"/765.couples-holding-hands.zh/:3:0","series":null,"tags":["greedy algorithm","hash table"],"title":"765.情侣牵手","uri":"/765.couples-holding-hands.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1140. Stone Game II (Medium) Alice and Bob continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. Alice and Bob take turns, with Alice starting first. Initially, M = 1. On each player’s turn, that player can take all the stones in the first X remaining piles, where 1 \u003c= X \u003c= 2M. Then, we set M = max(M, X). The game continues until all the stones have been taken. Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get. Example 1: text Input: piles = [2,7,9,4,4] Output: 10 Explanation: If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. Example 2: text Input: piles = [1,2,3,4,5,100] Output: 104 Constraints: 1 \u003c= piles.length \u003c= 100 1 \u003c= piles[i] \u003c= 10⁴ ","date":"2023-02-27","objectID":"/1140.stone-game-ii/:1:0","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.stone game ii","uri":"/1140.stone-game-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe meaning of playing optimally is if one get first x stones, the number of the other can get is minmum. If this point is noted, we can use memorized search to solve the problem, besides, we need to use suffix sum array. We can transform memorized search to dynamic programming. ","date":"2023-02-27","objectID":"/1140.stone-game-ii/:2:0","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.stone game ii","uri":"/1140.stone-game-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-02-27","objectID":"/1140.stone-game-ii/:3:0","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.stone game ii","uri":"/1140.stone-game-ii/#code"},{"categories":["leetcode"],"content":" 3.1 memorized search cpp class Solution { public: int dfs(int idx_start, int M, vector\u003cint\u003e \u0026postfix, int n, vector\u003cvector\u003cint\u003e\u003e \u0026cach) { if (idx_start \u003e= n) return 0; int minnum = 100001; if (cach[idx_start][M] \u003e= 0) { return cach[idx_start][M]; } for (int i = idx_start + 1; i \u003c= idx_start + 2 * M \u0026\u0026 i \u003c= n; i++) { int tmp = dfs(i, std::max(i - idx_start, M), postfix, n, cach); if (minnum \u003e tmp) { minnum = tmp; } } cach[idx_start][M] = postfix[idx_start] - minnum; return cach[idx_start][M]; } int stoneGameII(vector\u003cint\u003e\u0026 piles) { int n = piles.size(); vector\u003cint\u003e postfix(n + 1, 0); for (int i = n - 1; i \u003e= 0; i--) { postfix[i] = postfix[i + 1] + piles[i]; } vector\u003cvector\u003cint\u003e\u003e cach(n + 1, vector\u003cint\u003e(n, -1)); return dfs(0, 1, postfix, n, cach); } }; ","date":"2023-02-27","objectID":"/1140.stone-game-ii/:3:1","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.stone game ii","uri":"/1140.stone-game-ii/#memorized-search"},{"categories":["leetcode"],"content":" 3.2 Dynamic programming cpp class Solution { public: int stoneGameII(vector\u003cint\u003e \u0026piles) { int n = piles.size(); vector\u003cint\u003e postfix(n + 1, 0); for (int i = n - 1; i \u003e= 0; i--) { postfix[i] = postfix[i + 1] + piles[i]; } vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(n + 1, 0)); for (int i = n - 1; i \u003e= 0; i--) { for (int M = 1; M \u003c= i / 2 + 1; M++) { if (i + 2 * M \u003e= n) { dp[i][M] = postfix[i]; } else { int min_num = INT_MAX; for (int x = 1; x \u003c= 2 * M; x++) { min_num = std::min(min_num, dp[i + x][std::max(M, x)]); } dp[i][M] = postfix[i] - min_num; } } } return dp[0][1]; } }; ","date":"2023-02-27","objectID":"/1140.stone-game-ii/:3:2","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.stone game ii","uri":"/1140.stone-game-ii/#dynamic-programming"},{"categories":["leetcode"],"content":" 1 问题描述1140. 石子游戏 II (Medium) 爱丽丝和鲍勃继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。 爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初， M = 1。 在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 \u003c= X \u003c= 2M。然后，令 M = max(M, X)。 游戏一直持续到所有石子都被拿走。 假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。 示例 1： text 输入：piles = [2,7,9,4,4] 输出：10 解释：如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。 示例 2: text 输入：piles = [1,2,3,4,5,100] 输出：104 提示： 1 \u003c= piles.length \u003c= 100 1 \u003c= piles[i] \u003c= 10⁴ ","date":"2023-02-27","objectID":"/1140.stone-game-ii.zh/:1:0","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.石子游戏 II","uri":"/1140.stone-game-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先这里要明确发挥最佳水平的含义： 如果自己拿了前x块石子之后，对方所能拿到的石子最少，这就是博弈中的发挥最佳水平，对应到dfs，明白了这一点就能写出递归和记忆化搜索，注意这里还需要用到后缀数组。 写出记忆化搜索之后可以改写成动态规划。 ","date":"2023-02-27","objectID":"/1140.stone-game-ii.zh/:2:0","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.石子游戏 II","uri":"/1140.stone-game-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-02-27","objectID":"/1140.stone-game-ii.zh/:3:0","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.石子游戏 II","uri":"/1140.stone-game-ii.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 记忆化搜索 cpp class Solution { public: int dfs(int idx_start, int M, vector\u003cint\u003e \u0026postfix, int n, vector\u003cvector\u003cint\u003e\u003e \u0026cach) { if (idx_start \u003e= n) return 0; int minnum = 100001; if (cach[idx_start][M] \u003e= 0) { return cach[idx_start][M]; } for (int i = idx_start + 1; i \u003c= idx_start + 2 * M \u0026\u0026 i \u003c= n; i++) { // i表示下一个人拿石子的开始位置，所以i至少为idx_start+1 int tmp = dfs(i, std::max(i - idx_start, M), postfix, n, cach); if (minnum \u003e tmp) { minnum = tmp; } } cach[idx_start][M] = postfix[idx_start] - minnum; return cach[idx_start][M]; } int stoneGameII(vector\u003cint\u003e\u0026 piles) { int n = piles.size(); vector\u003cint\u003e postfix(n + 1, 0); for (int i = n - 1; i \u003e= 0; i--) { postfix[i] = postfix[i + 1] + piles[i]; } vector\u003cvector\u003cint\u003e\u003e cach(n + 1, vector\u003cint\u003e(n, -1)); return dfs(0, 1, postfix, n, cach); } }; ","date":"2023-02-27","objectID":"/1140.stone-game-ii.zh/:3:1","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.石子游戏 II","uri":"/1140.stone-game-ii.zh/#记忆化搜索"},{"categories":["leetcode"],"content":" 3.2 动态规划 cpp class Solution { public: int stoneGameII(vector\u003cint\u003e \u0026piles) { int n = piles.size(); vector\u003cint\u003e postfix(n + 1, 0); // 后缀和数组 for (int i = n - 1; i \u003e= 0; i--) { postfix[i] = postfix[i + 1] + piles[i]; } // dp[i][j]表示从坐标`i`开始拿`j`个所能获得的最大石子数 vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(n + 1, 0)); for (int i = n - 1; i \u003e= 0; i--) { for (int M = 1; M \u003c= i / 2 + 1; M++) { if (i + 2 * M \u003e= n) { // 说明可以直接拿走剩余的石子 dp[i][M] = postfix[i]; } else { int min_num = INT_MAX; for (int x = 1; x \u003c= 2 * M; x++) { // 因为从dp[i + x]递推到dp[i]，所以`i`要倒序循环 min_num = std::min(min_num, dp[i + x][std::max(M, x)]); } dp[i][M] = postfix[i] - min_num; } } } return dp[0][1]; } }; ","date":"2023-02-27","objectID":"/1140.stone-game-ii.zh/:3:2","series":null,"tags":["dynamic programming","memorized search"],"title":"1140.石子游戏 II","uri":"/1140.stone-game-ii.zh/#动态规划"},{"categories":["leetcode"],"content":" 1 Description1255. Maximum Score Words Formed by Letters (Hard) Given a list of words, list of single letters (might be repeating) and score of every character. Return the maximum score of any valid set of words formed by using the given letters ( words[i] cannot be used two or more times). It is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', … , 'z' is given by score[0], score[1], … , score[25] respectively. Example 1: text Input: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] Output: 23 Explanation: Score a=1, c=9, d=5, g=3, o=2 Given letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23. Words \"dad\" and \"dog\" only get a score of 21. Example 2: text Input: words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10] Output: 27 Explanation: Score a=4, b=4, c=4, x=5, z=10 Given letters, we can form the words \"ax\" (4+5), \"bx\" (4+5) and \"cx\" (4+5) with a score of 27. Word \"xxxz\" only get a score of 25. Example 3: text Input: words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0] Output: 0 Explanation: Letter \"e\" can only be used once. Constraints: 1 \u003c= words.length \u003c= 14 1 \u003c= words[i].length \u003c= 15 1 \u003c= letters.length \u003c= 100 letters[i].length == 1 score.length == 26 0 \u003c= score[i] \u003c= 10 words[i], letters[i] contains only lower case English letters. ","date":"2023-02-27","objectID":"/1255.maximum-score-words-formed-by-letters/:1:0","series":null,"tags":["dfs"],"title":"1255.maximum score words formed by letters","uri":"/1255.maximum-score-words-formed-by-letters/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use a hash table letters_arr to keep track of the numbers of letters that can be used when backtracking. ","date":"2023-02-27","objectID":"/1255.maximum-score-words-formed-by-letters/:2:0","series":null,"tags":["dfs"],"title":"1255.maximum score words formed by letters","uri":"/1255.maximum-score-words-formed-by-letters/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int dfs(int st_idx, vector\u003cint\u003e \u0026letters_arr, vector\u003cstring\u003e \u0026words, vector\u003cint\u003e \u0026score) { if (st_idx \u003e= words.size()) { return 0; } int maxnum = 0; for (int i = st_idx; i \u003c words.size(); i++) { int total = 0; bool check = true; for (char \u0026c : words[i]) { letters_arr[c - 'a']--; total += score[c - 'a']; if (letters_arr[c - 'a'] \u003c 0) { check = false; } } if (check) { maxnum = std::max(maxnum, total + dfs(i + 1, letters_arr, words, score)); } for (char \u0026c : words[i]) { letters_arr[c - 'a']++; } } return maxnum; } int maxScoreWords(vector\u003cstring\u003e \u0026words, vector\u003cchar\u003e \u0026letters, vector\u003cint\u003e \u0026score) { vector\u003cint\u003e words_arr(26, 0); vector\u003cint\u003e letters_arr(26, 0); for (int i = 0; i \u003c letters.size(); i++) { letters_arr[letters[i] - 'a']++; } // 回溯 return dfs(0, letters_arr, words, score); } }; ","date":"2023-02-27","objectID":"/1255.maximum-score-words-formed-by-letters/:3:0","series":null,"tags":["dfs"],"title":"1255.maximum score words formed by letters","uri":"/1255.maximum-score-words-formed-by-letters/#code"},{"categories":["leetcode"],"content":" 1 问题描述1255. 得分最高的单词集合 (Hard) 你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。 请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。 单词拼写游戏的规则概述如下： 玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。 可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。 单词表 words 中每个单词只能计分（使用）一次。 根据字母得分情况表 score，字母 'a', 'b', 'c', … , 'z' 对应的得分分别为 score[0], score[1], …, score[25]。 本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。 示例 1： text 输入：words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] 输出：23 解释： 字母得分为 a=1, c=9, d=5, g=3, o=2 使用给定的字母表 letters，我们可以拼写单词 \"dad\" (5+1+5)和 \"good\" (3+2+2+5)，得分为 23 。 而单词 \"dad\" 和 \"dog\" 只能得到 21 分。 示例 2： text 输入：words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10] 输出：27 解释： 字母得分为 a=4, b=4, c=4, x=5, z=10 使用给定的字母表 letters，我们可以组成单词 \"ax\" (4+5)， \"bx\" (4+5) 和 \"cx\" (4+5) ，总得分为 27 。 单词 \"xxxz\" 的得分仅为 25 。 示例 3： text 输入：words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0] 输出：0 解释： 字母 \"e\" 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。 提示： 1 \u003c= words.length \u003c= 14 1 \u003c= words[i].length \u003c= 15 1 \u003c= letters.length \u003c= 100 letters[i].length == 1 score.length == 26 0 \u003c= score[i] \u003c= 10 words[i] 和 letters[i] 只包含小写的英文字母。 ","date":"2023-02-27","objectID":"/1255.maximum-score-words-formed-by-letters.zh/:1:0","series":null,"tags":["dfs"],"title":"1255.得分最高的单词集合","uri":"/1255.maximum-score-words-formed-by-letters.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用哈希表letters_arr记录回溯过程中的剩余的字母可用次数变化，回溯即可。 ","date":"2023-02-27","objectID":"/1255.maximum-score-words-formed-by-letters.zh/:2:0","series":null,"tags":["dfs"],"title":"1255.得分最高的单词集合","uri":"/1255.maximum-score-words-formed-by-letters.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int dfs(int st_idx, vector\u003cint\u003e \u0026letters_arr, vector\u003cstring\u003e \u0026words, vector\u003cint\u003e \u0026score) { if (st_idx \u003e= words.size()) { return 0; } int maxnum = 0; for (int i = st_idx; i \u003c words.size(); i++) { int total = 0; bool check = true; for (char \u0026c : words[i]) { letters_arr[c - 'a']--; total += score[c - 'a']; if (letters_arr[c - 'a'] \u003c 0) { check = false; } } if (check) { maxnum = std::max(maxnum, total + dfs(i + 1, letters_arr, words, score)); } for (char \u0026c : words[i]) { letters_arr[c - 'a']++; } } return maxnum; } int maxScoreWords(vector\u003cstring\u003e \u0026words, vector\u003cchar\u003e \u0026letters, vector\u003cint\u003e \u0026score) { vector\u003cint\u003e words_arr(26, 0); vector\u003cint\u003e letters_arr(26, 0); for (int i = 0; i \u003c letters.size(); i++) { letters_arr[letters[i] - 'a']++; } // 回溯 return dfs(0, letters_arr, words, score); } }; ","date":"2023-02-27","objectID":"/1255.maximum-score-words-formed-by-letters.zh/:3:0","series":null,"tags":["dfs"],"title":"1255.得分最高的单词集合","uri":"/1255.maximum-score-words-formed-by-letters.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2170. Minimum Operations to Make the Array Alternating (Medium) You are given a 0-indexed array nums consisting of n positive integers. The array nums is called alternating if: nums[i - 2] == nums[i], where 2 \u003c= i \u003c= n - 1. nums[i - 1] != nums[i], where 1 \u003c= i \u003c= n - 1. In one operation, you can choose an index i and change nums[i] into any positive integer. Return the minimum number of operations required to make the array alternating. Example 1: text Input: nums = [3,1,3,2,4,3] Output: 3 Explanation: One way to make the array alternating is by converting it to [3,1,3,1,3,1]. The number of operations required in this case is 3. It can be proven that it is not possible to make the array alternating in less than 3 operations. Example 2: text Input: nums = [1,2,2,2,2] Output: 2 Explanation: One way to make the array alternating is by converting it to [1,2,1,2,1]. The number of operations required in this case is 2. Note that the array cannot be converted to [2,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array. Constraints: 1 \u003c= nums.length \u003c= 10⁵ 1 \u003c= nums[i] \u003c= 10⁵ ","date":"2023-02-27","objectID":"/2170.minimum-operations-to-make-the-array-alternating/:1:0","series":null,"tags":["greedy algorithm"],"title":"2170.minimum operations to make the array alternating","uri":"/2170.minimum-operations-to-make-the-array-alternating/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can record the two elements with most occurrence in the elements of the odd index of nums and their occurrences respectively, as max_2, max_num2, second_2, second_num2, and the two elements with the most occurrences in the elements of the even index of nums and their occurrences respectively. if max_1 != max_2, res = nums.size() - max_num1 - max_num2; otherwise, res = std::min(nums.size() - max_num1 - second_num2, nums.size() - second_num1 - max_num2). ","date":"2023-02-27","objectID":"/2170.minimum-operations-to-make-the-array-alternating/:2:0","series":null,"tags":["greedy algorithm"],"title":"2170.minimum operations to make the array alternating","uri":"/2170.minimum-operations-to-make-the-array-alternating/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: // map，内部元素为pair\u003cint, int\u003e 数字以及数字出现个数 int minimumOperations(vector\u003cint\u003e \u0026nums) { auto cmp = [\u0026](pair\u003cint, int\u003e \u0026p1, pair\u003cint, int\u003e \u0026p2) { return p1.second \u003c p2.second; }; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq1(cmp); priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq2(cmp); unordered_map\u003cint, int\u003e mp1, mp2; for (int i = 0; i \u003c nums.size(); i += 2) { mp1[nums[i]]++; if (i + 1 \u003c nums.size()) { mp2[nums[i + 1]]++; } } int max_1 = 0, second_1 = 0; int max_num1 = 0, second_num1 = 0; int max_2 = 0, second_2 = 0; int max_num2 = 0, second_num2 = 0; for (auto \u0026p1 : mp1) { if (p1.second \u003e= max_1) { second_1 = max_1; second_num1 = max_num1; max_1 = p1.second; max_num1 = p1.first; } else if (p1.second \u003e= second_1) { second_1 = p1.second; second_num1 = p1.first; } } for (auto \u0026p2 : mp2) { if (p2.second \u003e= max_2) { second_2 = max_2; second_num2 = max_num2; max_2 = p2.second; max_num2 = p2.first; } else if (p2.second \u003e= second_2) { second_2 = p2.second; second_num2 = p2.first; } } if (max_num1 != max_num2) { return nums.size() - max_1 - max_2; } return std::min(nums.size() - max_1 - second_2, nums.size() - max_2 - second_1); } }; ","date":"2023-02-27","objectID":"/2170.minimum-operations-to-make-the-array-alternating/:3:0","series":null,"tags":["greedy algorithm"],"title":"2170.minimum operations to make the array alternating","uri":"/2170.minimum-operations-to-make-the-array-alternating/#code"},{"categories":["leetcode"],"content":" 1 问题描述2170. 使数组变成交替数组的最少操作数 (Medium) 给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。 如果满足下述条件，则数组 nums 是一个 交替数组 ： nums[i - 2] == nums[i] ，其中 2 \u003c= i \u003c= n - 1 。 nums[i - 1] != nums[i] ，其中 1 \u003c= i \u003c= n - 1 。 在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。 返回使数组变成交替数组的 最少操作数 。 示例 1： text 输入：nums = [3,1,3,2,4,3] 输出：3 解释： 使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。 在这种情况下，操作数为 3 。 可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。 示例 2： text 输入：nums = [1,2,2,2,2] 输出：2 解释： 使数组变成交替数组的方法之一是将该数组转换为 [1,2,1,2,1]. 在这种情况下，操作数为 2 。 注意，数组不能转换成 [2,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。 提示： 1 \u003c= nums.length \u003c= 10⁵ 1 \u003c= nums[i] \u003c= 10⁵ ","date":"2023-02-27","objectID":"/2170.minimum-operations-to-make-the-array-alternating.zh/:1:0","series":null,"tags":["greedy algorithm"],"title":"2170.使数组变成交替数组的最少操作数","uri":"/2170.minimum-operations-to-make-the-array-alternating.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心，分别记录nums的奇数索引的元素中出现最多的两个元素及其出现次数，记为max_2, max_num2, second_2, second_num2，以及nums的偶数索引的元素中出现最多的两个元素及其出现次数，记为max_1, max_num1, second_1, second_num1，如果max_1 != max_2，结果res为nums.size() - max_num1 - max_num2，否则res = std::min(nums.size() - max_num1 - second_num2, nums.size() - second_num1 - max_num2)。 ","date":"2023-02-27","objectID":"/2170.minimum-operations-to-make-the-array-alternating.zh/:2:0","series":null,"tags":["greedy algorithm"],"title":"2170.使数组变成交替数组的最少操作数","uri":"/2170.minimum-operations-to-make-the-array-alternating.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: // map，内部元素为pair\u003cint, int\u003e 数字以及数字出现个数 int minimumOperations(vector\u003cint\u003e \u0026nums) { auto cmp = [\u0026](pair\u003cint, int\u003e \u0026p1, pair\u003cint, int\u003e \u0026p2) { return p1.second \u003c p2.second; }; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq1(cmp); priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, decltype(cmp)\u003e pq2(cmp); unordered_map\u003cint, int\u003e mp1, mp2; for (int i = 0; i \u003c nums.size(); i += 2) { mp1[nums[i]]++; if (i + 1 \u003c nums.size()) { mp2[nums[i + 1]]++; } } int max_1 = 0, second_1 = 0; int max_num1 = 0, second_num1 = 0; int max_2 = 0, second_2 = 0; int max_num2 = 0, second_num2 = 0; for (auto \u0026p1 : mp1) { if (p1.second \u003e= max_1) { second_1 = max_1; second_num1 = max_num1; max_1 = p1.second; max_num1 = p1.first; } else if (p1.second \u003e= second_1) { second_1 = p1.second; second_num1 = p1.first; } } for (auto \u0026p2 : mp2) { if (p2.second \u003e= max_2) { second_2 = max_2; second_num2 = max_num2; max_2 = p2.second; max_num2 = p2.first; } else if (p2.second \u003e= second_2) { second_2 = p2.second; second_num2 = p2.first; } } if (max_num1 != max_num2) { return nums.size() - max_1 - max_2; } return std::min(nums.size() - max_1 - second_2, nums.size() - max_2 - second_1); } }; ","date":"2023-02-27","objectID":"/2170.minimum-operations-to-make-the-array-alternating.zh/:3:0","series":null,"tags":["greedy algorithm"],"title":"2170.使数组变成交替数组的最少操作数","uri":"/2170.minimum-operations-to-make-the-array-alternating.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1144. Decrease Elements To Make Array Zigzag (Medium) Given an array nums of integers, a move consists of choosing any element and decreasing it by 1. An array A is a zigzag array if either: Every even-indexed element is greater than adjacent elements, ie. A[0] \u003e A[1] \u003c A[2] \u003e A[3] \u003c A[4] \u003e ... OR, every odd-indexed element is greater than adjacent elements, ie. A[0] \u003c A[1] \u003e A[2] \u003c A[3] \u003e A[4] \u003c ... Return the minimum number of moves to transform the given array nums into a zigzag array. Example 1: text Input: nums = [1,2,3] Output: 2 Explanation: We can decrease 2 to 0 or 3 to 1. Example 2: text Input: nums = [9,6,1,6,2] Output: 4 Constraints: 1 \u003c= nums.length \u003c= 1000 1 \u003c= nums[i] \u003c= 1000 ","date":"2023-02-27","objectID":"/1144.decrease-elements-to-make-array-zigzag/:1:0","series":null,"tags":["greedy algorithm"],"title":"1144.decrease elements to make array zigzag","uri":"/1144.decrease-elements-to-make-array-zigzag/#description"},{"categories":["leetcode"],"content":" 2 SolutionNote that element can only be decreased by 1. Analog by case. ","date":"2023-02-27","objectID":"/1144.decrease-elements-to-make-array-zigzag/:2:0","series":null,"tags":["greedy algorithm"],"title":"1144.decrease elements to make array zigzag","uri":"/1144.decrease-elements-to-make-array-zigzag/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int movesToMakeZigzag(vector\u003cint\u003e \u0026nums) { if (nums.size() == 1) return 0; int cnt2 = 0; for (int i = 1; i \u003c nums.size(); i += 2) { if (i + 1 \u003c nums.size() \u0026\u0026 i - 1 \u003e= 0) { int tmp = std::min(nums[i + 1], nums[i - 1]); if (tmp \u003c= nums[i]) { cnt2 += nums[i] - tmp + 1; } } else if (i + 1 \u003e= nums.size()) { if (nums[i - 1] \u003c= nums[i]) { cnt2 += nums[i] - nums[i - 1] + 1; } } else { if (nums[i + 1] \u003c= nums[i]) { cnt2 += nums[i] - nums[i + 1] + 1; } } } int cnt4 = 0; for (int i = 0; i \u003c nums.size(); i += 2) { if (i + 1 \u003c nums.size() \u0026\u0026 i - 1 \u003e= 0) { int tmp = std::min(nums[i + 1], nums[i - 1]); if (tmp \u003c= nums[i]) { cnt4 += nums[i] - tmp + 1; } } else if (i + 1 \u003e= nums.size()) { if (nums[i - 1] \u003c= nums[i]) { cnt4 += nums[i] - nums[i - 1] + 1; } } else { if (nums[i + 1] \u003c= nums[i]) { cnt4 += nums[i] - nums[i + 1] + 1; } } } return std::min(cnt2, cnt4); } }; ","date":"2023-02-27","objectID":"/1144.decrease-elements-to-make-array-zigzag/:3:0","series":null,"tags":["greedy algorithm"],"title":"1144.decrease elements to make array zigzag","uri":"/1144.decrease-elements-to-make-array-zigzag/#code"},{"categories":["leetcode"],"content":" 1 问题描述1144. 递减元素使数组呈锯齿状 (Medium) 给你一个整数数组 nums，每次 操作 会从中选择一个元素并 将该元素的值减少 1。 如果符合下列情况之一，则数组 A 就是 锯齿数组： 每个偶数索引对应的元素都大于相邻的元素，即 A[0] \u003e A[1] \u003c A[2] \u003e A[3] \u003c A[4] \u003e ... 或者，每个奇数索引对应的元素都大于相邻的元素，即 A[0] \u003c A[1] \u003e A[2] \u003c A[3] \u003e A[4] \u003c ... 返回将数组 nums 转换为锯齿数组所需的最小操作次数。 示例 1： text 输入：nums = [1,2,3] 输出：2 解释：我们可以把 2 递减到 0，或把 3 递减到 1。 示例 2： text 输入：nums = [9,6,1,6,2] 输出：4 提示： 1 \u003c= nums.length \u003c= 1000 1 \u003c= nums[i] \u003c= 1000 ","date":"2023-02-27","objectID":"/1144.decrease-elements-to-make-array-zigzag.zh/:1:0","series":null,"tags":["greedy algorithm"],"title":"1144.递减元素使数组呈锯齿状","uri":"/1144.decrease-elements-to-make-array-zigzag.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先要注意本题只允许递减数字，只需要考虑分别考虑偶数索引满足情况和奇数索引满足情况的情况，模拟即可。 ","date":"2023-02-27","objectID":"/1144.decrease-elements-to-make-array-zigzag.zh/:2:0","series":null,"tags":["greedy algorithm"],"title":"1144.递减元素使数组呈锯齿状","uri":"/1144.decrease-elements-to-make-array-zigzag.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int movesToMakeZigzag(vector\u003cint\u003e \u0026nums) { if (nums.size() == 1) return 0; // 考虑偶数索引大的情况 int cnt2 = 0; for (int i = 1; i \u003c nums.size(); i += 2) { if (i + 1 \u003c nums.size() \u0026\u0026 i - 1 \u003e= 0) { int tmp = std::min(nums[i + 1], nums[i - 1]); if (tmp \u003c= nums[i]) { cnt2 += nums[i] - tmp + 1; } } else if (i + 1 \u003e= nums.size()) { if (nums[i - 1] \u003c= nums[i]) { cnt2 += nums[i] - nums[i - 1] + 1; } } else { if (nums[i + 1] \u003c= nums[i]) { cnt2 += nums[i] - nums[i + 1] + 1; } } } // 考虑奇数索引大的情况 int cnt4 = 0; for (int i = 0; i \u003c nums.size(); i += 2) { if (i + 1 \u003c nums.size() \u0026\u0026 i - 1 \u003e= 0) { int tmp = std::min(nums[i + 1], nums[i - 1]); if (tmp \u003c= nums[i]) { cnt4 += nums[i] - tmp + 1; } } else if (i + 1 \u003e= nums.size()) { if (nums[i - 1] \u003c= nums[i]) { cnt4 += nums[i] - nums[i - 1] + 1; } } else { if (nums[i + 1] \u003c= nums[i]) { cnt4 += nums[i] - nums[i + 1] + 1; } } } return std::min(cnt2, cnt4); } }; ","date":"2023-02-27","objectID":"/1144.decrease-elements-to-make-array-zigzag.zh/:3:0","series":null,"tags":["greedy algorithm"],"title":"1144.递减元素使数组呈锯齿状","uri":"/1144.decrease-elements-to-make-array-zigzag.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description881. Boats to Save People (Medium) You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. Example 1: text Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2: text Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3: text Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Constraints: 1 \u003c= people.length \u003c= 5 * 10⁴ 1 \u003c= people[i] \u003c= limit \u003c= 3 * 10⁴ ","date":"2023-02-25","objectID":"/881.boats-to-save-people/:1:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"881.boats to save people","uri":"/881.boats-to-save-people/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe should pair the heaviest people with the heaviest peole if the sum of their weight is less than limit, or we just let the heaviest people on one boat. ","date":"2023-02-25","objectID":"/881.boats-to-save-people/:2:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"881.boats to save people","uri":"/881.boats-to-save-people/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int numRescueBoats(vector\u003cint\u003e\u0026 people, int limit) { std::sort(people.begin(), people.end()); int left = 0, right = people.size() - 1; int cnt = 0; while (left \u003c= right) { if (people[right] + people[left] \u003c= limit) { cnt++; right--; left++; } else { cnt++; right--; } } return cnt; } }; ","date":"2023-02-25","objectID":"/881.boats-to-save-people/:3:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"881.boats to save people","uri":"/881.boats-to-save-people/#code"},{"categories":["leetcode"],"content":" 1 问题描述881. 救生艇 (Medium) 给定数组 people 。 people[i] 表示第 i 个人的体重 ， 船的数量不限，每艘船可以承载的最大重量为 limit。 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。 返回 承载所有人所需的最小船数 。 示例 1： text 输入：people = [1,2], limit = 3 输出：1 解释：1 艘船载 (1, 2) 示例 2： text 输入：people = [3,2,2,1], limit = 3 输出：3 解释：3 艘船分别载 (1, 2), (2) 和 (3) 示例 3： text 输入：people = [3,5,3,4], limit = 5 输出：4 解释：4 艘船分别载 (3), (3), (4), (5) 提示： 1 \u003c= people.length \u003c= 5 * 10⁴ 1 \u003c= people[i] \u003c= limit \u003c= 3 * 10⁴ ","date":"2023-02-25","objectID":"/881.boats-to-save-people.zh/:1:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"881.救生艇","uri":"/881.boats-to-save-people.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路每次必定选择最轻的的和二者重量和不超过limit的最重的人上船，因此可以将数组排序，然后一左一右双指针向中间遍历。 ","date":"2023-02-25","objectID":"/881.boats-to-save-people.zh/:2:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"881.救生艇","uri":"/881.boats-to-save-people.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int numRescueBoats(vector\u003cint\u003e\u0026 people, int limit) { std::sort(people.begin(), people.end()); int left = 0, right = people.size() - 1; int cnt = 0; while (left \u003c= right) { if (people[right] + people[left] \u003c= limit) { cnt++; right--; left++; } else { cnt++; right--; } } return cnt; } }; ","date":"2023-02-25","objectID":"/881.boats-to-save-people.zh/:3:0","series":null,"tags":["greedy algorithm","two pointers"],"title":"881.救生艇","uri":"/881.boats-to-save-people.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1247. Minimum Swaps to Make Strings Equal (Medium) You are given two strings s1 and s2 of equal length consisting of letters \"x\" and \"y\" only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j]. Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so. Example 1: text Input: s1 = \"xx\", s2 = \"yy\" Output: 1 Explanation: Swap s1[0] and s2[1], s1 = \"yx\", s2 = \"yx\". Example 2: text Input: s1 = \"xy\", s2 = \"yx\" Output: 2 Explanation: Swap s1[0] and s2[0], s1 = \"yy\", s2 = \"xx\". Swap s1[0] and s2[1], s1 = \"xy\", s2 = \"xy\". Note that you cannot swap s1[0] and s1[1] to make s1 equal to \"yx\", cause we can only swap chars in different strings. Example 3: text Input: s1 = \"xx\", s2 = \"xy\" Output: -1 Constraints: 1 \u003c= s1.length, s2.length \u003c= 1000 s1, s2 only contain 'x' or 'y'. ","date":"2023-02-25","objectID":"/1247.minimum-swaps-to-make-strings-equal/:1:0","series":null,"tags":["daily","greedy algorithm"],"title":"1247.minimum swaps to make strings.equal","uri":"/1247.minimum-swaps-to-make-strings-equal/#description"},{"categories":["leetcode"],"content":" 2 Solutionmatch x-y with x-y, y-x with y-x first. ","date":"2023-02-25","objectID":"/1247.minimum-swaps-to-make-strings-equal/:2:0","series":null,"tags":["daily","greedy algorithm"],"title":"1247.minimum swaps to make strings.equal","uri":"/1247.minimum-swaps-to-make-strings-equal/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minimumSwap(string s1, string s2) { int cnt_s1[2] = {0}, cnt_s2[2] = {0}; // cnt_s1[0]表示x,y cnt_s1[1]表示y,x for (int i = 0; i \u003c s1.size(); i++) { if (s1[i] != s2[i]) { if (s1[i] == 'x') { cnt_s1[0]++; } else { cnt_s1[1]++; } } } if ((cnt_s1[0] + cnt_s1[1]) % 2 == 1) { return false; } return (cnt_s1[0] + 1) / 2 + (cnt_s1[1] + 1) / 2; } }; ","date":"2023-02-25","objectID":"/1247.minimum-swaps-to-make-strings-equal/:3:0","series":null,"tags":["daily","greedy algorithm"],"title":"1247.minimum swaps to make strings.equal","uri":"/1247.minimum-swaps-to-make-strings-equal/#code"},{"categories":["leetcode"],"content":" 1 问题描述1247. 交换字符使得字符串相同 (Medium) 有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 \"x\" 和 \"y\"，你需要通过「交换字符」的方式使这两个字符串相同。 每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。 交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。 最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。 示例 1： text 输入：s1 = \"xx\", s2 = \"yy\" 输出：1 解释： 交换 s1[0] 和 s2[1]，得到 s1 = \"yx\"，s2 = \"yx\"。 示例 2： text 输入：s1 = \"xy\", s2 = \"yx\" 输出：2 解释： 交换 s1[0] 和 s2[0]，得到 s1 = \"yy\"，s2 = \"xx\" 。 交换 s1[0] 和 s2[1]，得到 s1 = \"xy\"，s2 = \"xy\" 。 注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 \"yx\"，因为我们只能交换属于两个不同字符串的字符。 示例 3： text 输入：s1 = \"xx\", s2 = \"xy\" 输出：-1 示例 4： text 输入：s1 = \"xxyyxyxyxx\", s2 = \"xyyxyxxxyx\" 输出：4 提示： 1 \u003c= s1.length, s2.length \u003c= 1000 s1, s2 只包含 'x' 或 'y'。 ","date":"2023-02-25","objectID":"/1247.minimum-swaps-to-make-strings-equal.zh/:1:0","series":null,"tags":["daily","greedy algorithm"],"title":"1247.交换字符使得字符串相同","uri":"/1247.minimum-swaps-to-make-strings-equal.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路我们可以忽略s1[i]和s2[i]相同的情况，只需要统计x-y和y-x的情况，如果x-y和y-x的数量之和为奇数，说明无法通过替换使字符串相等；由于两个x-y只需要一次替换就能相等，因此我们优先让x-y内部替换，y-x内部替换，剩下的一个x-y和y-x替换。 ","date":"2023-02-25","objectID":"/1247.minimum-swaps-to-make-strings-equal.zh/:2:0","series":null,"tags":["daily","greedy algorithm"],"title":"1247.交换字符使得字符串相同","uri":"/1247.minimum-swaps-to-make-strings-equal.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minimumSwap(string s1, string s2) { int cnt_s1[2] = {0}, cnt_s2[2] = {0}; // cnt_s1[0]表示x,y cnt_s1[1]表示y,x for (int i = 0; i \u003c s1.size(); i++) { if (s1[i] != s2[i]) { if (s1[i] == 'x') { cnt_s1[0]++; } else { cnt_s1[1]++; } } } if ((cnt_s1[0] + cnt_s1[1]) % 2 == 1) { return false; } return (cnt_s1[0] + 1) / 2 + (cnt_s1[1] + 1) / 2; } }; ","date":"2023-02-25","objectID":"/1247.minimum-swaps-to-make-strings-equal.zh/:3:0","series":null,"tags":["daily","greedy algorithm"],"title":"1247.交换字符使得字符串相同","uri":"/1247.minimum-swaps-to-make-strings-equal.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述312. 戳气球 (Hard) 有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1 或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。 求所能获得硬币的最大数量。 示例 1： text 输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8] --\u003e [3,5,8] --\u003e [3,8] --\u003e [8] --\u003e [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 示例 2： text 输入：nums = [1,5] 输出：10 提示： n == nums.length 1 \u003c= n \u003c= 300 0 \u003c= nums[i] \u003c= 100 ","date":"2023-02-24","objectID":"/312.burst-balloons.zh/:1:0","series":null,"tags":["dynamic programming","memorized search","divide and conquer"],"title":"312.戳气球","uri":"/312.burst-balloons.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-02-24","objectID":"/312.burst-balloons.zh/:2:0","series":null,"tags":["dynamic programming","memorized search","divide and conquer"],"title":"312.戳气球","uri":"/312.burst-balloons.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 分治法+记忆化搜索首先在数组的首尾各插入元素1，以便于计算； 我们可以考虑将这个问题划分成两个不存在相互依赖的子问题，例如考虑[1, 3, 1, 5, 8, 1](注意首尾的1是后来单独插入的)，这里我们考虑，假设最后一个戳爆的气球是5，那么该问题就可以划分成戳[1, 3, 1, 5]和戳[5, 8, 1]两组气球的得分再加上最后戳爆气球5的得分，（注意这里数组中的第一个和最后一个元素实际上都不是气球的元素，不能戳）。 从递归的角度来说，有dfs(nums, left, right) = max(dfs(nums, left, mid) + dfs(nums, mid, right) + nums[mid] * nums[l] * nums[r])；但是这样直接递归必然导致超时，因此我们考虑采用一个数组cach[left][right]来保存dfs(nums, left, right)的结果，如果cach[left][right]不为0，说明dfs(nums, left, right)已经计算过了，不需要再重复计算了，直接return cach[left][right]就好了。 ","date":"2023-02-24","objectID":"/312.burst-balloons.zh/:2:1","series":null,"tags":["dynamic programming","memorized search","divide and conquer"],"title":"312.戳气球","uri":"/312.burst-balloons.zh/#分治法记忆化搜索"},{"categories":["leetcode"],"content":" 2.2 动态规划由上面的记忆化搜索，其实可以非常方便地改写成动态规划的形式，即 dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid][right] + nums[left] * nums[mid] * nums[right])； 这里状态dp[left][right]的定义为：开区间(left, right)引爆气球所能获得的最大分数，mid表示的是最后一个引爆的气球的坐标； 因此，这里要注意状态转移方程遍历的顺序。 ","date":"2023-02-24","objectID":"/312.burst-balloons.zh/:2:2","series":null,"tags":["dynamic programming","memorized search","divide and conquer"],"title":"312.戳气球","uri":"/312.burst-balloons.zh/#动态规划"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-02-24","objectID":"/312.burst-balloons.zh/:3:0","series":null,"tags":["dynamic programming","memorized search","divide and conquer"],"title":"312.戳气球","uri":"/312.burst-balloons.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 分治法+记忆化搜索 cpp class Solution { public: 保证子问题之间不存在依赖， 分治：递归搜索+保存计算结果 int dfs(vector\u003cint\u003e \u0026nums, int left, int right, vector\u003cvector\u003cint\u003e\u003e \u0026cach) { if (left \u003e= right) { return 0; } int maxnum = 0; for (int i = left + 1; i \u003c right; i++) { if (cach[left][right] \u003e 0) return cach[left][right]; else maxnum = std::max(maxnum, nums[left] * nums[i] * nums[right] + dfs(nums, left, i, cach) + dfs(nums, i, right, cach)); } cach[left][right] = maxnum; return maxnum; } int maxCoins(vector\u003cint\u003e \u0026nums) { nums.insert(nums.begin(), 1); nums.push_back(1); int n = nums.size(); vector\u003cvector\u003cint\u003e\u003e cach(n, vector\u003cint\u003e(n, 0)); return dfs(nums, 0, n - 1, cach); } } ","date":"2023-02-24","objectID":"/312.burst-balloons.zh/:3:1","series":null,"tags":["dynamic programming","memorized search","divide and conquer"],"title":"312.戳气球","uri":"/312.burst-balloons.zh/#分治法记忆化搜索-1"},{"categories":["leetcode"],"content":" 3.2 动态规划 cpp #include \u003cvector\u003e using std::vector; class Solution { public: int maxCoins(vector\u003cint\u003e \u0026nums) { nums.insert(nums.begin(), 1); nums.push_back(1); int n = nums.size(); vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(n, 0)); for (int l = n - 1; l \u003e= 0; l--) { // 注意这里的遍历顺序！ for (int r = 0; r \u003c n; r++) { for (int mid = l + 1; mid \u003c r; mid++) { dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid][r] + nums[mid] * nums[l] * nums[r]); } } } return dp[0][n - 1]; } }; ","date":"2023-02-24","objectID":"/312.burst-balloons.zh/:3:2","series":null,"tags":["dynamic programming","memorized search","divide and conquer"],"title":"312.戳气球","uri":"/312.burst-balloons.zh/#动态规划-1"},{"categories":["leetcode"],"content":" 4 错误示范 cpp class Solution { public: int dfs(vector\u003cint\u003e \u0026nums, set\u003cint\u003e \u0026rset, set\u003cint, std::greater\u003cint\u003e\u003e \u0026lset, vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e \u0026cach, int n) { if (rset.size() == 2) return 0; int maxnum = 0; //应该说递归，转化为子问题的时候就出问题了，完全变成回溯了 for (int i = 1; i \u003c= n; i++) { auto iter = rset.find(i); if (iter != rset.end()) { int idx_left = *lset.upper_bound(i); int idx_right = *rset.upper_bound(i); if (cach[i][idx_left][idx_right] \u003e 0) { maxnum = std::max(maxnum, cach[i][idx_left][idx_right]); } else { rset.erase(i); lset.erase(i); cach[i][idx_left][idx_right] = nums[i] * nums[idx_left] * nums[idx_right] + dfs(nums, rset, lset, cach, n); maxnum = std::max(maxnum, cach[i][idx_left][idx_right]); rset.insert(i); lset.insert(i); } } } return maxnum; } int maxCoins(vector\u003cint\u003e \u0026nums) { set\u003cint\u003e rset; set\u003cint, std::greater\u003cint\u003e\u003e lset; int n = nums.size(); nums.insert(nums.begin(), 1); nums.push_back(1); for (int i = 0; i \u003c nums.size(); i++) { rset.insert(i); lset.insert(i); } vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e cach(nums.size(), vector\u003cvector\u003cint\u003e\u003e(nums.size(), vector\u003cint\u003e(nums.size(), -1))); return dfs(nums, rset, lset, cach, n); } }; 这份代码，如果去掉保存计算结果的数组，就变成暴力回溯了，那么答案正确，但是会超时，加上保存计算结果的数组之后，答案则会出现错误，cach[i][left][right] = nums[i] * nums[idx_left] * nums[idx_right] + dfs(nums, rset, lset, cach, n);从表面含义来看，是在当前气球排列为left, i, right的情况下，戳爆i所能获得的最大硬币数，问题在于，这样写的到的结果是[0,1,2], [1,2,3], [2,3,4]...[i - 1, i, rihgt]中的最大值。 ","date":"2023-02-24","objectID":"/312.burst-balloons.zh/:4:0","series":null,"tags":["dynamic programming","memorized search","divide and conquer"],"title":"312.戳气球","uri":"/312.burst-balloons.zh/#错误示范"},{"categories":["leetcode"],"content":" 1 Description2357. Make Array Zero by Subtracting Equal Amounts (Easy) You are given a non-negative integer array nums. In one operation, you must: Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums. Subtract x from every positive element in nums. Return the minimum number of operations to make every element in nums equal to 0. Example 1: text Input: nums = [1,5,0,3,5] Output: 3 Explanation: In the first operation, choose x = 1. Now, nums = [0,4,0,2,4]. In the second operation, choose x = 2. Now, nums = [0,2,0,0,2]. In the third operation, choose x = 2. Now, nums = [0,0,0,0,0]. Example 2: text Input: nums = [0] Output: 0 Explanation: Each element in nums is already 0 so no operations are needed. Constraints: 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 100 ","date":"2023-02-24","objectID":"/2357.make-array-zero-by-subtracting-equal-amounts/:1:0","series":null,"tags":["greedy algorithm","daily"],"title":"2357.make array zero by subtracting equal amounts","uri":"/2357.make-array-zero-by-subtracting-equal-amounts/#description"},{"categories":["leetcode"],"content":" 2 SolutionGreedy algorithm: for each operation, we subtract the smallest non-zero element in nums, so the result is the amount of types of non-zero elements in nums. ","date":"2023-02-24","objectID":"/2357.make-array-zero-by-subtracting-equal-amounts/:2:0","series":null,"tags":["greedy algorithm","daily"],"title":"2357.make array zero by subtracting equal amounts","uri":"/2357.make-array-zero-by-subtracting-equal-amounts/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minimumOperations(vector\u003cint\u003e \u0026nums) { unordered_map\u003cint, int\u003e mp; for (int \u0026num : nums) { if (num != 0) { mp[num]++; } } return mp.size(); } }; ","date":"2023-02-24","objectID":"/2357.make-array-zero-by-subtracting-equal-amounts/:3:0","series":null,"tags":["greedy algorithm","daily"],"title":"2357.make array zero by subtracting equal amounts","uri":"/2357.make-array-zero-by-subtracting-equal-amounts/#code"},{"categories":["leetcode"],"content":" 1 问题描述2357. 使数组中所有元素都等于零 (Easy) 给你一个非负整数数组 nums 。在一步操作中，你必须： 选出一个正整数 x ， x 需要小于或等于 nums 中 最小 的 非零 元素。 nums 中的每个正整数都减去 x。 返回使 nums 中所有元素都等于 0 需要的 最少 操作数。 示例 1： text 输入：nums = [1,5,0,3,5] 输出：3 解释： 第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。 第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。 第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。 示例 2： text 输入：nums = [0] 输出：0 解释：nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。 提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 100 ","date":"2023-02-24","objectID":"/2357.make-array-zero-by-subtracting-equal-amounts.zh/:1:0","series":null,"tags":["greedy algorithm","daily"],"title":"2357.使数组中所有元素都等于零","uri":"/2357.make-array-zero-by-subtracting-equal-amounts.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心：不考虑数组中的零元素，每次必定减去数组中的最小非零元素，因此操作次数实际上就是数组中非零元素的种类数。 ","date":"2023-02-24","objectID":"/2357.make-array-zero-by-subtracting-equal-amounts.zh/:2:0","series":null,"tags":["greedy algorithm","daily"],"title":"2357.使数组中所有元素都等于零","uri":"/2357.make-array-zero-by-subtracting-equal-amounts.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minimumOperations(vector\u003cint\u003e \u0026nums) { unordered_map\u003cint, int\u003e mp; for (int \u0026num : nums) { if (num != 0) { mp[num]++; } } return mp.size(); } }; ","date":"2023-02-24","objectID":"/2357.make-array-zero-by-subtracting-equal-amounts.zh/:3:0","series":null,"tags":["greedy algorithm","daily"],"title":"2357.使数组中所有元素都等于零","uri":"/2357.make-array-zero-by-subtracting-equal-amounts.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description397. Integer Replacement (Medium) Given a positive integer n, you can apply one of the following operations: If n is even, replace n with n / 2. If n is odd, replace n with either n + 1 or n - 1. Return the minimum number of operations needed for nto become 1. Example 1: text Input: n = 8 Output: 3 Explanation: 8 -\u003e 4 -\u003e 2 -\u003e 1 Example 2: text Input: n = 7 Output: 4 Explanation: 7 -\u003e 8 -\u003e 4 -\u003e 2 -\u003e 1 or 7 -\u003e 6 -\u003e 3 -\u003e 2 -\u003e 1 Example 3: text Input: n = 4 Output: 2 Constraints: 1 \u003c= n \u003c= 2³¹ - 1 ","date":"2023-02-23","objectID":"/397.integer-replacement/:1:0","series":null,"tags":["greedy algorithm"],"title":"397.integer replacement","uri":"/397.integer-replacement/#description"},{"categories":["leetcode"],"content":" 2 SolutionGreedy algorithm, we only need discuss the case when n is odd, then n + 1 or n - 1 can be devided exactly, if (n + 1) % 4 == 0, n = n + 1, or n = n - 1, note that n == 3 is an exception. ","date":"2023-02-23","objectID":"/397.integer-replacement/:2:0","series":null,"tags":["greedy algorithm"],"title":"397.integer replacement","uri":"/397.integer-replacement/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp ```cpp class Solution { public: int integerReplacement(int n) { int cnt = 0; while (n != 1) { while ((n \u0026 1) == 0) { // n为偶数 n \u003e\u003e= 1; // 相当于除以2 cnt++; } if (n == 1) { return cnt; } if (n == 3) return cnt + 2; if ((n + 1) \u0026 3 == 0) { // n能被4整除 n += 1; cnt++; } else { n -= 1; cnt++; } } return cnt; } }; ","date":"2023-02-23","objectID":"/397.integer-replacement/:3:0","series":null,"tags":["greedy algorithm"],"title":"397.integer replacement","uri":"/397.integer-replacement/#code"},{"categories":["leetcode"],"content":" 1 问题描述397. 整数替换 (Medium) 给定一个正整数 n ，你可以做如下操作： 如果 n 是偶数，则用 n / 2 替换 n。 如果 n 是奇数，则可以用 n + 1 或 n - 1 替换 n 。 返回 n 变为 1 所需的 最小替换次数 。 示例 1： text 输入：n = 8 输出：3 解释：8 -\u003e 4 -\u003e 2 -\u003e 1 示例 2： text 输入：n = 7 输出：4 解释：7 -\u003e 8 -\u003e 4 -\u003e 2 -\u003e 1 或 7 -\u003e 6 -\u003e 3 -\u003e 2 -\u003e 1 示例 3： text 输入：n = 4 输出：2 提示： 1 \u003c= n \u003c= 2³¹ - 1 ","date":"2023-02-23","objectID":"/397.integer-replacement.zh/:1:0","series":null,"tags":["greedy algorithm"],"title":"397.整数替换","uri":"/397.integer-replacement.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心的思想。这里只需要讨论n为奇数的情况，如果n为奇数，那么n + 1和n - 1必然有一个能被4整除，如果(n + 1) % 4 == 0，那么n = n + 1，否则n = n - 1，注意3是例外。 ","date":"2023-02-23","objectID":"/397.integer-replacement.zh/:2:0","series":null,"tags":["greedy algorithm"],"title":"397.整数替换","uri":"/397.integer-replacement.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int integerReplacement(int n) { int cnt = 0; while (n != 1) { while ((n \u0026 1) == 0) { // n为偶数 n \u003e\u003e= 1; // 相当于除以2 cnt++; } if (n == 1) { return cnt; } if (n == 3) return cnt + 2; if ((n + 1) \u0026 3 == 0) { // n能被4整除 n += 1; cnt++; } else { n -= 1; cnt++; } } return cnt; } }; ","date":"2023-02-23","objectID":"/397.integer-replacement.zh/:3:0","series":null,"tags":["greedy algorithm"],"title":"397.整数替换","uri":"/397.integer-replacement.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1238. Circular Permutation in Binary Representation (Medium) Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that : p[0] = start p[i] and p[i+1] differ by only one bit in their binary representation. p[0] and p[2^n -1] must also differ by only one bit in their binary representation. Example 1: text Input: n = 2, start = 3 Output: [3,2,0,1] Explanation: The binary representation of the permutation is (11,10,00,01). All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2] Example 2: text Input: n = 3, start = 2 Output: [2,6,7,5,4,0,1,3] Explanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011). Constraints: 1 \u003c= n \u003c= 16 0 \u003c= start \u003c 2 ^ n ","date":"2023-02-23","objectID":"/1238.circular-permutation-in-binary-representation/:1:0","series":null,"tags":["math","daily"],"title":"1238.circular permutation in binary representation","uri":"/1238.circular-permutation-in-binary-representation/#description"},{"categories":["leetcode"],"content":" 2 SolutionIt’s the same as 89.gray-code, we just make res[i] = res[i] ^ start, since x ^ 0 = x holds for any x. ","date":"2023-02-23","objectID":"/1238.circular-permutation-in-binary-representation/:2:0","series":null,"tags":["math","daily"],"title":"1238.circular permutation in binary representation","uri":"/1238.circular-permutation-in-binary-representation/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e circularPermutation(int n, int start) { vector\u003cint\u003e res(1 \u003c\u003c n, 0); for (int i = 0; i \u003c res.size(); i++) { res[i] = i ^ (i / 2) ^ start; } return res; } }; ","date":"2023-02-23","objectID":"/1238.circular-permutation-in-binary-representation/:3:0","series":null,"tags":["math","daily"],"title":"1238.circular permutation in binary representation","uri":"/1238.circular-permutation-in-binary-representation/#code"},{"categories":["leetcode"],"content":" 1 问题描述1238. 循环码排列 (Medium) 给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,...,2^n-1) 的排列 p，并且满足： p[0] = start p[i] 和 p[i+1] 的二进制表示形式只有一位不同 p[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同 示例 1： text 输入：n = 2, start = 3 输出：[3,2,0,1] 解释：这个排列的二进制表示是 (11,10,00,01) 所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2] 示例 2： text 输出：n = 3, start = 2 输出：[2,6,7,5,4,0,1,3] 解释：这个排列的二进制表示是 (010,110,111,101,100,000,001,011) 提示： 1 \u003c= n \u003c= 16 0 \u003c= start \u003c 2^n ","date":"2023-02-23","objectID":"/1238.circular-permutation-in-binary-representation.zh/:1:0","series":null,"tags":["math","daily"],"title":"1238.循环码排列","uri":"/1238.circular-permutation-in-binary-representation.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路参照89.格雷编码，只需要将得到的结果再与start按位异或就好了，因为x ^ 0 = x对任意x恒成立。 ","date":"2023-02-23","objectID":"/1238.circular-permutation-in-binary-representation.zh/:2:0","series":null,"tags":["math","daily"],"title":"1238.循环码排列","uri":"/1238.circular-permutation-in-binary-representation.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e circularPermutation(int n, int start) { vector\u003cint\u003e res(1 \u003c\u003c n, 0); for (int i = 0; i \u003c res.size(); i++) { res[i] = i ^ (i / 2) ^ start; } return res; } }; ","date":"2023-02-23","objectID":"/1238.circular-permutation-in-binary-representation.zh/:3:0","series":null,"tags":["math","daily"],"title":"1238.循环码排列","uri":"/1238.circular-permutation-in-binary-representation.zh/#code"},{"categories":["leetcode"],"content":" 1 Description89. Gray Code (Medium) An n-bit gray code sequence is a sequence of 2ⁿ integers where: Every integer is in the inclusive range [0, 2ⁿ - 1], The first integer is 0, An integer appears no more than once in the sequence, The binary representation of every pair of adjacent integers differs by exactly one bit, and The binary representation of the first and last integers differs by exactly one bit. Given an integer n, return any valid n-bit gray code sequence. Example 1: text Input: n = 2 Output: [0,1,3,2] Explanation: The binary representation of [0,1,3,2] is [00,01,11,10]. - 00 and 01 differ by one bit - 01 and 11 differ by one bit - 11 and 10 differ by one bit - 10 and 00 differ by one bit [0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01]. - 00 and 10 differ by one bit - 10 and 11 differ by one bit - 11 and 01 differ by one bit - 01 and 00 differ by one bit Example 2: text Input: n = 1 Output: [0,1] Constraints: 1 \u003c= n \u003c= 16 ","date":"2023-02-23","objectID":"/89.gray-code/:1:0","series":null,"tags":["math"],"title":"89.gray code","uri":"/89.gray-code/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe formual of gray code is f[i] = i ^ (i / 2); ","date":"2023-02-23","objectID":"/89.gray-code/:2:0","series":null,"tags":["math"],"title":"89.gray code","uri":"/89.gray-code/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e grayCode(int n) { int num = 1 \u003c\u003c n; vector\u003cint\u003e res(num, 0); for (int i = 0; i \u003c num; i++) { res[i] = i ^ (i / 2); } return res; } }; ","date":"2023-02-23","objectID":"/89.gray-code/:3:0","series":null,"tags":["math"],"title":"89.gray code","uri":"/89.gray-code/#code"},{"categories":["leetcode"],"content":" 1 问题描述89. 格雷编码 (Medium) n 位格雷码序列 是一个由 2ⁿ 个整数组成的序列，其中： 每个整数都在范围 [0, 2ⁿ - 1] 内（含 0 和 2ⁿ - 1） 第一个整数是 0 一个整数在序列中出现 不超过一次 每对 相邻 整数的二进制表示 恰好一位不同 ，且 第一个 和 最后一个 整数的二进制表示 恰好一位不同 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。 示例 1： text 输入：n = 2 输出：[0,1,3,2] 解释： [0,1,3,2] 的二进制表示是 [00,01,11,10] 。 - 00 和 01 有一位不同 - 01 和 11 有一位不同 - 11 和 10 有一位不同 - 10 和 00 有一位不同 [0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。 - 00 和 10 有一位不同 - 10 和 11 有一位不同 - 11 和 01 有一位不同 - 01 和 00 有一位不同 示例 2： text 输入：n = 1 输出：[0,1] 提示： 1 \u003c= n \u003c= 16 ","date":"2023-02-23","objectID":"/89.gray-code.zh/:1:0","series":null,"tags":["math"],"title":"89.格雷编码","uri":"/89.gray-code.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路格雷编码的公式为f[i] = i ^ (i / 2); ","date":"2023-02-23","objectID":"/89.gray-code.zh/:2:0","series":null,"tags":["math"],"title":"89.格雷编码","uri":"/89.gray-code.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e grayCode(int n) { int num = 1 \u003c\u003c n; vector\u003cint\u003e res(num, 0); for (int i = 0; i \u003c num; i++) { res[i] = i ^ (i / 2); } return res; } }; ","date":"2023-02-23","objectID":"/89.gray-code.zh/:3:0","series":null,"tags":["math"],"title":"89.格雷编码","uri":"/89.gray-code.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1326. Minimum Number of Taps to Open to Water a Garden (Hard) There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n). There are n + 1 taps located at points [0, 1, ..., n] in the garden. Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open. Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1. Example 1: text Input: n = 5, ranges = [3,4,1,1,0,0] Output: 1 Explanation: The tap at point 0 can cover the interval [-3,3] The tap at point 1 can cover the interval [-3,5] The tap at point 2 can cover the interval [1,3] The tap at point 3 can cover the interval [2,4] The tap at point 4 can cover the interval [4,4] The tap at point 5 can cover the interval [5,5] Opening Only the second tap will water the whole garden [0,5] Example 2: text Input: n = 3, ranges = [0,0,0,0] Output: -1 Explanation: Even if you activate all the four taps you cannot water the whole garden. Constraints: 1 \u003c= n \u003c= 10⁴ ranges.length == n + 1 0 \u003c= ranges[i] \u003c= 100 ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/:1:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.minimum number of taps to open to water a garden","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/:2:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.minimum number of taps to open to water a garden","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/#solution"},{"categories":["leetcode"],"content":" 2.1 Dynamic programmingWe represent dp[i] as the least amount of taps to cover [0, i]. Assuming that the coverage of the last tap is [start[i], end[j]], then for start[j] \u003c k \u003c end[j], dp[k] = min(dp[k], dp[start[j]] + 1), so we need to initialize dp[i] as very large values, and sort the water_range array by start[i] from small to large. ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/:2:1","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.minimum number of taps to open to water a garden","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/#dynamic-programming"},{"categories":["leetcode"],"content":" 2.2 Sort + Binary SearchGreey algorithm: Suppose the rightmost end that can be watered is end and the corresponding tap is start_idx, then the i that satisfies start[i] \u003c= end and end[i] is the largest i should be selected, we can find the maximum idx of i that satisfies start[i] \u003c= end by using dichotomous search, then traverse [start_idx, idx] to find the largest end[i] and update start_idx. ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/:2:2","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.minimum number of taps to open to water a garden","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/#sort--binary-search"},{"categories":["leetcode"],"content":" 2.3 Greedy algorithmSuppose the rightmost end that can be watered is end and the corresponding tap is start_idx, then the i that satifies start[i] \u003c= end and end[i] is the largest should be selected. We use an array vector\u003cint\u003e right_most(n + 1, 0) that represents the farthest point that can be watered when the point with coordinate i can be watered. Then, we traverse i from 0 to n, and if right_most[i] is greater than next_right, then update next_right, and the original next_right is recorded as cur_right, and if i == cur_right now, it means that another tap has to be opened. ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/:2:3","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.minimum number of taps to open to water a garden","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/#greedy-algorithm"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/:3:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.minimum number of taps to open to water a garden","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/#code"},{"categories":["leetcode"],"content":" 3.1 Dynamic programming cpp class Solution { public: int minTaps(int n, vector\u003cint\u003e \u0026ranges) { vector\u003cvector\u003cint\u003e\u003e water_range; for (int i = 0; i \u003c= n; i++) { water_range.push_back({std::max(0, i - ranges[i]), std::min(i + ranges[i], n)}); } std::sort(water_range.begin(), water_range.end()); vector\u003cint\u003e dp(n + 1, 30000); dp[0] = 0; for(int i = 0; i \u003c= n; i++) { if (dp[water_range[i][0]] == 30000) return -1; for (int j = water_range[i][0]; j \u003c= water_range[i][1]; j++) { dp[j] = std::min(dp[j], dp[water_range[i][0]] + 1); } } return dp[n]; } }; ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/:3:1","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.minimum number of taps to open to water a garden","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/#dynamic-programming-1"},{"categories":["leetcode"],"content":" 3.2 Sort + Binary search cpp class Solution { public: // binary search int Bfind(vector\u003cvector\u003cint\u003e\u003e \u0026vec, int target, int start_idx) { int left = start_idx, right = vec.size(); int mid = left + (right - left) / 2; while (left \u003c right) { if (vec[mid][0] \u003c target) { left = mid + 1; } else { right = mid; } mid = left + (right - left) / 2; } return left; } int minTaps(int n, vector\u003cint\u003e \u0026ranges) { vector\u003cvector\u003cint\u003e\u003e water_range; for (int i = 0; i \u003c= n; i++) { water_range.push_back({i - ranges[i], i + ranges[i]}); } auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { if (v1[0] == v2[0]) return v1[1] \u003c= v2[1]; return v1[0] \u003c v2[0]; }; std::sort(water_range.begin(), water_range.end(), cmp); int start_idx = 0, end = 0; int cnt = 0; while (end \u003c n) { int idx = Bfind(water_range, end + 1, start_idx) - 1; // find greatest idx that satisfies start[idx] \u003c= end for (int i = start_idx; i \u003c= idx; i++) { if (water_range[i][1] \u003e end) { start_idx = i; end = water_range[i][1]; } } cnt++; if (cnt \u003e n) return -1; } return cnt; } }; ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/:3:2","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.minimum number of taps to open to water a garden","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/#sort--binary-search-1"},{"categories":["leetcode"],"content":" 3.3 Greedy algorithm cpp class Solution { public: int minTaps(int n, vector\u003cint\u003e \u0026ranges) { int right_most[n + 1]; memset(right_most, 0, sizeof(right_most)); for (int i = 0; i \u003c= n; ++i) { int r = ranges[i]; if (i \u003e r) right_most[i - r] = i + r; else right_most[0] = max(right_most[0], i + r); } int ans = 0; int cur_right = 0; int next_right = 0; for (int i = 0; i \u003c n; ++i) { next_right = max(next_right, right_most[i]); if (i == cur_right) { if (i == next_right) return -1; cur_right = next_right; ++ans; } } return ans; } }; ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/:3:3","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.minimum number of taps to open to water a garden","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden/#greedy-algorithm-1"},{"categories":["leetcode"],"content":" 1 问题描述1326. 灌溉花园的最少水龙头数目 (Hard) 在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。 花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。 给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i - ranges[i], i + ranges[i]] 。 请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。 示例 1： text 输入：n = 5, ranges = [3,4,1,1,0,0] 输出：1 解释： 点 0 处的水龙头可以灌溉区间 [-3,3] 点 1 处的水龙头可以灌溉区间 [-3,5] 点 2 处的水龙头可以灌溉区间 [1,3] 点 3 处的水龙头可以灌溉区间 [2,4] 点 4 处的水龙头可以灌溉区间 [4,4] 点 5 处的水龙头可以灌溉区间 [5,5] 只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。 示例 2： text 输入：n = 3, ranges = [0,0,0,0] 输出：-1 解释：即使打开所有水龙头，你也无法灌溉整个花园。 提示： 1 \u003c= n \u003c= 10⁴ ranges.length == n + 1 0 \u003c= ranges[i] \u003c= 100 ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/:1:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.浇灌花园的最少水龙头数目","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/:2:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.浇灌花园的最少水龙头数目","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 贪心假设当前能浇灌的最右端为end，对应的水龙头为start_idx，那么应该选满足start[i] \u003c= end且end[i]最大的i。在这里，我们构建一个数组vector\u003cint\u003e right_most(n + 1, 0)，表示当坐标i的点能被浇灌到时，所能浇灌到的最远点。 然后，我们从0~n遍历i，如果right_most[i]大于next_right，那么更新next_right，原先的next_right记为cur_right，如果i == cur_right了，说明要再开一个水龙头。 ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/:2:1","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.浇灌花园的最少水龙头数目","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/#贪心"},{"categories":["leetcode"],"content":" 2.2 排序+二分查找这个做法也是有一点贪心的思路，假设当前能浇灌的最右端为end，对应的水龙头为start_idx，那么应该选满足start[i] \u003c= end且end[i]最大的i，可以利用二分查找找到满足start[i] \u003c= end的i的最大值idx，然后遍历[start_idx, idx]，找最大的end[i],并更新start_idx。 ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/:2:2","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.浇灌花园的最少水龙头数目","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/#排序二分查找"},{"categories":["leetcode"],"content":" 2.3 动态规划dp[i]表示覆盖[0, i]所需要的最少水龙头数量； 我们假设dp[i]的情况下，打开的最后一个水龙头为(start[j], end[j])，那么对于start[j] \u003c k \u003c end[j]，dp[k] = min(dp[k], dp[start[j]] + 1)，所以这里我们需要将dp[i]初始化为一个极大值，并且需要将water_range数组按照start[i]从小到大排序。 ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/:2:3","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.浇灌花园的最少水龙头数目","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/#动态规划"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/:3:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.浇灌花园的最少水龙头数目","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 动态规划 cpp class Solution { public: int minTaps(int n, vector\u003cint\u003e \u0026ranges) { vector\u003cvector\u003cint\u003e\u003e water_range; for (int i = 0; i \u003c= n; i++) { water_range.push_back({std::max(0, i - ranges[i]), std::min(i + ranges[i], n)}); } std::sort(water_range.begin(), water_range.end()); vector\u003cint\u003e dp(n + 1, 30000); dp[0] = 0; for(int i = 0; i \u003c= n; i++) { if (dp[water_range[i][0]] == 30000) return -1; for (int j = water_range[i][0]; j \u003c= water_range[i][1]; j++) { dp[j] = std::min(dp[j], dp[water_range[i][0]] + 1); } } return dp[n]; } }; ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/:3:1","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.浇灌花园的最少水龙头数目","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/#动态规划-1"},{"categories":["leetcode"],"content":" 3.2 贪心 cpp class Solution { public: int minTaps(int n, vector\u003cint\u003e \u0026ranges) { int right_most[n + 1]; memset(right_most, 0, sizeof(right_most)); for (int i = 0; i \u003c= n; ++i) { int r = ranges[i]; if (i \u003e r) right_most[i - r] = i + r; // 对于 i-r 来说，i+r 必然是它目前的最大值 else right_most[0] = max(right_most[0], i + r); } int ans = 0; int cur_right = 0; // 已建造的桥的右端点 int next_right = 0; // 下一座桥的右端点的最大值 for (int i = 0; i \u003c n; ++i) { // 注意这里没有遍历到 n，因为它已经是终点了 next_right = max(next_right, right_most[i]); if (i == cur_right) { // 到达已建造的桥的右端点 if (i == next_right) return -1; // 无论怎么造桥，都无法从 i 到 i+1 cur_right = next_right; // 造一座桥 ++ans; } } return ans; } }; ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/:3:2","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.浇灌花园的最少水龙头数目","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/#贪心-1"},{"categories":["leetcode"],"content":" 3.3 排序+二分查找 cpp class Solution { public: // 二分查找 int Bfind(vector\u003cvector\u003cint\u003e\u003e \u0026vec, int target, int start_idx) { int left = start_idx, right = vec.size(); int mid = left + (right - left) / 2; while (left \u003c right) { if (vec[mid][0] \u003c target) { left = mid + 1; } else { right = mid; } mid = left + (right - left) / 2; } return left; } int minTaps(int n, vector\u003cint\u003e \u0026ranges) { vector\u003cvector\u003cint\u003e\u003e water_range; for (int i = 0; i \u003c= n; i++) { water_range.push_back({i - ranges[i], i + ranges[i]}); } auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { if (v1[0] == v2[0]) return v1[1] \u003c= v2[1]; return v1[0] \u003c v2[0]; }; std::sort(water_range.begin(), water_range.end(), cmp); int start_idx = 0, end = 0; int cnt = 0; while (end \u003c n) { int idx = Bfind(water_range, end + 1, start_idx) - 1; // 找到满足start[idx] \u003c= end的最大的idx for (int i = start_idx; i \u003c= idx; i++) { if (water_range[i][1] \u003e end) { start_idx = i; end = water_range[i][1]; } } cnt++; if (cnt \u003e n) return -1; } return cnt; } }; ","date":"2023-02-21","objectID":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/:3:3","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"1326.浇灌花园的最少水龙头数目","uri":"/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/#排序二分查找-1"},{"categories":["leetcode"],"content":" 1 Description1792. Maximum Average Pass Ratio (Medium) There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passᵢ, totalᵢ]. You know beforehand that in the ith class, there are totalᵢ total students, but only passᵢ number of students will pass the exam. You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes. The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes. Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-⁵ of the actual answer will be accepted. Example 1: text Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2 Output: 0.78333 Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333. Example 2: text Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4 Output: 0.53485 Constraints: 1 \u003c= classes.length \u003c= 10⁵ classes[i].length == 2 1 \u003c= passᵢ \u003c= totalᵢ \u003c= 10⁵ 1 \u003c= extraStudents \u003c= 10⁵ ","date":"2023-02-20","objectID":"/1792.maximum-average-pass-ratio/:1:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1792.maximum average pass ratio","uri":"/1792.maximum-average-pass-ratio/#description"},{"categories":["leetcode"],"content":" 2 SolutionGreedy algorithm, we choose the class whose pass ratio will increase the most each time. We can use a priority queue to simulate the process. ","date":"2023-02-20","objectID":"/1792.maximum-average-pass-ratio/:2:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1792.maximum average pass ratio","uri":"/1792.maximum-average-pass-ratio/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: double maxAverageRatio(vector\u003cvector\u003cint\u003e\u003e \u0026classes, int extraStudents) { auto cmp = [\u0026](int a, int b) { return (double)(classes[a][1] - classes[a][0]) / ((long long)classes[a][1] * classes[a][1] + classes[a][1]) \u003c (double)(classes[b][1] - classes[b][0]) / ((long long)classes[b][1] * classes[b][1] + classes[b][1]); }; std::priority_queue\u003cint, vector\u003cint\u003e, decltype(cmp)\u003e pq(cmp); for (int i = 0; i \u003c classes.size(); i++) { pq.push(i); } for (int num = 1; num \u003c= extraStudents; num++) { int idx = pq.top(); pq.pop(); classes[idx][0] += 1; classes[idx][1] += 1; pq.push(idx); } double res = 0; for (auto \u0026vec : classes) { res += (double)(vec[0]) / vec[1]; } return res / classes.size(); } }; ","date":"2023-02-20","objectID":"/1792.maximum-average-pass-ratio/:3:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1792.maximum average pass ratio","uri":"/1792.maximum-average-pass-ratio/#code"},{"categories":["leetcode"],"content":" 1 问题描述1792. 最大平均通过率 (Medium) 一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passᵢ, totalᵢ] ，表示你提前知道了第 i 个班级总共有 totalᵢ 个学生，其中只有 passᵢ 个学生可以通过考试。 给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。 一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。 平均通过率 是所有班级的通过率之和除以班级数目。 请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-⁵ 以内的结果都会视为正确结果。 示例 1： text 输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2 输出：0.78333 解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。 示例 2： text 输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4 输出：0.53485 提示： 1 \u003c= classes.length \u003c= 10⁵ classes[i].length == 2 1 \u003c= passᵢ \u003c= totalᵢ \u003c= 10⁵ 1 \u003c= extraStudents \u003c= 10⁵ ","date":"2023-02-20","objectID":"/1792.maximum-average-pass-ratio.zh/:1:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1792.最大平均通过率","uri":"/1792.maximum-average-pass-ratio.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心，每次选择使通过率提升最大的那个班级，利用优先队列来模拟这个过程。 ","date":"2023-02-20","objectID":"/1792.maximum-average-pass-ratio.zh/:2:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1792.最大平均通过率","uri":"/1792.maximum-average-pass-ratio.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: double maxAverageRatio(vector\u003cvector\u003cint\u003e\u003e \u0026classes, int extraStudents) { auto cmp = [\u0026](int a, int b) { return (double)(classes[a][1] - classes[a][0]) / ((long long)classes[a][1] * classes[a][1] + classes[a][1]) \u003c (double)(classes[b][1] - classes[b][0]) / ((long long)classes[b][1] * classes[b][1] + classes[b][1]); }; std::priority_queue\u003cint, vector\u003cint\u003e, decltype(cmp)\u003e pq(cmp); for (int i = 0; i \u003c classes.size(); i++) { pq.push(i); } for (int num = 1; num \u003c= extraStudents; num++) { int idx = pq.top(); pq.pop(); classes[idx][0] += 1; classes[idx][1] += 1; pq.push(idx); } double res = 0; for (auto \u0026vec : classes) { res += (double)(vec[0]) / vec[1]; } return res / classes.size(); } }; ","date":"2023-02-20","objectID":"/1792.maximum-average-pass-ratio.zh/:3:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1792.最大平均通过率","uri":"/1792.maximum-average-pass-ratio.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1833. Maximum Ice Cream Bars (Medium) It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. Note: The boy can buy the ice cream bars in any order. Return the maximum number of ice cream bars the boy can buy with coins coins. You must solve the problem by counting sort. Example 1: text Input: costs = [1,3,2,4,1], coins = 7 Output: 4 Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7. Example 2: text Input: costs = [10,6,8,7,7,8], coins = 5 Output: 0 Explanation: The boy cannot afford any of the ice cream bars. Example 3: text Input: costs = [1,6,3,1,2,5], coins = 20 Output: 6 Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18. Constraints: costs.length == n 1 \u003c= n \u003c= 10⁵ 1 \u003c= costs[i] \u003c= 10⁵ 1 \u003c= coins \u003c= 10⁸ ","date":"2023-02-20","objectID":"/1833.maximum-ice-cream-bars/:1:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1833.maximum Ice Cream Bars","uri":"/1833.maximum-ice-cream-bars/#description"},{"categories":["leetcode"],"content":" 2 SolutionGreedy algorithm: the optimal way is to buy the cheapest ice-cream each time, we can use a priority queue to simulate the process. ","date":"2023-02-20","objectID":"/1833.maximum-ice-cream-bars/:2:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1833.maximum Ice Cream Bars","uri":"/1833.maximum-ice-cream-bars/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maxIceCream(vector\u003cint\u003e \u0026costs, int coins) { priority_queue\u003cint, vector\u003cint\u003e, std::greater\u003cint\u003e\u003e pq; // small top stack for (int \u0026price : costs) { pq.push(price); } int cnt = 0; while (!pq.empty() \u0026\u0026 coins \u003e= pq.top()) { cnt++; coins -= pq.top(); pq.pop(); } return cnt; } }; ","date":"2023-02-20","objectID":"/1833.maximum-ice-cream-bars/:3:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1833.maximum Ice Cream Bars","uri":"/1833.maximum-ice-cream-bars/#code"},{"categories":["leetcode"],"content":" 1 问题描述1833. 雪糕的最大数量 (Medium) 夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。 商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。 注意： Tony 可以按任意顺序购买雪糕。 给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。 示例 1： text 输入：costs = [1,3,2,4,1], coins = 7 输出：4 解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7 示例 2： text 输入：costs = [10,6,8,7,7,8], coins = 5 输出：0 解释：Tony 没有足够的钱买任何一支雪糕。 示例 3： text 输入：costs = [1,6,3,1,2,5], coins = 20 输出：6 解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。 提示： costs.length == n 1 \u003c= n \u003c= 10⁵ 1 \u003c= costs[i] \u003c= 10⁵ 1 \u003c= coins \u003c= 10⁸ ","date":"2023-02-20","objectID":"/1833.maximum-ice-cream-bars.zh/:1:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1833.雪糕的最大数量","uri":"/1833.maximum-ice-cream-bars.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心，最优方案一定是每次买最便宜的雪糕，因此可以用优先队列来模拟买雪糕的过程 ","date":"2023-02-20","objectID":"/1833.maximum-ice-cream-bars.zh/:2:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1833.雪糕的最大数量","uri":"/1833.maximum-ice-cream-bars.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxIceCream(vector\u003cint\u003e \u0026costs, int coins) { priority_queue\u003cint, vector\u003cint\u003e, std::greater\u003cint\u003e\u003e pq; // 小顶堆 for (int \u0026price : costs) { pq.push(price); } int cnt = 0; while (!pq.empty() \u0026\u0026 coins \u003e= pq.top()) { cnt++; coins -= pq.top(); pq.pop(); } return cnt; } }; ","date":"2023-02-20","objectID":"/1833.maximum-ice-cream-bars.zh/:3:0","series":null,"tags":["greedy algorithm","priority queue"],"title":"1833.雪糕的最大数量","uri":"/1833.maximum-ice-cream-bars.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2347. Best Poker Hand (Easy) You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i]. The following are the types of poker hands you can make from best to worst: \"Flush\": Five cards of the same suit. \"Three of a Kind\": Three cards of the same rank. \"Pair\": Two cards of the same rank. \"High Card\": Any single card. Return a string representing the best type of poker hand you can make with the given cards. Note that the return values are case-sensitive. Example 1: text Input: ranks = [13,2,3,1,9], suits = [\"a\",\"a\",\"a\",\"a\",\"a\"] Output: \"Flush\" Explanation: The hand with all the cards consists of 5 cards with the same suit, so we have a \"Flush\". Example 2: text Input: ranks = [4,4,2,4,4], suits = [\"d\",\"a\",\"a\",\"b\",\"c\"] Output: \"Three of a Kind\" Explanation: The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a \"Three of a Kind\". Note that we could also make a \"Pair\" hand but \"Three of a Kind\" is a better hand. Also note that other cards could be used to make the \"Three of a Kind\" hand. Example 3: text Input: ranks = [10,10,2,12,9], suits = [\"a\",\"b\",\"c\",\"a\",\"d\"] Output: \"Pair\" Explanation: The hand with the first and second card consists of 2 cards with the same rank, so we have a \"Pair\". Note that we cannot make a \"Flush\" or a \"Three of a Kind\". Constraints: ranks.length == suits.length == 5 1 \u003c= ranks[i] \u003c= 13 'a' \u003c= suits[i] \u003c= 'd' No two cards have the same rank and suit. ","date":"2023-02-20","objectID":"/2347.best-poker-hand/:1:0","series":null,"tags":["daily","hash table"],"title":"2347.best poker hand","uri":"/2347.best-poker-hand/#description"},{"categories":["leetcode"],"content":" 2 SolutionJust use two arrays as two hash table. ","date":"2023-02-20","objectID":"/2347.best-poker-hand/:2:0","series":null,"tags":["daily","hash table"],"title":"2347.best poker hand","uri":"/2347.best-poker-hand/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: string bestHand(vector\u003cint\u003e \u0026ranks, vector\u003cchar\u003e \u0026suits) { vector\u003cint\u003e color(4, 0); vector\u003cint\u003e number(14, 0); for (int i = 0; i \u003c 5; i++) { color[suits[i] - 'a']++; if (color[suits[i] - 'a'] == 5) return \"Flush\"; number[ranks[i]]++; } int maxnum = 0; for (int i = 1; i \u003c= 13; i++) { maxnum = std::max(maxnum, number[i]); } if (maxnum \u003e= 3) return \"Three of a Kind\"; if (maxnum == 2) return \"Pair\"; return \"High Card\"; } }; ","date":"2023-02-20","objectID":"/2347.best-poker-hand/:3:0","series":null,"tags":["daily","hash table"],"title":"2347.best poker hand","uri":"/2347.best-poker-hand/#code"},{"categories":["leetcode"],"content":" 1 问题描述2347. 最好的扑克手牌 (Easy) 给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。 下述是从好到坏你可能持有的 手牌类型： \"Flush\"：同花，五张相同花色的扑克牌。 \"Three of a Kind\"：三条，有 3 张大小相同的扑克牌。 \"Pair\"：对子，两张大小一样的扑克牌。 \"High Card\"：高牌，五张大小互不相同的扑克牌。 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。 注意： 返回的字符串 大小写 需与题目描述相同。 示例 1： text 输入：ranks = [13,2,3,1,9], suits = [\"a\",\"a\",\"a\",\"a\",\"a\"] 输出：\"Flush\" 解释：5 张扑克牌的花色相同，所以返回 \"Flush\" 。 示例 2： text 输入：ranks = [4,4,2,4,4], suits = [\"d\",\"a\",\"a\",\"b\",\"c\"] 输出：\"Three of a Kind\" 解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 \"Three of a Kind\" 。 注意我们也可以得到 \"Pair\" ，但是 \"Three of a Kind\" 是更好的手牌类型。 有其他的 3 张牌也可以组成 \"Three of a Kind\" 手牌类型。 示例 3： text 输入：ranks = [10,10,2,12,9], suits = [\"a\",\"b\",\"c\",\"a\",\"d\"] 输出：\"Pair\" 解释：第一和第二张牌大小相同，所以得到 \"Pair\" 。 我们无法得到 \"Flush\" 或者 \"Three of a Kind\" 。 提示： ranks.length == suits.length == 5 1 \u003c= ranks[i] \u003c= 13 'a' \u003c= suits[i] \u003c= 'd' 任意两张扑克牌不会同时有相同的大小和花色。 ","date":"2023-02-20","objectID":"/2347.best-poker-hand.zh/:1:0","series":null,"tags":["daily","hash table"],"title":"2347.最好的扑克手牌","uri":"/2347.best-poker-hand.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用两个数组作为哈希表 ","date":"2023-02-20","objectID":"/2347.best-poker-hand.zh/:2:0","series":null,"tags":["daily","hash table"],"title":"2347.最好的扑克手牌","uri":"/2347.best-poker-hand.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: string bestHand(vector\u003cint\u003e \u0026ranks, vector\u003cchar\u003e \u0026suits) { vector\u003cint\u003e color(4, 0); vector\u003cint\u003e number(14, 0); for (int i = 0; i \u003c 5; i++) { color[suits[i] - 'a']++; if (color[suits[i] - 'a'] == 5) return \"Flush\"; number[ranks[i]]++; } int maxnum = 0; for (int i = 1; i \u003c= 13; i++) { maxnum = std::max(maxnum, number[i]); } if (maxnum \u003e= 3) return \"Three of a Kind\"; if (maxnum == 2) return \"Pair\"; return \"High Card\"; } }; ","date":"2023-02-20","objectID":"/2347.best-poker-hand.zh/:3:0","series":null,"tags":["daily","hash table"],"title":"2347.最好的扑克手牌","uri":"/2347.best-poker-hand.zh/#代码"},{"categories":["leetcode"],"content":" 1 Solution781. Rabbits in Forest (Medium) There is a forest with an unknown number of rabbits. We asked n rabbits “How many rabbits have the same color as you?” and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit. Given the array answers, return the minimum number of rabbits that could be in the forest. Example 1: text Input: answers = [1,1,2] Output: 5 Explanation: The two rabbits that answered \"1\" could both be the same color, say red. The rabbit that answered \"2\" can't be red or the answers would be inconsistent. Say the rabbit that answered \"2\" was blue. Then there should be 2 other blue rabbits in the forest that didn't answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't. Example 2: text Input: answers = [10,10,10] Output: 11 Constraints: 1 \u003c= answers.length \u003c= 1000 0 \u003c= answers[i] \u003c 1000 ","date":"2023-02-18","objectID":"/781.rabbits-in-forest/:1:0","series":null,"tags":["hash table","greedy algorithm"],"title":"781.rabbits in forest","uri":"/781.rabbits-in-forest/#solution"},{"categories":["leetcode"],"content":" 2 SolutionIf we want the amount of rabbits is the maximum, we need to make the rabbits that answer the same number is the same color, if possible. We use a hash table unordered_map\u003cint, int\u003e ump to record for each answer the amount of rabbits that answer the answer, key means the answer, value means the amount of rabbits that answer the answer. If ump[i] \u003e i + 1, then there is more than one kind of color among these rabbits. The least amount of kind of color is (ump[i] - 1) / (i + 1) + 1, for each kind of color, there are i + 1 rabbits. ","date":"2023-02-18","objectID":"/781.rabbits-in-forest/:2:0","series":null,"tags":["hash table","greedy algorithm"],"title":"781.rabbits in forest","uri":"/781.rabbits-in-forest/#solution-1"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int numRabbits(vector\u003cint\u003e \u0026answers) { unordered_map\u003cint, int\u003e ump; int res = 0; for (auto \u0026num : answers) { ump[num]++; } for (auto \u0026num : ump) { // if (num.second % (num.first + 1) == 0) { // res += num.second; // } else { // res += (num.second / (num.first + 1) + 1) * (num.first + 1); // } res += ((num.second - 1) / (num.first + 1) + 1) * (num.first + 1); } return res; } }; ","date":"2023-02-18","objectID":"/781.rabbits-in-forest/:3:0","series":null,"tags":["hash table","greedy algorithm"],"title":"781.rabbits in forest","uri":"/781.rabbits-in-forest/#code"},{"categories":["leetcode"],"content":" 1 问题描述781. 森林中的兔子 (Medium) 森林中有未知数量的兔子。提问其中若干只兔子 “还有多少只兔子与你（指被提问的兔子）颜色相同?” ，将答案收集到一个整数数组 answers 中，其中 answers[i] 是第 i 只兔子的回答。 给你数组 answers ，返回森林中兔子的最少数量。 示例 1： text 输入：answers = [1,1,2] 输出：5 解释： 两只回答了 \"1\" 的兔子可能有相同的颜色，设为红色。 之后回答了 \"2\" 的兔子不会是红色，否则他们的回答会相互矛盾。 设回答了 \"2\" 的兔子为蓝色。 此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。 因此森林中兔子的最少数量是 5 只：3 只回答的和 2 只没有回答的。 示例 2： text 输入：answers = [10,10,10] 输出：11 提示： 1 \u003c= answers.length \u003c= 1000 0 \u003c= answers[i] \u003c 1000 ","date":"2023-02-18","objectID":"/781.rabbits-in-forest.zh/:1:0","series":null,"tags":["hash table","greedy algorithm"],"title":"781.森林中的兔子","uri":"/781.rabbits-in-forest.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路从题目中给出的例子我们可以发现，要想让兔子数量最小，那么要尽量让回答结果相同的兔子是同一个颜色的； 我们用一个哈希表unordered_map\u003cint, int\u003e ump来记录每种结果有多少只兔子回答了，key为回答结果，value是回答该结果的兔子的数量； 如果ump[i] \u003e i + 1，说明这批兔子至少有不止一种颜色，颜色数为(ump[i] - 1) / (i + 1) + 1，每种颜色有i + 1个兔子。 ","date":"2023-02-18","objectID":"/781.rabbits-in-forest.zh/:2:0","series":null,"tags":["hash table","greedy algorithm"],"title":"781.森林中的兔子","uri":"/781.rabbits-in-forest.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int numRabbits(vector\u003cint\u003e \u0026answers) { unordered_map\u003cint, int\u003e ump; int res = 0; for (auto \u0026num : answers) { ump[num]++; } for (auto \u0026num : ump) { // if (num.second % (num.first + 1) == 0) { // res += num.second; // } else { // res += (num.second / (num.first + 1) + 1) * (num.first + 1); // } res += ((num.second - 1) / (num.first + 1) + 1) * (num.first + 1); } return res; } }; ","date":"2023-02-18","objectID":"/781.rabbits-in-forest.zh/:3:0","series":null,"tags":["hash table","greedy algorithm"],"title":"781.森林中的兔子","uri":"/781.rabbits-in-forest.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1223. Dice Roll Simulation (Hard) A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] ( 1-indexed) consecutive times. Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 10⁹ + 7. Two sequences are considered different if at least one element differs from each other. Example 1: text Input: n = 2, rollMax = [1,1,2,2,2,3] Output: 34 Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34. Example 2: text Input: n = 2, rollMax = [1,1,1,1,1,1] Output: 30 Example 3: text Input: n = 3, rollMax = [1,1,1,2,2,3] Output: 181 Constraints: 1 \u003c= n \u003c= 5000 rollMax.length == 6 1 \u003c= rollMax[i] \u003c= 15 ","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game/:1:0","series":null,"tags":["hash table"],"title":"1996.the number of weak characters in the game","uri":"/1996.the-number-of-weak-characters-in-the-game/#description"},{"categories":["leetcode"],"content":" 2 SolutionSort the properties by attack from lowest to highest. If the two roles have the same, the one with the lower defense is on top. We can traverse the sorted properties, if properties[i][0] \u003c properties[0][0] \u0026\u0026 properties[i][1] \u003c defend_max, res++; if properties[i][1] \u003e defend_max, update defend_max; ","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game/:2:0","series":null,"tags":["hash table"],"title":"1996.the number of weak characters in the game","uri":"/1996.the-number-of-weak-characters-in-the-game/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int numberOfWeakCharacters(vector\u003cvector\u003cint\u003e\u003e \u0026properties) { std::sort(properties.begin(), properties.end(), [\u0026](vector\u003cint\u003e \u0026vec1, vector\u003cint\u003e \u0026vec2) { if (vec1[0] == vec2[0]) return vec1[1] \u003c= vec2[1]; return vec1[0] \u003e vec2[0]; }); int cnt = 0; int attack_max = properties[0][0]; int defend_max = properties[0][1]; for (int i = 1; i \u003c properties.size(); i++) { if (properties[i][0] \u003c attack_max \u0026\u0026 properties[i][1] \u003c defend_max) { cnt++; } else if (properties[i][1] \u003e defend_max) { defend_max = properties[i][1]; } } return cnt; } }; ","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game/:3:0","series":null,"tags":["hash table"],"title":"1996.the number of weak characters in the game","uri":"/1996.the-number-of-weak-characters-in-the-game/#code"},{"categories":["leetcode"],"content":" 1 问题描述1996. 游戏中弱角色的数量 (Medium) 你正在参加一个多角色游戏，每个角色都有两个主要属性： 攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attackᵢ, defenseᵢ] 表示游戏中第 i 个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackⱼ \u003e attackᵢ 且 defenseⱼ \u003e defenseᵢ 。 返回 弱角色 的数量。 示例 1： text 输入：properties = [[5,5],[6,3],[3,6]] 输出：0 解释：不存在攻击和防御都严格高于其他角色的角色。 示例 2： text 输入：properties = [[2,2],[3,3]] 输出：1 解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 示例 3： text 输入：properties = [[1,5],[10,4],[4,3]] 输出：1 解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 提示： 2 \u003c= properties.length \u003c= 10⁵ properties[i].length == 2 1 \u003c= attackᵢ, defenseᵢ \u003c= 10⁵ ","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game.zh/:1:0","series":null,"tags":["hash table"],"title":"1996.游戏中弱角色的数量","uri":"/1996.the-number-of-weak-characters-in-the-game.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先将角色按照攻击值从大到小排序，至于相同攻击值之间的角色的排序，有两种思路 ","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game.zh/:2:0","series":null,"tags":["hash table"],"title":"1996.游戏中弱角色的数量","uri":"/1996.the-number-of-weak-characters-in-the-game.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 按照防御值从大到小排序利用哈希表记录每个攻击值有多少攻击值相同的角色，遍历排好序的properties数组时，从i = 1, j= roles[properties[i][0]]开始遍历，一直到j == i + roles[properties[i][0]]，此时++i; j = roles[properties[i + 1][0]]，角色的攻击值一定是相对较小的，如果角色的防御值小于记录的防御值最大值，那么i + roles[properties[i][0]]] - j就是本次i循环中发现的弱角色的数量，否则更新防御最大值defend_max. ","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game.zh/:2:1","series":null,"tags":["hash table"],"title":"1996.游戏中弱角色的数量","uri":"/1996.the-number-of-weak-characters-in-the-game.zh/#按照防御值从大到小排序"},{"categories":["leetcode"],"content":" 2.2 按照防御值从小到大排序直接遍历排好序的properties数组，如果properties[i][0] \u003c properties[0][0] \u0026\u0026 properties[i][1] \u003c defend_max, res++；如果properties[i][1] \u003e defend_max，更新defend_max. ","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game.zh/:2:2","series":null,"tags":["hash table"],"title":"1996.游戏中弱角色的数量","uri":"/1996.the-number-of-weak-characters-in-the-game.zh/#按照防御值从小到大排序"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game.zh/:3:0","series":null,"tags":["hash table"],"title":"1996.游戏中弱角色的数量","uri":"/1996.the-number-of-weak-characters-in-the-game.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 按照防御值从大到小排序 cpp class Solution { public: int numberOfWeakCharacters(vector\u003cvector\u003cint\u003e\u003e \u0026properties) { std::sort(properties.begin(), properties.end(), [\u0026](vector\u003cint\u003e \u0026vec1, vector\u003cint\u003e \u0026vec2) { if (vec1[0] == vec2[0]) return vec1[1] \u003e= vec2[1]; return vec1[0] \u003e vec2[0]; }); int cnt = 0; int attack_max = properties[0][0]; int defend_max = properties[0][1]; unordered_map\u003cint, int\u003e roles; // 记录同一攻击值有多少角色 for (int i = 0; i \u003c properties.size(); i++) { roles[properties[i][0]]++; } for (int i = roles[attack_max]; i \u003c properties.size(); i += roles[properties[i][0]]) { int j = i; while (j \u003c i + roles[properties[i][0]] \u0026\u0026 properties[j][1] \u003e= defend_max) { j++; // 寻找小于defend_max的properties[j][1] } cnt += i + roles[properties[i][0]] - j; defend_max = std::max(defend_max, properties[i][1]); // 更新defend_max } return cnt; } }; ","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game.zh/:3:1","series":null,"tags":["hash table"],"title":"1996.游戏中弱角色的数量","uri":"/1996.the-number-of-weak-characters-in-the-game.zh/#按照防御值从大到小排序-1"},{"categories":["leetcode"],"content":" 3.2 按照防御值从小到大排序 cpp class Solution { public: int numberOfWeakCharacters(vector\u003cvector\u003cint\u003e\u003e \u0026properties) { std::sort(properties.begin(), properties.end(), [\u0026](vector\u003cint\u003e \u0026vec1, vector\u003cint\u003e \u0026vec2) { if (vec1[0] == vec2[0]) return vec1[1] \u003c= vec2[1]; return vec1[0] \u003e vec2[0]; }); int cnt = 0; int attack_max = properties[0][0]; int defend_max = properties[0][1]; for (int i = 1; i \u003c properties.size(); i++) { if (properties[i][0] \u003c attack_max \u0026\u0026 properties[i][1] \u003c defend_max) { cnt++; } else if (properties[i][1] \u003e defend_max) { defend_max = properties[i][1]; } } return cnt; } }; ","date":"2023-02-18","objectID":"/1996.the-number-of-weak-characters-in-the-game.zh/:3:2","series":null,"tags":["hash table"],"title":"1996.游戏中弱角色的数量","uri":"/1996.the-number-of-weak-characters-in-the-game.zh/#按照防御值从小到大排序-1"},{"categories":["leetcode"],"content":" 1 Description1797. Design Authentication Manager (Medium) There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime. Implement the AuthenticationManager class: AuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive. generate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds. renew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens. countUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime. Note that if a token expires at time t, and another action happens on time t ( renew or countUnexpiredTokens), the expiration takes place before the other actions. Example 1: text Input [\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"] [[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]] Output [null, null, null, 1, null, null, null, 0] Explanation AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds. authenticationManager.renew(\"aaa\", 1); // No token exists with tokenId \"aaa\" at time 1, so nothing happens. authenticationManager.generate(\"aaa\", 2); // Generates a new token with tokenId \"aaa\" at time 2. authenticationManager.countUnexpiredTokens(6); // The token with tokenId \"aaa\" is the only unexpired one at time 6, so return 1. authenticationManager.generate(\"bbb\", 7); // Generates a new token with tokenId \"bbb\" at time 7. authenticationManager.renew(\"aaa\", 8); // The token with tokenId \"aaa\" expired at time 7, and 8 \u003e= 7, so at time 8 the renew request is ignored, and nothing happens. authenticationManager.renew(\"bbb\", 10); // The token with tokenId \"bbb\" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15. authenticationManager.countUnexpiredTokens(15); // The token with tokenId \"bbb\" expires at time 15, and the token with tokenId \"aaa\" expired at time 7, so currently no token is unexpired, so return 0. Constraints: 1 \u003c= timeToLive \u003c= 10⁸ 1 \u003c= currentTime \u003c= 10⁸ 1 \u003c= tokenId.length \u003c= 5 tokenId consists only of lowercase letters. All calls to generate will contain unique values of tokenId. The values of currentTime across all the function calls will be strictly increasing. At most 2000 calls will be made to all functions combined. ","date":"2023-02-18","objectID":"/1797.design-authentication-manager/:1:0","series":null,"tags":["hash table"],"title":"1797.design authentication manager","uri":"/1797.design-authentication-manager/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use a hash table to store the tokens that are unexpired. ","date":"2023-02-18","objectID":"/1797.design-authentication-manager/:2:0","series":null,"tags":["hash table"],"title":"1797.design authentication manager","uri":"/1797.design-authentication-manager/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class AuthenticationManager { public: AuthenticationManager(int timeToLive) { time_to_live = timeToLive; } void generate(string tokenId, int currentTime) { tokens[tokenId] = currentTime; } void renew(string tokenId, int currentTime) { if (tokens.find(tokenId) != tokens.end()) { if (currentTime - tokens[tokenId] \u003c time_to_live) { tokens[tokenId] = currentTime; } else { tokens.erase(tokenId); } } } int countUnexpiredTokens(int currentTime) { int cnt = 0; for (auto iter = tokens.begin(); iter != tokens.end(); iter++) { if (currentTime - iter-\u003esecond \u003c time_to_live) cnt++; } return cnt; } private: int time_to_live; std::unordered_map\u003cstring, int\u003e tokens; }; ","date":"2023-02-18","objectID":"/1797.design-authentication-manager/:3:0","series":null,"tags":["hash table"],"title":"1797.design authentication manager","uri":"/1797.design-authentication-manager/#code"},{"categories":["leetcode"],"content":" 1 问题描述1797. 设计一个验证系统 (Medium) 你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。 请你实现 AuthenticationManager 类： AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。 generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。 renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。 countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻， 未过期 的验证码数目。 如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（ renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。 示例 1： text 输入： [\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"] [[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]] 输出： [null, null, null, 1, null, null, null, 0] 解释： AuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 timeToLive = 5 秒。 authenticationManager.renew(\"aaa\", 1); // 时刻 1 时，没有验证码的 tokenId 为 \"aaa\" ，没有验证码被更新。 authenticationManager.generate(\"aaa\", 2); // 时刻 2 时，生成一个 tokenId 为 \"aaa\" 的新验证码。 authenticationManager.countUnexpiredTokens(6); // 时刻 6 时，只有 tokenId 为 \"aaa\" 的验证码未过期，所以返回 1 。 authenticationManager.generate(\"bbb\", 7); // 时刻 7 时，生成一个 tokenId 为 \"bbb\" 的新验证码。 authenticationManager.renew(\"aaa\", 8); // tokenId 为 \"aaa\" 的验证码在时刻 7 过期，且 8 \u003e= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。 authenticationManager.renew(\"bbb\", 10); // tokenId 为 \"bbb\" 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。 authenticationManager.countUnexpiredTokens(15); // tokenId 为 \"bbb\" 的验证码在时刻 15 过期，tokenId 为 \"aaa\" 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。 提示： 1 \u003c= timeToLive \u003c= 10⁸ 1 \u003c= currentTime \u003c= 10⁸ 1 \u003c= tokenId.length \u003c= 5 tokenId 只包含小写英文字母。 所有 generate 函数的调用都会包含独一无二的 tokenId 值。 所有函数调用中， currentTime 的值 严格递增 。 所有函数的调用次数总共不超过 2000 次。 ","date":"2023-02-18","objectID":"/1797.design-authentication-manager.zh/:1:0","series":null,"tags":["hash table"],"title":"1797.设计一个验证系统","uri":"/1797.design-authentication-manager.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用哈希表存储所有未过期的token。 ","date":"2023-02-18","objectID":"/1797.design-authentication-manager.zh/:2:0","series":null,"tags":["hash table"],"title":"1797.设计一个验证系统","uri":"/1797.design-authentication-manager.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class AuthenticationManager { public: AuthenticationManager(int timeToLive) { time_to_live = timeToLive; } void generate(string tokenId, int currentTime) { tokens[tokenId] = currentTime; } void renew(string tokenId, int currentTime) { if (tokens.find(tokenId) != tokens.end()) { if (currentTime - tokens[tokenId] \u003c time_to_live) { tokens[tokenId] = currentTime; } else { tokens.erase(tokenId); } } } int countUnexpiredTokens(int currentTime) { int cnt = 0; for (auto iter = tokens.begin(); iter != tokens.end(); iter++) { if (currentTime - iter-\u003esecond \u003c time_to_live) cnt++; } return cnt; } private: int time_to_live; std::unordered_map\u003cstring, int\u003e tokens; }; ","date":"2023-02-18","objectID":"/1797.design-authentication-manager.zh/:3:0","series":null,"tags":["hash table"],"title":"1797.设计一个验证系统","uri":"/1797.design-authentication-manager.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1233. Remove Sub-Folders from the Filesystem (Medium) Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order. If a folder[i] is located within another folder[j], it is called a sub-folder of it. The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters. For example, \"/leetcode\" and \"/leetcode/problems\" are valid paths while an empty string and \"/\" are not. Example 1: text Input: folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"] Output: [\"/a\",\"/c/d\",\"/c/f\"] Explanation: Folders \"/a/b\" is a subfolder of \"/a\" and \"/c/d/e\" is inside of folder \"/c/d\" in our filesystem. Example 2: text Input: folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"] Output: [\"/a\"] Explanation: Folders \"/a/b/c\" and \"/a/b/d\" will be removed because they are subfolders of \"/a\". Example 3: text Input: folder = [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"] Output: [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"] Constraints: 1 \u003c= folder.length \u003c= 4 * 10⁴ 2 \u003c= folder[i].length \u003c= 100 folder[i] contains only lowercase letters and '/'. folder[i] always starts with the character '/'. Each folder name is unique. ","date":"2023-02-18","objectID":"/1233.remove-sub-folders-from-the-filesystem/:1:0","series":null,"tags":["hash table"],"title":"1233.remove sub folders from the filesystem","uri":"/1233.remove-sub-folders-from-the-filesystem/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use hash table to check whether the folder is subfolder. ","date":"2023-02-18","objectID":"/1233.remove-sub-folders-from-the-filesystem/:2:0","series":null,"tags":["hash table"],"title":"1233.remove sub folders from the filesystem","uri":"/1233.remove-sub-folders-from-the-filesystem/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool CheckSub(unordered_set\u003cstring\u003e \u0026folders, string \u0026loc) { for (int i = 1; i \u003c loc.size(); i++) { if (loc[i] == '/') { if (folders.find(loc.substr(0, i)) != folders.end()) return true; } } return false; } vector\u003cstring\u003e removeSubfolders(vector\u003cstring\u003e \u0026folder) { sort(folder.begin(), folder.end()); unordered_set\u003cstring\u003e folders; for (auto \u0026loc : folder) { if (!CheckSub(folders, loc)) folders.insert(loc); } vector\u003cstring\u003e res(folders.begin(), folders.end()); return res; } }; ","date":"2023-02-18","objectID":"/1233.remove-sub-folders-from-the-filesystem/:3:0","series":null,"tags":["hash table"],"title":"1233.remove sub folders from the filesystem","uri":"/1233.remove-sub-folders-from-the-filesystem/#code"},{"categories":["leetcode"],"content":" 1 问题描述[1233. 删除子文件夹 (Medium)] 你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’/’ 后跟一个或者多个小写英文字母。 例如， \"/leetcode\" 和 \"/leetcode/problems\" 都是有效的路径，而空字符串和 \"/\" 不是。 示例 1： text 输入：folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"] 输出：[\"/a\",\"/c/d\",\"/c/f\"] 解释：\"/a/b\" 是 \"/a\" 的子文件夹，而 \"/c/d/e\" 是 \"/c/d\" 的子文件夹。 示例 2： text 输入：folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"] 输出：[\"/a\"] 解释：文件夹 \"/a/b/c\" 和 \"/a/b/d\" 都会被删除，因为它们都是 \"/a\" 的子文件夹。 示例 3： text 输入: folder = [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"] 输出: [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"] 提示： 1 \u003c= folder.length \u003c= 4 * 10⁴ 2 \u003c= folder[i].length \u003c= 100 folder[i] 只包含小写字母和 '/' folder[i] 总是以字符 '/' 起始 folder 每个元素都是 唯一 的 ","date":"2023-02-18","objectID":"/1233.remove-sub-folders-from-the-filesystem.zh/:1:0","series":null,"tags":["hash table"],"title":"1233.删除子文件夹","uri":"/1233.remove-sub-folders-from-the-filesystem.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路遍历folder，如果路径不是子路径，就将该路径添加到哈希表中，可以通过哈希表检查该路径是否是子路径。 ","date":"2023-02-18","objectID":"/1233.remove-sub-folders-from-the-filesystem.zh/:2:0","series":null,"tags":["hash table"],"title":"1233.删除子文件夹","uri":"/1233.remove-sub-folders-from-the-filesystem.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool CheckSub(unordered_set\u003cstring\u003e \u0026folders, string \u0026loc) { for (int i = 1; i \u003c loc.size(); i++) { if (loc[i] == '/') { if (folders.find(loc.substr(0, i)) != folders.end()) return true; } } return false; } vector\u003cstring\u003e removeSubfolders(vector\u003cstring\u003e \u0026folder) { sort(folder.begin(), folder.end()); unordered_set\u003cstring\u003e folders; for (auto \u0026loc : folder) { if (!CheckSub(folders, loc)) folders.insert(loc); } vector\u003cstring\u003e res(folders.begin(), folders.end()); return res; } }; ","date":"2023-02-18","objectID":"/1233.remove-sub-folders-from-the-filesystem.zh/:3:0","series":null,"tags":["hash table"],"title":"1233.删除子文件夹","uri":"/1233.remove-sub-folders-from-the-filesystem.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description646. Maximum Length of Pair Chain (Medium) You are given an array of n pairs pairs where pairs[i] = [leftᵢ, rightᵢ] and leftᵢ \u003c rightᵢ. A pair p2 = [c, d] follows a pair p1 = [a, b] if b \u003c c. A chain of pairs can be formed in this fashion. Return the length longest chain which can be formed. You do not need to use up all the given intervals. You can select pairs in any order. Example 1: text Input: pairs = [[1,2],[2,3],[3,4]] Output: 2 Explanation: The longest chain is [1,2] -\u003e [3,4]. Example 2: text Input: pairs = [[1,2],[7,8],[4,5]] Output: 3 Explanation: The longest chain is [1,2] -\u003e [4,5] -\u003e [7,8]. Constraints: n == pairs.length 1 \u003c= n \u003c= 1000 -1000 \u003c= leftᵢ \u003c rightᵢ \u003c= 1000 ","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain/:1:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.maximum length of pair chain","uri":"/646.maximum-length-of-pair-chain/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain/:2:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.maximum length of pair chain","uri":"/646.maximum-length-of-pair-chain/#solution"},{"categories":["leetcode"],"content":" 2.1 Greedy AlgorithmWhen we choose the first pair, we need to choose i which makes pairs[i][1] is the minimum. When we choose the second pair, we need to choose j, which makes pairs[j][0] \u003e pairs[i][1] and pairs[j][1] is the minimum. And so on… So we need sort pairs by pairs[i][1]. ","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain/:2:1","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.maximum length of pair chain","uri":"/646.maximum-length-of-pair-chain/#greedy-algorithm"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int findLongestChain(vector\u003cvector\u003cint\u003e\u003e \u0026pairs) { auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { if (v1[1] == v2[1]) { return v1[0] \u003c= v2[0]; } return v1[1] \u003c v2[1]; }; std::sort(pairs.begin(), pairs.end(), cmp); int cnt = 1; int left = pairs[0][1]; for (int i = 1; i \u003c pairs.size(); i++) { if (pairs[i][0] \u003e left) { cnt++; left = pairs[i][1]; } } return cnt; } }; ","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain/:3:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.maximum length of pair chain","uri":"/646.maximum-length-of-pair-chain/#code"},{"categories":["leetcode"],"content":" 1 问题描述646. 最长数对链 (Medium) 给你一个由 n 个数对组成的数对数组 pairs ，其中 pairs[i] = [leftᵢ, rightᵢ] 且 leftᵢ \u003c rightᵢ 现在，我们定义一种 跟随 关系，当且仅当 b \u003c c 时，数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面。我们用这种形式来构造 数对链 。 找出并返回能够形成的 最长数对链的长度 。 你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例 1： text 输入：pairs = [[1,2], [2,3], [3,4]] 输出：2 解释：最长的数对链是 [1,2] -\u003e [3,4] 。 示例 2： text 输入：pairs = [[1,2],[7,8],[4,5]] 输出：3 解释：最长的数对链是 [1,2] -\u003e [4,5] -\u003e [7,8] 。 提示： n == pairs.length 1 \u003c= n \u003c= 1000 -1000 \u003c= leftᵢ \u003c rightᵢ \u003c= 1000 ","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain.zh/:1:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.最长数对链","uri":"/646.maximum-length-of-pair-chain.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain.zh/:2:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.最长数对链","uri":"/646.maximum-length-of-pair-chain.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 贪心在选择第一个数对时，必定选择使pairs[i][1]最小的那个i，第二个数对则必定选择pairs[j][0] \u003e pairs[i][1]且使pairs[j][0]最小的j，因此类推，因此我们将pairs按照其第二个元素升序排列。 ","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain.zh/:2:1","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.最长数对链","uri":"/646.maximum-length-of-pair-chain.zh/#贪心"},{"categories":["leetcode"],"content":" 2.2 动态规划","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain.zh/:2:2","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.最长数对链","uri":"/646.maximum-length-of-pair-chain.zh/#动态规划"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain.zh/:3:0","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.最长数对链","uri":"/646.maximum-length-of-pair-chain.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 贪心 cpp class Solution { public: int findLongestChain(vector\u003cvector\u003cint\u003e\u003e \u0026pairs) { auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { if (v1[1] == v2[1]) { return v1[0] \u003c= v2[0]; } return v1[1] \u003c v2[1]; }; std::sort(pairs.begin(), pairs.end(), cmp); int cnt = 1; int left = pairs[0][1]; for (int i = 1; i \u003c pairs.size(); i++) { if (pairs[i][0] \u003e left) { cnt++; left = pairs[i][1]; } } return cnt; } }; ","date":"2023-02-18","objectID":"/646.maximum-length-of-pair-chain.zh/:3:1","series":null,"tags":["greedy algorithm","dynamic programming"],"title":"646.最长数对链","uri":"/646.maximum-length-of-pair-chain.zh/#贪心-1"},{"categories":["leetcode"],"content":" 1 Description1124. Longest Well-Performing Interval (Medium) We are given hours, a list of the number of hours worked per day for a given employee. A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8. A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days. Return the length of the longest well-performing interval. Example 1: text Input: hours = [9,9,6,0,6,6,9] Output: 3 Explanation: The longest well-performing interval is [9,9,6]. Example 2: text Input: hours = [6,6,6] Output: 0 Constraints: 1 \u003c= hours.length \u003c= 10⁴ 0 \u003c= hours[i] \u003c= 16 ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval/:1:0","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.longest well performing interval","uri":"/1124.longest-well-performing-interval/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval/:2:0","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.longest well performing interval","uri":"/1124.longest-well-performing-interval/#solution"},{"categories":["leetcode"],"content":" 2.1 Monotone stackFirst, we set element greater than 8 to be 1, elements less than 8 to be -1. And we compute the prefix sum of the new array to get a prefix sum array prefix. We need to find the maximum j - i that satisfies prefix[j] - prefix[i]. First, consider the left endpoint. If prefix[i1] \u003c prefix[i2] and i1 \u003c= i2, then we don’t need to consider taking i2 as the left endpoint. So we can traverse prefix forward, and push idx to the stack if prefix[idx] \u003c prefix[stk.top()]; Then, let’s traverse prefix backwards. If prefix[j1] \u003e prefix[stk.top()], update res = std::max(res, r - stk.top()), then pop the element in the top. If traverse prefix forward, we may omit res in the case that prefix[j] \u003c prefix[stk.top()]. ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval/:2:1","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.longest well performing interval","uri":"/1124.longest-well-performing-interval/#monotone-stack"},{"categories":["leetcode"],"content":" 2.2 Hash table if (prefix[i] \u003e 0), the i days is well-performing interval, res = max(res, i); if (prefix[i] \u003c= 0), if key prefix[i] don’t occured in hash table ump before, ump[prefix[i]] = i, otherwise we don’t update ump[prefix[i]], since the corresponding value of the key in hash table is less, so the difference (the same as length of interval) is greater; Otherwise the maximum length of well-performing interval ended on the ith day is ump[prefix[i]] - ump[prefix[i] - 1](there must be key prefix[i] - 1 in hash table, or length is 0, which means there is not such interval), since there only are 1 and -1 in new array, the value prefix[i] - 1 must occur earlier than prefix[i] - 2 in array prefix. ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval/:2:2","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.longest well performing interval","uri":"/1124.longest-well-performing-interval/#hash-table"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval/:3:0","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.longest well performing interval","uri":"/1124.longest-well-performing-interval/#code"},{"categories":["leetcode"],"content":" 3.1 Monotone stack cpp class Solution { public: int longestWPI(vector\u003cint\u003e \u0026hours) { int n = hours.size(); if (n == 1) { return hours[0] \u003e 8; } for (auto \u0026i : hours) { if (i \u003e 8) { i = 1; } else { i = -1; } } // 计算新hours的前缀和 vector\u003cint\u003e prefix(n + 1, 0); for (int i = 1; i \u003c= n; i++) { prefix[i] = prefix[i - 1] + hours[i - 1]; } // stack\u003cint\u003e l_stk; int res = 0; l_stk.push(0); for (int i = 1; i \u003c= n; i++) { if (prefix[i] \u003e 0) { res = std::max(res, i); } if (prefix[i] \u003c prefix[l_stk.top()]) { l_stk.push(i); } } for (int r = n; r \u003e= 1; r--) { while (!l_stk.empty() \u0026\u0026 prefix[r] \u003e prefix[l_stk.top()]) { if (l_stk.empty()) { return std::max(r, res); } res = std::max(res, r - l_stk.top()); l_stk.pop(); } } return res; } }; ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval/:3:1","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.longest well performing interval","uri":"/1124.longest-well-performing-interval/#monotone-stack-1"},{"categories":["leetcode"],"content":" 3.2 Hash table cpp class Solution { public: int max(int a, int b) { return a \u003e b ? a : b; } int longestWPI(vector\u003cint\u003e \u0026hours) { int n = hours.size(); for (auto \u0026i : hours) { if (i \u003e 8) { i = 1; } else { i = -1; } } // prefix sum of hours vector\u003cint\u003e prefix(n, 0); prefix[0] = hours[0]; for (int i = 1; i \u003c n; i++) { prefix[i] = prefix[i - 1] + hours[i]; } unordered_map\u003cint, int\u003e mp; int res = 0; for (int i = 0; i \u003c n; i++) { if (prefix[i] \u003e 0) res = max(res, i + 1); else { auto iter = mp.find(prefix[i] - 1); if (iter != mp.end()) { res = max(res, i - iter-\u003esecond); } if (mp.find(prefix[i]) == mp.end()) { mp[prefix[i]] = i; } } } return res; } }; ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval/:3:2","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.longest well performing interval","uri":"/1124.longest-well-performing-interval/#hash-table-1"},{"categories":["leetcode"],"content":" 1 问题描述1124. 表现良好的最长时间段 (Medium) 给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「 劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。 示例 1： text 输入：hours = [9,9,6,0,6,6,9] 输出：3 解释：最长的表现良好时间段是 [9,9,6]。 示例 2： text 输入：hours = [6,6,6] 输出：0 提示： 1 \u003c= hours.length \u003c= 10⁴ 0 \u003c= hours[i] \u003c= 16 ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval.zh/:1:0","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.表现良好的最长时间段","uri":"/1124.longest-well-performing-interval.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval.zh/:2:0","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.表现良好的最长时间段","uri":"/1124.longest-well-performing-interval.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 单调栈首先，将原数组中大于8的值设为1，小于或等于8的值设为-1，分别表示劳累的一天和不劳累的一天，然后求这个新数组的前缀和，得到一个前缀和数组prefix； 那么我们就是要求满足prefix[j] \u003e prefix[i]条件下的最大的j - i，首先，我们考虑左端点，如果prefix[i1] \u003c prefix[i2]且i1 \u003c= i2，那么我们完全不需要考虑使用i2作为左端点，因为选择i1作为左端点的res一定更大，所以我们可以正向遍历prefix，并将索引idx压入单调栈，满足栈底到栈顶单调递减； 然后，我们从从右往左遍历prefix找右端点，如果prefix[j1] \u003e prefix[stk.top()]，那就弹出栈顶元素并更新res = std::max(res, r - stk.top())，如果选择从左往右遍历的话，prefix[j2] \u003c prefix[stk.top()]的时候，最终结果可能是j2 - i，其中i是一个被弹出的元素，从左往右遍历右端点，这种情况无法考虑到。 ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval.zh/:2:1","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.表现良好的最长时间段","uri":"/1124.longest-well-performing-interval.zh/#单调栈"},{"categories":["leetcode"],"content":" 2.2 哈希表 如果prefix[i] \u003e 0，说明这i天内都是表现良好的时间段，那么res = max(i, res)； 如果prefix[i] \u003c= 0，如果key prefix[i]之前未在哈希表ump中出现过，那么ump[prefix[i]] = i, 否则不更新ump[prefix[i]]，因为哈希表中key对应的value一定更小，对应的差值即时间长度会更大， 以第i天结尾表现良好的时间段的最大长度即为ump[prefix[i]] - ump[prefix[i] - 1]（要求key prefix[i] - 1在哈希表中，否则为0，即不存在这样的时间段），这是因为由于新数组中只有1和-1两种元素，那么值prefix[i] - 1一定比prefix[i] - 2先出现在前缀和数组中。 ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval.zh/:2:2","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.表现良好的最长时间段","uri":"/1124.longest-well-performing-interval.zh/#哈希表"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval.zh/:3:0","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.表现良好的最长时间段","uri":"/1124.longest-well-performing-interval.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 单调栈 cpp class Solution { public: int longestWPI(vector\u003cint\u003e \u0026hours) { int n = hours.size(); if (n == 1) { return hours[0] \u003e 8; } for (auto \u0026i : hours) { if (i \u003e 8) { i = 1; } else { i = -1; } } // 计算新hours的前缀和 vector\u003cint\u003e prefix(n + 1, 0); for (int i = 1; i \u003c= n; i++) { prefix[i] = prefix[i - 1] + hours[i - 1]; } // stack\u003cint\u003e l_stk; int res = 0; l_stk.push(0); for (int i = 1; i \u003c= n; i++) { if (prefix[i] \u003e 0) { res = std::max(res, i); } if (prefix[i] \u003c prefix[l_stk.top()]) { l_stk.push(i); } } for (int r = n; r \u003e= 1; r--) { while (!l_stk.empty() \u0026\u0026 prefix[r] \u003e prefix[l_stk.top()]) { if (l_stk.empty()) { return std::max(r, res); } res = std::max(res, r - l_stk.top()); l_stk.pop(); } } return res; } }; ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval.zh/:3:1","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.表现良好的最长时间段","uri":"/1124.longest-well-performing-interval.zh/#单调栈-1"},{"categories":["leetcode"],"content":" 3.2 哈希表 cpp class Solution { public: int max(int a, int b) { return a \u003e b ? a : b; } int longestWPI(vector\u003cint\u003e \u0026hours) { int n = hours.size(); // 大于8的转化为1，小于等于8的转化为-1 for (auto \u0026i : hours) { if (i \u003e 8) { i = 1; } else { i = -1; } } // 计算新hours的前缀和 vector\u003cint\u003e prefix(n, 0); prefix[0] = hours[0]; for (int i = 1; i \u003c n; i++) { prefix[i] = prefix[i - 1] + hours[i]; } unordered_map\u003cint, int\u003e mp; // 前缀相同时，保留下标最小的那个 int res = 0; for (int i = 0; i \u003c n; i++) { if (prefix[i] \u003e 0) res = max(res, i + 1); else { auto iter = mp.find(prefix[i] - 1); if (iter != mp.end()) { res = max(res, i - iter-\u003esecond); } if (mp.find(prefix[i]) == mp.end()) { mp[prefix[i]] = i; } } } return res; } }; ","date":"2023-02-17","objectID":"/1124.longest-well-performing-interval.zh/:3:2","series":null,"tags":["hash table","prefix sum","monotone stack"],"title":"1124.表现良好的最长时间段","uri":"/1124.longest-well-performing-interval.zh/#哈希表-1"},{"categories":["leetcode"],"content":" 1 Description926. Flip String to Monotone Increasing (Medium) A binary string is monotone increasing if it consists of some number of 0’s (possibly none), followed by some number of 1’s (also possibly none). You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0. Return the minimum number of flips to make s monotone increasing. Example 1: text Input: s = \"00110\" Output: 1 Explanation: We flip the last digit to get 00111. Example 2: text Input: s = \"010110\" Output: 2 Explanation: We flip to get 011111, or alternatively 000111. Example 3: text Input: s = \"00011000\" Output: 2 Explanation: We flip to get 00000000. Constraints: 1 \u003c= s.length \u003c= 10⁵ s[i] is either '0' or '1'. ","date":"2023-02-17","objectID":"/926.flip-string-to-monotone-increasing/:1:0","series":null,"tags":["dynamic programming"],"title":"926.flip string to monotone increasing","uri":"/926.flip-string-to-monotone-increasing/#description"},{"categories":["leetcode"],"content":" 2 SolutionLet dp[i] be the minimum times of flipping to make string monotone increasing, cnt be the number of '1' in the first i characters: if (s[i - 1] == '1') dp[i] = dp[i - 1]; s[i - 1] == '0' dp[i] = min(dp[i - 1] + 1, cnt); ","date":"2023-02-17","objectID":"/926.flip-string-to-monotone-increasing/:2:0","series":null,"tags":["dynamic programming"],"title":"926.flip string to monotone increasing","uri":"/926.flip-string-to-monotone-increasing/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minFlipsMonoIncr(string s) { int cnt = 0, res = 0; // cnt为遍历中1的个数 vector\u003cint\u003e dp(s.size() + 1, 0); for (int i = 1; i \u003c= s.size(); i++) { if (s[i - 1] == '1') { cnt++; dp[i] = dp[i - 1]; } else { dp[i] = std::min(dp[i - 1] + 1, cnt); } } return dp[s.size()]; } }; ","date":"2023-02-17","objectID":"/926.flip-string-to-monotone-increasing/:3:0","series":null,"tags":["dynamic programming"],"title":"926.flip string to monotone increasing","uri":"/926.flip-string-to-monotone-increasing/#code"},{"categories":["leetcode"],"content":" 1 问题描述926. 将字符串翻转到单调递增 (Medium) 如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。 给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。 返回使 s 单调递增的最小翻转次数。 示例 1： text 输入：s = \"00110\" 输出：1 解释：翻转最后一位得到 00111. 示例 2： text 输入：s = \"010110\" 输出：2 解释：翻转得到 011111，或者是 000111。 示例 3： text 输入：s = \"00011000\" 输出：2 解释：翻转得到 00000000。 提示： 1 \u003c= s.length \u003c= 10⁵ s[i] 为 '0' 或 '1' ","date":"2023-02-17","objectID":"/926.flip-string-to-monotone-increasing.zh/:1:0","series":null,"tags":["dynamic programming"],"title":"926.将字符串翻转到单调递增","uri":"/926.flip-string-to-monotone-increasing.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路令dp[i]为将前i个字符翻转成单调递增的字符串所需要的最少翻转次数，cnt表示前i个字符中'1'的个数，其递推关系很容易分析: s[i - 1] == '1'，dp[i] = dp[i - 1]; s[i - 1] == '0'，dp[i] = min(dp[i - 1] + 1, cnt); ","date":"2023-02-17","objectID":"/926.flip-string-to-monotone-increasing.zh/:2:0","series":null,"tags":["dynamic programming"],"title":"926.将字符串翻转到单调递增","uri":"/926.flip-string-to-monotone-increasing.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minFlipsMonoIncr(string s) { int cnt = 0, res = 0; // cnt为遍历中1的个数 vector\u003cint\u003e dp(s.size() + 1, 0); for (int i = 1; i \u003c= s.size(); i++) { if (s[i - 1] == '1') { cnt++; dp[i] = dp[i - 1]; } else { dp[i] = std::min(dp[i - 1] + 1, cnt); } } return dp[s.size()]; } }; ","date":"2023-02-17","objectID":"/926.flip-string-to-monotone-increasing.zh/:3:0","series":null,"tags":["dynamic programming"],"title":"926.将字符串翻转到单调递增","uri":"/926.flip-string-to-monotone-increasing.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1139. Largest 1-Bordered Square (Medium) Given a 2D grid of 0 s and 1 s, return the number of elements in the largest square subgrid that has all 1 s on its border, or 0 if such a subgrid doesn’t exist in the grid. Example 1: text Input: grid = [[1,1,1],[1,0,1],[1,1,1]] Output: 9 Example 2: text Input: grid = [[1,1,0,0]] Output: 1 Constraints: 1 \u003c= grid.length \u003c= 100 1 \u003c= grid[0].length \u003c= 100 grid[i][j] is 0 or 1 ","date":"2023-02-17","objectID":"/1139.largest-1-bordered-square/:1:0","series":null,"tags":["daily","prefix sum"],"title":"1139.largest 1 bordered square","uri":"/1139.largest-1-bordered-square/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use prefix sum to reduce coumputaional comlexity. By enumerating the length l of the square, we can find the maximum l, compare l with res. ","date":"2023-02-17","objectID":"/1139.largest-1-bordered-square/:2:0","series":null,"tags":["daily","prefix sum"],"title":"1139.largest 1 bordered square","uri":"/1139.largest-1-bordered-square/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int largest1BorderedSquare(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { int m = grid.size(), n = grid[0].size(); vector\u003cvector\u003cint\u003e\u003e sum_row(m, vector\u003cint\u003e(n + 1, 0)); vector\u003cvector\u003cint\u003e\u003e sum_col(m + 1, vector\u003cint\u003e(n, 0)); for (int i = 0; i \u003c grid.size(); i++) { for (int j = 1; j \u003c= n; j++) { sum_row[i][j] = sum_row[i][j - 1] + grid[i][j - 1]; } } for (int i = 1; i \u003c= m; i++) { for (int j = 0; j \u003c n; j++) { sum_col[i][j] = sum_col[i - 1][j] + grid[i - 1][j]; } } int res = 0; for (int i = 1; i \u003c= m; i++) { for (int j = 1; j \u003c= n; j++) { for (int l = res + 1; l \u003c= std::min(i, j); l++) { if (sum_col[i][j - 1] - sum_col[i - l][j - 1] == l \u0026\u0026 sum_row[i - 1][j] - sum_row[i - 1][j - l] == l \u0026\u0026 sum_col[i][j - l] - sum_col[i - l][j - l] == l \u0026\u0026 sum_row[i - l][j] - sum_row[i - l][j - l] == l) res = std::max(l, res); } } } return res * res; } }; ","date":"2023-02-17","objectID":"/1139.largest-1-bordered-square/:3:0","series":null,"tags":["daily","prefix sum"],"title":"1139.largest 1 bordered square","uri":"/1139.largest-1-bordered-square/#code"},{"categories":["leetcode"],"content":" 1 问题描述1139. 最大的以 1 为边界的正方形 (Medium) 给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。 示例 1： text 输入：grid = [[1,1,1],[1,0,1],[1,1,1]] 输出：9 示例 2： text 输入：grid = [[1,1,0,0]] 输出：1 提示： 1 \u003c= grid.length \u003c= 100 1 \u003c= grid[0].length \u003c= 100 grid[i][j] 为 0 或 1 ","date":"2023-02-17","objectID":"/1139.largest-1-bordered-square.zh/:1:0","series":null,"tags":["daily","prefix sum"],"title":"1139.最大的以1为边界的正方形","uri":"/1139.largest-1-bordered-square.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用前缀和来简化满足正方形条件的计算，枚举正方形边长，找到最大的l，再和已经得出的结果进行比较。 ","date":"2023-02-17","objectID":"/1139.largest-1-bordered-square.zh/:2:0","series":null,"tags":["daily","prefix sum"],"title":"1139.最大的以1为边界的正方形","uri":"/1139.largest-1-bordered-square.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int largest1BorderedSquare(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { // 前缀和 int m = grid.size(), n = grid[0].size(); vector\u003cvector\u003cint\u003e\u003e sum_row(m, vector\u003cint\u003e(n + 1, 0)); // 每行前缀和 vector\u003cvector\u003cint\u003e\u003e sum_col(m + 1, vector\u003cint\u003e(n, 0)); // 每列前缀和 for (int i = 0; i \u003c grid.size(); i++) { for (int j = 1; j \u003c= n; j++) { sum_row[i][j] = sum_row[i][j - 1] + grid[i][j - 1]; } } for (int i = 1; i \u003c= m; i++) { for (int j = 0; j \u003c n; j++) { sum_col[i][j] = sum_col[i - 1][j] + grid[i - 1][j]; } } int res = 0; for (int i = 1; i \u003c= m; i++) { for (int j = 1; j \u003c= n; j++) { for (int l = res + 1; l \u003c= std::min(i, j); l++) { // 直接从res开始 if (sum_col[i][j - 1] - sum_col[i - l][j - 1] == l \u0026\u0026 sum_row[i - 1][j] - sum_row[i - 1][j - l] == l \u0026\u0026 sum_col[i][j - l] - sum_col[i - l][j - l] == l \u0026\u0026 sum_row[i - l][j] - sum_row[i - l][j - l] == l) res = std::max(l, res); } } } return res * res; } }; ","date":"2023-02-17","objectID":"/1139.largest-1-bordered-square.zh/:3:0","series":null,"tags":["daily","prefix sum"],"title":"1139.最大的以1为边界的正方形","uri":"/1139.largest-1-bordered-square.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description456. 132 Pattern (Medium) Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i \u003c j \u003c k and nums[i] \u003c nums[k] \u003c nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false. Example 1: text Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Example 2: text Input: nums = [3,1,4,2] Output: true Explanation: There is a 132 pattern in the sequence: [1, 4, 2]. Example 3: text Input: nums = [-1,3,2,0] Output: true Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. Constraints: n == nums.length 1 \u003c= n \u003c= 2 * 10⁵ -10⁹ \u003c= nums[i] \u003c= 10⁹ ","date":"2023-02-17","objectID":"/456.132-pattern/:1:0","series":null,"tags":["greedy algorithm","monotone stack"],"title":"456.132 pattern","uri":"/456.132-pattern/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can enumerate i to find (j, k) that meets the requirements. Greedy Algorithm: we need to find the maximum nums[k] that satisfies the requirements. Since k \u003e j, we can traverse the array from back to front. Denote first = nums[i], second = nums[j], third = -INT_MAX， we can use a monotone stack whose elements decrease from bottom to top to simulate the process. If the stack is empty, we push the element into the stack and don’t update third; If the element to be pushed into the stack is greater than the elemment in the top, we pop the element at the top(if the element popped is larger than third ,we update third), until the stack is empty or the element to be pushed is less than the element at the top; If the element to push is less than the element in the top, we compare the element with third, if the element is less than third, we find the answer, otherwise, we push the element to the stack. ","date":"2023-02-17","objectID":"/456.132-pattern/:2:0","series":null,"tags":["greedy algorithm","monotone stack"],"title":"456.132 pattern","uri":"/456.132-pattern/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool find132pattern(vector\u003cint\u003e \u0026nums) { int first = nums[0], second = nums[nums.size() - 1], third = -INT_MAX; int i = 0; stack\u003cint\u003e stk; stk.push(nums[nums.size() - 1]); for (int r = nums.size() - 2; r \u003e= 0; r--) { if (nums[r] \u003c stk.top()) { // if (stk.top() \u003e third) { if (nums[r] \u003c third) { return true; // } } stk.push(nums[r]); } else if (nums[r] == stk.top()) { stk.push(nums[r]); } else { while (!stk.empty() \u0026\u0026 nums[r] \u003e stk.top()) { third = std::max(stk.top(), third); stk.pop(); } stk.push(nums[r]); } } return false; } }; ","date":"2023-02-17","objectID":"/456.132-pattern/:3:0","series":null,"tags":["greedy algorithm","monotone stack"],"title":"456.132 pattern","uri":"/456.132-pattern/#code"},{"categories":["leetcode"],"content":" 1 问题描述456. 132 模式 (Medium) 给你一个整数数组 nums ，数组中共有 n 个整数。 132 模式的子序列 由三个整数 nums[i]、 nums[j] 和 nums[k] 组成，并同时满足： i \u003c j \u003c k 和 nums[i] \u003c nums[k] \u003c nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 示例 1： text 输入：nums = [1,2,3,4] 输出：false 解释：序列中不存在 132 模式的子序列。 示例 2： text 输入：nums = [3,1,4,2] 输出：true 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3： text 输入：nums = [-1,3,2,0] 输出：true 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示： n == nums.length 1 \u003c= n \u003c= 2 * 10⁵ -10⁹ \u003c= nums[i] \u003c= 10⁹ ","date":"2023-02-17","objectID":"/456.132-pattern.zh/:1:0","series":null,"tags":["greedy algorithm","monotone stack"],"title":"456.132模式","uri":"/456.132-pattern.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路枚举i，找到符合条件的(j, k)，贪心想法，nums[k]必定是满足j \u003e k且nums[k] \u003c nums[j]的所有nums[k]中最大的一个，因此这里我们采用单调栈来模拟寻找(j, k)的过程，考虑到k \u003e j，这里需要从后往前遍历。 记first = nums[i], second = nums[j], third = -INT_MAX，栈为单调递减的（考虑入栈顺序），即栈底到栈顶单调递减，从后往前遍历数组： 如果栈为空，就入栈，不更新third； 如果将要入栈的元素大于栈顶元素，那就将栈顶元素弹出（如果栈顶元素大于third，更新third），直到栈为空或者要将入栈的元素小于栈顶元素； 如果将要入栈的元素小于栈顶元素，那么比较该元素和third的大小，如果该元素小于third，说明找到了三元组，否则将该元素入栈 本题的关键我认为有三个，一是想到枚举i找(j, k)，二是找最大的nums[k]，三是从后往前遍历。 ","date":"2023-02-17","objectID":"/456.132-pattern.zh/:2:0","series":null,"tags":["greedy algorithm","monotone stack"],"title":"456.132模式","uri":"/456.132-pattern.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool find132pattern(vector\u003cint\u003e \u0026nums) { int first = nums[0], second = nums[nums.size() - 1], third = -INT_MAX; int i = 0; stack\u003cint\u003e stk; // 栈顶到栈底从小到大 stk.push(nums[nums.size() - 1]); for (int r = nums.size() - 2; r \u003e= 0; r--) { // 栈应该不可能为空 if (nums[r] \u003c stk.top()) { // if (stk.top() \u003e third) { if (nums[r] \u003c third) { return true; // } } stk.push(nums[r]); } else if (nums[r] == stk.top()) { stk.push(nums[r]); } else { while (!stk.empty() \u0026\u0026 nums[r] \u003e stk.top()) { third = std::max(stk.top(), third); stk.pop(); } stk.push(nums[r]); } } return false; } }; ","date":"2023-02-17","objectID":"/456.132-pattern.zh/:3:0","series":null,"tags":["greedy algorithm","monotone stack"],"title":"456.132模式","uri":"/456.132-pattern.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description334. Increasing Triplet Subsequence (Medium) Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i \u003c j \u003c k and nums[i] \u003c nums[j] \u003c nums[k]. If no such indices exists, return false. Example 1: text Input: nums = [1,2,3,4,5] Output: true Explanation: Any triplet where i \u003c j \u003c k is valid. Example 2: text Input: nums = [5,4,3,2,1] Output: false Explanation: No triplet exists. Example 3: text Input: nums = [2,1,5,0,4,6] Output: true Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 \u003c nums[4] == 4 \u003c nums[5] == 6. Constraints: 1 \u003c= nums.length \u003c= 5 * 10⁵ -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 Follow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity? ","date":"2023-02-17","objectID":"/334.increasing-triplet-subsequence/:1:0","series":null,"tags":["greedy algorithm"],"title":"334.increasing triplet subsequence","uri":"/334.increasing-triplet-subsequence/#description"},{"categories":["leetcode"],"content":" 2 SolutionLet’s traverse the array from i = 0, if we find the first pair (left, mid), we can make nums[k] == mid, and traverse the array from i = k + 1. If nums[i] \u003e mid, we find the answer; If left \u003c nums[i] \u003c= mid, we can assign left as nums[i]; If nums[i] \u003c= left, the result depends on nums[i + 1]: If i + 1 == nums.size(), return false; If nums[i + 1] \u003e mid, return true; If nums[i + 1] \u003e nums[i] \u0026\u0026 nums[i + 1] \u003c= mid, update left and mid; Else, continue; ","date":"2023-02-17","objectID":"/334.increasing-triplet-subsequence/:2:0","series":null,"tags":["greedy algorithm"],"title":"334.increasing triplet subsequence","uri":"/334.increasing-triplet-subsequence/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool increasingTriplet(vector\u003cint\u003e \u0026nums) { int left = nums[0], mid = nums[0], right = nums[0]; if (nums.size() \u003c 3) return false; int i = 0; while (i \u003c nums.size() \u0026\u0026 nums[i] \u003c= left) { left = nums[i]; ++i; } if (i \u003e= nums.size() - 1) return false; mid = nums[i++]; while (i \u003c nums.size() \u0026\u0026 nums[i] \u003c= mid) { if (nums[i] \u003e left) { mid = nums[i]; } else { // nums[i] \u003c= left，res depends on nums[i + 1] int left2 = nums[i]; ++i; while (i \u003c nums.size() \u0026\u0026 nums[i] \u003c= left2) { left2 = nums[i]; ++i; } if (i == nums.size()) return false; // 此时nums[i] \u003e left2 if (nums[i] \u003e mid) return true; mid = nums[i]; // update mid left = left2; // update left } ++i; } return i \u003c nums.size(); } }; ","date":"2023-02-17","objectID":"/334.increasing-triplet-subsequence/:3:0","series":null,"tags":["greedy algorithm"],"title":"334.increasing triplet subsequence","uri":"/334.increasing-triplet-subsequence/#code"},{"categories":["leetcode"],"content":" 1 问题描述334. 递增的三元子序列 (Medium) 给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标 (i, j, k) 且满足 i \u003c j \u003c k ，使得 nums[i] \u003c nums[j] \u003c nums[k] ，返回 true ；否则，返回 false 。 示例 1： text 输入：nums = [1,2,3,4,5] 输出：true 解释：任何 i \u003c j \u003c k 的三元组都满足题意 示例 2： text 输入：nums = [5,4,3,2,1] 输出：false 解释：不存在满足题意的三元组 示例 3： text 输入：nums = [2,1,5,0,4,6] 输出：true 解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 \u003c nums[4] == 4 \u003c nums[5] == 6 提示： 1 \u003c= nums.length \u003c= 5 * 10⁵ -2³¹ \u003c= nums[i] \u003c= 2³¹ - 1 进阶： 你能实现时间复杂度为 O(n) ，空间复杂度为 O(1) 的解决方案吗？ ","date":"2023-02-17","objectID":"/334.increasing-triplet-subsequence.zh/:1:0","series":null,"tags":["greedy algorithm"],"title":"334.递增的三元子序列","uri":"/334.increasing-triplet-subsequence.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心：i从0开始遍历，首先找到第一组(left, mid)，令nums[k] == mid，再从i == k + 1开始遍历，如果nums[i] \u003e mid，说明找到了三元组，如果left \u003c nums[i] \u003c= mid，那就将mid更新为nums[i]，而如果nums[i] \u003c= left，就要考虑更新left和mid了，具体流程见代码. ","date":"2023-02-17","objectID":"/334.increasing-triplet-subsequence.zh/:2:0","series":null,"tags":["greedy algorithm"],"title":"334.递增的三元子序列","uri":"/334.increasing-triplet-subsequence.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool increasingTriplet(vector\u003cint\u003e \u0026nums) { int left = nums[0], mid = nums[0], right = nums[0]; if (nums.size() \u003c 3) return false; int i = 0; while (i \u003c nums.size() \u0026\u0026 nums[i] \u003c= left) { left = nums[i]; ++i; } if (i \u003e= nums.size() - 1) return false; mid = nums[i++]; while (i \u003c nums.size() \u0026\u0026 nums[i] \u003c= mid) { if (nums[i] \u003e left) { mid = nums[i]; } else { // nums[i] \u003c= left，此时考虑nums[i + 1]，如果nums[i + 1] int left2 = nums[i]; ++i; while (i \u003c nums.size() \u0026\u0026 nums[i] \u003c= left2) { left2 = nums[i]; ++i; } if (i == nums.size()) return false; // 此时nums[i] \u003e left2 if (nums[i] \u003e mid) return true; mid = nums[i]; // 更新mid left = left2; // 更新left } ++i; } return i \u003c nums.size(); } }; ","date":"2023-02-17","objectID":"/334.increasing-triplet-subsequence.zh/:3:0","series":null,"tags":["greedy algorithm"],"title":"334.递增的三元子序列","uri":"/334.increasing-triplet-subsequence.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1218. Longest Arithmetic Subsequence of Given Difference (Medium) Longest Arithmetic Subsequence of Given Difference (Medium) Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference. A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements. Example 1: text Input: arr = [1,2,3,4], difference = 1 Output: 4 Explanation: The longest arithmetic subsequence is [1,2,3,4]. Example 2: text Input: arr = [1,3,5,7], difference = 1 Output: 1 Explanation: The longest arithmetic subsequence is any single element. Example 3: text Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2 Output: 4 Explanation: The longest arithmetic subsequence is [7,5,3,1]. Constraints: 1 \u003c= arr.length \u003c= 10⁵ -10⁴ \u003c= arr[i], difference \u003c= 10⁴ ","date":"2023-02-16","objectID":"/1218.longest-arithmetic-subsequence-of-given-difference/:1:0","series":null,"tags":["hash table"],"title":"1218.longest arithmetic subsequence of given difference","uri":"/1218.longest-arithmetic-subsequence-of-given-difference/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use a hash table ump[nums[i]] to record the length of longest arithmetic subsequence in which nums[i] is the last element. We have cpp if (ump.find(num - difference) != ump.end()) { ump[num] = ump[num - difference] + 1; } else { ump[num] = 1; } ","date":"2023-02-16","objectID":"/1218.longest-arithmetic-subsequence-of-given-difference/:2:0","series":null,"tags":["hash table"],"title":"1218.longest arithmetic subsequence of given difference","uri":"/1218.longest-arithmetic-subsequence-of-given-difference/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int longestSubsequence(vector\u003cint\u003e \u0026arr, int difference) { unordered_map\u003cint, int\u003e ump; for (auto \u0026num : arr) { if (ump.find(num - difference) != ump.end()) { ump[num] = ump[num - difference] + 1; } else { ump[num] = 1; } } int res = 0; for (auto \u0026num : ump) { res = res \u003c num.second ? num.second : res; } return res; } }; ","date":"2023-02-16","objectID":"/1218.longest-arithmetic-subsequence-of-given-difference/:3:0","series":null,"tags":["hash table"],"title":"1218.longest arithmetic subsequence of given difference","uri":"/1218.longest-arithmetic-subsequence-of-given-difference/#code"},{"categories":["leetcode"],"content":" 1 问题描述1218. 最长定差子序列 (Medium) 给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。 子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。 示例 1： text 输入：arr = [1,2,3,4], difference = 1 输出：4 解释：最长的等差子序列是 [1,2,3,4]。 示例 2： text 输入：arr = [1,3,5,7], difference = 1 输出：1 解释：最长的等差子序列是任意单个元素。 示例 3： text 输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2 输出：4 解释：最长的等差子序列是 [7,5,3,1]。 提示： 1 \u003c= arr.length \u003c= 10⁵ -10⁴ \u003c= arr[i], difference \u003c= 10⁴ ","date":"2023-02-16","objectID":"/1218.longest-arithmetic-subsequence-of-given-difference.zh/:1:0","series":null,"tags":["hash table"],"title":"1218.最长定差子序列","uri":"/1218.longest-arithmetic-subsequence-of-given-difference.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用哈希表，记录数组中每个元素，作为子序列末尾元素时，该元素对应的最长子序列的长度，有 cpp if (ump.find(num - difference) != ump.end()) { ump[num] = ump[num - difference] + 1; } else { ump[num] = 1; } ","date":"2023-02-16","objectID":"/1218.longest-arithmetic-subsequence-of-given-difference.zh/:2:0","series":null,"tags":["hash table"],"title":"1218.最长定差子序列","uri":"/1218.longest-arithmetic-subsequence-of-given-difference.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int longestSubsequence(vector\u003cint\u003e \u0026arr, int difference) { unordered_map\u003cint, int\u003e ump; for (auto \u0026num : arr) { if (ump.find(num - difference) != ump.end()) { ump[num] = ump[num - difference] + 1; } else { ump[num] = 1; } } int res = 0; for (auto \u0026num : ump) { res = res \u003c num.second ? num.second : res; } return res; } }; ","date":"2023-02-16","objectID":"/1218.longest-arithmetic-subsequence-of-given-difference.zh/:3:0","series":null,"tags":["hash table"],"title":"1218.最长定差子序列","uri":"/1218.longest-arithmetic-subsequence-of-given-difference.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2341. Maximum Number of Pairs in Array (Easy) You are given a 0-indexed integer array nums. In one operation, you may do the following: Choose two integers in nums that are equal. Remove both integers from nums, forming a pair. The operation is done on nums as many times as possible. Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible. Example 1: text Input: nums = [1,3,2,1,3,2,2] Output: [3,1] Explanation: Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2]. Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2]. Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2]. No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums. Example 2: text Input: nums = [1,1] Output: [1,0] Explanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = []. No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums. Example 3: text Input: nums = [0] Output: [0,1] Explanation: No pairs can be formed, and there is 1 number leftover in nums. Constraints: 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 100 ","date":"2023-02-16","objectID":"/2341.maximum-number-of-pairs-in-array/:1:0","series":null,"tags":["daily","hash table"],"title":"2341.maximum Number of Pairs in Array","uri":"/2341.maximum-number-of-pairs-in-array/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use a hashtable to record the times of occurrence of each element. ","date":"2023-02-16","objectID":"/2341.maximum-number-of-pairs-in-array/:2:0","series":null,"tags":["daily","hash table"],"title":"2341.maximum Number of Pairs in Array","uri":"/2341.maximum-number-of-pairs-in-array/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e numberOfPairs(vector\u003cint\u003e\u0026 nums) { int arr[101] = {0}; vector\u003cint\u003e res(2, 0); for (int i = 0; i \u003c nums.size(); i++) { if (arr[nums[i]] == 0) { arr[nums[i]]++; } else { arr[nums[i]] = 0; res[0]++; } } for (int i = 0; i \u003c= 100; i++) { if (arr[i] \u003e 0) { res[1]++; } } return res; } }; ","date":"2023-02-16","objectID":"/2341.maximum-number-of-pairs-in-array/:3:0","series":null,"tags":["daily","hash table"],"title":"2341.maximum Number of Pairs in Array","uri":"/2341.maximum-number-of-pairs-in-array/#code"},{"categories":["leetcode"],"content":" 1 问题描述2341. 数组能形成多少数对 (Easy) 给你一个下标从 0 开始的整数数组 nums 。在一步操作中，你可以执行以下步骤： 从 nums 选出 两个 相等的 整数 从 nums 中移除这两个整数，形成一个 数对 请你在 nums 上多次执行此操作直到无法继续执行。 返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目， answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。 示例 1： text 输入：nums = [1,3,2,1,3,2,2] 输出：[3,1] 解释： nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。 nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。 nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。 无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。 示例 2： text 输入：nums = [1,1] 输出：[1,0] 解释：nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [] 。 无法形成更多数对。总共形成 1 个数对，nums 中剩下 0 个数字。 示例 3： text 输入：nums = [0] 输出：[0,1] 解释：无法形成数对，nums 中剩下 1 个数字。 提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 100 ","date":"2023-02-16","objectID":"/2341.maximum-number-of-pairs-in-array.zh/:1:0","series":null,"tags":["daily","hash table"],"title":"2341.maximum Number of Pairs in Array","uri":"/2341.maximum-number-of-pairs-in-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路考虑到0 \u003c= nums[i] \u003c= 100，可以用长度为101的数组充当哈希表. ","date":"2023-02-16","objectID":"/2341.maximum-number-of-pairs-in-array.zh/:2:0","series":null,"tags":["daily","hash table"],"title":"2341.maximum Number of Pairs in Array","uri":"/2341.maximum-number-of-pairs-in-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e numberOfPairs(vector\u003cint\u003e\u0026 nums) { int arr[101] = {0}; vector\u003cint\u003e res(2, 0); for (int i = 0; i \u003c nums.size(); i++) { if (arr[nums[i]] == 0) { arr[nums[i]]++; } else { arr[nums[i]] = 0; res[0]++; } } for (int i = 0; i \u003c= 100; i++) { if (arr[i] \u003e 0) { res[1]++; } } return res; } }; ","date":"2023-02-16","objectID":"/2341.maximum-number-of-pairs-in-array.zh/:3:0","series":null,"tags":["daily","hash table"],"title":"2341.maximum Number of Pairs in Array","uri":"/2341.maximum-number-of-pairs-in-array.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description[2335. Minimum Amount of Time to Fill Cups (Easy)] You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water. You are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively. Return the minimum number of seconds needed to fill up all the cups. Example 1: text Input: amount = [1,4,2] Output: 4 Explanation: One way to fill up the cups is: Second 1: Fill up a cold cup and a warm cup. Second 2: Fill up a warm cup and a hot cup. Second 3: Fill up a warm cup and a hot cup. Second 4: Fill up a warm cup. It can be proven that 4 is the minimum number of seconds needed. Example 2: text Input: amount = [5,4,4] Output: 7 Explanation: One way to fill up the cups is: Second 1: Fill up a cold cup, and a hot cup. Second 2: Fill up a cold cup, and a warm cup. Second 3: Fill up a cold cup, and a warm cup. Second 4: Fill up a warm cup, and a hot cup. Second 5: Fill up a cold cup, and a hot cup. Second 6: Fill up a cold cup, and a warm cup. Second 7: Fill up a hot cup. Example 3: text Input: amount = [5,0,0] Output: 5 Explanation: Every second, we fill up a cold cup. Constraints: amount.length == 3 0 \u003c= amount[i] \u003c= 100 ","date":"2023-02-15","objectID":"/2335.minimum-amount-of-time-to-fill-cups/:1:0","series":null,"tags":["greedy algorithm"],"title":"2335.minimum amount of time to fill cups","uri":"/2335.minimum-amount-of-time-to-fill-cups/#description"},{"categories":["leetcode"],"content":" 2 SolutionIf max \u003e= mid + min, res = max; Ifmax \u003cmid + min, res = (max + mid - min) / 2. ","date":"2023-02-15","objectID":"/2335.minimum-amount-of-time-to-fill-cups/:2:0","series":null,"tags":["greedy algorithm"],"title":"2335.minimum amount of time to fill cups","uri":"/2335.minimum-amount-of-time-to-fill-cups/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int fillCups(vector\u003cint\u003e\u0026 amount) { int amax = amount[0], amin = amount[0]; int asum = amount[0]; for (int i = 1; i \u003c amount.size(); i++) { amax = max(amax, amount[i]); amin = min(amin, amount[i]); asum += amount[i]; } int amid = asum - amax - amin; if (amax \u003e= amin + amid) return amax; return (asum + 1) / 2; } }; ","date":"2023-02-15","objectID":"/2335.minimum-amount-of-time-to-fill-cups/:3:0","series":null,"tags":["greedy algorithm"],"title":"2335.minimum amount of time to fill cups","uri":"/2335.minimum-amount-of-time-to-fill-cups/#code"},{"categories":["leetcode"],"content":" 1 问题描述2335. 装满杯子需要的最短总时长 (Easy) 现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。 给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、 amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。 示例 1： text 输入：amount = [1,4,2] 输出：4 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯温水。 第 2 秒：装满一杯温水和一杯热水。 第 3 秒：装满一杯温水和一杯热水。 第 4 秒：装满一杯温水。 可以证明最少需要 4 秒才能装满所有杯子。 示例 2： text 输入：amount = [5,4,4] 输出：7 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯热水。 第 2 秒：装满一杯冷水和一杯温水。 第 3 秒：装满一杯冷水和一杯温水。 第 4 秒：装满一杯温水和一杯热水。 第 5 秒：装满一杯冷水和一杯热水。 第 6 秒：装满一杯冷水和一杯温水。 第 7 秒：装满一杯热水。 示例 3： text 输入：amount = [5,0,0] 输出：5 解释：每秒装满一杯冷水。 提示： amount.length == 3 0 \u003c= amount[i] \u003c= 100 ","date":"2023-02-15","objectID":"/2335.minimum-amount-of-time-to-fill-cups.zh/:1:0","series":null,"tags":["greedy algorithm"],"title":"2335.装满杯子所需要的最短时长","uri":"/2335.minimum-amount-of-time-to-fill-cups.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路记冷水、温水、热水中所需的最多杯子数量为max，最少的为min，另一个为mid。 如果max \u003e= mid + min，那么结果就是max； 如果max \u003c mid + min，那么设mid中取a次和max配对，min中取b次和max配对，a + b = max ,mid - a = min - b，结果为max + mid - a == (max + mid - min + 1) / 2 ","date":"2023-02-15","objectID":"/2335.minimum-amount-of-time-to-fill-cups.zh/:2:0","series":null,"tags":["greedy algorithm"],"title":"2335.装满杯子所需要的最短时长","uri":"/2335.minimum-amount-of-time-to-fill-cups.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int fillCups(vector\u003cint\u003e\u0026 amount) { int amax = amount[0], amin = amount[0]; int asum = amount[0]; for (int i = 1; i \u003c amount.size(); i++) { amax = max(amax, amount[i]); amin = min(amin, amount[i]); asum += amount[i]; } int amid = asum - amax - amin; if (amax \u003e= amin + amid) return amax; return (asum + 1) / 2; } }; ","date":"2023-02-15","objectID":"/2335.minimum-amount-of-time-to-fill-cups.zh/:3:0","series":null,"tags":["greedy algorithm"],"title":"2335.装满杯子所需要的最短时长","uri":"/2335.minimum-amount-of-time-to-fill-cups.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1705.maximum-number-of-eaten-apples ","date":"2023-02-15","objectID":"/1705.maximum-number-of-eaten-apples/:1:0","series":null,"tags":["Greedy algorithm","priority queue"],"title":"1705.maximum number of eaten apples","uri":"/1705.maximum-number-of-eaten-apples/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe optimal strategy is to eat the apple that rots first, we can use the priority queue to simulate the process. app_decay[i][0] indicates the expected decay time of the apples born on day i, and app_decay[i][1] indicates how many apples were born on day i. The top() of the priority queue pq must be a vector with the minimum vec[0]. We traverse the array by time, if there are apples born on this day, we push app_decay[i] to pq, and pop the elements of the top() of pq until the heap is empty or pq.top()[0] \u003e i, then pq.top()[1]--. ","date":"2023-02-15","objectID":"/1705.maximum-number-of-eaten-apples/:2:0","series":null,"tags":["Greedy algorithm","priority queue"],"title":"1705.maximum number of eaten apples","uri":"/1705.maximum-number-of-eaten-apples/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int eatenApples(vector\u003cint\u003e \u0026apples, vector\u003cint\u003e \u0026days) { vector\u003cvector\u003cint\u003e\u003e app_decay(apples.size(), vector\u003cint\u003e(2, 0)); for (int i = 0; i \u003c apples.size(); i++) { app_decay[i][0] = i + days[i]; app_decay[i][1] = apples[i]; } priority_queue\u003cvector\u003cint\u003e\u003e q; auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { return v1[0] \u003e= v2[0]; }; priority_queue\u003cvector\u003cint\u003e, vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); int res = 0; for (int i = 0; i \u003c apples.size(); i++) { if (app_decay[i][1] != 0) { pq.push(app_decay[i]); } vector\u003cint\u003e vec; while (!pq.empty() \u0026\u0026 pq.top()[0] \u003c= i) { pq.pop(); } if (!pq.empty()) { vec = pq.top(); pq.pop(); } if (!vec.empty() \u0026\u0026 vec[0] \u003e i) { vec[1]--; if (vec[1] != 0) { pq.push(vec); } res++; } } int date = apples.size(); while (!pq.empty()) { vector\u003cint\u003e vec1; while (!pq.empty() \u0026\u0026 pq.top()[0] \u003c= date) { pq.pop(); } if (!pq.empty()) { vec1 = pq.top(); pq.pop(); } if (!vec1.empty() \u0026\u0026 vec1[0] \u003e date) { vec1[1]--; if (vec1[1] != 0) pq.push(vec1); res++; } date++; } return res; } }; ","date":"2023-02-15","objectID":"/1705.maximum-number-of-eaten-apples/:3:0","series":null,"tags":["Greedy algorithm","priority queue"],"title":"1705.maximum number of eaten apples","uri":"/1705.maximum-number-of-eaten-apples/#code"},{"categories":["leetcode"],"content":" 1 问题描述1705.吃苹果的最大数目 中等 There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0. You decided to eat at most one apple a day (to keep the doctors away). Note that you can keep eating after the first n days. Given two integer arrays days and apples of length n, return the maximum number of apples you can eat. Example 1: text Input: apples = [1,2,3,5,2], days = [3,2,1,4,2] Output: 7 Explanation: You can eat 7 apples: - On the first day, you eat an apple that grew on the first day. - On the second day, you eat an apple that grew on the second day. - On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot. - On the fourth to the seventh days, you eat apples that grew on the fourth day. Example 2: text Input: apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] Output: 5 Explanation: You can eat 5 apples: - On the first to the third day you eat apples that grew on the first day. - Do nothing on the fouth and fifth days. - On the sixth and seventh days you eat apples that grew on the sixth day. Constraints: n == apples.length == days.length 1 \u003c= n \u003c= 2 * 10⁴ 0 \u003c= apples[i], days[i] \u003c= 2 * 10⁴ days[i] = 0 if and only if apples[i] = 0. ","date":"2023-02-15","objectID":"/1705.maximum-number-of-eaten-apples.zh/:1:0","series":null,"tags":["Greedy algorithm","priority queue"],"title":"1705.吃苹果的最大数目","uri":"/1705.maximum-number-of-eaten-apples.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路吃苹果的最佳策略就是，每次只吃最先腐烂的苹果，即吃腐烂日期最小的苹果，利用优先队列来模拟这个过程。 vector\u003cvector\u003cint\u003e\u003e app_decay(apples.size(), vector\u003cint\u003e(2, 0)); app_decay[i][0]表示第i天结出的苹果的预计腐烂时间，app_decay[i][1]表示第i天结出了多少个苹果。 优先队列的top()必须是腐烂时间最小的app_decay[i] 按时间遍历，如果当天结出了苹果，就将其加入优先队列pq，然后弹出堆顶元素直到堆为空或者pq.top()[0] \u003e i，然后将pq.top()[1]--。 n天之后再进行单独判断 ","date":"2023-02-15","objectID":"/1705.maximum-number-of-eaten-apples.zh/:2:0","series":null,"tags":["Greedy algorithm","priority queue"],"title":"1705.吃苹果的最大数目","uri":"/1705.maximum-number-of-eaten-apples.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int eatenApples(vector\u003cint\u003e \u0026apples, vector\u003cint\u003e \u0026days) { // 优先吃最早腐烂的苹果，即吃腐烂日期最小的苹果 vector\u003cvector\u003cint\u003e\u003e app_decay(apples.size(), vector\u003cint\u003e(2, 0)); for (int i = 0; i \u003c apples.size(); i++) { app_decay[i][0] = i + days[i]; app_decay[i][1] = apples[i]; } priority_queue\u003cvector\u003cint\u003e\u003e q; auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2) { return v1[0] \u003e= v2[0]; }; // 优先队列的top应该是腐烂日期最小的 priority_queue\u003cvector\u003cint\u003e, vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); int res = 0; for (int i = 0; i \u003c apples.size(); i++) { if (app_decay[i][1] != 0) { pq.push(app_decay[i]); } vector\u003cint\u003e vec; while (!pq.empty() \u0026\u0026 pq.top()[0] \u003c= i) { pq.pop(); } if (!pq.empty()) { vec = pq.top(); pq.pop(); } if (!vec.empty() \u0026\u0026 vec[0] \u003e i) { vec[1]--; if (vec[1] != 0) { pq.push(vec); } res++; } } int date = apples.size(); while (!pq.empty()) { vector\u003cint\u003e vec1; while (!pq.empty() \u0026\u0026 pq.top()[0] \u003c= date) { pq.pop(); } if (!pq.empty()) { vec1 = pq.top(); pq.pop(); } if (!vec1.empty() \u0026\u0026 vec1[0] \u003e date) { vec1[1]--; if (vec1[1] != 0) pq.push(vec1); res++; } date++; } return res; } }; ","date":"2023-02-15","objectID":"/1705.maximum-number-of-eaten-apples.zh/:3:0","series":null,"tags":["Greedy algorithm","priority queue"],"title":"1705.吃苹果的最大数目","uri":"/1705.maximum-number-of-eaten-apples.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description871.minimum-number-of-refueling-stops ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops/:1:0","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.minimum number of refueling stops","uri":"/871.minimum-number-of-refueling-stops/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops/:2:0","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.minimum number of refueling stops","uri":"/871.minimum-number-of-refueling-stops/#solution"},{"categories":["leetcode"],"content":" 2.1 Dynamic programmingIn this problem, the number is finite, and there is a recurrence relation, so we can use dynamic programming to solve this problem. Let dp[i][j] means the furthest distance we can reach after passing throught i stations and adding fuel for j times. Obviously, i \u003e= j. So we can discuss dp[i][j] in two cases: We don’t add fuel at the ith station: dp[i][j] = dp[i - 1][j] We add fuel in the ith station(We have to arrive at the ith station in the case we have just added fuel for j - 1 times before, that is: dp[i - 1][j - 1] \u003e= stations[i - 1][0]): dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1]. dp[i][j] is the maximum value of the two values. ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops/:2:1","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.minimum number of refueling stops","uri":"/871.minimum-number-of-refueling-stops/#dynamic-programming"},{"categories":["leetcode"],"content":" 2.2 Greedy algorithmIt is easy to see that the optimal strategy is to add fuel in the station with the most fuel. Actually, we can get fuel from the station that we passed through. For each time we can’t get to the next station or destination, we get fuel from the station with the most fuel that we passed through but didn’t get fuel from, until we get to the next station or destination or there is no station we can get fuel from. ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops/:2:2","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.minimum number of refueling stops","uri":"/871.minimum-number-of-refueling-stops/#greedy-algorithm"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops/:3:0","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.minimum number of refueling stops","uri":"/871.minimum-number-of-refueling-stops/#code"},{"categories":["leetcode"],"content":" 3.1 Dynamic programming cpp class Solution { public: int minRefuelStops(int target, int startFuel, vector\u003cvector\u003cint\u003e\u003e \u0026stations) { int n = stations.size(); if (n == 0) { if (startFuel \u003e= target) return 0; return -1; } vector\u003cvector\u003clong long\u003e\u003e dp(n + 1, vector\u003clong long\u003e(n + 1, 0)); dp[0][0] = startFuel; for (int i = 1; i \u003c= n; i++) { dp[i][0] = stations[i - 1][0] \u003c= startFuel ? startFuel : 0; } for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= i; j++) { // We have to arrive at the `i`th station in the case we have just added fuel for `j - 1` times before, if (dp[i - 1][j - 1] \u003e= stations[i - 1][0]) dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - 1] + stations[i - 1][1]); else dp[i][j] = dp[i - 1][j]; } } int res = 600; for (int i = 0; i \u003c= n; i++) { for (int j = 0; j \u003c= i; j++) { if (dp[i][j] \u003e= target) res = std::min(res, j); } } return res \u003e= 600 ? -1 : res; } }; ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops/:3:1","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.minimum number of refueling stops","uri":"/871.minimum-number-of-refueling-stops/#dynamic-programming-1"},{"categories":["leetcode"],"content":" 3.2 Greedy algorithm cpp class Solution { public: int minRefuelStops(int target, int startFuel, vector\u003cvector\u003cint\u003e\u003e\u0026 stations) { int n = stations.size(); if (n == 0) { if (startFuel \u003e= target) return 0; return -1; } if (startFuel \u003c stations[0][0]) return -1; int res = 0; auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2){ return v1[1] \u003c= v2[1]; }; priority_queue\u003cvector\u003cint\u003e, vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); // heap top is the station with the most fuel pq.push(stations[0]); int cur_fuel = startFuel - stations[0][0]; for (int i = 1; i \u003c n; i++) { while (!pq.empty() \u0026\u0026 cur_fuel \u003c stations[i][0] - stations[i - 1][0]) { // notice the **while**, and judge if pq is empty first! cur_fuel += pq.top()[1]; pq.pop(); res++; } if (cur_fuel \u003c stations[i][0] - stations[i - 1][0]) { return -1; } pq.push(stations[i]); cur_fuel = cur_fuel - (stations[i][0] - stations[i - 1][0]); } while (!pq.empty() \u0026\u0026 cur_fuel \u003c target - stations[n - 1][0]) { cur_fuel += pq.top()[1]; res++; pq.pop(); } if (cur_fuel \u003c target - stations[n - 1][0]) return -1; return res; } }; ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops/:3:2","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.minimum number of refueling stops","uri":"/871.minimum-number-of-refueling-stops/#greedy-algorithm-1"},{"categories":["leetcode"],"content":" 1 问题描述871.最低加油次数 ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops.zh/:1:0","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.最低加油次数","uri":"/871.minimum-number-of-refueling-stops.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops.zh/:2:0","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.最低加油次数","uri":"/871.minimum-number-of-refueling-stops.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 动态规划对于这种有限次数，能看出来有递推关系的，可以考虑动态规划。 这里状态记为dp[i][j]，表示经过前i个加油站，加j次油之后，能够到达的最远距离，这里显然有i \u003e= j。 那么考虑dp[i][j]的递推关系，可以分在第i个加油站加油和不加油两种情况来讨论： 在第i个加油站不加油：dp[i][j] = dp[i - 1][j] 在第i个加油站加油（要求第i个加油站可以在之前只加了j - 1次油的情况下到达），即dp[i - 1][j - 1] \u003e= stations[i - 1][0]，此时dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1] dp[i][j]取两者中的最大值 ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops.zh/:2:1","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.最低加油次数","uri":"/871.minimum-number-of-refueling-stops.zh/#动态规划"},{"categories":["leetcode"],"content":" 2.2 贪心首先，很容易想到，最佳策略每次加油，都是在油最多的加油站去加油，这里实际上可以认为能直接从经过的加油站中取油，即每次发现到达不了下一个加油站或者终点了，就从已经经过但是没加过油的加油站里加油，直到可以到达下一个加油站或者终点，可以利用优先队列来模拟这个过程，每次需要更新剩余的燃油cur_fuel。 ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops.zh/:2:2","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.最低加油次数","uri":"/871.minimum-number-of-refueling-stops.zh/#贪心"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops.zh/:3:0","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.最低加油次数","uri":"/871.minimum-number-of-refueling-stops.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 动态规划 cpp class Solution { public: int minRefuelStops(int target, int startFuel, vector\u003cvector\u003cint\u003e\u003e \u0026stations) { int n = stations.size(); if (n == 0) { if (startFuel \u003e= target) return 0; return -1; } vector\u003cvector\u003clong long\u003e\u003e dp(n + 1, vector\u003clong long\u003e(n + 1, 0)); dp[0][0] = startFuel; for (int i = 1; i \u003c= n; i++) { dp[i][0] = stations[i - 1][0] \u003c= startFuel ? startFuel : 0; } for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= i; j++) { // 如果stations[i - 1](第i个加油站可以在dp[i - 1][j - 1]的情况下到达) if (dp[i - 1][j - 1] \u003e= stations[i - 1][0]) dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - 1] + stations[i - 1][1]); else dp[i][j] = dp[i - 1][j]; } } int res = 600; for (int i = 0; i \u003c= n; i++) { for (int j = 0; j \u003c= i; j++) { if (dp[i][j] \u003e= target) res = std::min(res, j); } } return res \u003e= 600 ? -1 : res; } }; ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops.zh/:3:1","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.最低加油次数","uri":"/871.minimum-number-of-refueling-stops.zh/#动态规划-1"},{"categories":["leetcode"],"content":" 3.2 贪心 cpp class Solution { public: int minRefuelStops(int target, int startFuel, vector\u003cvector\u003cint\u003e\u003e\u0026 stations) { int n = stations.size(); if (n == 0) { if (startFuel \u003e= target) return 0; return -1; } if (startFuel \u003c stations[0][0]) return -1; int res = 0; auto cmp = [\u0026](vector\u003cint\u003e \u0026v1, vector\u003cint\u003e \u0026v2){ return v1[1] \u003c= v2[1]; }; priority_queue\u003cvector\u003cint\u003e, vector\u003cvector\u003cint\u003e\u003e, decltype(cmp)\u003e pq(cmp); // 油最多的加油站在堆顶 pq.push(stations[0]); int cur_fuel = startFuel - stations[0][0]; for (int i = 1; i \u003c n; i++) { while (!pq.empty() \u0026\u0026 cur_fuel \u003c stations[i][0] - stations[i - 1][0]) { cur_fuel += pq.top()[1]; pq.pop(); res++; } if (cur_fuel \u003c stations[i][0] - stations[i - 1][0]) { return -1; } pq.push(stations[i]); cur_fuel = cur_fuel - (stations[i][0] - stations[i - 1][0]); } while (!pq.empty() \u0026\u0026 cur_fuel \u003c target - stations[n - 1][0]) { cur_fuel += pq.top()[1]; res++; pq.pop(); } if (cur_fuel \u003c target - stations[n - 1][0]) return -1; return res; } }; ","date":"2023-02-15","objectID":"/871.minimum-number-of-refueling-stops.zh/:3:2","series":null,"tags":["dynamic programming","greedy algorithm","priority queue"],"title":"871.最低加油次数","uri":"/871.minimum-number-of-refueling-stops.zh/#贪心-1"},{"categories":["leetcode"],"content":" 1 Description1250.check-if-it-is-a-good-array ","date":"2023-02-15","objectID":"/1250.check-if-it-is-a-good-array/:1:0","series":null,"tags":["daily","math"],"title":"1250.check if it is a good array","uri":"/1250.check-if-it-is-a-good-array/#description"},{"categories":["leetcode"],"content":" 2 SolutionActually, what we need to determine is whether the maximum common divisor of all elements in the array is 1. We can use rolling division to get the maximum common divisor gcd of nums[0] and nums[1], then get the new maximum common divisor gcd of gcd and nums[2]… ","date":"2023-02-15","objectID":"/1250.check-if-it-is-a-good-array/:2:0","series":null,"tags":["daily","math"],"title":"1250.check if it is a good array","uri":"/1250.check-if-it-is-a-good-array/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: int gcd(int a, int b) { // b^=a,a^=b,b^=a the same as swap(a, b) while (b ^= (a ^= (b ^= (a %= b)))) ; return a; } bool isGoodArray(vector\u003cint\u003e \u0026nums) { if (nums.size() == 1) return nums[0] == 1; for (int i = 0; i \u003c nums.size() - 1; i++) { int tmp = gcd(nums[i], nums[i + 1]); if (tmp == 1) // gcd is 1 return true; nums[i + 1] = tmp; } return true; } }; ","date":"2023-02-15","objectID":"/1250.check-if-it-is-a-good-array/:3:0","series":null,"tags":["daily","math"],"title":"1250.check if it is a good array","uri":"/1250.check-if-it-is-a-good-array/#code"},{"categories":["leetcode"],"content":" 1 问题描述1250.检查“好数组” ","date":"2023-02-15","objectID":"/1250.check-if-it-is-a-good-array.zh/:1:0","series":null,"tags":["daily","math"],"title":"1250.检查“好数组”","uri":"/1250.check-if-it-is-a-good-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，要注意到，本题的要求，其实可以转化为数组中所有元素的最大公因数为1； 利用辗转相除法，将nums[0]和nums[1]求得的最大公因数num再与nums[2]求最大公因数作为新的num，如果到最后num == 1，返回true，否则返回false。 ","date":"2023-02-15","objectID":"/1250.check-if-it-is-a-good-array.zh/:2:0","series":null,"tags":["daily","math"],"title":"1250.检查“好数组”","uri":"/1250.check-if-it-is-a-good-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool isGoodArray(vector\u003cint\u003e \u0026nums) { std::sort(nums.begin(), nums.end()); // 利用哈希表储存不为1的因子，然后遍历，如果最后哈希表为空，return true if (nums[0] == 1) return true; std::unordered_set\u003cint\u003e factor; int root = sqrt(nums[0]); for (int i = 2; i \u003c= root; i++) { if (nums[0] % i == 0) { if (factor.empty()) { factor.insert(i); factor.insert(nums[0] / i); } else { int flag = 0; // 为0说明factor里面没有它的因子 for (auto \u0026num : factor) { if (i % num == 0) { flag = 1; break; } } if (flag == 0) { factor.insert(i); factor.insert(nums[0] / i); } } } } if (factor.empty()) { factor.insert(nums[0]); } for (int i = 1; i \u003c nums.size(); i++) { auto tmp = factor; for (auto \u0026num : tmp) { if (nums[i] % num != 0) { // 不是公因子，就移除 factor.erase(num); } } } return factor.empty(); } }; cpp #include \u003cvector\u003e using std::vector; class Solution { public: int gcd(int a, int b) { // 其中b^=a,a^=b,b^=a相当于swap(a,b) while (b ^= (a ^= (b ^= (a %= b)))) ; return a; } bool isGoodArray(vector\u003cint\u003e \u0026nums) { if (nums.size() == 1) return nums[0] == 1; for (int i = 0; i \u003c nums.size() - 1; i++) { int tmp = gcd(nums[i], nums[i + 1]); if (tmp == 1) // 最大公因数已经是1了 return true; nums[i + 1] = tmp; } return true; } }; ","date":"2023-02-15","objectID":"/1250.check-if-it-is-a-good-array.zh/:3:0","series":null,"tags":["daily","math"],"title":"1250.检查“好数组”","uri":"/1250.check-if-it-is-a-good-array.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1234.replace-the-substring-for-balanced-string ","date":"2023-02-13","objectID":"/1234.replace-the-substring-for-balanced-string/:1:0","series":null,"tags":["daily","sliding window"],"title":"1234.replace the substring for balanced string","uri":"/1234.replace-the-substring-for-balanced-string/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe use two pointers left and right. Let’s traverse the string throughright from right = 0. If the amount of each character in the string other than [left, right] is less than or equal to n / 4, it means that we can form a balanced string by replacing [left, right], then increment left until [left, right] can’t form a balanced string. ","date":"2023-02-13","objectID":"/1234.replace-the-substring-for-balanced-string/:2:0","series":null,"tags":["daily","sliding window"],"title":"1234.replace the substring for balanced string","uri":"/1234.replace-the-substring-for-balanced-string/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool check(unordered_map\u003cchar, int\u003e \u0026mp, int m) { if (mp['Q'] \u003e m || mp['W'] \u003e m || mp['E'] \u003e m || mp['R'] \u003e m) return true; else return false; } int balancedString(string s) { int n = s.size(), partial = n / 4; int res = n; unordered_map\u003cchar, int\u003e chars; for (auto \u0026c : s) chars[c]++; int flag = 1; for (auto \u0026pa : chars) { // 检查字符串本身是否平衡 if (pa.second != partial) flag = 0; } if (flag == 1) return 0; for (int right = 0, left = 0; right \u003c n; right++) { chars[s[right]]--; while (left \u003c= right \u0026\u0026 !check(chars, partial)) { chars[s[left]]++; res = min(right - left + 1, res); left++; } } return res; } }; ","date":"2023-02-13","objectID":"/1234.replace-the-substring-for-balanced-string/:3:0","series":null,"tags":["daily","sliding window"],"title":"1234.replace the substring for balanced string","uri":"/1234.replace-the-substring-for-balanced-string/#code"},{"categories":["leetcode"],"content":" 1 问题描述1234.替换子串得到平衡字符串 ","date":"2023-02-13","objectID":"/1234.replace-the-substring-for-balanced-string.zh/:1:0","series":null,"tags":["daily","sliding window"],"title":"1234.替换子串得到平衡字符串","uri":"/1234.replace-the-substring-for-balanced-string.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用两个指针left，right，right从0开始遍历，如果[left, right]之外的字符串中，每个字符出现次数都小于或等于n / 4，说明替换[left, right]可以构成平衡字符串，此时递增left，直到移除[left, right]不能构成平衡字符串。 ","date":"2023-02-13","objectID":"/1234.replace-the-substring-for-balanced-string.zh/:2:0","series":null,"tags":["daily","sliding window"],"title":"1234.替换子串得到平衡字符串","uri":"/1234.replace-the-substring-for-balanced-string.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool check(unordered_map\u003cchar, int\u003e \u0026mp, int m) { if (mp['Q'] \u003e m || mp['W'] \u003e m || mp['E'] \u003e m || mp['R'] \u003e m) return true; else return false; } int balancedString(string s) { int n = s.size(), partial = n / 4; int res = n; unordered_map\u003cchar, int\u003e chars; for (auto \u0026c : s) chars[c]++; int flag = 1; for (auto \u0026pa : chars) { // 检查字符串本身是否平衡 if (pa.second != partial) flag = 0; } if (flag == 1) return 0; for (int right = 0, left = 0; right \u003c n; right++) { chars[s[right]]--; while (left \u003c= right \u0026\u0026 !check(chars, partial)) { chars[s[left]]++; res = min(right - left + 1, res); left++; } } return res; } }; ","date":"2023-02-13","objectID":"/1234.replace-the-substring-for-balanced-string.zh/:3:0","series":null,"tags":["daily","sliding window"],"title":"1234.替换子串得到平衡字符串","uri":"/1234.replace-the-substring-for-balanced-string.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述517.超级洗衣机 ","date":"2023-02-13","objectID":"/517.super-washing-machines.zh/:1:0","series":null,"tags":["daily"],"title":"517.超级洗衣机","uri":"/517.super-washing-machines.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路参照直观清晰：理解官方题解——超级洗衣机和贪心,再动一点点脑子。 这个题我也还没搞懂，先搁置 ","date":"2023-02-13","objectID":"/517.super-washing-machines.zh/:2:0","series":null,"tags":["daily"],"title":"517.超级洗衣机","uri":"/517.super-washing-machines.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int findMinMoves(vector\u003cint\u003e \u0026machines) { int tot = accumulate(machines.begin(), machines.end(), 0); int n = machines.size(); if (tot % n) { return -1; } int avg = tot / n; int ans = 0, sum = 0; for (int num: machines) { num -= avg; sum += num; ans = max(ans, max(abs(sum), num)); } return ans; } }; ","date":"2023-02-13","objectID":"/517.super-washing-machines.zh/:3:0","series":null,"tags":["daily"],"title":"517.超级洗衣机","uri":"/517.super-washing-machines.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description502.IPO ","date":"2023-02-12","objectID":"/502.ipo/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"502.IPO","uri":"/502.ipo/#description"},{"categories":["leetcode"],"content":" 2 SolutionGreedy algorithm: if we want to maximize the final capital, we choose the project whose profit is maximum and whose minimum captial required is less than or equal to our current capital. map\u003cint, map\u003cint, int\u003e, std::greater\u003cint\u003e\u003e projs Let key be the profits, value be a map, of which key is the minimum capital required while value is the amount of the corresponding project. ","date":"2023-02-12","objectID":"/502.ipo/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"502.IPO","uri":"/502.ipo/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int findMaximizedCapital(int k, int w, vector\u003cint\u003e\u0026 profits, vector\u003cint\u003e\u0026 capital) { map\u003cint, map\u003cint, int\u003e, std::greater\u003cint\u003e\u003e projs; for (int i = 0; i \u003c profits.size(); i++) { projs[profits[i]][capital[i]]++; } for (int i = 0; i \u003c k; i++) { int find_flag = 0; for (auto \u0026prj : projs) { if (w \u003e= ((prj.second).begin())-\u003efirst) { w += prj.first; prj.second.begin()-\u003esecond--; // 该项目已经完成 if (prj.second.begin()-\u003esecond == 0) prj.second.erase(prj.second.begin()); if (prj.second.empty()) projs.erase(prj.first); find_flag = 1; break; } } if (find_flag == 0) // 如果任何项目的最小资本需求都不能满足，就要结束IPO return w; } return w; } }; ","date":"2023-02-12","objectID":"/502.ipo/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"502.IPO","uri":"/502.ipo/#code"},{"categories":["leetcode"],"content":" 1 问题描述502.IPO ","date":"2023-02-12","objectID":"/502.ipo.zh/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"502.IPO","uri":"/502.ipo.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心：要最大化最终资本，因此必然选择满足当前资本需要的纯利润最大的项目。 map\u003cint, map\u003cint, int\u003e, std::greater\u003cint\u003e\u003e projs key为纯利润，value也是map，该map的key为启动所需最小资本、value为项目数量。 ","date":"2023-02-12","objectID":"/502.ipo.zh/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"502.IPO","uri":"/502.ipo.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int findMaximizedCapital(int k, int w, vector\u003cint\u003e\u0026 profits, vector\u003cint\u003e\u0026 capital) { map\u003cint, map\u003cint, int\u003e, std::greater\u003cint\u003e\u003e projs; for (int i = 0; i \u003c profits.size(); i++) { projs[profits[i]][capital[i]]++; } for (int i = 0; i \u003c k; i++) { int find_flag = 0; for (auto \u0026prj : projs) { if (w \u003e= ((prj.second).begin())-\u003efirst) { w += prj.first; prj.second.begin()-\u003esecond--; // 该项目已经完成 if (prj.second.begin()-\u003esecond == 0) prj.second.erase(prj.second.begin()); if (prj.second.empty()) projs.erase(prj.first); find_flag = 1; break; } } if (find_flag == 0) // 如果任何项目的最小资本需求都不能满足，就要结束IPO return w; } return w; } }; ","date":"2023-02-12","objectID":"/502.ipo.zh/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"502.IPO","uri":"/502.ipo.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1138.alphabet-board-path ","date":"2023-02-12","objectID":"/1138.alphabet-board-path/:1:0","series":null,"tags":["daily","data structure and algorithms"],"title":"1138.alphabet board path","uri":"/1138.alphabet-board-path/#description"},{"categories":["leetcode"],"content":" 2 SolutionHash table. Notice that we shouldn’t go left then go down or go right then go up. ","date":"2023-02-12","objectID":"/1138.alphabet-board-path/:2:0","series":null,"tags":["daily","data structure and algorithms"],"title":"1138.alphabet board path","uri":"/1138.alphabet-board-path/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: string alphabetBoardPath(string target) { string res; vector\u003cint\u003e cur_loc{0, 0}; vector\u003cint\u003e target_loc{0, 0}; // 要注意边缘的存在 for (auto \u0026c : target) { target_loc[0] = (c - 'a') / 5; target_loc[1] = (c - 'a') % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col \u003c 0) { res.insert(res.end(), -move_col, 'L'); if (move_row \u003e= 0) res.insert(res.end(), move_row, 'D'); else res.insert(res.end(), -move_row, 'U'); } else { if (move_row \u003e= 0) res.insert(res.end(), move_row, 'D'); else res.insert(res.end(), -move_row, 'U'); res.insert(res.end(), move_col, 'R'); } res.push_back('!'); } return res; } }; ","date":"2023-02-12","objectID":"/1138.alphabet-board-path/:3:0","series":null,"tags":["daily","data structure and algorithms"],"title":"1138.alphabet board path","uri":"/1138.alphabet-board-path/#code"},{"categories":["leetcode"],"content":" 1 问题描述1138.字母板上的路径 ","date":"2023-02-12","objectID":"/1138.alphabet-board-path.zh/:1:0","series":null,"tags":["daily","data structure and algorithms"],"title":"1138.字母板上的路径","uri":"/1138.alphabet-board-path.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路考虑到’z’单独在一个地方，因此移动顺序中，左下、右上不能反过来，即不能先往下再往左或者先往右再往上。 ","date":"2023-02-12","objectID":"/1138.alphabet-board-path.zh/:2:0","series":null,"tags":["daily","data structure and algorithms"],"title":"1138.字母板上的路径","uri":"/1138.alphabet-board-path.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: string alphabetBoardPath(string target) { string res; vector\u003cint\u003e cur_loc{0, 0}; vector\u003cint\u003e target_loc{0, 0}; // 要注意边缘的存在 for (auto \u0026c : target) { target_loc[0] = (c - 'a') / 5; target_loc[1] = (c - 'a') % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col \u003c 0) { res.insert(res.end(), -move_col, 'L'); if (move_row \u003e= 0) res.insert(res.end(), move_row, 'D'); else res.insert(res.end(), -move_row, 'U'); } else { if (move_row \u003e= 0) res.insert(res.end(), move_row, 'D'); else res.insert(res.end(), -move_row, 'U'); res.insert(res.end(), move_col, 'R'); } res.push_back('!'); } return res; } }; ","date":"2023-02-12","objectID":"/1138.alphabet-board-path.zh/:3:0","series":null,"tags":["daily","data structure and algorithms"],"title":"1138.字母板上的路径","uri":"/1138.alphabet-board-path.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period ","date":"2023-02-07","objectID":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/:1:0","series":null,"tags":["data structure and algorithms","daily","hash table"],"title":"1604.alert using same key card three or more times in a one hour period","uri":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/#description"},{"categories":["leetcode"],"content":" 2 SolutionAnalog, hash table + sort. ","date":"2023-02-07","objectID":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/:2:0","series":null,"tags":["data structure and algorithms","daily","hash table"],"title":"1604.alert using same key card three or more times in a one hour period","uri":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int to_min(string \u0026s) { return ((s[0] - '0') * 10 + s[1] - '0') * 60 + (s[3] - '0') * 10 + s[4] - '0'; } bool in_hour(vector\u003cstring\u003e \u0026time, int j) { return to_min(time[j]) - to_min(time[j - 2]) \u003c= 60; } vector\u003cstring\u003e alertNames(vector\u003cstring\u003e \u0026keyName, vector\u003cstring\u003e \u0026keyTime) { unordered_map\u003cstring, set\u003cstring\u003e\u003e name_time; vector\u003cstring\u003e time; unordered_set\u003cstring\u003e res; for (int i = 0; i \u003c keyName.size(); i++) { name_time[keyName[i]].insert(keyTime[i]); } for (auto \u0026iter : name_time) { time.assign(iter.second.begin(), iter.second.end()); for (int j = 2; j \u003c time.size(); j++) { if (in_hour(time, j)) { if (res.find(iter.first) == res.end()) res.insert(iter.first); } } } vector\u003cstring\u003e man(res.begin(), res.end()); std::sort(man.begin(), man.end()); return man; } }; ","date":"2023-02-07","objectID":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/:3:0","series":null,"tags":["data structure and algorithms","daily","hash table"],"title":"1604.alert using same key card three or more times in a one hour period","uri":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/#code"},{"categories":["leetcode"],"content":" 1 问题描述1604.警告一小时内使用相同员工卡大于等于三次的人 ","date":"2023-02-07","objectID":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/:1:0","series":null,"tags":["data structure and algorithms","daily","hash table"],"title":"1604.警告一小时内使用相同员工卡大于等于三次的人","uri":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路模拟，哈希表+排序 ","date":"2023-02-07","objectID":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/:2:0","series":null,"tags":["data structure and algorithms","daily","hash table"],"title":"1604.警告一小时内使用相同员工卡大于等于三次的人","uri":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int to_min(string \u0026s) { return ((s[0] - '0') * 10 + s[1] - '0') * 60 + (s[3] - '0') * 10 + s[4] - '0'; } bool in_hour(vector\u003cstring\u003e \u0026time, int j) { return to_min(time[j]) - to_min(time[j - 2]) \u003c= 60; } vector\u003cstring\u003e alertNames(vector\u003cstring\u003e \u0026keyName, vector\u003cstring\u003e \u0026keyTime) { unordered_map\u003cstring, set\u003cstring\u003e\u003e name_time; vector\u003cstring\u003e time; unordered_set\u003cstring\u003e res; for (int i = 0; i \u003c keyName.size(); i++) { name_time[keyName[i]].insert(keyTime[i]); } for (auto \u0026iter : name_time) { time.assign(iter.second.begin(), iter.second.end()); for (int j = 2; j \u003c time.size(); j++) { if (in_hour(time, j)) { if (res.find(iter.first) == res.end()) res.insert(iter.first); } } } vector\u003cstring\u003e man(res.begin(), res.end()); std::sort(man.begin(), man.end()); return man; } }; ","date":"2023-02-07","objectID":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/:3:0","series":null,"tags":["data structure and algorithms","daily","hash table"],"title":"1604.警告一小时内使用相同员工卡大于等于三次的人","uri":"/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述575.分糖果 ","date":"2023-02-07","objectID":"/575.distribute-candies.zh/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"575.分糖果","uri":"/575.distribute-candies.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路最优思路为一种糖果只吃一颗。 ","date":"2023-02-07","objectID":"/575.distribute-candies.zh/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"575.分糖果","uri":"/575.distribute-candies.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int distributeCandies(vector\u003cint\u003e\u0026 candyType) { int n = candyType.size(), res = n / 2; std::unordered_set\u003cint\u003e type; for (auto i : candyType) type.insert(i); return res \u003c type.size() ? res : type.size(); } }; ","date":"2023-02-07","objectID":"/575.distribute-candies.zh/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"575.分糖果","uri":"/575.distribute-candies.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description575.distribute-candies ","date":"2023-02-07","objectID":"/575.distribute-candies/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"575.distribute candies","uri":"/575.distribute-candies/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe optimal way is to eat only one candy for each kind of candy. ","date":"2023-02-07","objectID":"/575.distribute-candies/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"575.distribute candies","uri":"/575.distribute-candies/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int distributeCandies(vector\u003cint\u003e\u0026 candyType) { int n = candyType.size(), res = n / 2; std::unordered_set\u003cint\u003e type; for (auto i : candyType) type.insert(i); return res \u003c type.size() ? res : type.size(); } }; ","date":"2023-02-07","objectID":"/575.distribute-candies/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"575.distribute candies","uri":"/575.distribute-candies/#code"},{"categories":["leetcode"],"content":" 1 Description2331.evaluate-boolean-binary-tree ","date":"2023-02-06","objectID":"/2331.evaluate-boolean-binary-tree/:1:0","series":null,"tags":["daily","dfs","data structure and algorithms"],"title":"2331.evaluate boolean binary tree","uri":"/2331.evaluate-boolean-binary-tree/#description"},{"categories":["leetcode"],"content":" 2 Solutiondfs(recursion) ","date":"2023-02-06","objectID":"/2331.evaluate-boolean-binary-tree/:2:0","series":null,"tags":["daily","dfs","data structure and algorithms"],"title":"2331.evaluate boolean binary tree","uri":"/2331.evaluate-boolean-binary-tree/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool dfs(TreeNode *root) { if (root-\u003eleft == nullptr) { return root-\u003eval; } if (root-\u003e val == 2) { return dfs(root-\u003eleft) || dfs(root-\u003eright); } else { return dfs(root-\u003eleft) \u0026\u0026 dfs(root-\u003eright); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; ","date":"2023-02-06","objectID":"/2331.evaluate-boolean-binary-tree/:3:0","series":null,"tags":["daily","dfs","data structure and algorithms"],"title":"2331.evaluate boolean binary tree","uri":"/2331.evaluate-boolean-binary-tree/#code"},{"categories":["leetcode"],"content":" 1 问题描述2331.计算布尔二叉树的值 ","date":"2023-02-06","objectID":"/2331.evaluate-boolean-binary-tree.zh/:1:0","series":null,"tags":["daily","dfs","data structure and algorithms"],"title":"2331.计算布尔二叉树的值","uri":"/2331.evaluate-boolean-binary-tree.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路递归 ","date":"2023-02-06","objectID":"/2331.evaluate-boolean-binary-tree.zh/:2:0","series":null,"tags":["daily","dfs","data structure and algorithms"],"title":"2331.计算布尔二叉树的值","uri":"/2331.evaluate-boolean-binary-tree.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool dfs(TreeNode *root) { if (root-\u003eleft == nullptr) { return root-\u003eval; } if (root-\u003e val == 2) { return dfs(root-\u003eleft) || dfs(root-\u003eright); } else { return dfs(root-\u003eleft) \u0026\u0026 dfs(root-\u003eright); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; ","date":"2023-02-06","objectID":"/2331.evaluate-boolean-binary-tree.zh/:3:0","series":null,"tags":["daily","dfs","data structure and algorithms"],"title":"2331.计算布尔二叉树的值","uri":"/2331.evaluate-boolean-binary-tree.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description553.optimal division ","date":"2023-02-06","objectID":"/553.optimal-division/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"553.optimal division","uri":"/553.optimal-division/#description"},{"categories":["leetcode"],"content":" 2 SolutionGreedy algorithm The optimal method is actually to bracket the penultimate elements. ","date":"2023-02-06","objectID":"/553.optimal-division/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"553.optimal division","uri":"/553.optimal-division/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: string optimalDivision(vector\u003cint\u003e\u0026 nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + \"/\" + to_string(nums[1]); return res; } res += \"/(\"; for (int i = 1; i \u003c nums.size(); i++) { res += to_string(nums[i]); res.push_back('/'); } res.pop_back(); res.push_back(')'); return res; } }; ","date":"2023-02-06","objectID":"/553.optimal-division/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"553.optimal division","uri":"/553.optimal-division/#code"},{"categories":["leetcode"],"content":" 1 问题描述553.最优除法 ","date":"2023-02-06","objectID":"/553.optimal-division.zh/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"553.最优除法","uri":"/553.optimal-division.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心，最优的除法实际上就是把第二个到最后一个元素括起来。 ","date":"2023-02-06","objectID":"/553.optimal-division.zh/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"553.最优除法","uri":"/553.optimal-division.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: string optimalDivision(vector\u003cint\u003e\u0026 nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + \"/\" + to_string(nums[1]); return res; } res += \"/(\"; for (int i = 1; i \u003c nums.size(); i++) { res += to_string(nums[i]); res.push_back('/'); } res.pop_back(); res.push_back(')'); return res; } }; ","date":"2023-02-06","objectID":"/553.optimal-division.zh/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"553.最优除法","uri":"/553.optimal-division.zh/#代码"},{"categories":["tutorial"],"content":" 1 概述涉及以下插件的安装和配置Package Control Terminus LSP LSP-clangd clang-format LSP-pyright LSP-json ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:1:0","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#概述"},{"categories":["tutorial"],"content":" 2 配置sublime安装Package Control以进行包管理。 ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:2:0","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#配置sublime"},{"categories":["tutorial"],"content":" 3 Terminus安装Terminus以实现sublime text4内的terminal。 绑定快捷键： json [ { \"keys\": [ \"ctrl+shift+t\" ], \"command\": \"terminus_open\", \"args\": { // 打开时要执行的命令 // \"cmd\": \"fish\", \"cwd\": \"${file_path:${folder}}\" } } ] 自定义在Terminus的终端中编译运行cpp文件: 在Tools-\u003eBuild System-\u003eNew Build System中新建编译文件，保存为CppTerminus.sublime-build，替换内容为: json { // MacOS \"cmd\": [ \"zsh\", \"-c\", \"clang++ '${file}' -std=c++17 -stdlib=libc++ -o '${file_path}/../bin/${file_base_name}' \u0026\u0026 ${file_path}/../bin/${file_base_name}\" ], \"file_regex\": \"^(..{FNXX==XXFN}*):([0-9]+):?([0-9]+)?:? (.*)$\", \"working_dir\": \"${file_path}\", \"encoding\": \"utf-8\", \"selector\": \"source.c, source.c++\", \"variants\": [ { \"name\": \"Run In Terminus\", \"target\": \"terminus_exec\", \"cancel\": \"terminus_cancel_build\", \"cmd\": [ \"zsh\", \"-c\", \"clang++ '${file}' -std=c++17 -stdlib=libc++ -o '${file_path}/../bin/${file_base_name}' \u0026\u0026 ${file_path}/../bin/${file_base_name}\" ] }, { \"name\": \"Create Input File\", \"cmd\": [ \"zsh\", \"-c\", \"touch ${file_path}/../in_out/${file_base_name}.in \u0026\u0026 open -a Sublime\\\\ Text ${file_path}/../in_out/${file_base_name}.in\" ] }, { \"name\": \"Run In Terminal\", \"cmd\": [ \"zsh\", \"-c\", \"clang++ '${file}' -std=c++17 -stdlib=libc++ -o '${file_path}/../bin/${file_base_name}' \u0026\u0026 open -a Terminal.app '${file_path}/../bin/${file_base_name}'\" ] }, ] } 注意要保证源文件和bin文件夹、in_out文件夹在同一目录下。 ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:3:0","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#terminus"},{"categories":["tutorial"],"content":" 4 配置LSP + LSP-clangd安装这两个插件，windows和linux需要手动安装clangd并添加到path。 ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:4:0","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#配置lsp--lsp-clangd"},{"categories":["tutorial"],"content":" 4.1 mac下安装clangd我的mac已经自带了clangd，安装好这两个插件即可实现语法提示； 如果没有安装clangd，通过以下命令安装： shell brew install llvm echo 'export PATH=\"/opt/homebrew/opt/llvm/bin:$PATH\"' \u003e\u003e ~/.zshrc echo 'export LDFLAGS=\"-L/opt/homebrew/opt/llvm/lib\"' \u003e\u003e ~/.zshrc echo 'export CPPFLAGS=\"-I/opt/homebrew/opt/llvm/include\"' \u003e\u003e ~/.zshrc 以上是针对默认 shell 为 zsh 的配置，如果你像我一样，mac 的默认 shell 是 fish，那么需要修改 ~/.config/fish/config.fish，添加环境变量，添加下方法为追加以下内容： sh set -gx PATH /opt/homebrew/opt/llvm/bin $PATH set -gx LDFLAGS -L/opt/homebrew/opt/llvm/lib set -gx CPPFLAGS -I/opt/homebrew/opt/llvm/include ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:4:1","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#mac下安装clangd"},{"categories":["tutorial"],"content":" 4.2 Debian(testing)安装clangd和clangsudo apt install clangd, sudo apt install llvm, sudo apt install clang ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:4:2","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#debiantesting安装clangd和clang"},{"categories":["tutorial"],"content":" 4.3 windows下安装llvm借助scoop, 执行 scoop install llvm，然后安装Visual Stdudio Build Tools，鉴于windows上clang默认的c++库就是msvc，所以就用这个吧，别折腾mingw了。 ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:4:3","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#windows下安装llvm"},{"categories":["tutorial"],"content":" 4.4 配置LSP-clangd到Preferences-\u003ePackage Settings-\u003eLSP-\u003eSettings，写入这样几行 json { // 在主页面只显示error红色下划线 //\"show_diagnostics_severity_level\": 1, // 代码提示显示灯泡图标 \"show_code_actions\": \"bulb\", // 保存时自动格式化 \"lsp_format_on_save\": true, } 再到Preferences-\u003ePackage Settings-\u003eLSP-\u003eServers-\u003eLSP-clangd中，写入以下几行 json // Settings in here override those in \"LSP-clangd/LSP-clangd.sublime-settings\" { \"initializationOptions\": { // 启用clang-tidy代码检查，可能启用后warning会比较多，自己看着办吧 \"clangd.clang-tidy\": true, // 美化clangd输出的JSON \"clangd.pretty\": true, } } 再到project/code（源文件所在目录）下新建.clang-tidy文件，写入: txt Checks: \"bugprone-*,\\ google-*,\\ misc-*,\\ modernize-*,\\ performance-*,\\ readability-*,\\ portability-*,\\ \" HeaderFilterRegex: 'Source/cm[^/]*\\.(h|hxx|cxx)$' CheckOptions: - key: modernize-use-default-member-init.UseAssignment value: '1' - key: modernize-use-equals-default.IgnoreMacros value: '0' - key: modernize-use-auto.MinTypeNameLength value: '80' LSP-clangd默认是使用c++98来检查代码的，要修改为c++17，需要在项目根目录下新建.clangd文件，文件内容如下: txt CompileFlags: Add: [-std=c++17] 更推荐方式为利用cmake生成compile_commands.json, CMakeLists.txt的内容如下： json cmake_minimum_required(VERSION 3.22) # Enable C++11 set(CMAKE_CXX_STANDARD 17) # 设置项目名 project(LeetCpp) # 源文件 aux_source_directory(. SOURCES) # 头文件 include_directories(.) add_executable(${PROJECT_NAME} ${SOURCES}) 通过cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=1生成compile_commands.json文件，注意要在build目录下，且build的上级目录存在CMakelists.txt。 ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:4:4","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#配置lsp-clangd"},{"categories":["tutorial"],"content":" 5 配置clang-format安装好clang-format插件之后，只需在project/code下新建.clang-format文件，写入以下内容 抄的网上的，修改了大括号换行的部分（左大括号不单独位于一行） sh # 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto Language: Cpp # BasedOnStyle: LLVM # 访问说明符(public、private等)的偏移 AccessModifierOffset: -2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket: Align # 连续赋值时，对齐所有等号 AlignConsecutiveAssignments: false # 连续声明时，对齐所有声明的变量名 AlignConsecutiveDeclarations: false # 右对齐逃脱换行(使用反斜杠换行)的反斜杠 AlignEscapedNewlines: Right # 水平对齐二元和三元表达式的操作数 AlignOperands: true # 对齐连续的尾随的注释 AlignTrailingcomments: false # 不允许函数声明的所有参数在放在下一行 AllowAllParametersOfDeclarationOnNextLine: false # 不允许短的块放在同一行 AllowShortBlocksOnASingleLine: true # 允许短的case标签放在同一行 AllowShortCaseLabelsOnASingleLine: true # 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All AllowShortFunctionsOnASingleLine: None # 允许短的if语句保持在同一行 AllowShortIfStatementsOnASingleLine: true # 允许短的循环保持在同一行 AllowShortLoopsOnASingleLine: true # 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), # AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义) AlwaysBreakAfterReturnType: None # 总是在多行string字面量前换行 AlwaysBreakBeforeMultilineStrings: false # 总是在template声明后换行 AlwaysBreakTemplateDeclarations: true # false表示函数实参要么都在同一行，要么都各自一行 BinPackArguments: true # false表示所有形参要么都在同一行，要么都各自一行 BinPackParameters: true # 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效 BraceWrapping: # class定义后面 AfterClass: false # 控制语句后面 AfterControlStatement: false # enum定义后面 AfterEnum: false # 函数定义后面 AfterFunction: false # 命名空间定义后面 AfterNamespace: false # struct定义后面 AfterStruct: false # union定义后面 AfterUnion: false # extern之后 AfterExternBlock: false # catch之前 BeforeCatch: false # else之前 BeforeElse: false # 缩进大括号 IndentBraces: false # 分离空函数 SplitEmptyFunction: false # 分离空语句 SplitEmptyRecord: false # 分离空命名空间 SplitEmptyNamespace: false # 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行) BreakBeforeBinaryOperators: NonAssignment # 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), # Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), # Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom # 注：这里认为语句块也属于函数 BreakBeforeBraces: Custom # 在三元运算符前换行 BreakBeforeTernaryOperators: false # 在构造函数的初始化列表的冒号后换行 BreakConstructorInitializers: AfterColon #BreakInheritanceList: AfterColon BreakStringLiterals: false # 每行字符的限制，0表示没有限制 ColumnLimit: 0 CompactNamespaces: true # 构造函数的初始化列表要么都在同一行，要么都各自一行 ConstructorInitializerAllOnOneLineOrOnePerLine: false # 构造函数的初始化列表的缩进宽度 ConstructorInitializerIndentWidth: 4 # 延续的行的缩进宽度 ContinuationIndentWidth: 4 # 去除C++11的列表初始化的大括号{后和}前的空格 Cpp11BracedListStyle: true # 继承最常用的指针和引用的对齐方式 DerivePointerAlignment: false # 固定命名空间注释 FixNamespacecomments: false # 缩进case标签 IndentCaseLabels: false IndentPPDirectives: None # 缩进宽度 IndentWidth: 4 # 函数返回类型换行时，缩进函数声明或函数定义的函数名 IndentWrappedFunctionNames: false # 保留在块开始处的空行 KeepEmptyLinesAtTheStartOfBlocks: false # 连续空行的最大数量 MaxEmptyLinesToKeep: 1 # 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All NamespaceIndentation: None # 指针和引用的对齐: Left, Right, Middle PointerAlignment: Right # 允许重新排版注释 Reflowcomments: false # 允许排序#include SortIncludes: false # 允许排序 using 声明 SortUsingDeclarations: false # 在C风格类型转换后添加空格 SpaceAfterCStyleCast: false # 在Template 关键字后面添加空格 SpaceAfterTemplateKeyword: true # 在赋值运算符之前添加空格 SpaceBeforeAssignmentOperators: true # SpaceBeforeCpp11BracedList: true # SpaceBeforeCtorInitializerColon: true # SpaceBeforeInheritanceColon: true # 开圆括号之前添加一个空格: Never, ControlStatements, Always SpaceBeforeParens: ControlStatements # SpaceBeforeRangeBasedForLoopColon: true # 在空的圆括号中添加空格 SpaceInEmptyParentheses: false # 在尾随的评论前添加的空格数(只适用于//) SpacesBeforeTrailingComments: 1 # 在尖括号的\u003c后和\u003e前添加空格 SpacesInAngles: false # 在C风格类型转换的括号中添加空格 SpacesInCStyleCastParentheses: false # 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格 SpacesInContainerLiterals: true # 在圆括号的(后和)前添加空格 SpacesInParentheses: false # 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不","date":"2023-02-06","objectID":"/sublime_cpp.zh/:5:0","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#配置clang-format"},{"categories":["tutorial"],"content":" 6 命令行使用sublime text4打开文件mac下添加软连接: ln /Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl debian下执行sudo ln -s /opt/sublime_text/sublime_text /usr/local/bin/subl 之后就能用subl test.cpp命令来调用sublime text4打开test.cpp了。 ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:6:0","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#命令行使用sublime-text4打开文件"},{"categories":["tutorial"],"content":" 7 leetcode相关配置安装leetgo: brew install j178/tap/leetgo 在预期的leetcode项目目录下执行leetgo init，然后配置leetgo.yaml yaml author: zwyyy456 language: en code: lang: cpp filename_template: '{{ .Id}}{{ if .SlugIsMeaningful }}.{{ .Slug }}{{ end }}' leetcode: site: https://leetcode.com # credentials: # from: browser editor: use: custom command: \"subl\" args: \"{{.Folder}}\" # use: vscode ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:7:0","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#leetcode相关配置"},{"categories":["tutorial"],"content":" 8 自定义字体在 Sublime Text 的配置文件中（Preference -\u003e Settings），添加 \"font_face\": \"Name of Font\" 即可，例如我这里使用的是 \"font_face\": \"Cascadia Mono NF\",，要注意的是，有些字体例如 FiraMono Nerd Font Mono，直接将 font_face 的值设置为它在系统中显示的字体名称，Sublime Text 会显示无法找到该字体转而使用系统默认字体例如 Consolas，我们需要将字体上传到 opentype.js，再查看 Naming table -\u003e postScriptName 中显示的值，将 font_face 的值设为该值，例如 FiraMono Nerd Font Mono 显示的值为 FiraMonoNFM-Regular。 奇怪的地方在于，对于 Cascadia Mono NF，将 font_face 的值设置为 postScriptName 显示的值反而会有问题。 完整的配置文件如下： json { \"ignored_packages\": [ \"Vintage\", ], \"vintageous_ctrl_keys\": true, \"vintageous_i_escape_jk\": true, \"vintageous_use_sys_clipboard\": true, \"neovintageous_build_version\": 13200, \"font_face\": \"Cascadia Mono NF\", \"font_size\": 12, \"relative_line_numbers\": true, } ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:8:0","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#自定义字体"},{"categories":["tutorial"],"content":" 9 启用 Vim 模式利用 Sublime Text4 的 package control 安装 NeoVintageous 插件。 ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:9:0","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#启用-vim-模式"},{"categories":["tutorial"],"content":" 9.1 启用ctrl + [作为esc点击sublime Text -\u003e settings -\u003esettings，编辑右侧的配置文件，添加\"vintageous_ctrl_keys\": true,。 ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:9:1","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#启用ctrl--作为esc"},{"categories":["tutorial"],"content":" 9.2 启用jk为esc点击sublime Text -\u003e settings -\u003esettings，编辑右侧的配置文件，添加\"vintageous_i_escape_jk\": true, ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:9:2","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#启用jk为esc"},{"categories":["tutorial"],"content":" 9.3 使yy会复制到系统剪贴板点击sublime Text -\u003e settings -\u003esettings，编辑右侧的配置文件，添加\"vintageous_use_sys_clipboard\": true, ","date":"2023-02-06","objectID":"/sublime_cpp.zh/:9:3","series":null,"tags":["sublime","LSP","tips"],"title":"配置 Sublime Text4为 C++ 编辑器","uri":"/sublime_cpp.zh/#使yy会复制到系统剪贴板"},{"categories":["leetcode"],"content":" 1 Description1710.maximum-units-on-a-truck ","date":"2023-02-05","objectID":"/1710.maximum-units-on-a-truck/:1:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1710.maximum units on a truck","uri":"/1710.maximum-units-on-a-truck/#description"},{"categories":["leetcode"],"content":" 2 SolutionSort boxTypes by the units that the box can load, then put the box of which the units are maximum on the truck one by one. The time complexity can be decreased to $O(n)$ by using quick select. ","date":"2023-02-05","objectID":"/1710.maximum-units-on-a-truck/:2:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1710.maximum units on a truck","uri":"/1710.maximum-units-on-a-truck/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maximumUnits(vector\u003cvector\u003cint\u003e\u003e \u0026boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [\u0026](vector\u003cint\u003e vec1, vector\u003cint\u003e vec2) { return vec1[1] \u003e= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i \u003c boxTypes.size(); i++) { if (cnt + boxTypes[i][0] \u003c= truckSize) { sum += boxTypes[i][0] * boxTypes[i][1]; cnt += boxTypes[i][0]; } else { sum += (truckSize - cnt) * boxTypes[i][1]; break; } } return sum; } }; ","date":"2023-02-05","objectID":"/1710.maximum-units-on-a-truck/:3:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1710.maximum units on a truck","uri":"/1710.maximum-units-on-a-truck/#code"},{"categories":["leetcode"],"content":" 1 问题描述1710.卡车上的最大单元数 ","date":"2023-02-05","objectID":"/1710.maximum-units-on-a-truck.zh/:1:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1710.卡车上的最大单元数","uri":"/1710.maximum-units-on-a-truck.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路根据每个箱子可以装载的单元数量从大到小对boxTypes排序，然后每次将单元数量最大的箱子填入卡车。 使用快速选择算法可以将时间复杂度降低到$O(n)$。 ","date":"2023-02-05","objectID":"/1710.maximum-units-on-a-truck.zh/:2:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1710.卡车上的最大单元数","uri":"/1710.maximum-units-on-a-truck.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maximumUnits(vector\u003cvector\u003cint\u003e\u003e \u0026boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [\u0026](vector\u003cint\u003e vec1, vector\u003cint\u003e vec2) { return vec1[1] \u003e= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i \u003c boxTypes.size(); i++) { if (cnt + boxTypes[i][0] \u003c= truckSize) { sum += boxTypes[i][0] * boxTypes[i][1]; cnt += boxTypes[i][0]; } else { sum += (truckSize - cnt) * boxTypes[i][1]; break; } } return sum; } }; ","date":"2023-02-05","objectID":"/1710.maximum-units-on-a-truck.zh/:3:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1710.卡车上的最大单元数","uri":"/1710.maximum-units-on-a-truck.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1736.latest-time-by-replacing-hidden-digits ","date":"2023-02-05","objectID":"/1736.latest-time-by-replacing-hidden-digits/:1:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1736.latest time by replacing hidden digits","uri":"/1736.latest-time-by-replacing-hidden-digits/#description"},{"categories":["leetcode"],"content":" 2 SolutionAnalog + greedy algorithm ","date":"2023-02-05","objectID":"/1736.latest-time-by-replacing-hidden-digits/:2:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1736.latest time by replacing hidden digits","uri":"/1736.latest-time-by-replacing-hidden-digits/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == '?') { if (time[1] == '?') res += \"23\"; else { if (time[1] \u003e= '4') { res.push_back('1'); res.push_back(time[1]); } else { res.push_back('2'); res.push_back(time[1]); } } } else { if (time[1] == '?') { if (time[0] == '2') { res.push_back(time[0]); res.push_back('3'); } else { res.push_back(time[0]); res.push_back('9'); } } else { res.push_back(time[0]); res.push_back(time[1]); } } res.push_back(time[2]); // 再考虑分钟 if (time[3] == '?') { if (time[4] == '?') res += \"59\"; else { res.push_back('5'); res.push_back(time[4]); } } else { if (time[4] == '?') { res.push_back(time[3]); res.push_back('9'); } else { res.push_back(time[3]); res.push_back(time[4]); } } return res; } }; ","date":"2023-02-05","objectID":"/1736.latest-time-by-replacing-hidden-digits/:3:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1736.latest time by replacing hidden digits","uri":"/1736.latest-time-by-replacing-hidden-digits/#code"},{"categories":["leetcode"],"content":" 1 问题描述1736.替换隐藏数字得到的最晚时间 ","date":"2023-02-05","objectID":"/1736.latest-time-by-replacing-hidden-digits.zh/:1:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1736.替换隐藏数字得到的最晚时间","uri":"/1736.latest-time-by-replacing-hidden-digits.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路模拟+贪心 ","date":"2023-02-05","objectID":"/1736.latest-time-by-replacing-hidden-digits.zh/:2:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1736.替换隐藏数字得到的最晚时间","uri":"/1736.latest-time-by-replacing-hidden-digits.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == '?') { if (time[1] == '?') res += \"23\"; else { if (time[1] \u003e= '4') { res.push_back('1'); res.push_back(time[1]); } else { res.push_back('2'); res.push_back(time[1]); } } } else { if (time[1] == '?') { if (time[0] == '2') { res.push_back(time[0]); res.push_back('3'); } else { res.push_back(time[0]); res.push_back('9'); } } else { res.push_back(time[0]); res.push_back(time[1]); } } res.push_back(time[2]); // 再考虑分钟 if (time[3] == '?') { if (time[4] == '?') res += \"59\"; else { res.push_back('5'); res.push_back(time[4]); } } else { if (time[4] == '?') { res.push_back(time[3]); res.push_back('9'); } else { res.push_back(time[3]); res.push_back(time[4]); } } return res; } }; ","date":"2023-02-05","objectID":"/1736.latest-time-by-replacing-hidden-digits.zh/:3:0","series":null,"tags":["analog","greedy algorithm","data structure and algorithms"],"title":"1736.替换隐藏数字得到的最晚时间","uri":"/1736.latest-time-by-replacing-hidden-digits.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1210.minimum-moves-to-reach-target-with-rotations ","date":"2023-02-05","objectID":"/1210.minimum-moves-to-reach-target-with-rotations/:1:0","series":null,"tags":["bfs","daily","data structure and algorithms"],"title":"1210.minimum moves to reach target with rotations","uri":"/1210.minimum-moves-to-reach-target-with-rotations/#description"},{"categories":["leetcode"],"content":" 2 SolutionBFS. We can use (x, y state) to denote the position of the snake, x as the abscissa of the tail of the snake, y as the ordinate of the tail of the snake. state indicates whether the snake is vertical or horizontal. ","date":"2023-02-05","objectID":"/1210.minimum-moves-to-reach-target-with-rotations/:2:0","series":null,"tags":["bfs","daily","data structure and algorithms"],"title":"1210.minimum moves to reach target with rotations","uri":"/1210.minimum-moves-to-reach-target-with-rotations/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool is_pos(vector\u003cint\u003e \u0026vec_tmp, vector\u003cvector\u003cint\u003e\u003e \u0026grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] \u003e= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 \u0026\u0026 grid[vec_tmp[2]][vec_tmp[3]] == 0) return true; else return false; } } else if (i == 1) { vec_tmp[0] += 1; vec_tmp[2] += 1; if (vec_tmp[2] \u003e= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 \u0026\u0026 grid[vec_tmp[2]][vec_tmp[3]] == 0 \u0026\u0026 vec_tmp[2] \u003c grid.size()) return true; else return false; } } else if (i == 2) { if (vec_tmp[0] != vec_tmp[2]) return false; else { vec_tmp[2] += 1; vec_tmp[3] -= 1; if (vec_tmp[2] \u003e= grid.size()) return false; else { if (grid[vec_tmp[2]][vec_tmp[3]] == 0 \u0026\u0026 grid[vec_tmp[0] + 1][vec_tmp[1] + 1] == 0) return true; else return false; } } } else { if (vec_tmp[1] != vec_tmp[3]) return false; else { vec_tmp[2] -= 1; vec_tmp[3] += 1; if (vec_tmp[3] \u003e= grid.size()) return false; else { if (grid[vec_tmp[2]][vec_tmp[3]] == 0 \u0026\u0026 grid[vec_tmp[0] + 1][vec_tmp[1] + 1] == 0) return true; else return false; } } } } int bfs(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { int n = grid.size(); // tuple的第二个元素表示移动次数 queue\u003ctuple\u003cvector\u003cint\u003e, int\u003e\u003e q; // vec[0],vec[1]表示第一个格子的坐标，vec[2],vec[3]表示第二个格子的坐标 // 对应四种移动方式的坐标变化 vector\u003cvector\u003cint\u003e\u003e move{{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}}; map\u003cvector\u003cint\u003e, int\u003e visited; visited[{0, 0, 0, 1}] = 1; q.push({{0, 0, 0, 1}, 0}); while (!q.empty()) { auto [vec, cnt] = q.front(); q.pop(); // 到达终点 if (vec[0] == n - 1 \u0026\u0026 vec[1] == n - 2 \u0026\u0026 vec[2] == n - 1 \u0026\u0026 vec[3] == n - 1) return cnt; for (int i = 0; i \u003c 4; i++) { auto vec_tmp = vec; bool tmp = is_pos(vec_tmp, grid, i); if (tmp \u0026\u0026 visited.find(vec_tmp) == visited.end()) { q.push({vec_tmp, cnt + 1}); visited[vec_tmp] = 1; } } } return -1; } int minimumMoves(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { int cnt = bfs(grid); return cnt; } }; ","date":"2023-02-05","objectID":"/1210.minimum-moves-to-reach-target-with-rotations/:3:0","series":null,"tags":["bfs","daily","data structure and algorithms"],"title":"1210.minimum moves to reach target with rotations","uri":"/1210.minimum-moves-to-reach-target-with-rotations/#code"},{"categories":["leetcode"],"content":" 1 问题描述1210.穿过迷宫的最少移动次数 ","date":"2023-02-05","objectID":"/1210.minimum-moves-to-reach-target-with-rotations.zh/:1:0","series":null,"tags":["bfs","daily","data structure and algorithms"],"title":"1210.穿过迷宫的最少移动次数","uri":"/1210.minimum-moves-to-reach-target-with-rotations.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路广度优先搜索 可以用(x, y, state)来表示贪吃蛇当前所处的位置，x为蛇尾的横坐标，y为蛇尾的纵坐标，state表示蛇当前处于水平还是竖直状态。 ","date":"2023-02-05","objectID":"/1210.minimum-moves-to-reach-target-with-rotations.zh/:2:0","series":null,"tags":["bfs","daily","data structure and algorithms"],"title":"1210.穿过迷宫的最少移动次数","uri":"/1210.minimum-moves-to-reach-target-with-rotations.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool is_pos(vector\u003cint\u003e \u0026vec_tmp, vector\u003cvector\u003cint\u003e\u003e \u0026grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] \u003e= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 \u0026\u0026 grid[vec_tmp[2]][vec_tmp[3]] == 0) return true; else return false; } } else if (i == 1) { vec_tmp[0] += 1; vec_tmp[2] += 1; if (vec_tmp[2] \u003e= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 \u0026\u0026 grid[vec_tmp[2]][vec_tmp[3]] == 0 \u0026\u0026 vec_tmp[2] \u003c grid.size()) return true; else return false; } } else if (i == 2) { if (vec_tmp[0] != vec_tmp[2]) return false; else { vec_tmp[2] += 1; vec_tmp[3] -= 1; if (vec_tmp[2] \u003e= grid.size()) return false; else { if (grid[vec_tmp[2]][vec_tmp[3]] == 0 \u0026\u0026 grid[vec_tmp[0] + 1][vec_tmp[1] + 1] == 0) return true; else return false; } } } else { if (vec_tmp[1] != vec_tmp[3]) return false; else { vec_tmp[2] -= 1; vec_tmp[3] += 1; if (vec_tmp[3] \u003e= grid.size()) return false; else { if (grid[vec_tmp[2]][vec_tmp[3]] == 0 \u0026\u0026 grid[vec_tmp[0] + 1][vec_tmp[1] + 1] == 0) return true; else return false; } } } } int bfs(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { int n = grid.size(); // tuple的第二个元素表示移动次数 queue\u003ctuple\u003cvector\u003cint\u003e, int\u003e\u003e q; // vec[0],vec[1]表示第一个格子的坐标，vec[2],vec[3]表示第二个格子的坐标 // 对应四种移动方式的坐标变化 vector\u003cvector\u003cint\u003e\u003e move{{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}}; map\u003cvector\u003cint\u003e, int\u003e visited; visited[{0, 0, 0, 1}] = 1; q.push({{0, 0, 0, 1}, 0}); while (!q.empty()) { auto [vec, cnt] = q.front(); q.pop(); // 到达终点 if (vec[0] == n - 1 \u0026\u0026 vec[1] == n - 2 \u0026\u0026 vec[2] == n - 1 \u0026\u0026 vec[3] == n - 1) return cnt; for (int i = 0; i \u003c 4; i++) { auto vec_tmp = vec; bool tmp = is_pos(vec_tmp, grid, i); if (tmp \u0026\u0026 visited.find(vec_tmp) == visited.end()) { q.push({vec_tmp, cnt + 1}); visited[vec_tmp] = 1; } } } return -1; } int minimumMoves(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { int cnt = bfs(grid); return cnt; } }; ","date":"2023-02-05","objectID":"/1210.minimum-moves-to-reach-target-with-rotations.zh/:3:0","series":null,"tags":["bfs","daily","data structure and algorithms"],"title":"1210.穿过迷宫的最少移动次数","uri":"/1210.minimum-moves-to-reach-target-with-rotations.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1798.maximum-number-of-consecutive-values-you-can-make ","date":"2023-02-04","objectID":"/1798.maximum-number-of-consecutive-values-you-can-make/:1:0","series":null,"tags":["daily","greedy algorithm","dynamic programming"],"title":"1798.maximum number of consecutive values you can make","uri":"/1798.maximum-number-of-consecutive-values-you-can-make/#description"},{"categories":["leetcode"],"content":" 2 SolutionGreedy algorithm + dynamic programming First, we sort the array in ascending orders. Let res[n] be the maximum value of consecutive integer that we can make by using the first n numbers. if (coins[i - 1] \u003e res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; ","date":"2023-02-04","objectID":"/1798.maximum-number-of-consecutive-values-you-can-make/:2:0","series":null,"tags":["daily","greedy algorithm","dynamic programming"],"title":"1798.maximum number of consecutive values you can make","uri":"/1798.maximum-number-of-consecutive-values-you-can-make/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int getMaximumConsecutive(vector\u003cint\u003e\u0026 coins) { std::sort(coins.begin(), coins.end()); vector\u003cint\u003e res(coins.size() + 1, 0); // maximum integer by first nth numbers for (int i = 1; i \u003c= coins.size(); i++) { if (coins[i - 1] \u003e res[i - 1] + 1) res[i] = res[i - 1]; else res[i] = res[i - 1] + coins[i - 1]; } return res[coins.size()] + 1; } }; ","date":"2023-02-04","objectID":"/1798.maximum-number-of-consecutive-values-you-can-make/:3:0","series":null,"tags":["daily","greedy algorithm","dynamic programming"],"title":"1798.maximum number of consecutive values you can make","uri":"/1798.maximum-number-of-consecutive-values-you-can-make/#code"},{"categories":["leetcode"],"content":" 1 问题描述1798.你能构造出连续值的最大数目 ","date":"2023-02-04","objectID":"/1798.maximum-number-of-consecutive-values-you-can-make.zh/:1:0","series":null,"tags":["daily","greedy algorithm","dynamic programming"],"title":"1798.你能构造出连续值的最大数目","uri":"/1798.maximum-number-of-consecutive-values-you-can-make.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心+动态规划 首先将数组按升序排序，令res[n]为前n个数所能构造出的连续整数的最大值: if (coins[i - 1] \u003e res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; ","date":"2023-02-04","objectID":"/1798.maximum-number-of-consecutive-values-you-can-make.zh/:2:0","series":null,"tags":["daily","greedy algorithm","dynamic programming"],"title":"1798.你能构造出连续值的最大数目","uri":"/1798.maximum-number-of-consecutive-values-you-can-make.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int getMaximumConsecutive(vector\u003cint\u003e\u0026 coins) { std::sort(coins.begin(), coins.end()); vector\u003cint\u003e res(coins.size() + 1, 0); // 表示前n个数能表示出来的最大值 for (int i = 1; i \u003c= coins.size(); i++) { if (coins[i - 1] \u003e res[i - 1] + 1) res[i] = res[i - 1]; else res[i] = res[i - 1] + coins[i - 1]; } return res[coins.size()] + 1; } }; ","date":"2023-02-04","objectID":"/1798.maximum-number-of-consecutive-values-you-can-make.zh/:3:0","series":null,"tags":["daily","greedy algorithm","dynamic programming"],"title":"1798.你能构造出连续值的最大数目","uri":"/1798.maximum-number-of-consecutive-values-you-can-make.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description768.max-chunks-to-make-sorted-ii ","date":"2023-02-03","objectID":"/768.max-chunks-to-make-sorted-ii/:1:0","series":null,"tags":["greedy algorithm","monotone stack","data structure and algorithms"],"title":"768.max chunks to make sorted ii","uri":"/768.max-chunks-to-make-sorted-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionA sufficient condition for an array to be divisible into blocks that satisfy the condition is that all elements in the block are less than or equal to any of the undivided elements in the right-hand array. ","date":"2023-02-03","objectID":"/768.max-chunks-to-make-sorted-ii/:2:0","series":null,"tags":["greedy algorithm","monotone stack","data structure and algorithms"],"title":"768.max chunks to make sorted ii","uri":"/768.max-chunks-to-make-sorted-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maxChunksToSorted(vector\u003cint\u003e\u0026 arr) { int idx = 0; // 表示划分arr int ans = 0; map\u003cint, int, std::greater\u003cint\u003e\u003e l_map; map\u003cint, int\u003e r_map; for (int i = 0; i \u003c arr.size(); i++) r_map[arr[i]]++; while (idx \u003c arr.size()) { for (int i = idx; i \u003c arr.size(); i++) { l_map[arr[i]]++; r_map[arr[i]]--; if (r_map[arr[i]] == 0) r_map.erase(arr[i]); if (r_map.empty()) break; if (l_map.begin()-\u003efirst \u003c= r_map.begin()-\u003efirst) { idx = i + 1; ans++; break; } } if (r_map.empty()) { ans++; break; } } return ans; } }; ","date":"2023-02-03","objectID":"/768.max-chunks-to-make-sorted-ii/:3:0","series":null,"tags":["greedy algorithm","monotone stack","data structure and algorithms"],"title":"768.max chunks to make sorted ii","uri":"/768.max-chunks-to-make-sorted-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述768.最多能完成排序的块II ","date":"2023-02-03","objectID":"/768.max-chunks-to-make-sorted-ii.zh/:1:0","series":null,"tags":["greedy algorithm","monotone stack","data structure and algorithms"],"title":"768.最多能完成排序的块 II","uri":"/768.max-chunks-to-make-sorted-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路可以划分成满足条件的块的充分必要条件是，块内所有元素都小于等于右侧数组中未划分的任一元素。 本题中使用了map来进行处理，实际上使用单调栈就可以了。 ","date":"2023-02-03","objectID":"/768.max-chunks-to-make-sorted-ii.zh/:2:0","series":null,"tags":["greedy algorithm","monotone stack","data structure and algorithms"],"title":"768.最多能完成排序的块 II","uri":"/768.max-chunks-to-make-sorted-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxChunksToSorted(vector\u003cint\u003e\u0026 arr) { int idx = 0; // 表示划分arr int ans = 0; map\u003cint, int, std::greater\u003cint\u003e\u003e l_map; map\u003cint, int\u003e r_map; for (int i = 0; i \u003c arr.size(); i++) r_map[arr[i]]++; while (idx \u003c arr.size()) { for (int i = idx; i \u003c arr.size(); i++) { l_map[arr[i]]++; r_map[arr[i]]--; if (r_map[arr[i]] == 0) r_map.erase(arr[i]); if (r_map.empty()) break; if (l_map.begin()-\u003efirst \u003c= r_map.begin()-\u003efirst) { idx = i + 1; ans++; break; } } if (r_map.empty()) { ans++; break; } } return ans; } }; ","date":"2023-02-03","objectID":"/768.max-chunks-to-make-sorted-ii.zh/:3:0","series":null,"tags":["greedy algorithm","monotone stack","data structure and algorithms"],"title":"768.最多能完成排序的块 II","uri":"/768.max-chunks-to-make-sorted-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1145.binary-tree-coloring-game ","date":"2023-02-03","objectID":"/1145.binary-tree-coloring-game/:1:0","series":null,"tags":["greedy algorithm","daily","data structure and algorithms"],"title":"1145.binary tree coloring game","uri":"/1145.binary-tree-coloring-game/#description"},{"categories":["leetcode"],"content":" 2 SolutionGreedy algorithm: for second player, if he wants to win, there are three ways to color the node. color the parent node of x, then we use dfs to get the number of red nodes, the number of blue nodes is $n$ minus the nubmer of red nodes; color the left child node of x, then we use dfs to get the number of blue nodes, the number of red nodes is $n$ minus the number of blue nodes; color the right child node of x ","date":"2023-02-03","objectID":"/1145.binary-tree-coloring-game/:2:0","series":null,"tags":["greedy algorithm","daily","data structure and algorithms"],"title":"1145.binary tree coloring game","uri":"/1145.binary-tree-coloring-game/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root != nullptr) return get_num(root-\u003eleft) + get_num(root-\u003eright) + 1; else return 0; } TreeNode *get_pos(int x, int n, TreeNode *root) { // 获取当前x对应的指针 if (root == nullptr) return nullptr; else { if (root-\u003eval == x) return root; else { TreeNode *l = get_pos(x, n, root-\u003eleft); TreeNode *r = get_pos(x, n, root-\u003eright); if (l != nullptr) return l; else return r; } } } bool btreeGameWinningMove(TreeNode *root, int n, int x) { // 先判断是不是完全树 if (n == 1) return false; TreeNode *nodex = get_pos(x, n, root); int num_blue1 = n - get_num(nodex); // 表示占据父节点 int num_blue2 = get_num(nodex-\u003eleft); int num_blue3 = get_num(nodex-\u003eright); if (num_blue1 \u003e n - num_blue1) return true; if (num_blue2 \u003e n - num_blue2) return true; if (num_blue3 \u003e n - num_blue3) return true; return false; } }; ","date":"2023-02-03","objectID":"/1145.binary-tree-coloring-game/:3:0","series":null,"tags":["greedy algorithm","daily","data structure and algorithms"],"title":"1145.binary tree coloring game","uri":"/1145.binary-tree-coloring-game/#code"},{"categories":["leetcode"],"content":" 1 问题描述1145.二叉树着色游戏 ","date":"2023-02-03","objectID":"/1145.binary-tree-coloring-game.zh/:1:0","series":null,"tags":["greedy algorithm","daily","data structure and algorithms"],"title":"1145.二叉树着色游戏","uri":"/1145.binary-tree-coloring-game.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心策略：对二号玩家来说，想要取胜，选择染色节点只有三种可能： 选择x的父节点，则通过深度优先搜索可以求得红色节点数，蓝色节点数为$n$减去红色节点数 选择x的左子节点，则通过dfs可以求得蓝色节点数，红色节点数为$n$减去蓝色节点数 选择x的右子节点 ","date":"2023-02-03","objectID":"/1145.binary-tree-coloring-game.zh/:2:0","series":null,"tags":["greedy algorithm","daily","data structure and algorithms"],"title":"1145.二叉树着色游戏","uri":"/1145.binary-tree-coloring-game.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root != nullptr) return get_num(root-\u003eleft) + get_num(root-\u003eright) + 1; else return 0; } TreeNode *get_pos(int x, int n, TreeNode *root) { // 获取当前x对应的指针 if (root == nullptr) return nullptr; else { if (root-\u003eval == x) return root; else { TreeNode *l = get_pos(x, n, root-\u003eleft); TreeNode *r = get_pos(x, n, root-\u003eright); if (l != nullptr) return l; else return r; } } } bool btreeGameWinningMove(TreeNode *root, int n, int x) { // 先判断是不是完全树 if (n == 1) return false; TreeNode *nodex = get_pos(x, n, root); int num_blue1 = n - get_num(nodex); // 表示占据父节点 int num_blue2 = get_num(nodex-\u003eleft); int num_blue3 = get_num(nodex-\u003eright); if (num_blue1 \u003e n - num_blue1) return true; if (num_blue2 \u003e n - num_blue2) return true; if (num_blue3 \u003e n - num_blue3) return true; return false; } }; ","date":"2023-02-03","objectID":"/1145.binary-tree-coloring-game.zh/:3:0","series":null,"tags":["greedy algorithm","daily","data structure and algorithms"],"title":"1145.二叉树着色游戏","uri":"/1145.binary-tree-coloring-game.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1877.minimize-maximum-pair-sum-in-array ","date":"2023-02-02","objectID":"/1877.minimize-maximum-pair-sum-in-array/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1877.minimize maximum pair sum in array","uri":"/1877.minimize-maximum-pair-sum-in-array/#description"},{"categories":["leetcode"],"content":" 2 SolutionSort the array from smallest to largest, the smallest and largest pair, the next smallest and next largest pair, in that order. The result we need the maximum value of the sum of those pairs. ","date":"2023-02-02","objectID":"/1877.minimize-maximum-pair-sum-in-array/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1877.minimize maximum pair sum in array","uri":"/1877.minimize-maximum-pair-sum-in-array/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minPairSum(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i \u003c nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; ","date":"2023-02-02","objectID":"/1877.minimize-maximum-pair-sum-in-array/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1877.minimize maximum pair sum in array","uri":"/1877.minimize-maximum-pair-sum-in-array/#code"},{"categories":["leetcode"],"content":" 1 问题描述1877.数组中最大数对和的最小值 ","date":"2023-02-02","objectID":"/1877.minimize-maximum-pair-sum-in-array.zh/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1877.数组中最大数对和的最小值","uri":"/1877.minimize-maximum-pair-sum-in-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心 将数组从小到大排序，最小最大配对，次小次大配对，依次配对，结果就是这些配对和的最大值。 ","date":"2023-02-02","objectID":"/1877.minimize-maximum-pair-sum-in-array.zh/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1877.数组中最大数对和的最小值","uri":"/1877.minimize-maximum-pair-sum-in-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minPairSum(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i \u003c nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; ","date":"2023-02-02","objectID":"/1877.minimize-maximum-pair-sum-in-array.zh/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1877.数组中最大数对和的最小值","uri":"/1877.minimize-maximum-pair-sum-in-array.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1129.shortest-path-with-alternating-colors ","date":"2023-02-02","objectID":"/1129.shortest-path-with-alternating-colors/:1:0","series":null,"tags":["daily","bfs","data structure and algorithms"],"title":"1129.shortest path with alternating colors","uri":"/1129.shortest-path-with-alternating-colors/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirst, we need represent the graph as an edge matrix, and we use bfs to find the shortest path. In this problem, since the edge color of the shortest path must change along the path, when we judge whether the current node is visited, we should distinguish the cases that the current node is visited by red edges and the cases that the current node is visited by blue edges. The element in the queue is tie(point, len, c_flag), which means the index of the current node, the length of the path to the current node(may not be the shortest), the color of the edge by which we visited the node(0 means blue and 1 means red). The result of cpp q.push(0, 0, 0); q.push(0, 0, 1); bfs(q, red_connect, blue_connect, answer, n); is the same as cpp q.push(0, 0, 0); bfs(q, red_connect, blue_connect, answer, n); q.pop(); q.push(0, 0, 1); bfs(q, red_connect, blue_connect, answer, n); ","date":"2023-02-02","objectID":"/1129.shortest-path-with-alternating-colors/:2:0","series":null,"tags":["daily","bfs","data structure and algorithms"],"title":"1129.shortest path with alternating colors","uri":"/1129.shortest-path-with-alternating-colors/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: void bfs(queue\u003ctuple\u003cint, int, int\u003e\u003e q, vector\u003cvector\u003cint\u003e\u003e \u0026red_connect, vector\u003cvector\u003cint\u003e\u003e \u0026blue_connect, vector\u003cint\u003e \u0026answer, int n, int i) { vector\u003cvector\u003cint\u003e\u003e visited(n, vector\u003cint\u003e(2, 0)); // visited[k][1] == 1 means edge to be red, visited[k][0] == 1 means to be blue, both means the node has been visited. int tmp_point = 0; while (!q.empty()) { auto [point, len, c_flag] = q.front(); visited[point][c_flag] = 1; q.pop(); if (answer[point] == -1) answer[point] = len; else answer[point] = min(answer[point], len); if (c_flag == 0) { for (int k = 0; k \u003c red_connect[point].size(); k++) { tmp_point = red_connect[point][k]; if (visited[tmp_point][1] != 1) q.push({tmp_point, len + 1, 1}); } } else { for (int k = 0; k \u003c blue_connect[point].size(); k++) { tmp_point = blue_connect[point][k]; if (visited[tmp_point][0] != 1) q.push({tmp_point, len + 1, 0}); } } } } vector\u003cint\u003e shortestAlternatingPaths(int n, vector\u003cvector\u003cint\u003e\u003e \u0026redEdges, vector\u003cvector\u003cint\u003e\u003e \u0026blueEdges) { vector\u003cvector\u003cint\u003e\u003e red_connect(n); vector\u003cvector\u003cint\u003e\u003e blue_connect(n); for (auto \u0026vec : redEdges) { red_connect[vec[0]].push_back(vec[1]); } for (auto \u0026vec : blueEdges) { blue_connect[vec[0]].push_back(vec[1]); } vector\u003cint\u003e answer(n, -1); answer[0] = 0; queue\u003ctuple\u003cint, int, int\u003e\u003e q; q.push({0, 0, 0}); q.push({0, 0, 1}); bfs(q, red_connect, blue_connect, answer, n, 0); return answer; } }; ","date":"2023-02-02","objectID":"/1129.shortest-path-with-alternating-colors/:3:0","series":null,"tags":["daily","bfs","data structure and algorithms"],"title":"1129.shortest path with alternating colors","uri":"/1129.shortest-path-with-alternating-colors/#code"},{"categories":["leetcode"],"content":" 1 问题描述1129.颜色交替的最短路径 ","date":"2023-02-02","objectID":"/1129.shortest-path-with-alternating-colors.zh/:1:0","series":null,"tags":["daily","bfs","data structure and algorithms"],"title":"1129.颜色交替的最短路径","uri":"/1129.shortest-path-with-alternating-colors.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，将本题的图结构以边表的形式表现出来，然后采取广度优先搜索的方式寻找最短路径，一般来说广度优先搜索能够保证找到的是最短路径。 在本题中，由于要求最短路径是交替出现的，那么在判断节点是否已经访问过时，要分红色路径访问节点和蓝色路径访问节点两种情况讨论。 队列中的元素为三元组tie(point, len, c_flag)，分别表示当前节点的索引、到达当前节点的路径长度（不一定是最短的，本题中存在环）、到达当前节点的路径颜色（0表示蓝色，1表示红色） 提示bfs(q, red_connect, blue_connect, answer, n)（其中q包含tie(0, 0, 0)和tie(0, 0, 1)）与bfs(q, red_connect, blue_connect, answer, n)执行两次（q分别为tie(0, 0, 0)和tie(0, 0, 1)）的结果是一样的。 ","date":"2023-02-02","objectID":"/1129.shortest-path-with-alternating-colors.zh/:2:0","series":null,"tags":["daily","bfs","data structure and algorithms"],"title":"1129.颜色交替的最短路径","uri":"/1129.shortest-path-with-alternating-colors.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: void bfs(queue\u003ctuple\u003cint, int, int\u003e\u003e q, vector\u003cvector\u003cint\u003e\u003e \u0026red_connect, vector\u003cvector\u003cint\u003e\u003e \u0026blue_connect, vector\u003cint\u003e \u0026answer, int n, int i) { vector\u003cvector\u003cint\u003e\u003e visited(n, vector\u003cint\u003e(2, 0)); // visited[k][1]表示由红到point，visited[k][0]为1表示由蓝到point int tmp_point = 0; while (!q.empty()) { auto [point, len, c_flag] = q.front(); visited[point][c_flag] = 1; q.pop(); if (answer[point] == -1) answer[point] = len; else answer[point] = min(answer[point], len); if (c_flag == 0) { for (int k = 0; k \u003c red_connect[point].size(); k++) { tmp_point = red_connect[point][k]; if (visited[tmp_point][1] != 1) q.push({tmp_point, len + 1, 1}); } } else { for (int k = 0; k \u003c blue_connect[point].size(); k++) { tmp_point = blue_connect[point][k]; if (visited[tmp_point][0] != 1) q.push({tmp_point, len + 1, 0}); } } } } vector\u003cint\u003e shortestAlternatingPaths(int n, vector\u003cvector\u003cint\u003e\u003e \u0026redEdges, vector\u003cvector\u003cint\u003e\u003e \u0026blueEdges) { vector\u003cvector\u003cint\u003e\u003e red_connect(n); //red_connect[i]表示点的集合，存在从i出发直接到这些点红色有向边 vector\u003cvector\u003cint\u003e\u003e blue_connect(n); for (auto \u0026vec : redEdges) { red_connect[vec[0]].push_back(vec[1]); } for (auto \u0026vec : blueEdges) { blue_connect[vec[0]].push_back(vec[1]); } vector\u003cint\u003e answer(n, -1); answer[0] = 0; queue\u003ctuple\u003cint, int, int\u003e\u003e q; q.push({0, 0, 0}); q.push({0, 0, 1}); bfs(q, red_connect, blue_connect, answer, n, 0); return answer; } }; ","date":"2023-02-02","objectID":"/1129.shortest-path-with-alternating-colors.zh/:3:0","series":null,"tags":["daily","bfs","data structure and algorithms"],"title":"1129.颜色交替的最短路径","uri":"/1129.shortest-path-with-alternating-colors.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2325.decode-the-message ","date":"2023-02-01","objectID":"/2325.decode-the-message/:1:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"2325.decode the message","uri":"/2325.decode-the-message/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe use arrya as a hash table, to keep track of the order in which the letter appear. ","date":"2023-02-01","objectID":"/2325.decode-the-message/:2:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"2325.decode the message","uri":"/2325.decode-the-message/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector\u003cint\u003e arr(26, -1); // -1 means the letter never appears, other value means the order in which the letter appears for (auto \u0026c : key) { if (c != ' ') { if (arr[c - 'a'] == -1) { arr[c - 'a'] = cnt++; // cnt++; } } } string res; for (auto \u0026c : message) { if (c != ' ') res.push_back('a' + arr[c - 'a']); else res.push_back(c); } return res; } }; ","date":"2023-02-01","objectID":"/2325.decode-the-message/:3:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"2325.decode the message","uri":"/2325.decode-the-message/#code"},{"categories":["leetcode"],"content":" 1 问题描述2325.解密消息 ","date":"2023-02-01","objectID":"/2325.decode-the-message.zh/:1:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"2325.解密消息","uri":"/2325.decode-the-message.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用数组作为哈希表，记录每个字母是第几个出现的 ","date":"2023-02-01","objectID":"/2325.decode-the-message.zh/:2:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"2325.解密消息","uri":"/2325.decode-the-message.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector\u003cint\u003e arr(26, -1); // 为-1表示这个字母从未出现过，0，1，2等表示这个字母对应的解密字母 for (auto \u0026c : key) { if (c != ' ') { if (arr[c - 'a'] == -1) { arr[c - 'a'] = cnt++; // cnt++; } } } string res; for (auto \u0026c : message) { if (c != ' ') res.push_back('a' + arr[c - 'a']); else res.push_back(c); } return res; } }; ","date":"2023-02-01","objectID":"/2325.decode-the-message.zh/:3:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"2325.解密消息","uri":"/2325.decode-the-message.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1846.maximum-element-after-decreasing-and-rearranging ","date":"2023-02-01","objectID":"/1846.maximum-element-after-decreasing-and-rearranging/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1846.maximum element after decreasing and rearranging","uri":"/1846.maximum-element-after-decreasing-and-rearranging/#description"},{"categories":["leetcode"],"content":" 2 SolutionSince we can reorder the element in the array as many times as we like, so we should sort the array first. If we want to find the possible maximum number of array whose the first element must be 1 and the absolute difference of any 2 adjacent differences must be less or equal to 1， so we can get arr[i] = min(i + 1, arr[i - 1] + 1). We can’t increase the element in the array, so arr[i] = min(arr[i], i + 1, arr[i - 1] + 1). ","date":"2023-02-01","objectID":"/1846.maximum-element-after-decreasing-and-rearranging/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1846.maximum element after decreasing and rearranging","uri":"/1846.maximum-element-after-decreasing-and-rearranging/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maximumElementAfterDecrementingAndRearranging(vector\u003cint\u003e\u0026 arr) { sort(arr.begin(), arr.end()); arr[0] = 1; for (int i = 1; i \u003c arr.size(); i++) { arr[i] = min(arr[i - 1] + 1, min(arr[i], i + 1)); } return arr[arr.size() - 1]; } }; ","date":"2023-02-01","objectID":"/1846.maximum-element-after-decreasing-and-rearranging/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1846.maximum element after decreasing and rearranging","uri":"/1846.maximum-element-after-decreasing-and-rearranging/#code"},{"categories":["leetcode"],"content":" 1 问题描述1846.减小和重新排列数组后的最大元素 ","date":"2023-02-01","objectID":"/1846.maximum-element-after-decreasing-and-rearranging.zh/:1:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1846.减小和重新排列数组后的最大元素","uri":"/1846.maximum-element-after-decreasing-and-rearranging.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路由于题目允许我们重新排列数组中的元素任意次，因此首先将数组排序，根据arr中第一个元素必须为1，以及相邻两元素的差的绝对值小于等于1，可得arr[i] = min(i + 1, arr[i - 1] + 1)（因为我们要找arr可能的最大值），又因为不允许增大arr中的元素，所以arr[i] = min(arr[i], i + 1, arr[i - 1] + 1)。 ","date":"2023-02-01","objectID":"/1846.maximum-element-after-decreasing-and-rearranging.zh/:2:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1846.减小和重新排列数组后的最大元素","uri":"/1846.maximum-element-after-decreasing-and-rearranging.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maximumElementAfterDecrementingAndRearranging(vector\u003cint\u003e\u0026 arr) { sort(arr.begin(), arr.end()); arr[0] = 1; for (int i = 1; i \u003c arr.size(); i++) { arr[i] = min(arr[i - 1] + 1, min(arr[i], i + 1)); } return arr[arr.size() - 1]; } }; ","date":"2023-02-01","objectID":"/1846.maximum-element-after-decreasing-and-rearranging.zh/:3:0","series":null,"tags":["greedy algorithm","data structure and algorithms"],"title":"1846.减小和重新排列数组后的最大元素","uri":"/1846.maximum-element-after-decreasing-and-rearranging.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description2319.check-if-matrix-is-X-matrix ","date":"2023-01-31","objectID":"/2319.check-if-matrix-is-x-matrix/:1:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2319.check if matrix is X matrix","uri":"/2319.check-if-matrix-is-x-matrix/#description"},{"categories":["leetcode"],"content":" 2 SolutionAnalog ","date":"2023-01-31","objectID":"/2319.check-if-matrix-is-x-matrix/:2:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2319.check if matrix is X matrix","uri":"/2319.check-if-matrix-is-x-matrix/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool checkXMatrix(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { bool res = true; for (int i = 0; i \u003c grid.size(); i++) { for (int j = 0; j \u003c grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; ","date":"2023-01-31","objectID":"/2319.check-if-matrix-is-x-matrix/:3:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2319.check if matrix is X matrix","uri":"/2319.check-if-matrix-is-x-matrix/#code"},{"categories":["leetcode"],"content":" 1 问题描述2319.判断矩阵是否是一个X矩阵 ","date":"2023-01-31","objectID":"/2319.check-if-matrix-is-x-matrix.zh/:1:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2319.判断矩阵是否是一个X矩阵","uri":"/2319.check-if-matrix-is-x-matrix.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路模拟 ","date":"2023-01-31","objectID":"/2319.check-if-matrix-is-x-matrix.zh/:2:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2319.判断矩阵是否是一个X矩阵","uri":"/2319.check-if-matrix-is-x-matrix.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool checkXMatrix(vector\u003cvector\u003cint\u003e\u003e \u0026grid) { bool res = true; for (int i = 0; i \u003c grid.size(); i++) { for (int j = 0; j \u003c grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; ","date":"2023-01-31","objectID":"/2319.check-if-matrix-is-x-matrix.zh/:3:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2319.判断矩阵是否是一个X矩阵","uri":"/2319.check-if-matrix-is-x-matrix.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1669.merge-in-between-linked-list ","date":"2023-01-30","objectID":"/1669.merge-in-between-linked-list/:1:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"1669.merge in between linked list","uri":"/1669.merge-in-between-linked-list/#description"},{"categories":["leetcode"],"content":" 2 SolutionAnalog ","date":"2023-01-30","objectID":"/1669.merge-in-between-linked-list/:2:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"1669.merge in between linked list","uri":"/1669.merge-in-between-linked-list/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i \u003c a - 1; i++) { head = head-\u003enext; } for (int i = 0; i \u003c b; i++) { head2 = head2-\u003enext; } while (tail2-\u003enext != nullptr) tail2 = tail2-\u003enext; tail2-\u003enext = head2-\u003enext; head2-\u003enext = nullptr; head-\u003enext = list2; return list1; } }; ","date":"2023-01-30","objectID":"/1669.merge-in-between-linked-list/:3:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"1669.merge in between linked list","uri":"/1669.merge-in-between-linked-list/#code"},{"categories":["leetcode"],"content":" 1 问题描述1669.合并两个链表 ","date":"2023-01-30","objectID":"/1669.merge-in-between-linked-list.zh/:1:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"1669.合并两个链表","uri":"/1669.merge-in-between-linked-list.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路模拟 ","date":"2023-01-30","objectID":"/1669.merge-in-between-linked-list.zh/:2:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"1669.合并两个链表","uri":"/1669.merge-in-between-linked-list.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i \u003c a - 1; i++) { head = head-\u003enext; } for (int i = 0; i \u003c b; i++) { head2 = head2-\u003enext; } while (tail2-\u003enext != nullptr) tail2 = tail2-\u003enext; tail2-\u003enext = head2-\u003enext; head2-\u003enext = nullptr; head-\u003enext = list2; return list1; } }; ","date":"2023-01-30","objectID":"/1669.merge-in-between-linked-list.zh/:3:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"1669.合并两个链表","uri":"/1669.merge-in-between-linked-list.zh/#代码"},{"categories":[""],"content":" 1 Description1817.finding-the-users-active-minutes ","date":"2023-01-20","objectID":"/1817.finding-the-users-active-minutes/:1:0","series":null,"tags":[""],"title":"1817.finding the users active minutes","uri":"/1817.finding-the-users-active-minutes/#description"},{"categories":[""],"content":" 2 SolutionWe can use unordered_map\u003cint, unordered_set\u003cint\u003e\u003e mp to record the id and time_i that they operate. We can use unordered_map\u003cint, int\u003e mins to record the minutes and their number of users. ","date":"2023-01-20","objectID":"/1817.finding-the-users-active-minutes/:2:0","series":null,"tags":[""],"title":"1817.finding the users active minutes","uri":"/1817.finding-the-users-active-minutes/#solution"},{"categories":[""],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e findingUsersActiveMinutes(vector\u003cvector\u003cint\u003e\u003e\u0026 logs, int k) { unordered_map\u003cint, unordered_set\u003cint\u003e\u003e mp; for (auto \u0026vec : logs) { mp[vec[0]].insert(vec[1]); } unordered_map\u003cint, int\u003e mins; int num = mp.size(); vector\u003cint\u003e ans(k, 0); for (auto iter = mp.begin(); iter != mp.end(); iter++) { mins[(iter-\u003esecond).size()]++; } for (int i = 0; i \u003c k; i++) { if (mins.find(i + 1) != mins.end()) ans[i] = mins[i + 1]; else ans[i] = 0; } return ans; } }; ","date":"2023-01-20","objectID":"/1817.finding-the-users-active-minutes/:3:0","series":null,"tags":[""],"title":"1817.finding the users active minutes","uri":"/1817.finding-the-users-active-minutes/#code"},{"categories":["leetcode"],"content":" 1 问题描述1817. 查找用户活跃分钟数 (Medium) 给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDᵢ, timeᵢ] 表示 ID 为 IDᵢ 的用户在 timeᵢ 分钟时执行了某个操作。 多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。 指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。 请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（ 1 \u003c= j \u003c= k）， answer[j] 表示 用户活跃分钟数 等于 j 的用户数。 返回上面描述的答案数组 answer。 示例 1： text 输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5 输出：[0,2,0,0,0] 解释： ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次） ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2 2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0 示例 2： text 输入：logs = [[1,1],[2,2],[2,3]], k = 4 输出：[1,1,0,0] 解释： ID=1 的用户仅在分钟 1 执行单个操作。因此，该用户的用户活跃分钟数为 1 ID=2 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2 1 个用户的用户活跃分钟数是 1 ，1 个用户的用户活跃分钟数是 2 因此，answer[1] = 1 ，answer[2] = 1 ，其余的值都是 0 提示： 1 \u003c= logs.length \u003c= 10⁴ 0 \u003c= IDᵢ \u003c= 10⁹ 1 \u003c= timeᵢ \u003c= 10⁵ k 的取值范围是 [用户的最大用户活跃分钟数, 10⁵] ","date":"2023-01-20","objectID":"/1817.finding-the-users-active-minutes.zh/:1:0","series":null,"tags":["hash table"],"title":"1817.查找用户活跃分钟数","uri":"/1817.finding-the-users-active-minutes.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路哈希表 + 模拟 ","date":"2023-01-20","objectID":"/1817.finding-the-users-active-minutes.zh/:2:0","series":null,"tags":["hash table"],"title":"1817.查找用户活跃分钟数","uri":"/1817.finding-the-users-active-minutes.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e findingUsersActiveMinutes(vector\u003cvector\u003cint\u003e\u003e\u0026 logs, int k) { unordered_map\u003cint, unordered_set\u003cint\u003e\u003e mp; for (auto \u0026vec : logs) { mp[vec[0]].insert(vec[1]); } unordered_map\u003cint, int\u003e mins; int num = mp.size(); vector\u003cint\u003e ans(k, 0); for (auto iter = mp.begin(); iter != mp.end(); iter++) { mins[(iter-\u003esecond).size()]++; } for (int i = 0; i \u003c k; i++) { if (mins.find(i + 1) != mins.end()) ans[i] = mins[i + 1]; else ans[i] = 0; } return ans; } }; ","date":"2023-01-20","objectID":"/1817.finding-the-users-active-minutes.zh/:3:0","series":null,"tags":["hash table"],"title":"1817.查找用户活跃分钟数","uri":"/1817.finding-the-users-active-minutes.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1814.count-nice-pairs-in-an-array ","date":"2023-01-17","objectID":"/1814.count-nice-pairs-in-an-array/:1:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"1814.count nice pairs in an array","uri":"/1814.count-nice-pairs-in-an-array/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can change the requirements to nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]). Then we use hash tables to record the times of occurrence of the value. ","date":"2023-01-17","objectID":"/1814.count-nice-pairs-in-an-array/:2:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"1814.count nice pairs in an array","uri":"/1814.count-nice-pairs-in-an-array/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int rev(int num) { vector\u003cint\u003e tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i \u003c tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector\u003cint\u003e\u0026 nums) { map\u003cint, int\u003e mp; for (int i = 0; i \u003c nums.size(); i++) { mp[nums[i] - rev(nums[i])]++; } long long ans = 0; for (auto it = mp.begin(); it != mp.end(); it++) { ans += (long long) it-\u003esecond * (it-\u003esecond - 1) / 2; } return ans % (1000000007); } }; ","date":"2023-01-17","objectID":"/1814.count-nice-pairs-in-an-array/:3:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"1814.count nice pairs in an array","uri":"/1814.count-nice-pairs-in-an-array/#code"},{"categories":["leetcode"],"content":" 1 问题描述1814.统计一个数组中好对子的数目 ","date":"2023-01-17","objectID":"/1814.count-nice-pairs-in-an-array.zh/:1:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"1814.统计一个数组中好对子的数目","uri":"/1814.count-nice-pairs-in-an-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，变换一下题目的需求，nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])，然后利用哈希表记录每个值出现了多少次就可以了。 ","date":"2023-01-17","objectID":"/1814.count-nice-pairs-in-an-array.zh/:2:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"1814.统计一个数组中好对子的数目","uri":"/1814.count-nice-pairs-in-an-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int rev(int num) { vector\u003cint\u003e tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i \u003c tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector\u003cint\u003e\u0026 nums) { map\u003cint, int\u003e mp; for (int i = 0; i \u003c nums.size(); i++) { mp[nums[i] - rev(nums[i])]++; } long long ans = 0; for (auto it = mp.begin(); it != mp.end(); it++) { ans += (long long) it-\u003esecond * (it-\u003esecond - 1) / 2; } return ans % (1000000007); } }; ","date":"2023-01-17","objectID":"/1814.count-nice-pairs-in-an-array.zh/:3:0","series":null,"tags":["daily","hash table","data structure and algorithms"],"title":"1814.统计一个数组中好对子的数目","uri":"/1814.count-nice-pairs-in-an-array.zh/#代码"},{"categories":["notes"],"content":" 1 前言在刷 LeetCode 的时候，我们常常碰到需要枚举同时选择几个元素，或者说枚举选择一个集合的情况，即同时选择 $\\lbrace0, 1, 2\\rbrace$ 或者 $\\lbrace0, 1,3\\rbrace$ 等，这里集合中的数字表示要选择的元素的索引。 通常情况下，我们往往会使用哈希表来表示集合，好处在于可以方便的在 $O(1)$ 时间内确定元素是否处于集合中，坏处则是当我们需要做集合之间的运算，例如求交集或者并集，那么就需要 $O(n)$ 时间才能实现；另一个缺陷就是，当递归函数的可变实参中存在哈希表（或者对哈希表的引用）时，无法通过添加 $cach$ 数组实现记忆化搜索。 于是，我们需要想一个新的办法来表示集合，由于集合可以由全集（包含所有元素的集合）中每个元素的选或者不选来表示，因此，很容易联想到二进制上每一位的 $0$ 和 $1$，例如 $101 = 5$ 表示集合中只有第 $0$ 个元素和第 $2$ 个元素。 使用数学化一点的语言，即集合可以以如下方式压缩成二进制下的一个数字： $$f(S)=\\sum\\limits_{i\\in S}2^i$$ 其中 $i$ 表示集合中的元素在原数组中的索引。$\\lbrace a[0], a[1], a[3]\\rbrace$ 即可由 $2^0+2^1+2^3 = 13$ 即二进制数 $1101$ 表示。 ","date":"2023-01-05","objectID":"/bit_operation.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"位运算与集合","uri":"/bit_operation.zh/#前言"},{"categories":["notes"],"content":" 2 集合与元素根据上面提到的二进制表示集合的方法，我们可以在 $O(1)$ 的时间内实现集合与元素之间的运算。 具体运算表格参见灵神的 从集合论到位运算，常见位运算技巧分类总结！。 无需记忆，自己做题的时候很容易就能推导出来。 ","date":"2023-01-05","objectID":"/bit_operation.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"位运算与集合","uri":"/bit_operation.zh/#集合与元素"},{"categories":["notes"],"content":" 3 集合与集合集合与集合之间的运算也可以在用二进制数表示集合的情况下，在 $O(1)$ 时间内完成计算。 具体运算表格同样参见灵神的 从集合论到位运算，常见位运算技巧分类总结！。 同样无需记忆，自己做题的时候很容易就能推导出来。 ","date":"2023-01-05","objectID":"/bit_operation.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"位运算与集合","uri":"/bit_operation.zh/#集合与集合"},{"categories":["notes"],"content":" 4 遍历集合在集合用二进制数 $mask$ 表示的情况下，集合中的元素个数可以由 C++ 库函数 __builtin_popcount(mask) 计算出来。 设元素范围从 $0$ 到 $n - 1$，挨个判断元素是否在集合 $s$ 中： cpp for (int i = 0; i \u003c n; ++i) { if ((s \u003e\u003e i) \u0026 1) { // i 在 s 中，注意 == 运算优先级高于 \u0026 // } } ","date":"2023-01-05","objectID":"/bit_operation.zh/:4:0","series":null,"tags":["data structure and algorithms"],"title":"位运算与集合","uri":"/bit_operation.zh/#遍历集合"},{"categories":["notes"],"content":" 5 枚举集合重头戏来了：设集合为 $s$，从大到小枚举 $s$ 的所有非空子集 $sub$： cpp for (int mask = s; mask != 0; mask = ((mask - 1) \u0026 s)) { // 处理子集 sub 的逻辑 } 暴力的枚举集合的办法是从 $s$ 出发，不断减一直到 $0$，但是这样中途会有很多并不是 $s$ 的子集的情况。 假设集合 $s = 10101$，那么它的子集从大到小依次为： $$\\lbrace 10101, 10100, 10001, 10000, 00101, 00100, 00001\\rbrace$$ 如果忽略掉 $10101$ 中间的两个 $0$，即忽略第一位和第三位的 $0$（位索引从 $0$ 开始），那么它的子集的数字变化与普通的二进制减法是一样的，即： $$\\lbrace 111, 110, 101, 100, 011, 010, 001\\rbrace$$ 因此，当我们执行 $(mask - 1)$ \u0026 $s$ 时，以 $10100$ 为例，相当于强制跳过了 $10100$ 到 $10001$ 中间那些第一位和第三位数字不为 $0$ 的数。 套用灵神的说法，以 $10100$ 为例，普通的二进制减法会把最低位的 $1$ 变成 $0$，把这个最低位的 $1$ 右边的 $0$ 都变成 $1$，即 $10100\\rightarrow 10011$，我们这个压缩版的二进制减法，也是把最低位的 $1$ 变成 $0$，但对这个最低位的 $1$ 右边的 $0$，并不会全都变成 $1$，而是只保留 $s = 10101$ 中存在的 $1$，其他的会依旧是 $0$。 ","date":"2023-01-05","objectID":"/bit_operation.zh/:5:0","series":null,"tags":["data structure and algorithms"],"title":"位运算与集合","uri":"/bit_operation.zh/#枚举集合"},{"categories":["notes"],"content":" 6 Gosper’s HackGosper’s Hack 算法是生成 $n$ 元集合中所有包含 $k$ 个元素的子集的算法。 这里先给出 Gosper’s Hack 算法的代码 cpp while (x \u003c uplimit) { int lowbit = x \u0026 (-x); int left = x + lowbit; int right = ((x ^ (x + lowbit)) / lowbit) \u003e\u003e 2; x = left | right; } 接下来讲一下 Gopser’s Hack 算法的思想： 对一个二进制数，例如 $110110$，我们需要找到它从左往右的最后一个 $01$，然后把这个 $01$ 变成 $10$，再把它右边的 $1$ 全部集中到最右边（这里右边的 $1$ 显然都是连续的，否则与最后一个 $01$ 矛盾），即 $110110\\rightarrow 111001$。 在举了例子之后，Gosper’s Hack 算法的思想其实很好理解。 我们利用 $x + lowbit(x)$ 得到的结果，就是将 $x$ 的第一个 $01$ 变成 $0$，同时右边的数全都变成 $0$，即 $110110\\rightarrow 111000$，如果我们使用 $x \\oplus (x + lowbit(x))$，即可得到 $x$ 从最后一个 $01$ 起的右边的数，即 $110110\\rightarrow 001110$，我们再除以 $lowbit$，即可去掉 $x \\oplus (x + lowbit(x))$ 的最右边的连续的 $0$，又因为 $x + lowbit(x)$ 会将这个最后一个的 $01$ 变成 $10$，$01 \\oplus 10 = 11$，因此 $(x \\oplus(x + low)) / lowbit(x)$ 的 $1$ 的个数比 $x$ 的最后一个 $01$ 的右边的 $1$ 的个数还多了 $2$ 个，于是我们再右移两位，即得到了我们需要 $right$。 ","date":"2023-01-05","objectID":"/bit_operation.zh/:6:0","series":null,"tags":["data structure and algorithms"],"title":"位运算与集合","uri":"/bit_operation.zh/#gospers-hack"},{"categories":["notes"],"content":" 7 参考从集合论到位运算，常见位运算技巧分类总结！ 算法学习笔记(75): Gosper’s Hack ","date":"2023-01-05","objectID":"/bit_operation.zh/:7:0","series":null,"tags":["data structure and algorithms"],"title":"位运算与集合","uri":"/bit_operation.zh/#参考"},{"categories":["leetcode"],"content":" 1 Description2042.check-if-numbers-are-ascending-in-a-sentence ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence/:1:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.check if numbers are ascending in a sentence","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence/:2:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.check if numbers are ascending in a sentence","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence/#solution"},{"categories":["leetcode"],"content":" 2.1 analog1I change string s to \" \" + s + \" \", then traverse the new string, check whether substr between two blanks is numbers; ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence/:2:1","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.check if numbers are ascending in a sentence","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence/#analog1"},{"categories":["leetcode"],"content":" 2.2 analog2We just check whether current char is a number, if that, num = num * 10 + s[i] - '0', loop until current char is not a number. ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence/:2:2","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.check if numbers are ascending in a sentence","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence/#analog2"},{"categories":["leetcode"],"content":" 3 Code","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence/:3:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.check if numbers are ascending in a sentence","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence/#code"},{"categories":["leetcode"],"content":" 3.1 code1 cpp class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string \u0026s) { int ans = 0; for (int i = l + 1; i \u003c r; i++) { if (s[i] - '0' \u003c= 9 \u0026\u0026 s[i] - '0' \u003e= 0) { ans += mpow(s[i] - '0', r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector\u003cint\u003e numbers; s = \" \" + s + \" \"; for (int i = 0; i \u003c s.size(); i++) { if (s[i] == ' ') { blank_l = blank_r; blank_r = i; tmp = str2num(blank_l, blank_r, s); if (tmp \u003e 0) numbers.push_back(tmp); } } for (int i = 1; i \u003c numbers.size(); i++) { if (numbers[i] \u003c= numbers[i - 1]) return false; } return true; } }; ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence/:3:1","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.check if numbers are ascending in a sentence","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence/#code1"},{"categories":["leetcode"],"content":" 3.2 code2 cpp class Solution { public: bool areNumbersAscending(string s) { int pre = 0, pos = 0; while (pos \u003c s.size()) { if (isdigit(s[pos])) { int cur = 0; while (pos \u003c s.size() \u0026\u0026 isdigit(s[pos])) { cur = cur * 10 + s[pos] - '0'; pos++; } if (cur \u003c= pre) { return false; } pre = cur; } else { pos++; } } return true; } }; ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence/:3:2","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.check if numbers are ascending in a sentence","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence/#code2"},{"categories":["leetcode"],"content":" 1 问题描述2042.检查句子中的数字是否递增 ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/:1:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.检查句子中的数字是否递增","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/:2:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.检查句子中的数字是否递增","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 模拟一首先将字符串的首尾都加上空格，然后遍历即可，检查两次空格之间的字符串是否是数字，如果是就转化为数字; ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/:2:1","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.检查句子中的数字是否递增","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/#模拟一"},{"categories":["leetcode"],"content":" 2.2 模拟二直接判断字符是否是数字，如果是数字，num = num * 10 + s[i] - '0'，循环直到碰到空格 ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/:2:2","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.检查句子中的数字是否递增","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/#模拟二"},{"categories":["leetcode"],"content":" 3 代码","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/:3:0","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.检查句子中的数字是否递增","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 代码一 cpp class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string \u0026s) { int ans = 0; for (int i = l + 1; i \u003c r; i++) { if (s[i] - '0' \u003c= 9 \u0026\u0026 s[i] - '0' \u003e= 0) { ans += mpow(s[i] - '0', r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector\u003cint\u003e numbers; s = \" \" + s + \" \"; for (int i = 0; i \u003c s.size(); i++) { if (s[i] == ' ') { blank_l = blank_r; blank_r = i; tmp = str2num(blank_l, blank_r, s); if (tmp \u003e 0) numbers.push_back(tmp); } } for (int i = 1; i \u003c numbers.size(); i++) { if (numbers[i] \u003c= numbers[i - 1]) return false; } return true; } }; ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/:3:1","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.检查句子中的数字是否递增","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/#代码一"},{"categories":["leetcode"],"content":" 3.2 代码二 cpp class Solution { public: bool areNumbersAscending(string s) { int pre = 0, pos = 0; while (pos \u003c s.size()) { if (isdigit(s[pos])) { int cur = 0; while (pos \u003c s.size() \u0026\u0026 isdigit(s[pos])) { cur = cur * 10 + s[pos] - '0'; pos++; } if (cur \u003c= pre) { return false; } pre = cur; } else { pos++; } } return true; } }; ","date":"2023-01-03","objectID":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/:3:2","series":null,"tags":["daily","analog","data structure and algorithms"],"title":"2042.检查句子中的数字是否递增","uri":"/2042.check-if-numbers-are-ascending-in-a-sentence.zh/#代码二"},{"categories":["leetcode"],"content":" 1 Description847.shortest-path-visiting-all-nodes ","date":"2023-01-02","objectID":"/847.shortest-path-visiting-all-nodes/:1:0","series":null,"tags":["bfs","bitmask"],"title":"847.shortest path visiting all nodes","uri":"/847.shortest-path-visiting-all-nodes/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2023-01-02","objectID":"/847.shortest-path-visiting-all-nodes/:2:0","series":null,"tags":["bfs","bitmask"],"title":"847.shortest path visiting all nodes","uri":"/847.shortest-path-visiting-all-nodes/#solution"},{"categories":["leetcode"],"content":" 2.1 solution 1: bitmask + bfsFor example, $(0101)_2$ means the nodes numbered 0 and 2 have been accessed, while nodes nubmered 1 and 3 have not been accessed. bfs; Array seen[x][mask_x] means whether node x and path mask_x have been accessed. ","date":"2023-01-02","objectID":"/847.shortest-path-visiting-all-nodes/:2:1","series":null,"tags":["bfs","bitmask"],"title":"847.shortest path visiting all nodes","uri":"/847.shortest-path-visiting-all-nodes/#solution-1-bitmask--bfs"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int shortestPathLength(vector\u003cvector\u003cint\u003e\u003e \u0026graph) { int n = graph.size(); queue\u003ctuple\u003cint, int, int\u003e\u003e q; vector\u003cvector\u003cint\u003e\u003e seen(n, vector\u003cint\u003e(1 \u003c\u003c n)); for (int i = 0; i \u003c n; i++) { q.emplace(i, 1 \u003c\u003c i, 0); // idx,bitmask,dist seen[i][1 \u003c\u003c i] = 1; } int ans = 0; while (!q.empty()) { auto [idx, mask, dist] = q.front(); q.pop(); if (mask == (1 \u003c\u003c n) - 1) { // 2^n - 1 ans = dist; break; } // search nodes adjacent to the current node for (int x : graph[idx]) { int mask_x = mask | (1 \u003c\u003c x); if (!seen[x][mask_x]) { q.emplace(x, mask_x, dist + 1); seen[x][mask_x] = 1; } } } return ans; } }; ","date":"2023-01-02","objectID":"/847.shortest-path-visiting-all-nodes/:3:0","series":null,"tags":["bfs","bitmask"],"title":"847.shortest path visiting all nodes","uri":"/847.shortest-path-visiting-all-nodes/#code"},{"categories":["leetcode"],"content":" 1 问题描述847.访问所有节点的最短路径 ","date":"2023-01-02","objectID":"/847.shortest-path-visiting-all-nodes.zh/:1:0","series":null,"tags":["bfs","bitmask"],"title":"847.访问所有节点的最短路径","uri":"/847.shortest-path-visiting-all-nodes.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2023-01-02","objectID":"/847.shortest-path-visiting-all-nodes.zh/:2:0","series":null,"tags":["bfs","bitmask"],"title":"847.访问所有节点的最短路径","uri":"/847.shortest-path-visiting-all-nodes.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 方法一:状态压缩+bfs 2.1.1 状态压缩由于本题中，n只有12，且状态只有访问和未访问两种，因此可以使用二进制表示法，利用int的低12位来代指点是否被访问过; 例如$(000…0101)_2$表示编号为0和编号为2的节点已经被访问过，而编号为1和3的节点还没有被访问过; 假设mask存放了当前一系列点的访问状态，假如要检查编号为x的点是否被访问过，可以使用位运算a = (mask \u003e\u003e x) \u0026 1来检查，如果a为1，那么访问过，为0表示未访问; 假设如果表示在x未被访问的情况下，要去访问x，那么mask_v = mask | (1 \u003c\u003c x)，其中mask_v表示更新后的状态二进制数。 ","date":"2023-01-02","objectID":"/847.shortest-path-visiting-all-nodes.zh/:2:1","series":null,"tags":["bfs","bitmask"],"title":"847.访问所有节点的最短路径","uri":"/847.shortest-path-visiting-all-nodes.zh/#方法一状态压缩bfs"},{"categories":["leetcode"],"content":" 2.1 方法一:状态压缩+bfs 2.1.1 状态压缩由于本题中，n只有12，且状态只有访问和未访问两种，因此可以使用二进制表示法，利用int的低12位来代指点是否被访问过; 例如$(000…0101)_2$表示编号为0和编号为2的节点已经被访问过，而编号为1和3的节点还没有被访问过; 假设mask存放了当前一系列点的访问状态，假如要检查编号为x的点是否被访问过，可以使用位运算a = (mask \u003e\u003e x) \u0026 1来检查，如果a为1，那么访问过，为0表示未访问; 假设如果表示在x未被访问的情况下，要去访问x，那么mask_v = mask | (1 \u003c\u003c x)，其中mask_v表示更新后的状态二进制数。 ","date":"2023-01-02","objectID":"/847.shortest-path-visiting-all-nodes.zh/:2:1","series":null,"tags":["bfs","bitmask"],"title":"847.访问所有节点的最短路径","uri":"/847.shortest-path-visiting-all-nodes.zh/#状态压缩"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int shortestPathLength(vector\u003cvector\u003cint\u003e\u003e \u0026graph) { int n = graph.size(); queue\u003ctuple\u003cint, int, int\u003e\u003e q; vector\u003cvector\u003cint\u003e\u003e seen(n, vector\u003cint\u003e(1 \u003c\u003c n)); for (int i = 0; i \u003c n; i++) { q.emplace(i, 1 \u003c\u003c i, 0); // 索引、二进制掩码、距离 seen[i][1 \u003c\u003c i] = 1; } int ans = 0; while (!q.empty()) { auto [idx, mask, dist] = q.front(); q.pop(); if (mask == (1 \u003c\u003c n) - 1) { // 2^n - 1 ans = dist; break; } // 搜索当前idx相邻的节点 for (int x : graph[idx]) { int mask_x = mask | (1 \u003c\u003c x); if (!seen[x][mask_x]) { q.emplace(x, mask_x, dist + 1); seen[x][mask_x] = 1; } } } return ans; } }; ","date":"2023-01-02","objectID":"/847.shortest-path-visiting-all-nodes.zh/:3:0","series":null,"tags":["bfs","bitmask"],"title":"847.访问所有节点的最短路径","uri":"/847.shortest-path-visiting-all-nodes.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述1751.最多可以参加的会议数目II ","date":"2022-12-15","objectID":"/1751.maximum-number-of-events-that-can-be-attended-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming","binary search"],"title":"1751.最多可以参加的会议数目II","uri":"/1751.maximum-number-of-events-that-can-be-attended-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路动态规划+二分法 令dp[i][j]表示在前i个会议，最多参加j个会议，收获的最大价值: 考虑选择不参加events[i - 1]，dp[i][j] = dp[i - 1][j]; 选择参加events[i - 1]，dp[i][j] = dp[idx][j - 1] + events[i - 1][2]; 其中idx表示结束日期小于events[i - 1][0]且最接近events[i - 1][0]的会议的索引号，因此这里需要按照结束日期从小到大对events排序; 寻找idx可以使用二分查找; 二分查找要注意其中的不变量，即l左侧的值都小于target，r右侧的值都大于或等于target(这里是否等于取决于具体实现\u003e=或者\u003e) ","date":"2022-12-15","objectID":"/1751.maximum-number-of-events-that-can-be-attended-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming","binary search"],"title":"1751.最多可以参加的会议数目II","uri":"/1751.maximum-number-of-events-that-can-be-attended-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxValue(vector\u003cvector\u003cint\u003e\u003e \u0026events, int k) { vector\u003cvector\u003cint\u003e\u003e dp(events.size() + 1, vector\u003cint\u003e(k + 1, 0)); // 按照会议结束顺序排序 std::sort(events.begin(), events.end(), [](auto \u0026a, auto \u0026b) { return a[1] \u003c b[1]; }); // for (int i = 1; i \u003c= events.size(); i++) { // dp[i][1] = events[i - 1][2]; // } for (int i = 1; i \u003c= events.size(); i++) { for (int j = 1; j \u003c= k; j++) { int tmp1 = dp[i - 1][j]; // 不包含event[i - 1]的情况 int find_idx = 0; int l = 0; int r = i - 2; for (; l \u003c= r \u0026\u0026 r \u003e= 0;) { int mid = l + (r - l) / 2; if (events[mid][1] \u003e= events[i - 1][0]) { r = mid - 1; // mid = l + (r - l) / 2; } else { l = mid + 1; // mid = l + (r - l) / 2; } } // if (l == 0) // dp[i][j] = std::max(tmp1, events[i - 1][2]); // else dp[i][j] = std::max(tmp1, dp[l][j - 1] + events[i - 1][2]); } } return dp[events.size()][k]; } }; ","date":"2022-12-15","objectID":"/1751.maximum-number-of-events-that-can-be-attended-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming","binary search"],"title":"1751.最多可以参加的会议数目II","uri":"/1751.maximum-number-of-events-that-can-be-attended-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Solution1945.sum-of-digits-of-string-after-convert ","date":"2022-12-15","objectID":"/1945.sum-of-digits-of-string-after-convert/:1:0","series":null,"tags":["data structure and algorithms"],"title":"1945.sum of digits of string after convert","uri":"/1945.sum-of-digits-of-string-after-convert/#solution"},{"categories":["leetcode"],"content":" 2 Solution","date":"2022-12-15","objectID":"/1945.sum-of-digits-of-string-after-convert/:2:0","series":null,"tags":["data structure and algorithms"],"title":"1945.sum of digits of string after convert","uri":"/1945.sum-of-digits-of-string-after-convert/#solution-1"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int getLucky(string s, int k) { vector\u003cint\u003e num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - 'a' + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i \u003c k; i++) { while (sum != 0) { res_sum += sum % 10; sum = sum / 10; } sum = res_sum; res_sum = 0; } return sum; } }; ","date":"2022-12-15","objectID":"/1945.sum-of-digits-of-string-after-convert/:3:0","series":null,"tags":["data structure and algorithms"],"title":"1945.sum of digits of string after convert","uri":"/1945.sum-of-digits-of-string-after-convert/#code"},{"categories":["leetcode"],"content":" 1 问题描述1945.字符串转化后的各位数字之和 ","date":"2022-12-15","objectID":"/1945.sum-of-digits-of-string-after-convert.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"1945.字符串转化之后的各位数字之和","uri":"/1945.sum-of-digits-of-string-after-convert.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路正常思路就好。 ","date":"2022-12-15","objectID":"/1945.sum-of-digits-of-string-after-convert.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"1945.字符串转化之后的各位数字之和","uri":"/1945.sum-of-digits-of-string-after-convert.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int getLucky(string s, int k) { vector\u003cint\u003e num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - 'a' + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i \u003c k; i++) { while (sum != 0) { res_sum += sum % 10; sum = sum / 10; } sum = res_sum; res_sum = 0; } return sum; } }; ","date":"2022-12-15","objectID":"/1945.sum-of-digits-of-string-after-convert.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"1945.字符串转化之后的各位数字之和","uri":"/1945.sum-of-digits-of-string-after-convert.zh/#代码"},{"categories":["tutorial"],"content":" 1 前置这一步非必须,如果之前 N1 已经刷了 OpenWrt 或者 Armbian 那么就不需要了,否则最好还是先刷入 webpad 的官改 V2.2 固件 解压后利用双公头 usb 线和 usb-burning-tool 刷入到 N1 中。 具体步骤如下： usb-burning-tool 导入 webpad 2.2 线刷包，勾选 擦除 flash，取消勾选 擦除 bootloader； 点击 开始 按钮； 3 秒内让 N1 通电，识别成功自动开始刷入； 完成后拔电再上电，让 N1 重启； 当 N1 能正常开机之后，用鼠标开启 N1 的开发者模式（类似安卓手机，连续点击系统版本号即可）。 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:1:0","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#前置"},{"categories":["tutorial"],"content":" 2 制作镜像选择Armbian_23.02.0_amlogic_s905d_bullseye_6.0.11_server_2022.12.08.img.gz，下载好之后，解压，利用rufus刷入u盘。 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:2:0","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#制作镜像"},{"categories":["tutorial"],"content":" 3 安装由于盒子在刷入armbian前为安卓系统，已开启adb，mac的终端执行adb connect 192.168.123.193连接无线adb，192.168.123.193修改成N1的实际的ip地址，然后执行adb reboot update(这些过程最好都在N1外接显示器的环境下进行)，在显示器黑屏的瞬间将前一步的u盘插入到靠近hdmi的usb接口; 接下来显示器会跑一系列starting xxx的服务，直到最后让login的时候，应该是要先输入用户名root，再输入1234(默认密码)，然后输入两次重复的自定义密码(如x12x12); 然后会让你创建用户，可以按Ctrl+C跳过; 当显示已经启动完成，让你再登录之后，输入用户名root和前一步的自定义密码x12x12，即可进入命令行，然后执行nand–sata-install命令将系统刷写进N1的emmc中。 新的 armbian 镜像的刷入命令改成了 armbian-install，见 github release 的说明 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:3:0","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#安装"},{"categories":["tutorial"],"content":" 4 安装好后的配置","date":"2022-12-09","objectID":"/n1-armbian.zh/:4:0","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#安装好后的配置"},{"categories":["tutorial"],"content":" 4.1 添加用户执行 adduser zwyyy 创建用户并执行usermod -aG sudo username添加到sudo用户组，之后的命令都在zwyyy用户下执行; ","date":"2022-12-09","objectID":"/n1-armbian.zh/:4:1","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#添加用户"},{"categories":["tutorial"],"content":" 4.2 更换清华源首先执行sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak进行备份，然后执行echo \u003e /etc/apt/sources.list清空sources.list文件，然后执行sudo vi /etc/apt/sources.list，按下i进入INSERT模式，复制以下内容到sources.list中，然后执行:wq保存并退出; sh # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware # deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware 然后在 root 用户下执行 sh sed -i.bak 's#http://apt.armbian.com#https://mirrors.tuna.tsinghua.edu.cn/armbian#g' /etc/apt/sources.list.d/armbian.list apt update 最后执行sudo apt update。 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:4:2","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#更换清华源"},{"categories":["tutorial"],"content":" 4.3 网络配置由于本人在实验室，无法进入路由器后台查看，这里只能考虑设定静态ip，然而设置好了静态ip之后，无法联网，只能先使用dhcp，如果是家中，可直接进入路由器后台管理界面绑定和mac和ip; 刷好了armbian的N1在每次重启之后，mac会发生变化，因此首先执行ip addr，然后执行ifconfig | grep ether，其中一个是wan口的mac，另一个是lan口的mac，记下lan口的mac，我这里是9e:61:65:69:d7:aa; 执行sudo cp /etc/network/interfaces bak/network_interfaces.bak备份文件，将文件内容修改为, address 和 hwaddres ether 根据机器自身的 mac 地址和 ip 地址来决定。 text source /etc/network/interfaces.d/* # Network is managed by Network manager # You can choose one of the following two IP setting methods: # Use # to disable another setting method # 01. Enable dynamic DHCP to assign IP #auto eth0 #iface eth0 inet dhcp hwaddress ether 9E:61:A6:2B:7C:AA # 02. Enable static IP settings(IP is modified according to the actual) auto eth0 allow-hotplug eth0 iface eth0 inet static address 192.168.6.103 netmask 255.255.255.0 gateway 192.168.6.1 dns-nameservers 192.168.6.1 # 03. Docker install OpenWrt and communicate with each other #allow-hotplug eth0 #no-auto-down eth0 #auto eth0 #iface eth0 inet manual # #auto macvlan #iface macvlan inet dhcp # hwaddress ether 9E:61:A6:2B:7C:AA # pre-up ip link add macvlan link eth0 type macvlan mode bridge # post-down ip link del macvlan link eth0 type macvlan mode bridge # #auto lo #iface lo inet loopback ","date":"2022-12-09","objectID":"/n1-armbian.zh/:4:3","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#网络配置"},{"categories":["tutorial"],"content":" 4.4 固定ip和mac地址本机mac: 9e:61:81:68:8f:aa，每次重启之后mac会发生变化，因此考虑固定住mac地址; ","date":"2022-12-09","objectID":"/n1-armbian.zh/:4:4","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#固定ip和mac地址"},{"categories":["tutorial"],"content":" 5 docker","date":"2022-12-09","objectID":"/n1-armbian.zh/:5:0","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#docker"},{"categories":["tutorial"],"content":" 5.1 安装docker参照tuna docker镜像源使用帮助 首先安装依赖: sh sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common 创建/etc/apt/keyrings文件夹，然后信任Docker的GPG公钥: sh curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 添加软件仓库: sh echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 执行安装: sh sudo apt update sudo apt install docker-ce 建立docker用户组: sh sudo groupadd docker sudo usermod -aG docker $USER 设置docker hub中科大镜像源： sh sudo vim /etc/docker/daemon.json 文件中加入: json { \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn/\"] } ","date":"2022-12-09","objectID":"/n1-armbian.zh/:5:1","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#安装docker"},{"categories":["tutorial"],"content":" 5.2 安装portainer sh docker volume create portainer_data docker run -d -p 9000:9000 --name portainer -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/portainer_data portainer/portainer:linux-arm64 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:5:2","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#安装portainer"},{"categories":["tutorial"],"content":" 5.3 容器配置docker中配置openwrt作旁路由，由于实验室有线和Wi-Fi不在一个ip段，暂时放弃 armbian配置kvm虚拟openwrt ","date":"2022-12-09","objectID":"/n1-armbian.zh/:5:3","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#容器配置"},{"categories":["tutorial"],"content":" 5.4 kvm安装openwrt暂时，也许以后也用不上，留个记录吧。 5.4.1 armbian安装依赖包参照unifreq大佬的教程在 KVM 虚拟机中安装使用 OpenWrt 的说明，首先安装KVM依赖包，虽然unifreq提供的是基于ubuntu jammy的依赖列表，尽管我是基于debian的，但还是都装上这些依赖吧: text sudo apt-get install -y gconf2 qemu-system-arm qemu-utils qemu-efi ipxe-qemu libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager seabios vgabios gir1.2-spiceclientgtk-3.0 xauth at-spi2-core 确定armbian上ssh服务端开启了X11Forwarding功能: sh # vi /etc/ssh/sshd_config 文件 X11Forwarding yes # 如果之前未开启，保存配置文件后重启sshd sudo systemctl restart sshd 这里armbian已经默认开启 将用户添加到libvirt sh # root 用户下 groupadd libvirt usermod -aG libvirt zwyyy 5.4.2 安装服务端和客户端windows安装VcXsrv、putty，启动Xlaunch和putty，putty启动时，勾选ssh-x11-enable x11 forwarding，ssh连接到加入了libvirt用户组的用户: sh # -X 选项开启X11 Forwarding ssh -X zwyyy@host # 运行远程GUI程序，界面将在windows电脑上显示出来 virt-manager 5.4.3 armbian配置桥接网络参照debian10使用kvm虚拟机并配置桥接网络，另外可以参照debian-kvm-wiki 用brctl命令创建桥接接口并管理桥接接口: sh sudo brctl addbr br0 # 创建一个名为br0的桥接接口 sudo brctl show # 列出系统上所有桥接接口 将armbian的网卡接口加入到刚刚创建的br0桥接接口中: sh sudo brctl addif br0 eth0 删除物理网卡接口的ip地址，把物理网卡接口的ip地址配置到桥接接口上，并开启桥接接口，然后添加默认网关: sh sudo ip addr del dev eth0 10.80.17.82/24 sudo ip addr add 10.80.17.82/24 dev br0 sudo ip link set up br0 sudo route add default gw 10.80.17.1 如果要恢复原来的状态，只需要将桥接接口关闭，然后从桥接接口中删除物理网卡接口即可: sh sudo ip link set br0 down sudo brctl delif br0 eth0 sudo ip link set eth0 down sudo ip link set up eth0 #重启物理网卡 5.4.4 安装过程截图上传qemu固件镜像op.qcow2(下载自unifreq的tg频道，解压后改名为op.qcow2): sh scp Downloads/openwrt/op.qcow2 zwyyy@10.80.17.82:/home/zwyyy/op_kvm 安装过程截图参照unifreq 安装好之后，列出虚拟机列表 sh sudo virsh list --all # 或者root用户执行，否则只有空 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:5:4","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#kvm安装openwrt"},{"categories":["tutorial"],"content":" 5.4 kvm安装openwrt暂时，也许以后也用不上，留个记录吧。 5.4.1 armbian安装依赖包参照unifreq大佬的教程在 KVM 虚拟机中安装使用 OpenWrt 的说明，首先安装KVM依赖包，虽然unifreq提供的是基于ubuntu jammy的依赖列表，尽管我是基于debian的，但还是都装上这些依赖吧: text sudo apt-get install -y gconf2 qemu-system-arm qemu-utils qemu-efi ipxe-qemu libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager seabios vgabios gir1.2-spiceclientgtk-3.0 xauth at-spi2-core 确定armbian上ssh服务端开启了X11Forwarding功能: sh # vi /etc/ssh/sshd_config 文件 X11Forwarding yes # 如果之前未开启，保存配置文件后重启sshd sudo systemctl restart sshd 这里armbian已经默认开启 将用户添加到libvirt sh # root 用户下 groupadd libvirt usermod -aG libvirt zwyyy 5.4.2 安装服务端和客户端windows安装VcXsrv、putty，启动Xlaunch和putty，putty启动时，勾选ssh-x11-enable x11 forwarding，ssh连接到加入了libvirt用户组的用户: sh # -X 选项开启X11 Forwarding ssh -X zwyyy@host # 运行远程GUI程序，界面将在windows电脑上显示出来 virt-manager 5.4.3 armbian配置桥接网络参照debian10使用kvm虚拟机并配置桥接网络，另外可以参照debian-kvm-wiki 用brctl命令创建桥接接口并管理桥接接口: sh sudo brctl addbr br0 # 创建一个名为br0的桥接接口 sudo brctl show # 列出系统上所有桥接接口 将armbian的网卡接口加入到刚刚创建的br0桥接接口中: sh sudo brctl addif br0 eth0 删除物理网卡接口的ip地址，把物理网卡接口的ip地址配置到桥接接口上，并开启桥接接口，然后添加默认网关: sh sudo ip addr del dev eth0 10.80.17.82/24 sudo ip addr add 10.80.17.82/24 dev br0 sudo ip link set up br0 sudo route add default gw 10.80.17.1 如果要恢复原来的状态，只需要将桥接接口关闭，然后从桥接接口中删除物理网卡接口即可: sh sudo ip link set br0 down sudo brctl delif br0 eth0 sudo ip link set eth0 down sudo ip link set up eth0 #重启物理网卡 5.4.4 安装过程截图上传qemu固件镜像op.qcow2(下载自unifreq的tg频道，解压后改名为op.qcow2): sh scp Downloads/openwrt/op.qcow2 zwyyy@10.80.17.82:/home/zwyyy/op_kvm 安装过程截图参照unifreq 安装好之后，列出虚拟机列表 sh sudo virsh list --all # 或者root用户执行，否则只有空 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:5:4","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#armbian安装依赖包"},{"categories":["tutorial"],"content":" 5.4 kvm安装openwrt暂时，也许以后也用不上，留个记录吧。 5.4.1 armbian安装依赖包参照unifreq大佬的教程在 KVM 虚拟机中安装使用 OpenWrt 的说明，首先安装KVM依赖包，虽然unifreq提供的是基于ubuntu jammy的依赖列表，尽管我是基于debian的，但还是都装上这些依赖吧: text sudo apt-get install -y gconf2 qemu-system-arm qemu-utils qemu-efi ipxe-qemu libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager seabios vgabios gir1.2-spiceclientgtk-3.0 xauth at-spi2-core 确定armbian上ssh服务端开启了X11Forwarding功能: sh # vi /etc/ssh/sshd_config 文件 X11Forwarding yes # 如果之前未开启，保存配置文件后重启sshd sudo systemctl restart sshd 这里armbian已经默认开启 将用户添加到libvirt sh # root 用户下 groupadd libvirt usermod -aG libvirt zwyyy 5.4.2 安装服务端和客户端windows安装VcXsrv、putty，启动Xlaunch和putty，putty启动时，勾选ssh-x11-enable x11 forwarding，ssh连接到加入了libvirt用户组的用户: sh # -X 选项开启X11 Forwarding ssh -X zwyyy@host # 运行远程GUI程序，界面将在windows电脑上显示出来 virt-manager 5.4.3 armbian配置桥接网络参照debian10使用kvm虚拟机并配置桥接网络，另外可以参照debian-kvm-wiki 用brctl命令创建桥接接口并管理桥接接口: sh sudo brctl addbr br0 # 创建一个名为br0的桥接接口 sudo brctl show # 列出系统上所有桥接接口 将armbian的网卡接口加入到刚刚创建的br0桥接接口中: sh sudo brctl addif br0 eth0 删除物理网卡接口的ip地址，把物理网卡接口的ip地址配置到桥接接口上，并开启桥接接口，然后添加默认网关: sh sudo ip addr del dev eth0 10.80.17.82/24 sudo ip addr add 10.80.17.82/24 dev br0 sudo ip link set up br0 sudo route add default gw 10.80.17.1 如果要恢复原来的状态，只需要将桥接接口关闭，然后从桥接接口中删除物理网卡接口即可: sh sudo ip link set br0 down sudo brctl delif br0 eth0 sudo ip link set eth0 down sudo ip link set up eth0 #重启物理网卡 5.4.4 安装过程截图上传qemu固件镜像op.qcow2(下载自unifreq的tg频道，解压后改名为op.qcow2): sh scp Downloads/openwrt/op.qcow2 zwyyy@10.80.17.82:/home/zwyyy/op_kvm 安装过程截图参照unifreq 安装好之后，列出虚拟机列表 sh sudo virsh list --all # 或者root用户执行，否则只有空 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:5:4","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#安装服务端和客户端"},{"categories":["tutorial"],"content":" 5.4 kvm安装openwrt暂时，也许以后也用不上，留个记录吧。 5.4.1 armbian安装依赖包参照unifreq大佬的教程在 KVM 虚拟机中安装使用 OpenWrt 的说明，首先安装KVM依赖包，虽然unifreq提供的是基于ubuntu jammy的依赖列表，尽管我是基于debian的，但还是都装上这些依赖吧: text sudo apt-get install -y gconf2 qemu-system-arm qemu-utils qemu-efi ipxe-qemu libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager seabios vgabios gir1.2-spiceclientgtk-3.0 xauth at-spi2-core 确定armbian上ssh服务端开启了X11Forwarding功能: sh # vi /etc/ssh/sshd_config 文件 X11Forwarding yes # 如果之前未开启，保存配置文件后重启sshd sudo systemctl restart sshd 这里armbian已经默认开启 将用户添加到libvirt sh # root 用户下 groupadd libvirt usermod -aG libvirt zwyyy 5.4.2 安装服务端和客户端windows安装VcXsrv、putty，启动Xlaunch和putty，putty启动时，勾选ssh-x11-enable x11 forwarding，ssh连接到加入了libvirt用户组的用户: sh # -X 选项开启X11 Forwarding ssh -X zwyyy@host # 运行远程GUI程序，界面将在windows电脑上显示出来 virt-manager 5.4.3 armbian配置桥接网络参照debian10使用kvm虚拟机并配置桥接网络，另外可以参照debian-kvm-wiki 用brctl命令创建桥接接口并管理桥接接口: sh sudo brctl addbr br0 # 创建一个名为br0的桥接接口 sudo brctl show # 列出系统上所有桥接接口 将armbian的网卡接口加入到刚刚创建的br0桥接接口中: sh sudo brctl addif br0 eth0 删除物理网卡接口的ip地址，把物理网卡接口的ip地址配置到桥接接口上，并开启桥接接口，然后添加默认网关: sh sudo ip addr del dev eth0 10.80.17.82/24 sudo ip addr add 10.80.17.82/24 dev br0 sudo ip link set up br0 sudo route add default gw 10.80.17.1 如果要恢复原来的状态，只需要将桥接接口关闭，然后从桥接接口中删除物理网卡接口即可: sh sudo ip link set br0 down sudo brctl delif br0 eth0 sudo ip link set eth0 down sudo ip link set up eth0 #重启物理网卡 5.4.4 安装过程截图上传qemu固件镜像op.qcow2(下载自unifreq的tg频道，解压后改名为op.qcow2): sh scp Downloads/openwrt/op.qcow2 zwyyy@10.80.17.82:/home/zwyyy/op_kvm 安装过程截图参照unifreq 安装好之后，列出虚拟机列表 sh sudo virsh list --all # 或者root用户执行，否则只有空 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:5:4","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#armbian配置桥接网络"},{"categories":["tutorial"],"content":" 5.4 kvm安装openwrt暂时，也许以后也用不上，留个记录吧。 5.4.1 armbian安装依赖包参照unifreq大佬的教程在 KVM 虚拟机中安装使用 OpenWrt 的说明，首先安装KVM依赖包，虽然unifreq提供的是基于ubuntu jammy的依赖列表，尽管我是基于debian的，但还是都装上这些依赖吧: text sudo apt-get install -y gconf2 qemu-system-arm qemu-utils qemu-efi ipxe-qemu libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager seabios vgabios gir1.2-spiceclientgtk-3.0 xauth at-spi2-core 确定armbian上ssh服务端开启了X11Forwarding功能: sh # vi /etc/ssh/sshd_config 文件 X11Forwarding yes # 如果之前未开启，保存配置文件后重启sshd sudo systemctl restart sshd 这里armbian已经默认开启 将用户添加到libvirt sh # root 用户下 groupadd libvirt usermod -aG libvirt zwyyy 5.4.2 安装服务端和客户端windows安装VcXsrv、putty，启动Xlaunch和putty，putty启动时，勾选ssh-x11-enable x11 forwarding，ssh连接到加入了libvirt用户组的用户: sh # -X 选项开启X11 Forwarding ssh -X zwyyy@host # 运行远程GUI程序，界面将在windows电脑上显示出来 virt-manager 5.4.3 armbian配置桥接网络参照debian10使用kvm虚拟机并配置桥接网络，另外可以参照debian-kvm-wiki 用brctl命令创建桥接接口并管理桥接接口: sh sudo brctl addbr br0 # 创建一个名为br0的桥接接口 sudo brctl show # 列出系统上所有桥接接口 将armbian的网卡接口加入到刚刚创建的br0桥接接口中: sh sudo brctl addif br0 eth0 删除物理网卡接口的ip地址，把物理网卡接口的ip地址配置到桥接接口上，并开启桥接接口，然后添加默认网关: sh sudo ip addr del dev eth0 10.80.17.82/24 sudo ip addr add 10.80.17.82/24 dev br0 sudo ip link set up br0 sudo route add default gw 10.80.17.1 如果要恢复原来的状态，只需要将桥接接口关闭，然后从桥接接口中删除物理网卡接口即可: sh sudo ip link set br0 down sudo brctl delif br0 eth0 sudo ip link set eth0 down sudo ip link set up eth0 #重启物理网卡 5.4.4 安装过程截图上传qemu固件镜像op.qcow2(下载自unifreq的tg频道，解压后改名为op.qcow2): sh scp Downloads/openwrt/op.qcow2 zwyyy@10.80.17.82:/home/zwyyy/op_kvm 安装过程截图参照unifreq 安装好之后，列出虚拟机列表 sh sudo virsh list --all # 或者root用户执行，否则只有空 ","date":"2022-12-09","objectID":"/n1-armbian.zh/:5:4","series":null,"tags":["tips","geek","armbian"],"title":"N1 安装 Armbian 简单教程","uri":"/n1-armbian.zh/#安装过程截图"},{"categories":["leetcode"],"content":" 1 问题描述443.压缩字符串 ","date":"2022-12-08","objectID":"/443.string-compression.zh/:1:0","series":null,"tags":["two pointers","sliding window","data structure and algorithms"],"title":"443.压缩字符串","uri":"/443.string-compression.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路双指针、滑动窗口，注意for循环中不需要fast++。 ","date":"2022-12-08","objectID":"/443.string-compression.zh/:2:0","series":null,"tags":["two pointers","sliding window","data structure and algorithms"],"title":"443.压缩字符串","uri":"/443.string-compression.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int compress(vector\u003cchar\u003e\u0026 chars) { vector\u003cchar\u003e res; int cnt = 0; for (int slow = 0, fast = 0; fast \u003c chars.size(); ) { while (fast \u003c chars.size() \u0026\u0026 chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt \u003e 1 \u0026\u0026 cnt \u003c= 9) { res.push_back(chars[slow]); res.push_back(cnt + '0'); } else if (cnt \u003e= 10 \u0026\u0026 cnt \u003c= 99) { res.push_back(chars[slow]); res.push_back(cnt / 10 + '0'); res.push_back(cnt % 10 + '0'); } else if (cnt \u003e= 100 \u0026\u0026 cnt \u003c= 999) { res.push_back(chars[slow]); res.push_back(cnt / 100 + '0'); res.push_back((cnt % 100) / 10 + '0'); res.push_back((cnt % 100) % 10 + '0'); } else { res.push_back(chars[slow]); res.push_back(cnt / 1000 + '0'); res.push_back((cnt % 1000) / 100 + '0'); res.push_back((cnt % 1000) % 100 / 10 + '0'); res.push_back(cnt % 1000 % 100 % 10 + '0'); } slow = fast; } chars = res; return res.size(); } }; ","date":"2022-12-08","objectID":"/443.string-compression.zh/:3:0","series":null,"tags":["two pointers","sliding window","data structure and algorithms"],"title":"443.压缩字符串","uri":"/443.string-compression.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description443.string-compression ","date":"2022-12-08","objectID":"/443.string-compression/:1:0","series":null,"tags":["two pointers","sliding window","data structure and algorithms"],"title":"443.string compression","uri":"/443.string-compression/#description"},{"categories":["leetcode"],"content":" 2 SolutionSliding window, please pay attention to that fast++ is not needed in for loop. ","date":"2022-12-08","objectID":"/443.string-compression/:2:0","series":null,"tags":["two pointers","sliding window","data structure and algorithms"],"title":"443.string compression","uri":"/443.string-compression/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int compress(vector\u003cchar\u003e\u0026 chars) { vector\u003cchar\u003e res; int cnt = 0; for (int slow = 0, fast = 0; fast \u003c chars.size(); ) { while (fast \u003c chars.size() \u0026\u0026 chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt \u003e 1 \u0026\u0026 cnt \u003c= 9) { res.push_back(chars[slow]); res.push_back(cnt + '0'); } else if (cnt \u003e= 10 \u0026\u0026 cnt \u003c= 99) { res.push_back(chars[slow]); res.push_back(cnt / 10 + '0'); res.push_back(cnt % 10 + '0'); } else if (cnt \u003e= 100 \u0026\u0026 cnt \u003c= 999) { res.push_back(chars[slow]); res.push_back(cnt / 100 + '0'); res.push_back((cnt % 100) / 10 + '0'); res.push_back((cnt % 100) % 10 + '0'); } else { res.push_back(chars[slow]); res.push_back(cnt / 1000 + '0'); res.push_back((cnt % 1000) / 100 + '0'); res.push_back((cnt % 1000) % 100 / 10 + '0'); res.push_back(cnt % 1000 % 100 % 10 + '0'); } slow = fast; } chars = res; return res.size(); } }; ","date":"2022-12-08","objectID":"/443.string-compression/:3:0","series":null,"tags":["two pointers","sliding window","data structure and algorithms"],"title":"443.string compression","uri":"/443.string-compression/#code"},{"categories":["leetcode"],"content":" 1 Description1812.determine color of a chessboard square ","date":"2022-12-08","objectID":"/1812.determine-color-of-a-chessboard-square/:1:0","series":null,"tags":["data structure and algorithms"],"title":"1812.determine color of a chessboard square","uri":"/1812.determine-color-of-a-chessboard-square/#description"},{"categories":["leetcode"],"content":" 2 SolutionEasy ","date":"2022-12-08","objectID":"/1812.determine-color-of-a-chessboard-square/:2:0","series":null,"tags":["data structure and algorithms"],"title":"1812.determine color of a chessboard square","uri":"/1812.determine-color-of-a-chessboard-square/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - 'a' + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; ","date":"2022-12-08","objectID":"/1812.determine-color-of-a-chessboard-square/:3:0","series":null,"tags":["data structure and algorithms"],"title":"1812.determine color of a chessboard square","uri":"/1812.determine-color-of-a-chessboard-square/#code"},{"categories":["leetcode"],"content":" 1 问题描述1812.判断国际象棋棋盘中一个格子的颜色 ","date":"2022-12-08","objectID":"/1812.determine-color-of-a-chessboard-square.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"1812.判断国际象棋棋盘中一个格子的颜色","uri":"/1812.determine-color-of-a-chessboard-square.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路太简单了，不写 ","date":"2022-12-08","objectID":"/1812.determine-color-of-a-chessboard-square.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"1812.判断国际象棋棋盘中一个格子的颜色","uri":"/1812.determine-color-of-a-chessboard-square.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - 'a' + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; ","date":"2022-12-08","objectID":"/1812.determine-color-of-a-chessboard-square.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"1812.判断国际象棋棋盘中一个格子的颜色","uri":"/1812.determine-color-of-a-chessboard-square.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description698.partition-to-k-equal-sum-subsets ","date":"2022-12-08","objectID":"/698.partition-to-k-equal-sum-subsets/:1:0","series":null,"tags":["data structure and algorithms","backtracking"],"title":"698.partition to k equal sum subsets","uri":"/698.partition-to-k-equal-sum-subsets/#description"},{"categories":["leetcode"],"content":" 2 SolutionSort array from large to small, so that we can avoid making mistake of judging arrays like [1, 1, 2, 2]. We use used[i] to avoid using the same element more than once, if sum == target, sum = 0, if cnt == k, than it can be devided. ","date":"2022-12-08","objectID":"/698.partition-to-k-equal-sum-subsets/:2:0","series":null,"tags":["data structure and algorithms","backtracking"],"title":"698.partition to k equal sum subsets","uri":"/698.partition-to-k-equal-sum-subsets/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool dfs(vector\u003cint\u003e \u0026nums, int index, int sum, int target, int cnt, int k, vector\u003cint\u003e \u0026used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); // pay attention to the `idx - 1` rather than `index - 1` } for (int i = index; i \u003e= 0; i--) { if (used[i] || sum + nums[i] \u003e target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector\u003cint\u003e \u0026nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k != 0) return false; std::sort(nums.begin(), nums.end()); if (nums.back() \u003e sum / k) return false; vector\u003cint\u003e used(nums.size(), 0); return dfs(nums, nums.size() - 1, 0, sum / k, 0, k, used, nums.size() - 1); } }; ","date":"2022-12-08","objectID":"/698.partition-to-k-equal-sum-subsets/:3:0","series":null,"tags":["data structure and algorithms","backtracking"],"title":"698.partition to k equal sum subsets","uri":"/698.partition-to-k-equal-sum-subsets/#code"},{"categories":["leetcode"],"content":" 1 问题描述698.划为k个相等的子集 ","date":"2022-12-08","objectID":"/698.partition-to-k-equal-sum-subsets.zh/:1:0","series":null,"tags":["data structure and algorithms","backtracking"],"title":"698.划为k个相等的子集","uri":"/698.partition-to-k-equal-sum-subsets.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，对数组按照从大到小排序，相比从小到大排序，能避免[1, 1, 2, 2]这样的数组的误判; 利用used[i]数组避免重复使用同一个元素，如果sum == target，就将sum置零，如果cnt == k，说明满足条件。 ","date":"2022-12-08","objectID":"/698.partition-to-k-equal-sum-subsets.zh/:2:0","series":null,"tags":["data structure and algorithms","backtracking"],"title":"698.划为k个相等的子集","uri":"/698.partition-to-k-equal-sum-subsets.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool dfs(vector\u003cint\u003e \u0026nums, int index, int sum, int target, int cnt, int k, vector\u003cint\u003e \u0026used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); //注意这里是idex - 1而不是index - 1 } for (int i = index; i \u003e= 0; i--) { if (used[i] || sum + nums[i] \u003e target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector\u003cint\u003e \u0026nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k != 0) return false; std::sort(nums.begin(), nums.end()); if (nums.back() \u003e sum / k) return false; vector\u003cint\u003e used(nums.size(), 0); return dfs(nums, nums.size() - 1, 0, sum / k, 0, k, used, nums.size() - 1); } }; ","date":"2022-12-08","objectID":"/698.partition-to-k-equal-sum-subsets.zh/:3:0","series":null,"tags":["data structure and algorithms","backtracking"],"title":"698.划为k个相等的子集","uri":"/698.partition-to-k-equal-sum-subsets.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description438.find-all-anagrams-in-a-string ","date":"2022-12-07","objectID":"/438.find-all-anagrams-in-a-string/:1:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"438.find all anagrams in a string","uri":"/438.find-all-anagrams-in-a-string/#description"},{"categories":["leetcode"],"content":" 2 SolutionSimilar to 30.substring-with-concatenation-of-all-words, easier. ","date":"2022-12-07","objectID":"/438.find-all-anagrams-in-a-string/:2:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"438.find all anagrams in a string","uri":"/438.find-all-anagrams-in-a-string/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e findAnagrams(string s, string p) { unordered_map\u003cchar, int\u003e mp; for (char \u0026c : p) mp[c]++; vector\u003cint\u003e res; unordered_map\u003cchar, int\u003e tmp = mp; for (int l = 0, r = 0; r \u003c s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.find(s[r]) != mp.end()) { while (s[l] != s[r]) { tmp[s[l]]++; l++; } l++; } else { //s[r]不在p中 l = r + 1; tmp = mp; } // l++; } } return res; } }; ","date":"2022-12-07","objectID":"/438.find-all-anagrams-in-a-string/:3:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"438.find all anagrams in a string","uri":"/438.find-all-anagrams-in-a-string/#code"},{"categories":["leetcode"],"content":" 1 问题描述438.找到字符串中所有字母异位词 ","date":"2022-12-07","objectID":"/438.find-all-anagrams-in-a-string.zh/:1:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"438.找到字符串中所有字母异位词","uri":"/438.find-all-anagrams-in-a-string.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路参照30.串联所有单词串，思路完全一致。 ","date":"2022-12-07","objectID":"/438.find-all-anagrams-in-a-string.zh/:2:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"438.找到字符串中所有字母异位词","uri":"/438.find-all-anagrams-in-a-string.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e findAnagrams(string s, string p) { unordered_map\u003cchar, int\u003e mp; for (char \u0026c : p) mp[c]++; vector\u003cint\u003e res; unordered_map\u003cchar, int\u003e tmp = mp; for (int l = 0, r = 0; r \u003c s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.find(s[r]) != mp.end()) { while (s[l] != s[r]) { tmp[s[l]]++; l++; } l++; } else { //s[r]不在p中 l = r + 1; tmp = mp; } // l++; } } return res; } }; ","date":"2022-12-07","objectID":"/438.find-all-anagrams-in-a-string.zh/:3:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"438.找到字符串中所有字母异位词","uri":"/438.find-all-anagrams-in-a-string.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description93.restore-ip-addresses ","date":"2022-12-07","objectID":"/93.restore-ip-addresses/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"93.restore ip addresses","uri":"/93.restore-ip-addresses/#description"},{"categories":["leetcode"],"content":" 2 SolutionBacktracking is actually changing a problem to one like a tree, and doing DFS(depth first search). ","date":"2022-12-07","objectID":"/93.restore-ip-addresses/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"93.restore ip addresses","uri":"/93.restore-ip-addresses/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cstring\u003e res; string ip; bool check_ip(string \u0026s) { if (s.size() \u003e 3) return false; if (s[0] == '0') { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num \u003e 255) return false; else return true; } } void backtrack(string \u0026s, int index, string ip, int cnt) { if (index \u003e= s.size()) { if (cnt == 4) { ip.pop_back(); res.push_back(ip); return; } } for (int i = index; i \u003c s.size(); i++) { string tmp = s.substr(index, i - index + 1); if (check_ip(tmp)) { backtrack(s, i + 1, ip + tmp + \".\", cnt + 1); } } } vector\u003cstring\u003e restoreIpAddresses(string s) { string ip; backtrack(s, 0, ip, 0); return res; } }; ","date":"2022-12-07","objectID":"/93.restore-ip-addresses/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"93.restore ip addresses","uri":"/93.restore-ip-addresses/#code"},{"categories":["leetcode"],"content":" 1 问题描述93.复原ip地址 ","date":"2022-12-07","objectID":"/93.restore-ip-addresses.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"93.复原ip地址","uri":"/93.restore-ip-addresses.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路回溯实际上就是转化为树形问题，做深度优先遍历。 ","date":"2022-12-07","objectID":"/93.restore-ip-addresses.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"93.复原ip地址","uri":"/93.restore-ip-addresses.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cstring\u003e res; string ip; bool check_ip(string \u0026s) { if (s.size() \u003e 3) return false; if (s[0] == '0') { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num \u003e 255) return false; else return true; } } void backtrack(string \u0026s, int index, string ip, int cnt) { if (index \u003e= s.size()) { if (cnt == 4) { ip.pop_back(); res.push_back(ip); return; } } for (int i = index; i \u003c s.size(); i++) { string tmp = s.substr(index, i - index + 1); if (check_ip(tmp)) { backtrack(s, i + 1, ip + tmp + \".\", cnt + 1); } } } vector\u003cstring\u003e restoreIpAddresses(string s) { string ip; backtrack(s, 0, ip, 0); return res; } }; ","date":"2022-12-07","objectID":"/93.restore-ip-addresses.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"93.复原ip地址","uri":"/93.restore-ip-addresses.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1775.equal-sum-arrays-with-minmum-number-of-operations ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.equal sum arrays with minimum number of operations","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.equal sum arrays with minimum number of operations","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations/#solution"},{"categories":["leetcode"],"content":" 2.1 hash table + greedy algorithmThe general idea of this problem is hash + greedy algorithm. Assuming that the sum1 minus sum2 to be diff and diff \u003e 0, to reduce the difference of the sum of two arrays, we should make diff be value minus the maximum value of changing a number in one of the two array, and make the count of number changed minus 1, until diff \u003c 0. It’s similar when diff \u003c 0. ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations/:2:1","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.equal sum arrays with minimum number of operations","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations/#hash-table--greedy-algorithm"},{"categories":["leetcode"],"content":" 2.2 optimizationSuppose that sum1 \u003c sum2, otherwise swap(nums1, nums2) and swap(sum1, sum2). Then let diff = sum2 - sum1, diff can be minus 1, 2, 3, 4, 5 for some times, which depends on nums1 and nums2, we can use a hash table to record. Finally, we traverse i = 5, 4, 3, 2, 1. ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations/:2:2","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.equal sum arrays with minimum number of operations","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations/#optimization"},{"categories":["leetcode"],"content":" 3 Code","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.equal sum arrays with minimum number of operations","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations/#code"},{"categories":["leetcode"],"content":" 3.1 hash table + greedy algorithm cpp class Solution { public: int find_min(vector\u003cint\u003e \u0026v) { for (int i = 1; i \u003c v.size(); i++) { if (v[i] != 0) return i; } return 6; } int find_max(vector\u003cint\u003e \u0026v) { for (int i = v.size() - 1; i \u003e= 1; i--) { if (v[i] != 0) return i; } return 1; } int minOperations(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) { int sum1 = 0, sum2 = 0; vector\u003cint\u003e mp1(7, 0); vector\u003cint\u003e mp2(7, 0); if (nums1.size() \u003e 6 * nums2.size() || 6 * nums1.size() \u003c nums2.size()) return -1; for (int i = 0; i \u003c nums1.size(); i++) { mp1[nums1[i]]++; sum1 += nums1[i]; } for (int i = 0; i \u003c nums2.size(); i++) { mp2[nums2[i]]++; sum2 += nums2[i]; } int diff = sum1 - sum2; int cnt = 0; if (diff == 0) return cnt; else if (diff \u003e 0) { // for nums1, change a number: maximum value of change: find_max(mp1) - 1; // for nums2, 6 - find_min(mp1); while (diff \u003e 0) { cnt++; int minus1 = find_max(mp1) - 1; int plus2 = 6 - find_min(mp2); if (minus1 \u003e= plus2) { diff -= minus1; mp1[find_max(mp1)]--; } else { diff -= 6 - find_min(mp2); mp2[find_min(mp2)]--; } } return cnt; } else { // for nums1, change a number: maximum value of change: 6 - find_min(mp1); // 对nums2, maximum value of change: find_max(mp2) - 1; while (diff \u003c 0) { cnt++; int minus2 = find_max(mp2) - 1; int plus1 = 6 - find_min(mp1); if (minus2 \u003e= plus1) { diff += minus2; mp2[find_max(mp2)]--; } else { diff += plus1; mp1[find_min(mp1)]--; } } return cnt; } } }; ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations/:3:1","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.equal sum arrays with minimum number of operations","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations/#hash-table--greedy-algorithm-1"},{"categories":["leetcode"],"content":" 3.2 better code cpp class Solution { public: int minOperations(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { // 先判断不可能相等的情况 if (nums1.size() \u003e 6 * nums2.size() || nums2.size() \u003e 6 * nums1.size()) { return -1; } // 两个数组的和 int sum1 = 0, sum2 = 0; unordered_map\u003cint, int\u003e mp1; for (int \u0026num : nums1) { sum1 += num; } for (int \u0026num : nums2) { sum2 += num; } if (sum1 == sum2) { return 0; } if (sum1 \u003e sum2) { vector\u003cint\u003e tmp = nums1; int tmp_sum = sum1; nums1 = nums2; sum1 = sum2; nums2 = tmp; sum2 = tmp_sum; } int cnt = 0; int diff = sum2 - sum1; for (int num : nums1) { ++mp1[6 - num]; } for (int num : nums2) { ++mp1[num - 1]; } for (int i = 5;; i--) { if (diff \u003c= i * mp1[i]) { return cnt + (diff + i - 1) / i; } cnt += mp1[i]; diff -= i * mp1[i]; } return cnt; } }; ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations/:3:2","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.equal sum arrays with minimum number of operations","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations/#better-code"},{"categories":["leetcode"],"content":" 1 问题描述1775.通过最少操作次数使数组的和相等 ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.通过最少操作次数使数组的和相等","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.通过最少操作次数使数组的和相等","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 哈希+贪心本题总体思路为哈希+贪心，用两个数组mp1，mp2记录nums1，nums2中每个数各出现了多少次; 假设nums1的和sum1减去nums2的和sum2的结果为diff，这里假设diff \u003e 0，为了抹平两个数组的和的差距，应该每次减去两个数组中，变化数字引起的数值变化的最大值，并且将变化的数字的计数值减一; nums1的和小于nums2的和的情况类似。 ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/:2:1","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.通过最少操作次数使数组的和相等","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/#哈希贪心"},{"categories":["leetcode"],"content":" 2.2 优化首先假设sum1 \u003c sum2，否则我们交换nums1和nums2并交换sum1和sum2即可，接下来，必定是nums1缩小，nums2增大，对应diff = sum2 - sum1缩小，diff可以减少1,2,3,4,5各若干次，取决于nums1和nums2中原先各个数的数量，用一个哈希表来记录，最后我们从大到小遍历i = 5, 4, 3, 2, 1. ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/:2:2","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.通过最少操作次数使数组的和相等","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/#优化"},{"categories":["leetcode"],"content":" 3 代码","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.通过最少操作次数使数组的和相等","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 hash + greedy algorithm cpp class Solution { public: int find_min(vector\u003cint\u003e \u0026v) { for (int i = 1; i \u003c v.size(); i++) { if (v[i] != 0) return i; } return 6; } int find_max(vector\u003cint\u003e \u0026v) { for (int i = v.size() - 1; i \u003e= 1; i--) { if (v[i] != 0) return i; } return 1; } int minOperations(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) { int sum1 = 0, sum2 = 0; vector\u003cint\u003e mp1(7, 0); vector\u003cint\u003e mp2(7, 0); if (nums1.size() \u003e 6 * nums2.size() || 6 * nums1.size() \u003c nums2.size()) return -1; for (int i = 0; i \u003c nums1.size(); i++) { mp1[nums1[i]]++; sum1 += nums1[i]; } for (int i = 0; i \u003c nums2.size(); i++) { mp2[nums2[i]]++; sum2 += nums2[i]; } int diff = sum1 - sum2; int cnt = 0; if (diff == 0) return cnt; else if (diff \u003e 0) { // 对nums1, 移动一次最多减少 find_max(mp1) - 1; // 对nums2, 移动一次最多增加 6 - find_min(mp2); while (diff \u003e 0) { cnt++; int minus1 = find_max(mp1) - 1; int plus2 = 6 - find_min(mp2); if (minus1 \u003e= plus2) { diff -= minus1; mp1[find_max(mp1)]--; } else { diff -= 6 - find_min(mp2); mp2[find_min(mp2)]--; } } return cnt; } else { // 对nums1, 移动一次最多增加 6 - find_min(mp1); // 对nums2, 移动一次最多减少 find_max(mp2) - 1; while (diff \u003c 0) { cnt++; int minus2 = find_max(mp2) - 1; int plus1 = 6 - find_min(mp1); if (minus2 \u003e= plus1) { diff += minus2; mp2[find_max(mp2)]--; } else { diff += plus1; mp1[find_min(mp1)]--; } } return cnt; } } }; ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/:3:1","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.通过最少操作次数使数组的和相等","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/#hash--greedy-algorithm"},{"categories":["leetcode"],"content":" 3.2 better code cpp class Solution { public: int minOperations(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { // 先判断不可能相等的情况 if (nums1.size() \u003e 6 * nums2.size() || nums2.size() \u003e 6 * nums1.size()) { return -1; } // 两个数组的和 int sum1 = 0, sum2 = 0; unordered_map\u003cint, int\u003e mp1; for (int \u0026num : nums1) { sum1 += num; } for (int \u0026num : nums2) { sum2 += num; } if (sum1 == sum2) { return 0; } if (sum1 \u003e sum2) { vector\u003cint\u003e tmp = nums1; int tmp_sum = sum1; nums1 = nums2; sum1 = sum2; nums2 = tmp; sum2 = tmp_sum; } int cnt = 0; int diff = sum2 - sum1; for (int num : nums1) { ++mp1[6 - num]; } for (int num : nums2) { ++mp1[num - 1]; } for (int i = 5;; i--) { if (diff \u003c= i * mp1[i]) { return cnt + (diff + i - 1) / i; } cnt += mp1[i]; diff -= i * mp1[i]; } return cnt; } }; ","date":"2022-12-07","objectID":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/:3:2","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1775.通过最少操作次数使数组的和相等","uri":"/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/#better-code"},{"categories":["leetcode"],"content":" 1 Description219.contains-duplicate-ii ","date":"2022-12-06","objectID":"/219.contains-duplicate-ii/:1:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"219.contains duplicate ii","uri":"/219.contains-duplicate-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use unordered_map to record the number of ocurrence of each integer and slide window accrording the unordered_map. ","date":"2022-12-06","objectID":"/219.contains-duplicate-ii/:2:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"219.contains duplicate ii","uri":"/219.contains-duplicate-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool containsNearbyDuplicate(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e mp; for (int i = 0; i \u003c nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] \u003c= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; ","date":"2022-12-06","objectID":"/219.contains-duplicate-ii/:3:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"219.contains duplicate ii","uri":"/219.contains-duplicate-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述219.存在重复元素II ","date":"2022-12-06","objectID":"/219.contains-duplicate-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"219.存在重复元素II","uri":"/219.contains-duplicate-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用unordered_map记录元素出现的次数，使用滑动窗口法。 ","date":"2022-12-06","objectID":"/219.contains-duplicate-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"219.存在重复元素II","uri":"/219.contains-duplicate-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool containsNearbyDuplicate(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e mp; for (int i = 0; i \u003c nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] \u003c= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; ","date":"2022-12-06","objectID":"/219.contains-duplicate-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","sliding window"],"title":"219.存在重复元素II","uri":"/219.contains-duplicate-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description396. rotate-function ","date":"2022-12-06","objectID":"/396.rotate-function/:1:0","series":null,"tags":["data structure and algorithms","math","dynamic programming"],"title":"396.rotate function","uri":"/396.rotate-function/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe key is to find the mathematical laws ","date":"2022-12-06","objectID":"/396.rotate-function/:2:0","series":null,"tags":["data structure and algorithms","math","dynamic programming"],"title":"396.rotate function","uri":"/396.rotate-function/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maxRotateFunction(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e tmp(2 * nums.size(), 0); vector\u003cint\u003e res(nums.size(), 0); int sum = 0; for (int i = 0; i \u003c nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i \u003c nums.size(); i++) { res[i] = res[i - 1] + sum - (nums.size()) * tmp[2 * nums.size() - i]; if (res[i] \u003e max_Fk) max_Fk = res[i]; } return max_Fk; } }; ","date":"2022-12-06","objectID":"/396.rotate-function/:3:0","series":null,"tags":["data structure and algorithms","math","dynamic programming"],"title":"396.rotate function","uri":"/396.rotate-function/#code"},{"categories":["leetcode"],"content":" 1 问题描述396.旋转函数 ","date":"2022-12-06","objectID":"/396.rotate-function.zh/:1:0","series":null,"tags":["data structure and algorithms","math","dynamic programming"],"title":"396.旋转函数","uri":"/396.rotate-function.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路关键在于找到数学规律 ","date":"2022-12-06","objectID":"/396.rotate-function.zh/:2:0","series":null,"tags":["data structure and algorithms","math","dynamic programming"],"title":"396.旋转函数","uri":"/396.rotate-function.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxRotateFunction(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e tmp(2 * nums.size(), 0); vector\u003cint\u003e res(nums.size(), 0); int sum = 0; for (int i = 0; i \u003c nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i \u003c nums.size(); i++) { res[i] = res[i - 1] + sum - (nums.size()) * tmp[2 * nums.size() - i]; if (res[i] \u003e max_Fk) max_Fk = res[i]; } return max_Fk; } }; ","date":"2022-12-06","objectID":"/396.rotate-function.zh/:3:0","series":null,"tags":["data structure and algorithms","math","dynamic programming"],"title":"396.旋转函数","uri":"/396.rotate-function.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1796.second-largest-digit-in-a-string ","date":"2022-12-06","objectID":"/1796.second-largest-digit-in-a-string/:1:0","series":null,"tags":["data structure and algorithms"],"title":"1796.second largest digit in a string","uri":"/1796.second-largest-digit-in-a-string/#description"},{"categories":["leetcode"],"content":" 2 SolutionJust traversing. ","date":"2022-12-06","objectID":"/1796.second-largest-digit-in-a-string/:2:0","series":null,"tags":["data structure and algorithms"],"title":"1796.second largest digit in a string","uri":"/1796.second-largest-digit-in-a-string/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i \u003c s.size(); i++) { if (s[i] \u003c= '9') { if (s[i] - '0' \u003e first) { second = first; first = s[i] - '0'; } else if (s[i] - '0' \u003c first \u0026\u0026 s[i] - '0' \u003e second) second = s[i] - '0'; } } return second; } }; ","date":"2022-12-06","objectID":"/1796.second-largest-digit-in-a-string/:3:0","series":null,"tags":["data structure and algorithms"],"title":"1796.second largest digit in a string","uri":"/1796.second-largest-digit-in-a-string/#code"},{"categories":["leetcode"],"content":" 1 问题描述1796.字符串中第二大的数字 ","date":"2022-12-06","objectID":"/1796.second-largest-digit-in-a-string.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"1796.字符串中第二大的数字","uri":"/1796.second-largest-digit-in-a-string.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路遍历就好了 ","date":"2022-12-06","objectID":"/1796.second-largest-digit-in-a-string.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"1796.字符串中第二大的数字","uri":"/1796.second-largest-digit-in-a-string.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i \u003c s.size(); i++) { if (s[i] \u003c= '9') { if (s[i] - '0' \u003e first) { second = first; first = s[i] - '0'; } else if (s[i] - '0' \u003c first \u0026\u0026 s[i] - '0' \u003e second) second = s[i] - '0'; } } return second; } }; ","date":"2022-12-06","objectID":"/1796.second-largest-digit-in-a-string.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"1796.字符串中第二大的数字","uri":"/1796.second-largest-digit-in-a-string.zh/#代码"},{"categories":[""],"content":" 1 问题描述1774.最接近目标价格的甜点成本 ","date":"2022-12-06","objectID":"/1774.closest-dessert-cost.zh/:1:0","series":null,"tags":[""],"title":"1774.最接近目标价格的甜点成本","uri":"/1774.closest-dessert-cost.zh/#问题描述"},{"categories":[""],"content":" 2 解题思路","date":"2022-12-06","objectID":"/1774.closest-dessert-cost.zh/:2:0","series":null,"tags":[""],"title":"1774.最接近目标价格的甜点成本","uri":"/1774.closest-dessert-cost.zh/#解题思路"},{"categories":[""],"content":" 2.1 回溯法","date":"2022-12-06","objectID":"/1774.closest-dessert-cost.zh/:2:1","series":null,"tags":[""],"title":"1774.最接近目标价格的甜点成本","uri":"/1774.closest-dessert-cost.zh/#回溯法"},{"categories":[""],"content":" 2.2 动态规划法","date":"2022-12-06","objectID":"/1774.closest-dessert-cost.zh/:2:2","series":null,"tags":[""],"title":"1774.最接近目标价格的甜点成本","uri":"/1774.closest-dessert-cost.zh/#动态规划法"},{"categories":[""],"content":" 3 代码","date":"2022-12-06","objectID":"/1774.closest-dessert-cost.zh/:3:0","series":null,"tags":[""],"title":"1774.最接近目标价格的甜点成本","uri":"/1774.closest-dessert-cost.zh/#代码"},{"categories":[""],"content":" 3.1 回溯法 cpp class Solution { public: // res表示存储的最接近target的成本，sum表示和 int traverse(vector\u003cint\u003e \u0026toppingCosts, int target, int index, int sum, int res, vector\u003cint\u003e \u0026cnt) { if (cnt[index] \u003e 2) return res; if (sum \u003e= target) { // 返回最接近的成本 if (abs(sum - target) \u003c abs(target - res)) return sum; else if (abs(sum - target) == abs(target - res)) return min(res, sum); else return res; } for (int i = index; i \u003c toppingCosts.size(); i++) { sum += toppingCosts[i]; // int tmp = res; cnt[i]++; res = traverse(toppingCosts, target, i, sum, res, cnt); cnt[i]--; sum -= toppingCosts[i]; } if (abs(sum - target) \u003c abs(target - res)) return sum; else if (abs(sum - target) == abs(target - res)) return min(res, sum); else return res; } int closestCost(vector\u003cint\u003e \u0026baseCosts, vector\u003cint\u003e \u0026toppingCosts, int target) { // 考虑使用回溯法 int mcost = baseCosts[0]; vector\u003cint\u003e cnt(toppingCosts.size(), 0); for (int i = 0; i \u003c baseCosts.size(); i++) { if (baseCosts[i] == target) return target; else if (baseCosts[i] \u003e target) { if (baseCosts[i] - target \u003c abs(target - mcost)) mcost = baseCosts[i]; } else { // 注意这里？ int res = traverse(toppingCosts, target, 0, baseCosts[i], baseCosts[i], cnt); if (abs(res - target) \u003c abs(target - mcost)) mcost = res; else if (abs(res - target) == abs(target - mcost)) mcost = min(res, mcost); } } return mcost; } }; ","date":"2022-12-06","objectID":"/1774.closest-dessert-cost.zh/:3:1","series":null,"tags":[""],"title":"1774.最接近目标价格的甜点成本","uri":"/1774.closest-dessert-cost.zh/#回溯法-1"},{"categories":["leetcode"],"content":" 1 Descripiton1805.number-of-different-integers-in-a-string ","date":"2022-12-06","objectID":"/1805.number-of-different-integers-in-a-string/:1:0","series":null,"tags":["data structure and algorithms"],"title":"1805.number of different integers in a string","uri":"/1805.number-of-different-integers-in-a-string/#descripiton"},{"categories":["leetcode"],"content":" 2 SolutionTreating numbers as strings, save them in unordered_set, we need pay attention to pilot zero and the condition which last character is a number. ","date":"2022-12-06","objectID":"/1805.number-of-different-integers-in-a-string/:2:0","series":null,"tags":["data structure and algorithms"],"title":"1805.number of different integers in a string","uri":"/1805.number-of-different-integers-in-a-string/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int numDifferentIntegers(string word) { unordered_set\u003cstring\u003e words; string str; for (int i = 0; i \u003c word.size(); i++) { if (str.empty()) { if (word[i] - '0' \u003c= 9) str.push_back(word[i]); } else { if (word[i] - '0' \u003e 9) { if (words.find(str) == words.end()) words.insert(str); str.clear(); } else { if (str.size() == 1 \u0026\u0026 str[0] == '0') { // 去除先导0 str.clear(); } str.push_back(word[i]); } } } if (!str.empty() \u0026\u0026 words.find(str) == words.end()) words.insert(str); return words.size(); } }; ","date":"2022-12-06","objectID":"/1805.number-of-different-integers-in-a-string/:3:0","series":null,"tags":["data structure and algorithms"],"title":"1805.number of different integers in a string","uri":"/1805.number-of-different-integers-in-a-string/#code"},{"categories":["leetcode"],"content":" 1 问题描述1805.字符串中不同整数的数目 ","date":"2022-12-06","objectID":"/1805.number-of-different-integers-in-a-string.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"1805.字符串中不同整数的数目","uri":"/1805.number-of-different-integers-in-a-string.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路把数字当作字符串处理，存入unordered_set(哈希表)中，注意最后一个字符是数字的情况。 ","date":"2022-12-06","objectID":"/1805.number-of-different-integers-in-a-string.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"1805.字符串中不同整数的数目","uri":"/1805.number-of-different-integers-in-a-string.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int numDifferentIntegers(string word) { unordered_set\u003cstring\u003e words; string str; for (int i = 0; i \u003c word.size(); i++) { if (str.empty()) { if (word[i] - '0' \u003c= 9) str.push_back(word[i]); } else { if (word[i] - '0' \u003e 9) { if (words.find(str) == words.end()) words.insert(str); str.clear(); } else { if (str.size() == 1 \u0026\u0026 str[0] == '0') { // 去除先导0 str.clear(); } str.push_back(word[i]); } } } if (!str.empty() \u0026\u0026 words.find(str) == words.end()) words.insert(str); return words.size(); } }; ","date":"2022-12-06","objectID":"/1805.number-of-different-integers-in-a-string.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"1805.字符串中不同整数的数目","uri":"/1805.number-of-different-integers-in-a-string.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description131.palindrome-partitioning ","date":"2022-12-06","objectID":"/131.palindrome-patitioning/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming","backtracking"],"title":"131.palindrome patitioning","uri":"/131.palindrome-patitioning/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can whether it is palindrome by dynamic programming: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1]; When traversing, pay attention to the order of traversing i; Last, we use backtracking to update res. ","date":"2022-12-06","objectID":"/131.palindrome-patitioning/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming","backtracking"],"title":"131.palindrome patitioning","uri":"/131.palindrome-patitioning/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cvector\u003cstring\u003e\u003e res; vector\u003cstring\u003e res_tmp; void track_back(string \u0026s, int index, vector\u003cvector\u003cbool\u003e\u003e \u0026dp) { if (index \u003e= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i \u003c s.size(); i++) { if (dp[index][i]) { res_tmp.push_back(s.substr(index, i - index + 1)); track_back(s, i + 1, dp); res_tmp.pop_back(); } } return; } vector\u003cvector\u003cstring\u003e\u003e partition(string s) { vector\u003cvector\u003cbool\u003e\u003e dp(s.size(), vector\u003cbool\u003e(s.size(), false)); for (int i = 0; i \u003c s.size(); i++) { dp[i][i] = true; if (i \u003c s.size() - 1) { if (s[i] == s[i + 1]) dp[i][i + 1] = true; } } for (int i = s.size(); i \u003e= 0; i--) { for (int j = i + 2; j \u003c s.size(); j++) { if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1]; } } track_back(s, 0, dp); return res; } }; ","date":"2022-12-06","objectID":"/131.palindrome-patitioning/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming","backtracking"],"title":"131.palindrome patitioning","uri":"/131.palindrome-patitioning/#code"},{"categories":["leetcode"],"content":" 1 问题描述131.分割回文串 ","date":"2022-12-06","objectID":"/131.palindrome-patitioning.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming","backtracking"],"title":"131.分割回文串","uri":"/131.palindrome-patitioning.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用动态规划来判断字符串是否是回文串: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1]; 这里遍历的时候要注意i的遍历顺序; 最后考虑利用回溯法，更新答案。 ","date":"2022-12-06","objectID":"/131.palindrome-patitioning.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming","backtracking"],"title":"131.分割回文串","uri":"/131.palindrome-patitioning.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cvector\u003cstring\u003e\u003e res; vector\u003cstring\u003e res_tmp; void track_back(string \u0026s, int index, vector\u003cvector\u003cbool\u003e\u003e \u0026dp) { if (index \u003e= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i \u003c s.size(); i++) { if (dp[index][i]) { res_tmp.push_back(s.substr(index, i - index + 1)); track_back(s, i + 1, dp); res_tmp.pop_back(); } } return; } vector\u003cvector\u003cstring\u003e\u003e partition(string s) { vector\u003cvector\u003cbool\u003e\u003e dp(s.size(), vector\u003cbool\u003e(s.size(), false)); for (int i = 0; i \u003c s.size(); i++) { dp[i][i] = true; if (i \u003c s.size() - 1) { if (s[i] == s[i + 1]) dp[i][i + 1] = true; } } for (int i = s.size(); i \u003e= 0; i--) { for (int j = i + 2; j \u003c s.size(); j++) { if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1]; } } track_back(s, 0, dp); return res; } }; ","date":"2022-12-06","objectID":"/131.palindrome-patitioning.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming","backtracking"],"title":"131.分割回文串","uri":"/131.palindrome-patitioning.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description3.longest-substring-withou-repeating-characters ","date":"2022-12-05","objectID":"/3.longest-substring-without-repeating-characters/:1:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"3.longest substring without repeating characters","uri":"/3.longest-substring-without-repeating-characters/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe use arr[96] to record the number of occurence of each character. If the number is larger than 1, than there is repeating character between l and r; else, update res, if current length of substr is larger than res. ","date":"2022-12-05","objectID":"/3.longest-substring-without-repeating-characters/:2:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"3.longest substring without repeating characters","uri":"/3.longest-substring-without-repeating-characters/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r \u003c s.size(); r++) { arr[s[r] - ' ']++; if (arr[s[r] - ' '] \u003e 1) { while (l \u003c r \u0026\u0026 arr[s[r] - ' '] \u003e 1) arr[s[l++] - ' ']--; } else { res = max(r - l + 1, res); } } return res; } }; ","date":"2022-12-05","objectID":"/3.longest-substring-without-repeating-characters/:3:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"3.longest substring without repeating characters","uri":"/3.longest-substring-without-repeating-characters/#code"},{"categories":["leetcode"],"content":" 1 问题描述3.无重复字符的最长子串 ","date":"2022-12-05","objectID":"/3.longest-substring-without-repeating-characters.zh/:1:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"3.无重复字符的最长子串","uri":"/3.longest-substring-without-repeating-characters.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路用arr[96]记录每个字符出现的次数，如果字符次数大于1，说明已经包含了重复字符，则要更新l，否则递增r，并记录最大的子串长度。 ","date":"2022-12-05","objectID":"/3.longest-substring-without-repeating-characters.zh/:2:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"3.无重复字符的最长子串","uri":"/3.longest-substring-without-repeating-characters.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r \u003c s.size(); r++) { arr[s[r] - ' ']++; if (arr[s[r] - ' '] \u003e 1) { while (l \u003c r \u0026\u0026 arr[s[r] - ' '] \u003e 1) arr[s[l++] - ' ']--; } else { res = max(r - l + 1, res); } } return res; } }; ","date":"2022-12-05","objectID":"/3.longest-substring-without-repeating-characters.zh/:3:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"3.无重复字符的最长子串","uri":"/3.longest-substring-without-repeating-characters.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description30.substring-with-concatenation-of-all-words ","date":"2022-12-05","objectID":"/30.substring-with-concatenation-of-all-words/:1:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"30.substring with concatenation of all words","uri":"/30.substring-with-concatenation-of-all-words/#description"},{"categories":["leetcode"],"content":" 2 SolutionFor each word sequence {s.substr(i, word_len), s.substr(i + word_len, word_len)...} of i($ \\[0, word_len - 1\\] $), we use sliding window to judge; We should pay attention to the detail when judging. We can use mp to determine whether substr is in words, and mp_tmp to determine whether it is concatenated substring, if mp is empty, then it is; For key-value in mp_tmp, if value becomes 0, then erase(key); Don’t forget dealing with l! It’s also complicated. When mp_tmp becomes empty, mp_tmp[s.substr(l, word_len)]++; l+= word_len; When the word is in mp but not in mp_tmp, update l and mp_tmp. ","date":"2022-12-05","objectID":"/30.substring-with-concatenation-of-all-words/:2:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"30.substring with concatenation of all words","uri":"/30.substring-with-concatenation-of-all-words/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e findSubstring(string s, vector\u003cstring\u003e \u0026words) { unordered_map\u003cstring, int\u003e mp; int word_len = words[0].size(); int cnt = 0; vector\u003cint\u003e res; for (int i = 0; i \u003c words.size(); i++) { mp[words[i]]++; cnt++; } if (cnt * word_len \u003e s.size()) return res; // i : [0, word_len - 1], sliding windows for each word sequence for (int i = 0; i \u003c word_len; i++) { int l = i; unordered_map\u003cstring, int\u003e mp_tmp = mp; // unordered_map\u003cstring, int\u003e mp_tmp2 = mp; for (int r = i; r \u003c= s.size() - word_len; r += word_len) { string tmp = s.substr(r, word_len); if (mp_tmp.find(tmp) != mp_tmp.end()) { mp_tmp[tmp]--; if (mp_tmp[tmp] == 0) mp_tmp.erase(tmp); if (mp_tmp.empty()) { res.push_back(l); // update l mp_tmp[s.substr(l, word_len)]++; l += word_len; } } else { if (mp.find(tmp) == mp.end()) { // the key is not in words l = r + word_len; mp_tmp = mp; } else { string str_l = s.substr(l, word_len); while (str_l != tmp) { mp_tmp[str_l]++; l += word_len; str_l = s.substr(l, word_len); } l += word_len; } } } } return res; } }; ","date":"2022-12-05","objectID":"/30.substring-with-concatenation-of-all-words/:3:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"30.substring with concatenation of all words","uri":"/30.substring-with-concatenation-of-all-words/#code"},{"categories":["leetcode"],"content":" 1 问题描述30.串联所有单词串 ","date":"2022-12-05","objectID":"/30.substring-with-concatenation-of-all-words.zh/:1:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"30.串联所有单词串","uri":"/30.substring-with-concatenation-of-all-words.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，由于words中所有字符串长度相同，要比较words与s: - s从i = 0开始，可以划分为一系列的长为word_len = words[0].size()的单词; - s从i = 1开始，可以划分为一系列的长为word_len = words[0].size()的单词; - …… - s从i = word_len - 1开始…… 然后要注意利用unordered_map\u003cstring, int\u003e判断是否满足条件的细节，mp用于判断word是否在words中; mp_tmp的键值对中，如果值为0，就删掉该键; 还要注意l的处理，分为在mp_tmp为空，和mp_tmp不为空，但是word已经出现了超过words中的次数. ","date":"2022-12-05","objectID":"/30.substring-with-concatenation-of-all-words.zh/:2:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"30.串联所有单词串","uri":"/30.substring-with-concatenation-of-all-words.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e findSubstring(string s, vector\u003cstring\u003e \u0026words) { unordered_map\u003cstring, int\u003e mp; int word_len = words[0].size(); int cnt = 0; vector\u003cint\u003e res; for (int i = 0; i \u003c words.size(); i++) { mp[words[i]]++; cnt++; } if (cnt * word_len \u003e s.size()) return res; // i : [0, word_len - 1], 对每一个i组成的单词序列，都单独使用滑动窗口法判断 for (int i = 0; i \u003c word_len; i++) { int l = i; unordered_map\u003cstring, int\u003e mp_tmp = mp; // unordered_map\u003cstring, int\u003e mp_tmp2 = mp; for (int r = i; r \u003c= s.size() - word_len; r += word_len) { string tmp = s.substr(r, word_len); // 单词在words中 if (mp_tmp.find(tmp) != mp_tmp.end()) { mp_tmp[tmp]--; // 说明出现了超过words里单词的数量 if (mp_tmp[tmp] == 0) mp_tmp.erase(tmp); if (mp_tmp.empty()) { res.push_back(l); // 说明找到了目标 // mp_tmp = mp; // map变成新的 mp_tmp[s.substr(l, word_len)]++; l += word_len; } } else { if (mp.find(tmp) == mp.end()) { // 说明这个单词不在words里面 l = r + word_len; mp_tmp = mp; } else { // word出现次数超过words中对应单词的次数了，在mp中而不在mp_tmp中 string str_l = s.substr(l, word_len); while (str_l != tmp) { mp_tmp[str_l]++; l += word_len; str_l = s.substr(l, word_len); } l += word_len; } } } } return res; } }; ","date":"2022-12-05","objectID":"/30.substring-with-concatenation-of-all-words.zh/:3:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"30.串联所有单词串","uri":"/30.substring-with-concatenation-of-all-words.zh/#代码"},{"categories":["leetcode"],"content":" 1 Descripiton1610.maximum-number-of-visible-points ","date":"2022-12-04","objectID":"/1610.maximum-number-of-visible-points/:1:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"1610.maximum Number of Visible Points","uri":"/1610.maximum-number-of-visible-points/#descripiton"},{"categories":["leetcode"],"content":" 2 SoluitonWe can use function atan2 to change slope to angle in $-\\pi ~ \\pi$. We need also expand arrays, let angle[n + i] = angle[i] + 360, and the length of array to be 2 * n, so we can avoid omission. ","date":"2022-12-04","objectID":"/1610.maximum-number-of-visible-points/:2:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"1610.maximum Number of Visible Points","uri":"/1610.maximum-number-of-visible-points/#soluiton"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int visiblePoints(vector\u003cvector\u003cint\u003e\u003e \u0026points, int angle, vector\u003cint\u003e \u0026location) { vector\u003cfloat\u003e point_angle(points.size(), 0); for (int i = 0; i \u003c points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] \u003e location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.begin(), point_angle.end()); for (int i = point_angle.size() - 1; i \u003e= 0; i--) { if (point_angle[i] \u003e 360) { point_angle.pop_back(); cnt++; } } int ans = 0; vector\u003cfloat\u003e angle2(point_angle.size() * 2, 0); for (int i = 0; i \u003c point_angle.size(); i++) { angle2[i] = point_angle[i]; angle2[i + point_angle.size()] = point_angle[i] + 360; } int l = 0; for (int r = 0; r \u003c angle2.size(); r++) { if (angle2[r] - angle2[l] \u003e angle) while (l \u003c= r \u0026\u0026 angle2[r] - angle2[l] \u003e angle) l++; else ans = max(ans, r - l + 1); } return ans + cnt; } }; ","date":"2022-12-04","objectID":"/1610.maximum-number-of-visible-points/:3:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"1610.maximum Number of Visible Points","uri":"/1610.maximum-number-of-visible-points/#code"},{"categories":["leetcode"],"content":" 1 问题描述1610.可见点的最大数目 ","date":"2022-12-04","objectID":"/1610.maximum-number-of-visible-points.zh/:1:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"1610.可见点的最大数目","uri":"/1610.maximum-number-of-visible-points.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用atan2函数，即可将斜率转化为$-\\pi ~ \\pi$的角度; 扩充数组，令angle[n + i] = angle[i] + 360，使角度数组长度为2 * n，这样就能避免遗漏一四象限。 ","date":"2022-12-04","objectID":"/1610.maximum-number-of-visible-points.zh/:2:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"1610.可见点的最大数目","uri":"/1610.maximum-number-of-visible-points.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int visiblePoints(vector\u003cvector\u003cint\u003e\u003e \u0026points, int angle, vector\u003cint\u003e \u0026location) { vector\u003cfloat\u003e point_angle(points.size(), 0); for (int i = 0; i \u003c points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] \u003e location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.begin(), point_angle.end()); for (int i = point_angle.size() - 1; i \u003e= 0; i--) { if (point_angle[i] \u003e 360) { point_angle.pop_back(); cnt++; } } int ans = 0; vector\u003cfloat\u003e angle2(point_angle.size() * 2, 0); for (int i = 0; i \u003c point_angle.size(); i++) { angle2[i] = point_angle[i]; angle2[i + point_angle.size()] = point_angle[i] + 360; } int l = 0; for (int r = 0; r \u003c angle2.size(); r++) { if (angle2[r] - angle2[l] \u003e angle) while (l \u003c= r \u0026\u0026 angle2[r] - angle2[l] \u003e angle) l++; else ans = max(ans, r - l + 1); } return ans + cnt; } }; ","date":"2022-12-04","objectID":"/1610.maximum-number-of-visible-points.zh/:3:0","series":null,"tags":["data structure and algorithms","sliding window","三叶","two pointers"],"title":"1610.可见点的最大数目","uri":"/1610.maximum-number-of-visible-points.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description303.range-sum-query-immutable ","date":"2022-12-02","objectID":"/303.range-sum-query-immutable/:1:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"303.range sum query-immutable","uri":"/303.range-sum-query-immutable/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use prefix sum array, so we can get sum without traversing. ","date":"2022-12-02","objectID":"/303.range-sum-query-immutable/:2:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"303.range sum query-immutable","uri":"/303.range-sum-query-immutable/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class NumArray { private: vector\u003cint\u003e sum; public: NumArray(vector\u003cint\u003e \u0026nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i \u003c nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; ","date":"2022-12-02","objectID":"/303.range-sum-query-immutable/:3:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"303.range sum query-immutable","uri":"/303.range-sum-query-immutable/#code"},{"categories":["leetcode"],"content":" 1 问题描述303.区域和检索-数组不可变 ","date":"2022-12-02","objectID":"/303.range-sum-query-immutable.zh/:1:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"303.区域和检索-数组不可变","uri":"/303.range-sum-query-immutable.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路利用前缀和数组，使得求区间和时无需再遍历数组求和。 ","date":"2022-12-02","objectID":"/303.range-sum-query-immutable.zh/:2:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"303.区域和检索-数组不可变","uri":"/303.range-sum-query-immutable.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class NumArray { private: vector\u003cint\u003e sum; public: NumArray(vector\u003cint\u003e \u0026nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i \u003c nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; ","date":"2022-12-02","objectID":"/303.range-sum-query-immutable.zh/:3:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"303.区域和检索-数组不可变","uri":"/303.range-sum-query-immutable.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1769.minimum-number-of-operations-to-move-all-balls-to-each-box ","date":"2022-12-02","objectID":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/:1:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"1769.minimum number of operation to ove ll balls to each box","uri":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/#description"},{"categories":["leetcode"],"content":" 2 SolutionViolent solution: $\\Theta(n^2)$ We could use prefix sum to reduce the time complexity. nums[i] denotes the number of ball in first i + 1 boxes, res[i] is the minimum number of operation to ove ll balls to the i + 1th box, sum is the total number of balls. Compared to moving all balls to i th box, if we want to move all ball to the i + 1th box, the balls in 0 =\u003e i - 1 all need move an additional step, while the balls in i =\u003e n - 1 will move one step less. So: res[i] = res[i - 1] + nums[i - 1] - (sum - nums[i - 1]); ","date":"2022-12-02","objectID":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/:2:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"1769.minimum number of operation to ove ll balls to each box","uri":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e minOperations(string boxes) { vector\u003cint\u003e nums(boxes.size(), 0); int sum = boxes[0] - '0'; nums[0] = boxes[0] - '0'; for (int i = 1; i \u003c boxes.size(); i++) { if (boxes[i] == '1') { nums[i] = nums[i - 1] + 1; sum++; } else nums[i] = nums[i - 1]; } vector\u003cint\u003e res(boxes.size(), 0); for (int i = 1; i \u003c boxes.size(); i++) { res[0] += i * (boxes[i] - '0'); } for (int i = 1; i \u003c boxes.size(); i++) { res[i] = res[i - 1] + nums[i - 1] - (sum - nums[i - 1]); } return res; } }; ","date":"2022-12-02","objectID":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/:3:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"1769.minimum number of operation to ove ll balls to each box","uri":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/#code"},{"categories":["leetcode"],"content":" 1 问题描述1769.移动所有球到每个盒子所需的最小操作数 ","date":"2022-12-02","objectID":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/:1:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"1769.移动所有球到每个盒子所需的最小操作数","uri":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路暴力求解，时间复杂度为$\\Theta(n^2)$; 可以考虑利用前缀和来降低时间复杂度: 设nums[i]是前i + 1个盒子里的球的总个数，res[i]为将所有球移到第i + 1个盒子里所需要的操作数，sum为球总个数，移到第i + 1个盒子相比移到第i个盒子，左边的球各要多移一步，右边的球各少移一步，因此有那么有:res[i] = res[i - 1] + nums[i - 1] - (sum - nums[i - 1])， ","date":"2022-12-02","objectID":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/:2:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"1769.移动所有球到每个盒子所需的最小操作数","uri":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e minOperations(string boxes) { vector\u003cint\u003e nums(boxes.size(), 0); int sum = boxes[0] - '0'; nums[0] = boxes[0] - '0'; for (int i = 1; i \u003c boxes.size(); i++) { if (boxes[i] == '1') { nums[i] = nums[i - 1] + 1; sum++; } else nums[i] = nums[i - 1]; } vector\u003cint\u003e res(boxes.size(), 0); for (int i = 1; i \u003c boxes.size(); i++) { res[0] += i * (boxes[i] - '0'); } for (int i = 1; i \u003c boxes.size(); i++) { res[i] = res[i - 1] + nums[i - 1] - (sum - nums[i - 1]); } return res; } }; ","date":"2022-12-02","objectID":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/:3:0","series":null,"tags":["data structure and algorithms","prefix sum","三叶"],"title":"1769.移动所有球到每个盒子所需的最小操作数","uri":"/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/#代码"},{"categories":[""],"content":" 1 Description424.longest-repeating-character-replacement ","date":"2022-11-29","objectID":"/424.longest-repeating-character-replacement/:1:0","series":null,"tags":[""],"title":"424.longest repeating character replacement","uri":"/424.longest-repeating-character-replacement/#description"},{"categories":[""],"content":" 2 SolutionFirst, note that if the substring can be turned into a substring containing only the same letters by substituing for k times, then there must be max_cnt + k \u003e= subarray.size(); then the substring that does not satisfy the condition must have max_cnt + k \u003c subarray.size(), and according to this, we can use the sliding window method; If it satifies the condition, just right++, else right++, left++, so right - left must be incremental. And all kind of character will be checked. ","date":"2022-11-29","objectID":"/424.longest-repeating-character-replacement/:2:0","series":null,"tags":[""],"title":"424.longest repeating character replacement","uri":"/424.longest-repeating-character-replacement/#solution"},{"categories":[""],"content":" 3 Code cpp class Solution { public: int characterReplacement(string s, int k) { vector\u003cint\u003e num(26); int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right \u003c n) { num[s[right] - 'A']++; maxn = max(maxn, num[s[right] - 'A']); if (right - left + 1 - maxn \u003e k) { num[s[left] - 'A']--; left++; } right++; } return right - left; } }; ","date":"2022-11-29","objectID":"/424.longest-repeating-character-replacement/:3:0","series":null,"tags":[""],"title":"424.longest repeating character replacement","uri":"/424.longest-repeating-character-replacement/#code"},{"categories":["leetcode"],"content":" 1 问题描述424.替换后的最长重复字符 ","date":"2022-11-29","objectID":"/424.longest-repeating-character-replacement.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"424.替换后的最长重复字符","uri":"/424.longest-repeating-character-replacement.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，注意一点，子串如果能通过k次替换变成只包含相同字母的子串，那么一定有max_cnt + k \u003e= subarray.size();那么不满足条件的子串一定有max_cnt + k \u003c subarray.size()，根据这一点，我们可以采用滑动窗口法; 如果满足条件，那么只增加right，如果不满足条件，right++、left++，这样right - left一定是递增的，并且会遍历搜寻到所有的不同字符。 ","date":"2022-11-29","objectID":"/424.longest-repeating-character-replacement.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"424.替换后的最长重复字符","uri":"/424.longest-repeating-character-replacement.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int characterReplacement(string s, int k) { vector\u003cint\u003e num(26); int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right \u003c n) { num[s[right] - 'A']++; maxn = max(maxn, num[s[right] - 'A']); if (right - left + 1 - maxn \u003e k) { num[s[left] - 'A']--; left++; } right++; } return right - left; } }; ","date":"2022-11-29","objectID":"/424.longest-repeating-character-replacement.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"424.替换后的最长重复字符","uri":"/424.longest-repeating-character-replacement.zh/#代码"},{"categories":["leetcode"],"content":" 1 Descritpion413.arithmetic slices ","date":"2022-11-29","objectID":"/413.arithmetic-slices/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"413.arithmetic slices","uri":"/413.arithmetic-slices/#descritpion"},{"categories":["leetcode"],"content":" 2 SolutionWe should notice that the number of subarray $cnt = len - 3 + 1 + len - 4 + 1 + … + 1$(len) is the length of arithmetic array. ","date":"2022-11-29","objectID":"/413.arithmetic-slices/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"413.arithmetic slices","uri":"/413.arithmetic-slices/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e \u0026nums) { if (nums.size() \u003c 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i \u003c nums.size(); i++) { if (nums[i] - nums[i - 1] == dif) len++; else { if (len \u003e= 3) cnt += (len - 2) * (len - 1) / 2; len = 2; dif = nums[i] - nums[i - 1]; } } if (len \u003e= 3) cnt += (len - 2) * (len - 1) / 2; return cnt; } }; ","date":"2022-11-29","objectID":"/413.arithmetic-slices/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"413.arithmetic slices","uri":"/413.arithmetic-slices/#code"},{"categories":["leetcode"],"content":" 1 问题描述413.等差数列划分 ","date":"2022-11-29","objectID":"/413.arithmetic-slices.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"413.等差数列划分","uri":"/413.arithmetic-slices.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路注意到子数组个数$cnt = len - 3 + 1 + len - 4 + 1 + … + 1$，其中len是等差数组的长度，则cnt = (n - 1) * (n - 2) / 2，每次遍历找出连续的等差数组的长度即可。 测试test ","date":"2022-11-29","objectID":"/413.arithmetic-slices.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"413.等差数列划分","uri":"/413.arithmetic-slices.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int numberOfArithmeticSlices(vector\u003cint\u003e \u0026nums) { if (nums.size() \u003c 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i \u003c nums.size(); i++) { if (nums[i] - nums[i - 1] == dif) len++; else { if (len \u003e= 3) cnt += (len - 2) * (len - 1) / 2; len = 2; dif = nums[i] - nums[i - 1]; } } if (len \u003e= 3) cnt += (len - 2) * (len - 1) / 2; return cnt; } }; ","date":"2022-11-29","objectID":"/413.arithmetic-slices.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"413.等差数列划分","uri":"/413.arithmetic-slices.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description88.merge-sorted-array ","date":"2022-11-28","objectID":"/88.merge-sorted-array/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"88.merge sorted array","uri":"/88.merge-sorted-array/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe use pointers, assign values of nums1 from end to front, so we use only $\\Theta(1)$ extra space. ","date":"2022-11-28","objectID":"/88.merge-sorted-array/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"88.merge sorted array","uri":"/88.merge-sorted-array/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx \u003e= 0; idx--) { if (p1 \u003c 0) nums1[idx] = nums2[p2--]; else if (p1 \u003e= 0 \u0026\u0026 p2 \u003e= 0) { if (nums1[p1] \u003e nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; ","date":"2022-11-28","objectID":"/88.merge-sorted-array/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"88.merge sorted array","uri":"/88.merge-sorted-array/#code"},{"categories":["leetcode"],"content":" 1 问题描述88.合并两个有序数组 ","date":"2022-11-28","objectID":"/88.merge-sorted-array.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"88.合并两个有序数组","uri":"/88.merge-sorted-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路双指针，由于num1的长度是m + n，因此遍历时，可以考虑针对nums1，从后往前赋值，从而只需要$\\Theta(1)$的额外空间。 ","date":"2022-11-28","objectID":"/88.merge-sorted-array.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"88.合并两个有序数组","uri":"/88.merge-sorted-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx \u003e= 0; idx--) { if (p1 \u003c 0) nums1[idx] = nums2[p2--]; else if (p1 \u003e= 0 \u0026\u0026 p2 \u003e= 0) { if (nums1[p1] \u003e nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; ","date":"2022-11-28","objectID":"/88.merge-sorted-array.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"88.合并两个有序数组","uri":"/88.merge-sorted-array.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description142.linked-list-cycle-ii ","date":"2022-11-28","objectID":"/142.linked-list-cycle-ii/:1:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"142.linked list cycle ii","uri":"/142.linked-list-cycle-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionLike 141.linked-list-cycle, when fast and slow meet each other, we make a pointer p start from virtual head node, traverse one by one, the same as slow. slow and p will meet at the entrance of the cycle. ","date":"2022-11-28","objectID":"/142.linked-list-cycle-ii/:2:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"142.linked list cycle ii","uri":"/142.linked-list-cycle-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr \u0026\u0026 fast-\u003enext != nullptr) { fast = fast-\u003enext-\u003enext; slow = slow-\u003enext; if (fast == slow) { while (vhead != slow) { vhead = vhead-\u003enext; slow = slow-\u003enext; } delete vhead; return slow; } } return nullptr; } }; ","date":"2022-11-28","objectID":"/142.linked-list-cycle-ii/:3:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"142.linked list cycle ii","uri":"/142.linked-list-cycle-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述142.环形链表II ","date":"2022-11-28","objectID":"/142.linked-list-cycle-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"142.环形链表II","uri":"/142.linked-list-cycle-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路判断是否链表是否存在环的方式与141.环形链表一致，当两个指针相遇时，再让一个指针从虚拟头节点开始一个节点一个节点的遍历，slow指针也是，两个指针会在环的入口处相遇。 ","date":"2022-11-28","objectID":"/142.linked-list-cycle-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"142.环形链表II","uri":"/142.linked-list-cycle-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr \u0026\u0026 fast-\u003enext != nullptr) { fast = fast-\u003enext-\u003enext; slow = slow-\u003enext; if (fast == slow) { while (vhead != slow) { vhead = vhead-\u003enext; slow = slow-\u003enext; } delete vhead; return slow; } } return nullptr; } }; ","date":"2022-11-28","objectID":"/142.linked-list-cycle-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"142.环形链表II","uri":"/142.linked-list-cycle-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description141.linked-list-cycle ","date":"2022-11-27","objectID":"/141.linked-list-cycle/:1:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"141.linked list cycle","uri":"/141.linked-list-cycle/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use two pointers, one fast, one slow. For each time, fast move to next next node, slow move to next node. If there is cycle, fast will be equal to slow, or fast will be nullptr. ","date":"2022-11-27","objectID":"/141.linked-list-cycle/:2:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"141.linked list cycle","uri":"/141.linked-list-cycle/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr \u0026\u0026 fast-\u003enext != nullptr) { fast = fast-\u003enext-\u003enext; slow = slow-\u003enext; if (fast == slow) return true; } return false; } }; ","date":"2022-11-27","objectID":"/141.linked-list-cycle/:3:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"141.linked list cycle","uri":"/141.linked-list-cycle/#code"},{"categories":["leetcode"],"content":" 1 问题描述141.环形链表 ","date":"2022-11-27","objectID":"/141.linked-list-cycle.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"141.环形链表","uri":"/141.linked-list-cycle.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路使用快慢两个指针，fast一次移动两个节点，slow一次移动一个节点，如果链表存在环，那么fast和slow一定会有相等的时候，否则fast会运动到链表末尾。 ","date":"2022-11-27","objectID":"/141.linked-list-cycle.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"141.环形链表","uri":"/141.linked-list-cycle.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr \u0026\u0026 fast-\u003enext != nullptr) { fast = fast-\u003enext-\u003enext; slow = slow-\u003enext; if (fast == slow) return true; } return false; } }; ","date":"2022-11-27","objectID":"/141.linked-list-cycle.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers","linked list"],"title":"141.环形链表","uri":"/141.linked-list-cycle.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description345.reverse-vowels-of-a-string ","date":"2022-11-27","objectID":"/345.reverse-vowels-of-a-string/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"345.reverse vowels of a string","uri":"/345.reverse-vowels-of-a-string/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe use unordered_set to determine whether it is vowel, two pointers. ","date":"2022-11-27","objectID":"/345.reverse-vowels-of-a-string/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"345.reverse vowels of a string","uri":"/345.reverse-vowels-of-a-string/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: string reverseVowels(string s) { unordered_set\u003cchar\u003e mset{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}; int l = 0, r = s.size() - 1; while (l \u003c= r) { if (mset.find(s[l]) != mset.end() \u0026\u0026 mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.find(s[l]) != mset.end() \u0026\u0026 mset.find(s[r]) == mset.end()) r--; else if (mset.find(s[l]) == mset.end() \u0026\u0026 mset.find(s[r]) != mset.end()) l++; else { r--; l++; } } return s; } }; ","date":"2022-11-27","objectID":"/345.reverse-vowels-of-a-string/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"345.reverse vowels of a string","uri":"/345.reverse-vowels-of-a-string/#code"},{"categories":["leetcode"],"content":" 1 问题描述345.反转字符串中的元音字母 ","date":"2022-11-27","objectID":"/345.reverse-vowels-of-a-string.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"345.反转字符串中的元音字母","uri":"/345.reverse-vowels-of-a-string.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路双指针法，使用unordered_set(底层实现为哈希表)来判断是否是元音字母。 ","date":"2022-11-27","objectID":"/345.reverse-vowels-of-a-string.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"345.反转字符串中的元音字母","uri":"/345.reverse-vowels-of-a-string.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: string reverseVowels(string s) { unordered_set\u003cchar\u003e mset{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}; int l = 0, r = s.size() - 1; while (l \u003c= r) { if (mset.find(s[l]) != mset.end() \u0026\u0026 mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.find(s[l]) != mset.end() \u0026\u0026 mset.find(s[r]) == mset.end()) r--; else if (mset.find(s[l]) == mset.end() \u0026\u0026 mset.find(s[r]) != mset.end()) l++; else { r--; l++; } } return s; } }; ","date":"2022-11-27","objectID":"/345.reverse-vowels-of-a-string.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"345.反转字符串中的元音字母","uri":"/345.reverse-vowels-of-a-string.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description75.sort-colors ","date":"2022-11-25","objectID":"/75.sort-colors/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"75.sort colors","uri":"/75.sort-colors/#description"},{"categories":["leetcode"],"content":" 2 SolutionHere, we need three pointers l, r, idx, l for 0, r for 2, idx for traversing. When traversing: if nums[idx] == 0,swap(nums[idx], nums[l]);, and idx++; l++ if nums[idx] == 1, idx++; if nums[idx] == 2, swap(nums[idx], nums[r]);, and only r--, because new nums[idx] may be 0 or 1 or 2, so we need determine the value of nums[idx] again. if swap(nums[idx], nums[l]);, new nums[idx] will be 0 only when idx == l, or nums[idx] == 1, so we can increase idx. ","date":"2022-11-25","objectID":"/75.sort-colors/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"75.sort colors","uri":"/75.sort-colors/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: void sortColors(vector\u003cint\u003e \u0026nums) { int tmp = 0, index = 0; int l = 0, r = nums.size() - 1; while (index \u003c= r) { if (nums[index] == 0) { tmp = nums[l]; nums[l++] = 0; nums[index++] = tmp; } else if (nums[index] == 2) { tmp = nums[r]; nums[r--] = 2; nums[index] = tmp; } else index++; } } }; ","date":"2022-11-25","objectID":"/75.sort-colors/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"75.sort colors","uri":"/75.sort-colors/#code"},{"categories":["leetcode"],"content":" 1 问题描述75.颜色分类 ","date":"2022-11-25","objectID":"/75.sort-colors.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"75.颜色分类","uri":"/75.sort-colors.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路这里，我们需要三个指针l, r, idx, l用来存放0,r用来存放2，idx用来进行遍历数组。 要注意的是，在遍历数组时: if nums[idx] == 0，需要交换nums[idx]和nums[l]的值，同时idx++; l++; if nums[idx] == 1，idx++即可 if nums[idx] == 2，需要交换nums[idx]和nums[l]的值，但此时只是r--，不会idx++，这是因为新的交换后的nums[idx]的值可能是0、1、2中的任意一个，因此还需要重新判断nums[idx] 如果idx == l，那么[0, idx]区间范围内的数都是0，如果idx != l，那么[0, l - 1]区间范围内都是0，[l, idx)区间范围内都是1，因此可以进行idx++; ","date":"2022-11-25","objectID":"/75.sort-colors.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"75.颜色分类","uri":"/75.sort-colors.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: void sortColors(vector\u003cint\u003e \u0026nums) { int tmp = 0, index = 0; int l = 0, r = nums.size() - 1; while (index \u003c= r) { if (nums[index] == 0) { tmp = nums[l]; nums[l++] = 0; nums[index++] = tmp; } else if (nums[index] == 2) { tmp = nums[r]; nums[r--] = 2; nums[index] = tmp; } else index++; } } }; ","date":"2022-11-25","objectID":"/75.sort-colors.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"75.颜色分类","uri":"/75.sort-colors.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description26.remove-duplicates-from-sorted-array ","date":"2022-11-24","objectID":"/26.remove-duplicates-from-sorted-array/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"26.remove duplicates from sorted array","uri":"/26.remove-duplicates-from-sorted-array/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe use two pointers fast and slow, fast used to check if duplicated, slow use for assignment. ","date":"2022-11-24","objectID":"/26.remove-duplicates-from-sorted-array/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"26.remove duplicates from sorted array","uri":"/26.remove-duplicates-from-sorted-array/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: int removeDuplicates(vector\u003cint\u003e \u0026nums) { int fast = 1; int slow = 0; for (slow = 0; slow \u003c nums.size(); slow++) { while (fast \u003c nums.size() \u0026\u0026 nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; ","date":"2022-11-24","objectID":"/26.remove-duplicates-from-sorted-array/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"26.remove duplicates from sorted array","uri":"/26.remove-duplicates-from-sorted-array/#code"},{"categories":["leetcode"],"content":" 1 问题描述26.删除有序数组中的重复项 ","date":"2022-11-24","objectID":"/26.remove-duplicates-from-sorted-array.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"26.删除有序数组中的重复项","uri":"/26.remove-duplicates-from-sorted-array.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路采用双指针法，一快一慢，fast用于检测是否重复，slow用来被赋值。 ","date":"2022-11-24","objectID":"/26.remove-duplicates-from-sorted-array.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"26.删除有序数组中的重复项","uri":"/26.remove-duplicates-from-sorted-array.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: int removeDuplicates(vector\u003cint\u003e \u0026nums) { int fast = 1; int slow = 0; for (slow = 0; slow \u003c nums.size(); slow++) { while (fast \u003c nums.size() \u0026\u0026 nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; ","date":"2022-11-24","objectID":"/26.remove-duplicates-from-sorted-array.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"26.删除有序数组中的重复项","uri":"/26.remove-duplicates-from-sorted-array.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description18.4sum ","date":"2022-11-23","objectID":"/18.4sum/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"18.4sum","uri":"/18.4sum/#description"},{"categories":["leetcode"],"content":" 2 SolutionTwo pointers, i, j = i + 1, l = j + 1, r = nums.size() - 1; Pay attention to overflow exception and deduplication. ","date":"2022-11-23","objectID":"/18.4sum/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"18.4sum","uri":"/18.4sum/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e fourSum(vector\u003cint\u003e\u0026 nums, int target) { std::sort(nums.begin(), nums.end()); vector\u003cvector\u003cint\u003e\u003e res; if (nums.size() \u003c 4) return res; for (int i = 0; i \u003c nums.size() - 3; i++) { if (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1]) continue; for (int j = i + 1; j \u003c nums.size() - 2; j++) { if (j \u003e i + 1 \u0026\u0026 nums[j] == nums[j - 1]) continue; int l = j + 1, r = nums.size() - 1; while (l \u003c r) { long long sum = (long long)nums[i] + (long long)nums[j] + (long long)nums[l] + (long long)nums[r]; if (sum \u003c target) { l++; while (l \u003c nums.size() - 1 \u0026\u0026 nums[l] == nums[l - 1]) l++; } else if (sum \u003e target) { r--; while (r \u003e 2 \u0026\u0026 nums[r] == nums[r + 1]) r--; } else { res.push_back({nums[i], nums[j], nums[l], nums[r]}); l++; while (l \u003c nums.size() - 1 \u0026\u0026 nums[l] == nums[l - 1]) l++; r--; while (r \u003e 2 \u0026\u0026 nums[r] == nums[r + 1]) r--; } } } } return res; } }; ","date":"2022-11-23","objectID":"/18.4sum/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"18.4sum","uri":"/18.4sum/#code"},{"categories":["leetcode"],"content":" 1 问题描述18.四数之和 ","date":"2022-11-23","objectID":"/18.4sum.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"18.4四数之和","uri":"/18.4sum.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路双指针法，i, j = i + 1, l, r; 注意去重和溢出。 ","date":"2022-11-23","objectID":"/18.4sum.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"18.4四数之和","uri":"/18.4sum.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cvector\u003cint\u003e\u003e fourSum(vector\u003cint\u003e\u0026 nums, int target) { std::sort(nums.begin(), nums.end()); vector\u003cvector\u003cint\u003e\u003e res; if (nums.size() \u003c 4) return res; for (int i = 0; i \u003c nums.size() - 3; i++) { if (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1]) continue; for (int j = i + 1; j \u003c nums.size() - 2; j++) { if (j \u003e i + 1 \u0026\u0026 nums[j] == nums[j - 1]) continue; int l = j + 1, r = nums.size() - 1; while (l \u003c r) { long long sum = (long long)nums[i] + (long long)nums[j] + (long long)nums[l] + (long long)nums[r]; if (sum \u003c target) { l++; while (l \u003c nums.size() - 1 \u0026\u0026 nums[l] == nums[l - 1]) l++; } else if (sum \u003e target) { r--; while (r \u003e 2 \u0026\u0026 nums[r] == nums[r + 1]) r--; } else { res.push_back({nums[i], nums[j], nums[l], nums[r]}); l++; while (l \u003c nums.size() - 1 \u0026\u0026 nums[l] == nums[l - 1]) l++; r--; while (r \u003e 2 \u0026\u0026 nums[r] == nums[r + 1]) r--; } } } } return res; } }; ","date":"2022-11-23","objectID":"/18.4sum.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"18.4四数之和","uri":"/18.4sum.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description19.remove-nth-node-from-end-of-list ","date":"2022-11-23","objectID":"/19.remove-nth-node-from-end-of-list/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"19.remove nth node from end of list","uri":"/19.remove-nth-node-from-end-of-list/#description"},{"categories":["leetcode"],"content":" 2 SolutionFor convenience, we create a virtual head node pre, pre-\u003enext = head. We will use two pointers fast and slow. First, fast go head for n times, then fast and slow go ahead together. When fast arrives at last node, slow points to the last node of the node we need delete. ","date":"2022-11-23","objectID":"/19.remove-nth-node-from-end-of-list/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"19.remove nth node from end of list","uri":"/19.remove-nth-node-from-end-of-list/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i \u003c n; i++) { fast = fast-\u003enext; } while (fast-\u003enext != nullptr) { fast = fast-\u003enext; slow = slow-\u003enext; } slow-\u003enext = slow-\u003enext-\u003enext; return pre-\u003enext; } }; ","date":"2022-11-23","objectID":"/19.remove-nth-node-from-end-of-list/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"19.remove nth node from end of list","uri":"/19.remove-nth-node-from-end-of-list/#code"},{"categories":["leetcode"],"content":" 1 问题描述19.删除链表的倒数第N个节点 ","date":"2022-11-23","objectID":"/19.remove-nth-node-from-end-of-list.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"19.删除链表的倒数第N个节点","uri":"/19.remove-nth-node-from-end-of-list.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先设置一个虚拟头节点pre，pre-\u003enext = head; 双指针法，考虑使用两个指针fast，slow，一快一慢，fast指针先前进n个位置，然后fast和slow一起遍历，当fast到达最后一个节点的时候，slow刚好位于要删除的节点的前一个节点。 ","date":"2022-11-23","objectID":"/19.remove-nth-node-from-end-of-list.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"19.删除链表的倒数第N个节点","uri":"/19.remove-nth-node-from-end-of-list.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i \u003c n; i++) { fast = fast-\u003enext; } while (fast-\u003enext != nullptr) { fast = fast-\u003enext; slow = slow-\u003enext; } slow-\u003enext = slow-\u003enext-\u003enext; return pre-\u003enext; } }; ","date":"2022-11-23","objectID":"/19.remove-nth-node-from-end-of-list.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"19.删除链表的倒数第N个节点","uri":"/19.remove-nth-node-from-end-of-list.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description16.3sum-closest ","date":"2022-11-21","objectID":"/16.3sum-closest/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"16.3sum closest","uri":"/16.3sum-closest/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe violent solution: triple cycle, $\\Theta(n^3)$ We should notice that we don’t care the original index of array, so we can use two pointers to reduce the time complexity. First, we need sort the array, in outer loop, i iterates from 0 to nums.size() - 3, in inner loop, l and r come together from end to the middle. ","date":"2022-11-21","objectID":"/16.3sum-closest/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"16.3sum closest","uri":"/16.3sum-closest/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) \u003c abs(b - target)) return true; else return false; } public: int threeSumClosest(vector\u003cint\u003e \u0026nums, int target) { int res = 0; std::sort(nums.begin(), nums.end()); int sum = nums[0] + nums[1] + nums[2]; for (int i = 0; i \u003c nums.size() - 2; i++) { // skip the case repeated if (i != 0 \u0026\u0026 nums[i] == nums[i - 1]) continue; int l = i + 1, r = nums.size() - 1; while (l \u003c r) { if (nums[i] + nums[l] + nums[r] == target) return target; else if (nums[i] + nums[l] + nums[r] \u003c target) { if (mcmp(nums[i] + nums[l] + nums[r], sum, target)) sum = nums[i] + nums[l] + nums[r]; while (l \u003c nums.size() - 2 \u0026\u0026 nums[l] == nums[l + 1]) l++; l++; } else { if (mcmp(nums[i] + nums[l] + nums[r], sum, target)) sum = nums[i] + nums[l] + nums[r]; while (r \u003e 2 \u0026\u0026 nums[r] == nums[r - 1]) r--; r--; } } } return sum; } }; ","date":"2022-11-21","objectID":"/16.3sum-closest/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"16.3sum closest","uri":"/16.3sum-closest/#code"},{"categories":["leetcode"],"content":" 1 问题描述16.最接近的三数之和 ","date":"2022-11-21","objectID":"/16.3sum-closest.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"16.最接近的三数之和","uri":"/16.3sum-closest.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路暴力解法，三重循环，时间复杂度为$\\Theta(n^3)$; 注意到本题不关注数组中元素的初始索引，因此可以考虑利用双指针来降低时间复杂度: 首先将数组排序，最外层i从0遍历到nums.size() - 3，内层循环采用相向双指针l，r从两端向中间靠拢，并且要注意如何去重，(当然，此题可以不关注)。 ","date":"2022-11-21","objectID":"/16.3sum-closest.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"16.最接近的三数之和","uri":"/16.3sum-closest.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) \u003c abs(b - target)) return true; else return false; } public: int threeSumClosest(vector\u003cint\u003e \u0026nums, int target) { int res = 0; std::sort(nums.begin(), nums.end()); int sum = nums[0] + nums[1] + nums[2]; // 记录三数之和 for (int i = 0; i \u003c nums.size() - 2; i++) { // 跳过重复的 if (i != 0 \u0026\u0026 nums[i] == nums[i - 1]) continue; int l = i + 1, r = nums.size() - 1; while (l \u003c r) { if (nums[i] + nums[l] + nums[r] == target) return target; else if (nums[i] + nums[l] + nums[r] \u003c target) { if (mcmp(nums[i] + nums[l] + nums[r], sum, target)) sum = nums[i] + nums[l] + nums[r]; while (l \u003c nums.size() - 2 \u0026\u0026 nums[l] == nums[l + 1]) l++; l++; } else { if (mcmp(nums[i] + nums[l] + nums[r], sum, target)) sum = nums[i] + nums[l] + nums[r]; while (r \u003e 2 \u0026\u0026 nums[r] == nums[r - 1]) r--; r--; } } } return sum; } }; ","date":"2022-11-21","objectID":"/16.3sum-closest.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"16.最接近的三数之和","uri":"/16.3sum-closest.zh/#代码"},{"categories":["notes"],"content":" 1 定义快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $\\Theta(\\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $\\Theta(n)$ 的时间。 这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#定义"},{"categories":["notes"],"content":" 2 解释计算 $a$ 的 $n$ 次方表示将 $n$ 个 $a$ 乘在一起：$a^{n} = \\underbrace{a \\times a \\cdots \\times a}_{n\\text{ 个 a}}$。然而当 $a,n$ 太大的时侯，这种方法就不太适用了。不过我们知道：$a^{b+c} = a^b \\cdot a^c,,,a^{2b} = a^b \\cdot a^b = (a^b)^2$。二进制取幂的想法是，我们将取幂的任务按照指数的 二进制表示 来分割成更小的任务。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#解释"},{"categories":["notes"],"content":" 3 过程首先我们将 $n$ 表示为 2 进制，举一个例子吧： $$ 3^{13} = 3^{(1101)_2} = 3^8 \\cdot 3^4 \\cdot 3^1 $$ 因为 $n$ 有 $\\lfloor \\log_2 n \\rfloor + 1$ 个二进制位，因此当我们知道了 $a^1, a^2, a^4, a^8, \\dots, a^{2^{\\lfloor \\log_2 n \\rfloor}}$ 后，我们只用计算 $\\Theta(\\log n)$ 次乘法就可以计算出 $a^n$。 于是我们只需要知道一个快速的方法来计算上述 3 的 $2^k$ 次幂的序列。这个问题很简单，因为序列中（除第一个）任意一个元素就是其前一个元素的平方。举一个例子： $$ \\begin{align} 3^1 \u0026= 3 \\\\ 3^2 \u0026= \\left(3^1\\right)^2 = 3^2 = 9 \\\\ 3^4 \u0026= \\left(3^2\\right)^2 = 9^2 = 81 \\\\ 3^8 \u0026= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align} $$ 因此为了计算 $3^{13}$，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了： $$ 3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323 $$ 将上述过程说得形式化一些，如果把 $n$ 写作二进制为 $(n_tn_{t-1}\\cdots n_1n_0)_2$，那么有： $$ n = n_t2^t + n_{t-1}2^{t-1} + n_{t-2}2^{t-2} + \\cdots + n_12^1 + n_02^0 $$ 其中 $n_i\\in{0,1}$。那么就有 $$ \\begin{aligned} a^n \u0026 = (a^{n_t 2^t + \\cdots + n_0 2^0})\\\\\\\\ \u0026 = a^{n_0 2^0} \\times a^{n_1 2^1}\\times \\cdots \\times a^{n_t2^t} \\end{aligned} $$ 根据上式我们发现，原问题被我们转化成了形式相同的子问题的乘积，并且我们可以在常数时间内从 $2^i$ 项推出 $2^{i+1}$ 项。 这个算法的复杂度是 $\\Theta(\\log n)$ 的，我们计算了 $\\Theta(\\log n)$ 个 $2^k$ 次幂的数，然后花费 $\\Theta(\\log n)$ 的时间选择二进制为 1 对应的幂来相乘。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#过程"},{"categories":["notes"],"content":" 4 实现首先我们可以直接按照上述递归方法实现： cpp // C++ Version long long binpow(long long a, long long b) { if (b == 0) return 1; long long res = binpow(a, b / 2); if (b % 2) return res * res * a; else return res * res; } python # Python Version def binpow(a, b): if b == 0: return 1 res = binpow(a, b // 2) if (b % 2) == 1: return res * res * a else: return res * res 第二种实现方法是非递归式的。它在循环的过程中将二进制位为 1 时对应的幂累乘到答案中。尽管两者的理论复杂度是相同的，但第二种在实践过程中的速度是比第一种更快的，因为递归会花费一定的开销。 cpp // C++ Version long long binpow(long long a, long long b) { long long res = 1; while (b \u003e 0) { if (b \u0026 1) res = res * a; a = a * a; b \u003e\u003e= 1; } return res; } python # Python Version def binpow(a, b): res = 1 while b \u003e 0: if (b \u0026 1): res = res * a a = a * a b \u003e\u003e= 1 return res 模板：Luogu P1226 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:4:0","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#实现"},{"categories":["notes"],"content":" 5 应用","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:0","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#应用"},{"categories":["notes"],"content":" 5.1 模意义下取幂这是一个非常常见的应用，例如它可以用于计算模意义下的乘法逆元。 既然我们知道取模的运算不会干涉乘法运算，因此我们只需要在计算的过程中取模即可。 cpp // C++ Version long long binpow(long long a, long long b, long long m) { a %= m; long long res = 1; while (b \u003e 0) { if (b \u0026 1) res = res * a % m; a = a * a % m; b \u003e\u003e= 1; } return res; } python # Python Version def binpow(a, b, m): a = a % m res = 1 while b \u003e 0: if (b \u0026 1): res = res * a % m a = a * a % m b \u003e\u003e= 1 return res 注意：根据费马小定理，如果 $m$ 是一个质数，我们可以计算 $x^{n\\bmod (m-1)}$ 来加速算法过程。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:1","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#模意义下取幂"},{"categories":["notes"],"content":" 5.2 计算斐波那契数根据斐波那契数列的递推式 $F_n = F_{n-1} + F_{n-2}$，我们可以构建一个 $2\\times 2$ 的矩阵来表示从 $F_i,F_{i+1}$ 到 $F_{i+1},F_{i+2}$ 的变换。于是在计算这个矩阵的 $n$ 次幂的时侯，我们使用快速幂的思想，可以在 $\\Theta(\\log n)$ 的时间内计算出结果。对于更多的细节参见 斐波那契数列。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:2","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#计算斐波那契数"},{"categories":["notes"],"content":" 5.3 多次置换给你一个长度为 $n$ 的序列和一个置换，把这个序列置换 $k$ 次。 简单地把这个置换取 $k$ 次幂，然后把它应用到序列 $n$ 上即可。时间复杂度是 $O(n \\log k)$ 的。 注意：给这个置换建图，然后在每一个环上分别做 $k$ 次幂（事实上做一下 $k$ 对环长取模的运算即可）可以取得更高效的算法，达到 $O(n)$ 的复杂度。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:3","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#多次置换"},{"categories":["notes"],"content":" 5.4 加速几何中对点集的操作 5.4.1 引入 三维空间中，$n$ 个点 $p_i$，要求将 $m$ 个操作都应用于这些点。包含 3 种操作： 沿某个向量移动点的位置（Shift）。 按比例缩放这个点的坐标（Scale）。 绕某个坐标轴旋转（Rotate）。 还有一个特殊的操作，就是将一个操作序列重复 $k$ 次（Loop），这个序列中也可能有 Loop 操作（Loop 操作可以嵌套）。现在要求你在低于 $O(n \\cdot \\textit{length})$ 的时间内将这些变换应用到这个 $n$ 个点，其中 $\\textit{length}$ 表示把所有的 Loop 操作展开后的操作序列的长度。 5.4.2 解释让我们来观察一下这三种操作对坐标的影响： Shift 操作：将每一维的坐标分别加上一个常量； Scale 操作：把每一维坐标分别乘上一个常量； Rotate 操作：这个有点复杂，我们不打算深入探究，不过我们仍然可以使用一个线性组合来表示新的坐标。 可以看到，每一个变换可以被表示为对坐标的线性运算，因此，一个变换可以用一个 $4\\times 4$ 的矩阵来表示： $$ \\begin{bmatrix} a_{11} \u0026 a_ {12} \u0026 a_ {13} \u0026 a_ {14} \\\\ a_{21} \u0026 a_ {22} \u0026 a_ {23} \u0026 a_ {24} \\\\ a_{31} \u0026 a_ {32} \u0026 a_ {33} \u0026 a_ {34} \\\\ a_{41} \u0026 a_ {42} \u0026 a_ {43} \u0026 a_ {44} \\\\ \\end{bmatrix} $$ 使用这个矩阵就可以将一个坐标（向量）进行变换，得到新的坐标（向量）： $$ \\begin{bmatrix} a_{11} \u0026 a_ {12} \u0026 a_ {13} \u0026 a_ {14} \\\\ a_{21} \u0026 a_ {22} \u0026 a_ {23} \u0026 a_ {24} \\\\ a_{31} \u0026 a_ {32} \u0026 a_ {33} \u0026 a_ {34} \\\\ a_{41} \u0026 a_ {42} \u0026 a_ {43} \u0026 a_ {44} \\\\ \\end{bmatrix}\\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x' \\\\ y' \\\\ z' \\\\ 1 \\end{bmatrix} $$ 你可能会问，为什么一个三维坐标会多一个 1 出来？原因在于，如果没有这个多出来的 1，我们没法使用矩阵的线性变换来描述 Shift 操作。 5.4.3 过程接下来举一些简单的例子来说明我们的思路： Shift 操作：让 $x$ 坐标方向的位移为 $5$，$y$ 坐标的位移为 $7$，$z$ 坐标的位移为 $9$： $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 5 \\\\ 0 \u0026 1 \u0026 0 \u0026 7 \\\\ 0 \u0026 0 \u0026 1 \u0026 9 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ Scale 操作：把 $x$ 坐标拉伸 10 倍，$y,z$ 坐标拉伸 5 倍： $$ \\begin{bmatrix} 10 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 5 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 5 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ Rotate 操作：绕 $x$ 轴旋转 $\\theta$ 弧度，遵循右手定则（逆时针方向） $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos \\theta \u0026 \\sin \\theta \u0026 0 \\\\ 0 \u0026 -\\sin \\theta \u0026 \\cos \\theta \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ 现在，每一种操作都被表示为了一个矩阵，变换序列可以用矩阵的乘积来表示，而一个 Loop 操作相当于取一个矩阵的 k 次幂。这样可以用 $O(m \\log k)$ 计算出整个变换序列最终形成的矩阵。最后将它应用到 $n$ 个点上，总复杂度 $O(n + m \\log k)$。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:4","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#加速几何中对点集的操作"},{"categories":["notes"],"content":" 5.4 加速几何中对点集的操作 5.4.1 引入 三维空间中，$n$ 个点 $p_i$，要求将 $m$ 个操作都应用于这些点。包含 3 种操作： 沿某个向量移动点的位置（Shift）。 按比例缩放这个点的坐标（Scale）。 绕某个坐标轴旋转（Rotate）。 还有一个特殊的操作，就是将一个操作序列重复 $k$ 次（Loop），这个序列中也可能有 Loop 操作（Loop 操作可以嵌套）。现在要求你在低于 $O(n \\cdot \\textit{length})$ 的时间内将这些变换应用到这个 $n$ 个点，其中 $\\textit{length}$ 表示把所有的 Loop 操作展开后的操作序列的长度。 5.4.2 解释让我们来观察一下这三种操作对坐标的影响： Shift 操作：将每一维的坐标分别加上一个常量； Scale 操作：把每一维坐标分别乘上一个常量； Rotate 操作：这个有点复杂，我们不打算深入探究，不过我们仍然可以使用一个线性组合来表示新的坐标。 可以看到，每一个变换可以被表示为对坐标的线性运算，因此，一个变换可以用一个 $4\\times 4$ 的矩阵来表示： $$ \\begin{bmatrix} a_{11} \u0026 a_ {12} \u0026 a_ {13} \u0026 a_ {14} \\\\ a_{21} \u0026 a_ {22} \u0026 a_ {23} \u0026 a_ {24} \\\\ a_{31} \u0026 a_ {32} \u0026 a_ {33} \u0026 a_ {34} \\\\ a_{41} \u0026 a_ {42} \u0026 a_ {43} \u0026 a_ {44} \\\\ \\end{bmatrix} $$ 使用这个矩阵就可以将一个坐标（向量）进行变换，得到新的坐标（向量）： $$ \\begin{bmatrix} a_{11} \u0026 a_ {12} \u0026 a_ {13} \u0026 a_ {14} \\\\ a_{21} \u0026 a_ {22} \u0026 a_ {23} \u0026 a_ {24} \\\\ a_{31} \u0026 a_ {32} \u0026 a_ {33} \u0026 a_ {34} \\\\ a_{41} \u0026 a_ {42} \u0026 a_ {43} \u0026 a_ {44} \\\\ \\end{bmatrix}\\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x' \\\\ y' \\\\ z' \\\\ 1 \\end{bmatrix} $$ 你可能会问，为什么一个三维坐标会多一个 1 出来？原因在于，如果没有这个多出来的 1，我们没法使用矩阵的线性变换来描述 Shift 操作。 5.4.3 过程接下来举一些简单的例子来说明我们的思路： Shift 操作：让 $x$ 坐标方向的位移为 $5$，$y$ 坐标的位移为 $7$，$z$ 坐标的位移为 $9$： $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 5 \\\\ 0 \u0026 1 \u0026 0 \u0026 7 \\\\ 0 \u0026 0 \u0026 1 \u0026 9 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ Scale 操作：把 $x$ 坐标拉伸 10 倍，$y,z$ 坐标拉伸 5 倍： $$ \\begin{bmatrix} 10 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 5 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 5 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ Rotate 操作：绕 $x$ 轴旋转 $\\theta$ 弧度，遵循右手定则（逆时针方向） $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos \\theta \u0026 \\sin \\theta \u0026 0 \\\\ 0 \u0026 -\\sin \\theta \u0026 \\cos \\theta \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ 现在，每一种操作都被表示为了一个矩阵，变换序列可以用矩阵的乘积来表示，而一个 Loop 操作相当于取一个矩阵的 k 次幂。这样可以用 $O(m \\log k)$ 计算出整个变换序列最终形成的矩阵。最后将它应用到 $n$ 个点上，总复杂度 $O(n + m \\log k)$。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:4","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#引入"},{"categories":["notes"],"content":" 5.4 加速几何中对点集的操作 5.4.1 引入 三维空间中，$n$ 个点 $p_i$，要求将 $m$ 个操作都应用于这些点。包含 3 种操作： 沿某个向量移动点的位置（Shift）。 按比例缩放这个点的坐标（Scale）。 绕某个坐标轴旋转（Rotate）。 还有一个特殊的操作，就是将一个操作序列重复 $k$ 次（Loop），这个序列中也可能有 Loop 操作（Loop 操作可以嵌套）。现在要求你在低于 $O(n \\cdot \\textit{length})$ 的时间内将这些变换应用到这个 $n$ 个点，其中 $\\textit{length}$ 表示把所有的 Loop 操作展开后的操作序列的长度。 5.4.2 解释让我们来观察一下这三种操作对坐标的影响： Shift 操作：将每一维的坐标分别加上一个常量； Scale 操作：把每一维坐标分别乘上一个常量； Rotate 操作：这个有点复杂，我们不打算深入探究，不过我们仍然可以使用一个线性组合来表示新的坐标。 可以看到，每一个变换可以被表示为对坐标的线性运算，因此，一个变换可以用一个 $4\\times 4$ 的矩阵来表示： $$ \\begin{bmatrix} a_{11} \u0026 a_ {12} \u0026 a_ {13} \u0026 a_ {14} \\\\ a_{21} \u0026 a_ {22} \u0026 a_ {23} \u0026 a_ {24} \\\\ a_{31} \u0026 a_ {32} \u0026 a_ {33} \u0026 a_ {34} \\\\ a_{41} \u0026 a_ {42} \u0026 a_ {43} \u0026 a_ {44} \\\\ \\end{bmatrix} $$ 使用这个矩阵就可以将一个坐标（向量）进行变换，得到新的坐标（向量）： $$ \\begin{bmatrix} a_{11} \u0026 a_ {12} \u0026 a_ {13} \u0026 a_ {14} \\\\ a_{21} \u0026 a_ {22} \u0026 a_ {23} \u0026 a_ {24} \\\\ a_{31} \u0026 a_ {32} \u0026 a_ {33} \u0026 a_ {34} \\\\ a_{41} \u0026 a_ {42} \u0026 a_ {43} \u0026 a_ {44} \\\\ \\end{bmatrix}\\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x' \\\\ y' \\\\ z' \\\\ 1 \\end{bmatrix} $$ 你可能会问，为什么一个三维坐标会多一个 1 出来？原因在于，如果没有这个多出来的 1，我们没法使用矩阵的线性变换来描述 Shift 操作。 5.4.3 过程接下来举一些简单的例子来说明我们的思路： Shift 操作：让 $x$ 坐标方向的位移为 $5$，$y$ 坐标的位移为 $7$，$z$ 坐标的位移为 $9$： $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 5 \\\\ 0 \u0026 1 \u0026 0 \u0026 7 \\\\ 0 \u0026 0 \u0026 1 \u0026 9 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ Scale 操作：把 $x$ 坐标拉伸 10 倍，$y,z$ 坐标拉伸 5 倍： $$ \\begin{bmatrix} 10 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 5 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 5 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ Rotate 操作：绕 $x$ 轴旋转 $\\theta$ 弧度，遵循右手定则（逆时针方向） $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos \\theta \u0026 \\sin \\theta \u0026 0 \\\\ 0 \u0026 -\\sin \\theta \u0026 \\cos \\theta \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ 现在，每一种操作都被表示为了一个矩阵，变换序列可以用矩阵的乘积来表示，而一个 Loop 操作相当于取一个矩阵的 k 次幂。这样可以用 $O(m \\log k)$ 计算出整个变换序列最终形成的矩阵。最后将它应用到 $n$ 个点上，总复杂度 $O(n + m \\log k)$。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:4","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#解释-1"},{"categories":["notes"],"content":" 5.4 加速几何中对点集的操作 5.4.1 引入 三维空间中，$n$ 个点 $p_i$，要求将 $m$ 个操作都应用于这些点。包含 3 种操作： 沿某个向量移动点的位置（Shift）。 按比例缩放这个点的坐标（Scale）。 绕某个坐标轴旋转（Rotate）。 还有一个特殊的操作，就是将一个操作序列重复 $k$ 次（Loop），这个序列中也可能有 Loop 操作（Loop 操作可以嵌套）。现在要求你在低于 $O(n \\cdot \\textit{length})$ 的时间内将这些变换应用到这个 $n$ 个点，其中 $\\textit{length}$ 表示把所有的 Loop 操作展开后的操作序列的长度。 5.4.2 解释让我们来观察一下这三种操作对坐标的影响： Shift 操作：将每一维的坐标分别加上一个常量； Scale 操作：把每一维坐标分别乘上一个常量； Rotate 操作：这个有点复杂，我们不打算深入探究，不过我们仍然可以使用一个线性组合来表示新的坐标。 可以看到，每一个变换可以被表示为对坐标的线性运算，因此，一个变换可以用一个 $4\\times 4$ 的矩阵来表示： $$ \\begin{bmatrix} a_{11} \u0026 a_ {12} \u0026 a_ {13} \u0026 a_ {14} \\\\ a_{21} \u0026 a_ {22} \u0026 a_ {23} \u0026 a_ {24} \\\\ a_{31} \u0026 a_ {32} \u0026 a_ {33} \u0026 a_ {34} \\\\ a_{41} \u0026 a_ {42} \u0026 a_ {43} \u0026 a_ {44} \\\\ \\end{bmatrix} $$ 使用这个矩阵就可以将一个坐标（向量）进行变换，得到新的坐标（向量）： $$ \\begin{bmatrix} a_{11} \u0026 a_ {12} \u0026 a_ {13} \u0026 a_ {14} \\\\ a_{21} \u0026 a_ {22} \u0026 a_ {23} \u0026 a_ {24} \\\\ a_{31} \u0026 a_ {32} \u0026 a_ {33} \u0026 a_ {34} \\\\ a_{41} \u0026 a_ {42} \u0026 a_ {43} \u0026 a_ {44} \\\\ \\end{bmatrix}\\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x' \\\\ y' \\\\ z' \\\\ 1 \\end{bmatrix} $$ 你可能会问，为什么一个三维坐标会多一个 1 出来？原因在于，如果没有这个多出来的 1，我们没法使用矩阵的线性变换来描述 Shift 操作。 5.4.3 过程接下来举一些简单的例子来说明我们的思路： Shift 操作：让 $x$ 坐标方向的位移为 $5$，$y$ 坐标的位移为 $7$，$z$ 坐标的位移为 $9$： $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 5 \\\\ 0 \u0026 1 \u0026 0 \u0026 7 \\\\ 0 \u0026 0 \u0026 1 \u0026 9 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ Scale 操作：把 $x$ 坐标拉伸 10 倍，$y,z$ 坐标拉伸 5 倍： $$ \\begin{bmatrix} 10 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 5 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 5 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ Rotate 操作：绕 $x$ 轴旋转 $\\theta$ 弧度，遵循右手定则（逆时针方向） $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos \\theta \u0026 \\sin \\theta \u0026 0 \\\\ 0 \u0026 -\\sin \\theta \u0026 \\cos \\theta \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$ 现在，每一种操作都被表示为了一个矩阵，变换序列可以用矩阵的乘积来表示，而一个 Loop 操作相当于取一个矩阵的 k 次幂。这样可以用 $O(m \\log k)$ 计算出整个变换序列最终形成的矩阵。最后将它应用到 $n$ 个点上，总复杂度 $O(n + m \\log k)$。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:4","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#过程-1"},{"categories":["notes"],"content":" 5.5 定长路径计数给一个有向图（边权为 1），求任意两点 $u,v$ 间从 $u$ 到 $v$，长度为 $k$ 的路径的条数。 我们把该图的邻接矩阵 M 取 k 次幂，那么 $M_{i,j}$ 就表示从 $i$ 到 $j$ 长度为 $k$ 的路径的数目。该算法的复杂度是 $O(n^3 \\log k)$。有关该算法的细节请参见 矩阵 页面。 ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:5","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#定长路径计数"},{"categories":["notes"],"content":" 5.6 模意义下大整数乘法 计算 $a\\times b\\bmod m,,,a,b\\le m\\le 10^{18}$。 与二进制取幂的思想一样，这次我们将其中的一个乘数表示为若干个 2 的整数次幂的和的形式。因为在对一个数做乘 2 并取模的运算的时侯，我们可以转化为加减操作防止溢出。这样仍可以在 $O (\\log_2 m)$ 的时内解决问题。递归方法如下： $$ a \\cdot b = \\begin{cases} 0 \u0026\\text{if }a = 0 \\\\\\\\ 2 \\cdot \\frac{a}{2} \\cdot b \u0026\\text{if }a \u003e 0 \\text{ and }a \\text{ even} \\\\\\\\ 2 \\cdot \\frac{a-1}{2} \\cdot b + b \u0026\\text{if }a \u003e 0 \\text{ and }a \\text{ odd} \\end{cases} $$ 5.6.1 快速乘但是 $O(\\log_2 m)$ 的“龟速乘”还是太慢了，这在很多对常数要求比较高的算法比如 Miller_Rabin 和 Pollard-Rho 中，就显得不够用了。所以我们要介绍一种可以处理模数在 long long 范围内、不需要使用黑科技 __int128 的、复杂度为 $O(1)$ 的“快速乘”。 我们发现： $$ a\\times b\\bmod m=a\\times b-\\left\\lfloor \\dfrac{ab}m \\right\\rfloor\\times m $$ 我们巧妙运用 unsigned long long 的自然溢出： $$ a\\times b\\bmod m=a\\times b-\\left\\lfloor \\dfrac{ab}m \\right\\rfloor\\times m=\\left(a\\times b-\\left\\lfloor \\dfrac{ab}m \\right\\rfloor\\times m\\right)\\bmod 2^{64} $$ 于是在算出 $\\left\\lfloor\\dfrac{ab}m\\right\\rfloor$ 后，两边的乘法和中间的减法部分都可以使用 unsigned long long 直接计算，现在我们只需要解决如何计算 $\\left\\lfloor\\dfrac {ab}m\\right\\rfloor$。 我们考虑先使用 long double 算出 $\\dfrac am$ 再乘上 $b$。 既然使用了 long double，就无疑会有精度误差。极端情况就是第一个有效数字（二进制下）在小数点后一位。在 x86-64 机器下，long double 将被解释成 $80$ 位拓展小数（即符号为 $1$ 位，指数为 $15$ 位，尾数为 $64$ 位），所以 long double 最多能精确表示的有效位数为 $64$[^note1]。所以 $\\dfrac am$ 最差从第 $65$ 位开始出错，误差范围为 $\\left(-2^{-64},2^{64}\\right)$。乘上 $b$ 这个 $64$ 位整数，误差范围为 $(-0.5,0.5)$，再加上 $0.5$ 误差范围为 $(0,1)$，取整后误差范围位 ${0,1}$。于是乘上 $-m$ 后，误差范围变成 ${0,-m}$，我们需要判断这两种情况。 因为 $m$ 在 long long 范围内，所以如果计算结果 $r$ 在 $[0,m)$ 时，直接返回 $r$，否则返回 $r+m$，当然你也可以直接返回 $(r+m)\\bmod m$。 代码实现如下： cpp long long binmul(long long a, long long b, long long m) { unsigned long long c = (unsigned long long)a * b - (unsigned long long)((long double)a / m * b + 0.5L) * m; if (c \u003c m) return c; return c + m; } ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:6","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#模意义下大整数乘法"},{"categories":["notes"],"content":" 5.6 模意义下大整数乘法 计算 $a\\times b\\bmod m,,,a,b\\le m\\le 10^{18}$。 与二进制取幂的思想一样，这次我们将其中的一个乘数表示为若干个 2 的整数次幂的和的形式。因为在对一个数做乘 2 并取模的运算的时侯，我们可以转化为加减操作防止溢出。这样仍可以在 $O (\\log_2 m)$ 的时内解决问题。递归方法如下： $$ a \\cdot b = \\begin{cases} 0 \u0026\\text{if }a = 0 \\\\\\\\ 2 \\cdot \\frac{a}{2} \\cdot b \u0026\\text{if }a \u003e 0 \\text{ and }a \\text{ even} \\\\\\\\ 2 \\cdot \\frac{a-1}{2} \\cdot b + b \u0026\\text{if }a \u003e 0 \\text{ and }a \\text{ odd} \\end{cases} $$ 5.6.1 快速乘但是 $O(\\log_2 m)$ 的“龟速乘”还是太慢了，这在很多对常数要求比较高的算法比如 Miller_Rabin 和 Pollard-Rho 中，就显得不够用了。所以我们要介绍一种可以处理模数在 long long 范围内、不需要使用黑科技 __int128 的、复杂度为 $O(1)$ 的“快速乘”。 我们发现： $$ a\\times b\\bmod m=a\\times b-\\left\\lfloor \\dfrac{ab}m \\right\\rfloor\\times m $$ 我们巧妙运用 unsigned long long 的自然溢出： $$ a\\times b\\bmod m=a\\times b-\\left\\lfloor \\dfrac{ab}m \\right\\rfloor\\times m=\\left(a\\times b-\\left\\lfloor \\dfrac{ab}m \\right\\rfloor\\times m\\right)\\bmod 2^{64} $$ 于是在算出 $\\left\\lfloor\\dfrac{ab}m\\right\\rfloor$ 后，两边的乘法和中间的减法部分都可以使用 unsigned long long 直接计算，现在我们只需要解决如何计算 $\\left\\lfloor\\dfrac {ab}m\\right\\rfloor$。 我们考虑先使用 long double 算出 $\\dfrac am$ 再乘上 $b$。 既然使用了 long double，就无疑会有精度误差。极端情况就是第一个有效数字（二进制下）在小数点后一位。在 x86-64 机器下，long double 将被解释成 $80$ 位拓展小数（即符号为 $1$ 位，指数为 $15$ 位，尾数为 $64$ 位），所以 long double 最多能精确表示的有效位数为 $64$[^note1]。所以 $\\dfrac am$ 最差从第 $65$ 位开始出错，误差范围为 $\\left(-2^{-64},2^{64}\\right)$。乘上 $b$ 这个 $64$ 位整数，误差范围为 $(-0.5,0.5)$，再加上 $0.5$ 误差范围为 $(0,1)$，取整后误差范围位 ${0,1}$。于是乘上 $-m$ 后，误差范围变成 ${0,-m}$，我们需要判断这两种情况。 因为 $m$ 在 long long 范围内，所以如果计算结果 $r$ 在 $[0,m)$ 时，直接返回 $r$，否则返回 $r+m$，当然你也可以直接返回 $(r+m)\\bmod m$。 代码实现如下： cpp long long binmul(long long a, long long b, long long m) { unsigned long long c = (unsigned long long)a * b - (unsigned long long)((long double)a / m * b + 0.5L) * m; if (c \u003c m) return c; return c + m; } ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:6","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#快速乘"},{"categories":["notes"],"content":" 5.7 高精度快速幂请先学习 高精度 例题【NOIP2003 普及组改编·麦森数】（原题在此）\" 题目大意：从文件中输入 P（1000\u003cP\u003c3100000），计算 $2^P−1$ 的最后 100 位数字（用十进制高精度 数表示），不足 100 位时高位补 0。 代码实现如下： cpp --8\u003c-- \"docs/math/code/quick-pow/quick-pow_1.cpp\" ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:7","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#高精度快速幂"},{"categories":["notes"],"content":" 5.8 同一底数与同一模数的预处理快速幂在同一底数与同一模数的条件下，可以利用分块思想，用一定的时间（一般是 $O(\\sqrt n)$）预处理后用 $O(1)$ 的时间回答一次幂询问。 5.8.1 过程 选定一个数 $s$，预处理出 $a^0$ 到 $a^s$ 与 $a^{0\\cdot s}$ 到 $a^{\\lceil\\frac ps\\rceil\\cdot s}$ 的值并存在一个（或两个）数组里； 对于每一次询问 $a^b\\bmod p$，将 $b$ 拆分成 $\\left\\lfloor\\dfrac bs\\right\\rfloor\\cdot s+b\\bmod s$，则 $a^b=a^{\\lfloor\\frac bs\\rfloor\\cdot s}\\times a^{b\\bmod s}$，可以 $O(1)$ 求出答案。 关于这个数 $s$ 的选择，我们一般选择 $\\sqrt p$ 或者一个大小适当的 $2$ 的次幂（选择 $\\sqrt p$ 可以使预处理较优，选择 $2$ 的次幂可以使用位运算优化/简化计算）。 note \" 参考代码\" cpp int pow1[65536], pow2[65536]; void preproc(int a, int mod) { pow1[0] = pow2[0] = 1; for (int i = 1; i \u003c 65536; i++) pow1[i] = 1LL * pow1[i - 1] * a % mod; int pow65536 = 1LL * pow1[65535] * a % mod; for (int i = 1; i \u003c 65536; i++) pow2[i] = 1LL * pow2[i - 1] * pow65536 % mod; } int query(int pows) { return 1LL * pow1[pows \u0026 65535] * pow2[pows \u003e\u003e 16]; } ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:8","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#同一底数与同一模数的预处理快速幂"},{"categories":["notes"],"content":" 5.8 同一底数与同一模数的预处理快速幂在同一底数与同一模数的条件下，可以利用分块思想，用一定的时间（一般是 $O(\\sqrt n)$）预处理后用 $O(1)$ 的时间回答一次幂询问。 5.8.1 过程 选定一个数 $s$，预处理出 $a^0$ 到 $a^s$ 与 $a^{0\\cdot s}$ 到 $a^{\\lceil\\frac ps\\rceil\\cdot s}$ 的值并存在一个（或两个）数组里； 对于每一次询问 $a^b\\bmod p$，将 $b$ 拆分成 $\\left\\lfloor\\dfrac bs\\right\\rfloor\\cdot s+b\\bmod s$，则 $a^b=a^{\\lfloor\\frac bs\\rfloor\\cdot s}\\times a^{b\\bmod s}$，可以 $O(1)$ 求出答案。 关于这个数 $s$ 的选择，我们一般选择 $\\sqrt p$ 或者一个大小适当的 $2$ 的次幂（选择 $\\sqrt p$ 可以使预处理较优，选择 $2$ 的次幂可以使用位运算优化/简化计算）。 note \" 参考代码\" cpp int pow1[65536], pow2[65536]; void preproc(int a, int mod) { pow1[0] = pow2[0] = 1; for (int i = 1; i \u003c 65536; i++) pow1[i] = 1LL * pow1[i - 1] * a % mod; int pow65536 = 1LL * pow1[65535] * a % mod; for (int i = 1; i \u003c 65536; i++) pow2[i] = 1LL * pow2[i - 1] * pow65536 % mod; } int query(int pows) { return 1LL * pow1[pows \u0026 65535] * pow2[pows \u003e\u003e 16]; } ","date":"2022-11-19","objectID":"/exponentiating-by-squaring.zh/:5:8","series":null,"tags":["data structure and algorithms"],"title":"快速幂与快速乘","uri":"/exponentiating-by-squaring.zh/#过程-2"},{"categories":["leetcode"],"content":" 1 Description11.container-with-most-water ","date":"2022-11-19","objectID":"/11.container-with-most-water/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"11.container with most water","uri":"/11.container-with-most-water/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe violent solution of this problem has a time complexity of $O(n^2)$, to reduce the time complexity, we consider two-pointers. So, we need determine how left pointer l and right pointer r will meet each other: if (height[l] \u003e= height[r]), the capacity depends on height[r]. If l++, the capacity will become smaller, so we should r--. if (height[l] \u003c height[r]), the capacity depends on height[l]. If r--, the capacity will become smaller, so we should l++. ","date":"2022-11-19","objectID":"/11.container-with-most-water/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"11.container with most water","uri":"/11.container-with-most-water/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: int maxArea(vector\u003cint\u003e\u0026 height) { int l = 0, r = height.size() - 1; int res = 0; while (l \u003c r) { if (height[l] \u003e= height[r]) { res = max(res, (r - l) * height[r]); r--; // l++ will make capacity smaller } else { res = max(res, (r - l) * height[l]); l++; // r-- will make capacity smaller } } return res; } }; ","date":"2022-11-19","objectID":"/11.container-with-most-water/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"11.container with most water","uri":"/11.container-with-most-water/#code"},{"categories":["leetcode"],"content":" 1 问题描述11.盛最多水的容器 ","date":"2022-11-19","objectID":"/11.container-with-most-water.zh/:1:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"11.盛最多水的容器","uri":"/11.container-with-most-water.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题暴力解法，时间复杂度为$O(n^2)$(会超时，没试过)，为了降低时间复杂度，考虑使用双指针。 那么，本题需要考虑的就是左指针l和右指针r如何向中间靠拢： if (height[l] \u003e= height[r])，说明容器容积是由height[r]来决定的，这时候，l向中间考虑，只可能会缩小容积，因此应该r--; if (height[l] \u003c height[r])，说明容器容积由height[l]来决定，这时候，r向中间靠拢，只会缩小容积，因此应该l++; ","date":"2022-11-19","objectID":"/11.container-with-most-water.zh/:2:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"11.盛最多水的容器","uri":"/11.container-with-most-water.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: int maxArea(vector\u003cint\u003e\u0026 height) { int l = 0, r = height.size() - 1; int res = 0; while (l \u003c r) { if (height[l] \u003e= height[r]) { res = max(res, (r - l) * height[r]); r--; // 因为此时，增加l只可能缩小res，所以减少r } else { res = max(res, (r - l) * height[l]); l++; // height[l] \u003c height[r], 此时减少r也只会缩小res，所以增加l } } return res; } }; ","date":"2022-11-19","objectID":"/11.container-with-most-water.zh/:3:0","series":null,"tags":["data structure and algorithms","two pointers"],"title":"11.盛最多水的容器","uri":"/11.container-with-most-water.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description42.trapping-rain-water ","date":"2022-11-17","objectID":"/42.trapping-rain-water/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"42.trapping rain water","uri":"/42.trapping-rain-water/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can use monotone stack The capacity of unit cosist of height[stk.top()] is (min(height[r], height[l]) - height[stk.top()]) * (l - r - 1), l is next element below the top of the stack, since height[l] \u003e= height[stk.top()] r is the index of first column which height[r] \u003e= height[stk.top()]. The result is the sum. ","date":"2022-11-17","objectID":"/42.trapping-rain-water/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"42.trapping rain water","uri":"/42.trapping-rain-water/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp ```cpp #include \u003cstack\u003e #include \u003cvector\u003e using std::stack; using std::vector; class Solution { public: int trap(vector\u003cint\u003e \u0026height) { stack\u003cint\u003e stk; stk.push(0); int res = 0; for (int i = 1; i \u003c height.size(); i++) { while (!stk.empty() \u0026\u0026 height[i] \u003e height[stk.top()]) { int mid = stk.top(); stk.pop(); if (!stk.empty()) { int h = min(height[i], height[stk.top()]) - height[mid]; int w = i - stk.top() - 1; res += h * w; } } stk.push(i); } return res; } }; ","date":"2022-11-17","objectID":"/42.trapping-rain-water/:3:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"42.trapping rain water","uri":"/42.trapping-rain-water/#code"},{"categories":["leetcode"],"content":" 1 问题描述42.接雨水 ","date":"2022-11-17","objectID":"/42.trapping-rain-water.zh/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"42.接雨水","uri":"/42.trapping-rain-water.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题考虑使用单调栈(monotone stack)，栈顶到栈底依次递增。 由height[stk.top()]存放雨水的单元，其计算方式为(min(height[r], height[l]) - height[stk.top()]) * (l - r - 1)，其中l即栈顶的下一个元素，r则是第一个高度大于height[stk.top()]的柱子的索引。 结果为所有柱子能存放的雨水的累加。 ","date":"2022-11-17","objectID":"/42.trapping-rain-water.zh/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"42.接雨水","uri":"/42.trapping-rain-water.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cstack\u003e #include \u003cvector\u003e using std::stack; using std::vector; class Solution { public: int trap(vector\u003cint\u003e \u0026height) { stack\u003cint\u003e stk; stk.push(0); int res = 0; for (int i = 1; i \u003c height.size(); i++) { while (!stk.empty() \u0026\u0026 height[i] \u003e height[stk.top()]) { int mid = stk.top(); stk.pop(); if (!stk.empty()) { int h = min(height[i], height[stk.top()]) - height[mid]; int w = i - stk.top() - 1; res += h * w; } } stk.push(i); } return res; } }; ","date":"2022-11-17","objectID":"/42.trapping-rain-water.zh/:3:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"42.接雨水","uri":"/42.trapping-rain-water.zh/#代码"},{"categories":["tutorial"],"content":" 1 让 Vercel 部署 GitHub 项目成功时，不再自动发送邮件通知在github项目根目录下新建vercel.json，内容为: json { \"github\": { \"silent\": true } } ","date":"2022-11-16","objectID":"/vercel_scilence.zh/:1:0","series":null,"tags":["tips","geek"],"title":"Vercel 部署 Hugo","uri":"/vercel_scilence.zh/#让-vercel-部署-github-项目成功时不再自动发送邮件通知"},{"categories":["tutorial"],"content":" 2 Vercel 环境变量设置Vercel 默认的 Hugo 版本可能很低，需要通过环境变量指定 Hugo 版本，如下： ","date":"2022-11-16","objectID":"/vercel_scilence.zh/:2:0","series":null,"tags":["tips","geek"],"title":"Vercel 部署 Hugo","uri":"/vercel_scilence.zh/#vercel-环境变量设置"},{"categories":["tutorial"],"content":" 1 配置语言环境我在安装debian的时候，有个地方选择了HK，因此使用locale命令查看当前的区域相关设置时，显示为: 其中:LANG为默认的区域设置，该变量的值会覆盖所有未设置的LC_*变量的值; 要修改为en_US，首先执行sudo dpkg-reconfigure locales，然后选中en_US.UTF-8，取消en_HK那个，取消inherit的那个，还可以选中zh_CN.UTF-8，这样就启用了en_US.UTF-8和zh_CN.UTF-8; 由于我的桌面环境为KDE PLasma，其语言设置会覆盖locale.conf的设置，执行vim ~/.config/plasma-localerc，修改该文件为: toml [Formats] LANG=en_US.UTF-8 LC_ADDRESS=en_US.UTF-8 LC_MEASUREMENT=en_US.UTF-8 LC_MONETARY=en_US.UTF-8 LC_NAME=en_US.UTF-8 LC_NUMERIC=en_US.UTF-8 LC_TELEPHONE=en_US.UTF-8 LC_TIME=en_US.UTF-8 [Translations] LANGUAGE=en_US:C:zh_CN 其中LANGUAGE为备用语言，很多软件并未将其英文locale设置为en或en_US，而是使用默认locale C。如果在LANGUAGE中将非英文locale设置到English之后，例如LANGUAGE=en_US:en:es_ES，那么即使英语字符存在，应用程序可能会选择使用后备locale，解决方法是强制在英语locale后面设置C，例如 LANGUAGE=en_US:en:C:es_ES。 ","date":"2022-11-12","objectID":"/debian_testing.zh/:1:0","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#配置语言环境"},{"categories":["tutorial"],"content":" 2 fcitx-rime安装fcitx-rime sudo apt install fcitx-rime 安装小鹤双拼 sudo apt-get install librime-data-double-pinyin 将小鹤双拼官方网盘，3.1-挂接–音形码，小鹤音形鼠须管for macos里的default.custom.yaml复制到~/.config/fcitx/rime，并修改为: yaml patch: menu: page_size: 8 schema_list: - schema: flypy # 添加小鹤音形 - schema: double_pinyin_flypy - schema: luna_pinyin_simp key_binder/bindings: - when: paging accept: bracketleft send: Page_Up - when: has_menu accept: bracketright send: Page_Down - when: has_menu accept: minus send: Page_Up - when: has_menu accept: equal send: Page_Down 启动fcitx，按Ctrl+Space切换为fcitx，Ctrl+`切换选择输入方案。 ","date":"2022-11-12","objectID":"/debian_testing.zh/:2:0","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#fcitx-rime"},{"categories":["tutorial"],"content":" 3 设置双击打开文件Dolphin默认单击打开文件或者文件夹，点击System setting-\u003eWorkspace behavior-\u003eGeneral behavior-\u003eclicking files or folders修改为(select them) ","date":"2022-11-12","objectID":"/debian_testing.zh/:3:0","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#设置双击打开文件"},{"categories":["tutorial"],"content":" 4 Grub","date":"2022-11-12","objectID":"/debian_testing.zh/:4:0","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#grub"},{"categories":["tutorial"],"content":" 4.1 Grub找不到Windows启动项这是因为OS_PROBER没有默认被启用，要启用OS_PROBEER，执行sudo vim /etc/default/grub，插入一行GRUB_DISABLE_OS_PROBER=\"false\"，然后执行sudo grub-mkconfig -o /boot/grub/grub.cfg ","date":"2022-11-12","objectID":"/debian_testing.zh/:4:1","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#grub找不到windows启动项"},{"categories":["tutorial"],"content":" 4.2 Grub修改默认启动项为windows执行sudo vim /etc/default/grub，将GRUB_DEFAULT=0修改为GRUB_DEFAULT=2，然后执行sudo update-grub ","date":"2022-11-12","objectID":"/debian_testing.zh/:4:2","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#grub修改默认启动项为windows"},{"categories":["tutorial"],"content":" 5 Wayland下分数缩放模糊的问题System settings-\u003eDisplay and monitor-\u003eDisplay configuration-\u003elegacy application(x11)设置为Apply scaling themselves ","date":"2022-11-12","objectID":"/debian_testing.zh/:5:0","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#wayland下分数缩放模糊的问题"},{"categories":["tutorial"],"content":" 6 为自己下载的app创建快捷方式","date":"2022-11-12","objectID":"/debian_testing.zh/:6:0","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#为自己下载的app创建快捷方式"},{"categories":["tutorial"],"content":" 6.1 Jetbrains系以Idea为例，打开Idea，settings-\u003ecreate desktop entry ","date":"2022-11-12","objectID":"/debian_testing.zh/:6:1","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#jetbrains系"},{"categories":["tutorial"],"content":" 6.2 需要自行创建的以logseq为例，touch Logseq.desktop，sudo vim Logseq.desktop，编辑其中内容为 yaml #!/usr/bin/env xdg-open [Desktop Entry] Name=Logseq Comment=Logseq Exec=~/Desktop/Program/Logseq/Logseq.AppImage # AppImage所在目录 Icon=~/Desktop/Program/Logseq/logseq.png # 图片所在目录 Terminal=false Type=Application Categories=Math; # 对应Categories为Science\u0026Math ","date":"2022-11-12","objectID":"/debian_testing.zh/:6:2","series":null,"tags":["tips","geek","debian"],"title":"安装 Debian bookworm","uri":"/debian_testing.zh/#需要自行创建的"},{"categories":["leetcode"],"content":" 1 问题描述503.下一个更大元素II ","date":"2022-11-11","objectID":"/503.next-greater-element-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"503.下一个更大元素II","uri":"/503.next-greater-element-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路相比496.下一个更大元素I，在遍历数组上有所区别，如果i \u003e= nums.size()，用j = i - nums.size();来代替i，因此i的取值范围是[0, 2 * nums.size())。 ","date":"2022-11-11","objectID":"/503.next-greater-element-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"503.下一个更大元素II","uri":"/503.next-greater-element-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e nextGreaterElements(vector\u003cint\u003e \u0026nums) { vector\u003cint\u003e res(nums.size(), -1); stack\u003cint\u003e stk; stk.push(0); int j = 0; for (int i = 1; i \u003c 2 * nums.size(); i++) { if (i \u003e= nums.size()) { j = i - nums.size(); while (!stk.empty() \u0026\u0026 nums[j] \u003e nums[stk.top()]) { res[stk.top()] = nums[j]; stk.pop(); } stk.push(j); } else { while (!stk.empty() \u0026\u0026 nums[i] \u003e nums[stk.top()]) { res[stk.top()] = nums[i]; stk.pop(); } stk.push(i); } } return res; } }; ","date":"2022-11-11","objectID":"/503.next-greater-element-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"503.下一个更大元素II","uri":"/503.next-greater-element-ii.zh/#代码"},{"categories":["notes"],"content":" 1 Description496.next-greater-element-i ","date":"2022-11-11","objectID":"/496.next-greater-element-i/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"496.next greater element i","uri":"/496.next-greater-element-i/#description"},{"categories":["notes"],"content":" 2 SolutionWe can use monotone stack to traverse nums2, and use unordered_map to store the element in nums1 and corresponding result. ","date":"2022-11-11","objectID":"/496.next-greater-element-i/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"496.next greater element i","uri":"/496.next-greater-element-i/#solution"},{"categories":["notes"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e nextGreaterElement(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { unordered_map\u003cint, int\u003e umap; stack\u003cint\u003e stk; for (int i = 0; i \u003c nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i \u003c nums2.size(); i++) { while (!stk.empty() \u0026\u0026 nums2[i] \u003e nums2[stk.top()]) { if (umap.find(nums2[stk.top()]) != umap.end()) { umap[nums2[stk.top()]] = nums2[i]; } stk.pop(); } stk.push(i); } vector\u003cint\u003e res(nums1.size(), -1); for (int i = 0; i \u003c nums1.size(); i++) { res[i] = umap[nums1[i]]; } return res; } }; ","date":"2022-11-11","objectID":"/496.next-greater-element-i/:3:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"496.next greater element i","uri":"/496.next-greater-element-i/#code"},{"categories":["notes"],"content":" 1 问题描述496.下一个更大元素I ","date":"2022-11-11","objectID":"/496.next-greater-element-i.zh/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"496.下一个更大元素I","uri":"/496.next-greater-element-i.zh/#问题描述"},{"categories":["notes"],"content":" 2 解题思路本题利用单调栈(monotone stack)来遍历nums2，并且利用unordered_map来存储nums1中元素和对应的结果。 ","date":"2022-11-11","objectID":"/496.next-greater-element-i.zh/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"496.下一个更大元素I","uri":"/496.next-greater-element-i.zh/#解题思路"},{"categories":["notes"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e nextGreaterElement(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { unordered_map\u003cint, int\u003e umap; stack\u003cint\u003e stk; for (int i = 0; i \u003c nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i \u003c nums2.size(); i++) { while (!stk.empty() \u0026\u0026 nums2[i] \u003e nums2[stk.top()]) { if (umap.find(nums2[stk.top()]) != umap.end()) { umap[nums2[stk.top()]] = nums2[i]; } stk.pop(); } stk.push(i); } vector\u003cint\u003e res(nums1.size(), -1); for (int i = 0; i \u003c nums1.size(); i++) { res[i] = umap[nums1[i]]; } return res; } }; ","date":"2022-11-11","objectID":"/496.next-greater-element-i.zh/:3:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"496.下一个更大元素I","uri":"/496.next-greater-element-i.zh/#代码"},{"categories":["notes"],"content":" 1 创建python虚拟环境安装python指定环境 conda create -n zwyb python=3.9 安装python指定环境的时候安装相应的包 conda create -n zwyb python=3.9 pandas 进入指定的环境 conda activate zwyb 退出当前环境 conda deactive zwyb 显示所有环境 conda env list 删除指定的环境 conda env remove -n zwyb ","date":"2022-11-11","objectID":"/miniconda.zh/:1:0","series":null,"tags":["python"],"title":"miniconda 基础教程","uri":"/miniconda.zh/#创建python虚拟环境"},{"categories":["notes"],"content":" 2 更换清华源vim 编辑~/.condarc，将其中内容修改为 text channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 更换pip源，执行 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2022-11-11","objectID":"/miniconda.zh/:2:0","series":null,"tags":["python"],"title":"miniconda 基础教程","uri":"/miniconda.zh/#更换清华源"},{"categories":["notes"],"content":" 3 关闭启动终端后自动进入conda环境conda config --set auto_activate_base false ","date":"2022-11-11","objectID":"/miniconda.zh/:3:0","series":null,"tags":["python"],"title":"miniconda 基础教程","uri":"/miniconda.zh/#关闭启动终端后自动进入conda环境"},{"categories":["notes"],"content":" 1 Description","date":"2022-11-11","objectID":"/01-pack-problem.zh/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/01-pack-problem.zh/#description"},{"categories":["notes"],"content":" 1.1 briefMonotone stack is a stack whose elements(from top to bottom) are (strictly) monotonically increasing or decreasing. Monotone increasing stack: the element which is smaller than the element in the top can be pushed into stack, else we will pop the element in the top, until the stack is empty or the element is smaller than the element in the top, then we push the element into the stack. This data structure is usually used for problems to find first element that is larger than certain element. Monotone decreasing stack: is the opposite of a monotonically increasing stack, used for problems to find first element that is smaller than certain element. ","date":"2022-11-11","objectID":"/01-pack-problem.zh/:1:1","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/01-pack-problem.zh/#brief"},{"categories":["notes"],"content":" 1.2 how to judgeMonotonically increasing/decreasing stacks are generally determined by the order in which they exit the stack ","date":"2022-11-11","objectID":"/01-pack-problem.zh/:1:2","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/01-pack-problem.zh/#how-to-judge"},{"categories":["notes"],"content":" 1.3 the sentry tipsSometimes, if all the elements in the array is needed, that is: all the elements in the stack will be popped. It’s very likely that the border will not be passed because it is not considered. So we can use the sentinel method. For example, adding a -1 at the end of {1, 3, 4, 5, 2, 9, 6} as a sentinel, it becomes {1, 3, 4, 5, 2, 9, 6, -1}, a trick that simplifies the code logic. ","date":"2022-11-11","objectID":"/01-pack-problem.zh/:1:3","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/01-pack-problem.zh/#the-sentry-tips"},{"categories":["notes"],"content":" 2 Examples","date":"2022-11-11","objectID":"/01-pack-problem.zh/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/01-pack-problem.zh/#examples"},{"categories":["notes"],"content":" 3 代码 cpp #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; const int N = 1010; // 体积不超过 1000，物品件数也不超过 1000 int main() { int n, m; // n 为物品数量，m 为背包体积 cin \u003e\u003e n \u003e\u003e m; int dp[N][N] = {0}; int v[N] = {0}; // 体积 int w[N] = {0}; // 价值 for (int i = 1; i \u003c=n; i++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; if (j \u003e= v[i]) // 当前总体积肯定不能小于 v[i]，如果小于的话，第 i 个物品不能放 dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } // int res = 0; // for (int j = 1; j \u003c=m; j++) { // res = max(res, dp[n][j]); // 不需要遍历，直接输出 dp[n][m] 即可 // } cout \u003c\u003c dp[n][m] \u003c\u003c endl; return 0; } ","date":"2022-11-11","objectID":"/01-pack-problem.zh/:3:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/01-pack-problem.zh/#代码"},{"categories":["notes"],"content":" 4 优化分析上面的代码，实际上dp[i][j]递推时只会用到dp[i - 1][j]，而不会用到dp[i - 2][j], dp[i - 3][j]等，因此dp数组实际上只需要一维即可，索引为当前总体积。 那么，是否可以直接写成 cpp for (int i = 1; i \u003c n; i++) { for (int j = 1; j \u003c= m; j++) if (j \u003e= v[i]) // 这里的 max 实际上是 // max(dp[i][j], dp[i][j - v[i]] + w[i]) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } 不可以！原因已在上面的代码里的注释中给出，应该是max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])才对。 正确的写法应该是： cpp for (int i = 1; i \u003c= n; i++) { for (int j = m; j \u003e= v[i]; j--) // 因为 dp[j], dp[j - v[i]] 只在上一次的 i 循环中才被赋值了， // 所以这里用的实际上是 dp[i - 1][j - v[i]] dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } 如果dp[0] = 0， dp[i] = -INF，那么状态只能从dp[0]转移过来，可以求解总体积恰为$V$的情况。 优化后的完整代码： cpp #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; const int N = 1010; // 体积不超过 1000，物品件数也不超过 1000 int main() { int n, m; // n 为物品数量，m 为背包体积 cin \u003e\u003e n \u003e\u003e m; int dp[N] = {0}; int v[N] = {0}; // 体积 int w[N] = {0}; // 价值 for (int i = 1; i \u003c=n; i++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= n; i++) { for (int j = m; j \u003e= v[i]; j--) { // 当前总体积肯定不能小于 v[i]，如果小于的话，第 i 个物品不能放 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } // int res = 0; // for (int j = 1; j \u003c=m; j++) { // res = max(res, dp[n][j]); // 不需要遍历，直接输出 dp[n][m] 即可 // } cout \u003c\u003c dp[m] \u003c\u003c endl; return 0; } ","date":"2022-11-11","objectID":"/01-pack-problem.zh/:4:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/01-pack-problem.zh/#优化"},{"categories":["notes"],"content":" 5 例题 416.分割等和子集 416.分割等和子集 - 题解 1049.最后一块石头的重量 II 1049.最后一块石头的重量 II-题解 494.目标和 494.目标和 - 题解 474.一和零 474.一和零 - 题解 ","date":"2022-11-11","objectID":"/01-pack-problem.zh/:5:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/01-pack-problem.zh/#例题"},{"categories":["notes"],"content":" 1 Description","date":"2022-11-11","objectID":"/monotone-stack/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/monotone-stack/#description"},{"categories":["notes"],"content":" 1.1 briefMonotone stack is a stack whose elements(from top to bottom) are (strictly) monotonically increasing or decreasing. Monotone increasing stack: the element which is smaller than the element in the top can be pushed into stack, else we will pop the element in the top, until the stack is empty or the element is smaller than the element in the top, then we push the element into the stack. This data structure is usually used for problems to find first element that is larger than certain element. Monotone decreasing stack: is the opposite of a monotonically increasing stack, used for problems to find first element that is smaller than certain element. ","date":"2022-11-11","objectID":"/monotone-stack/:1:1","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/monotone-stack/#brief"},{"categories":["notes"],"content":" 1.2 how to judgeMonotonically increasing/decreasing stacks are generally determined by the order in which they exit the stack ","date":"2022-11-11","objectID":"/monotone-stack/:1:2","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/monotone-stack/#how-to-judge"},{"categories":["notes"],"content":" 1.3 the sentry tipsSometimes, if all the elements in the array is needed, that is: all the elements in the stack will be popped. It’s very likely that the border will not be passed because it is not considered. So we can use the sentinel method. For example, adding a -1 at the end of {1, 3, 4, 5, 2, 9, 6} as a sentinel, it becomes {1, 3, 4, 5, 2, 9, 6, -1}, a trick that simplifies the code logic. ","date":"2022-11-11","objectID":"/monotone-stack/:1:3","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/monotone-stack/#the-sentry-tips"},{"categories":["notes"],"content":" 2 Examples","date":"2022-11-11","objectID":"/monotone-stack/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"monotone stack","uri":"/monotone-stack/#examples"},{"categories":["notes"],"content":" 1 问题描述","date":"2022-11-11","objectID":"/monotone-stack.zh/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"单调栈","uri":"/monotone-stack.zh/#问题描述"},{"categories":["notes"],"content":" 1.1 简述单调栈(monotone stack)是指栈内元素(栈顶到栈底)都是(严格)单调递增或者递减的栈。 单调递增栈(从栈顶到栈底)：只有比栈顶小的才能入栈，否把栈顶元素弹出，直到栈为空或者或者待处理的元素小于栈顶元素，将元素入栈，适用于求解第一个大于某元素的数的情况； 单调递减栈，与递增栈相反，适用于求解第一个小于某位置元素的数； ","date":"2022-11-11","objectID":"/monotone-stack.zh/:1:1","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"单调栈","uri":"/monotone-stack.zh/#简述"},{"categories":["notes"],"content":" 1.2 判断方法单调递增/递减栈一般根据出栈后顺序来决定，例如栈内顺序[1, 2, 6]，出栈后顺序[6, 2, 1]，这就是单调递减栈。 ","date":"2022-11-11","objectID":"/monotone-stack.zh/:1:2","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"单调栈","uri":"/monotone-stack.zh/#判断方法"},{"categories":["notes"],"content":" 1.3 哨兵技巧对于有些时候，如果会用到数组的全部元素，即栈中的元素最后都要出栈，那么很可能因为没有考虑边界而无法通过。所以我们可以使用哨兵法。 例如在{1, 3, 4, 5, 2, 9, 6}末尾添加一个-1作为哨兵，变成了 {1, 3, 4, 5, 2, 9, 6, -1}，这种技巧可以简化代码逻辑。 ","date":"2022-11-11","objectID":"/monotone-stack.zh/:1:3","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"单调栈","uri":"/monotone-stack.zh/#哨兵技巧"},{"categories":["notes"],"content":" 2 例题","date":"2022-11-11","objectID":"/monotone-stack.zh/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"单调栈","uri":"/monotone-stack.zh/#例题"},{"categories":["leetcode"],"content":" 1 Description739.dail-temperatures ","date":"2022-11-11","objectID":"/739.daily-temperatures/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"739.daily temperatures","uri":"/739.daily-temperatures/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can consider monotone stack. If the stack is empty or the element to deal with is smaller than the element in the top of the stack, we can push the element to the stack, else we should pop the element in the top of the stack until the stack is empty or the element is smaller than the element in the top of the stack. It’s convenient to push the index i into the stack. ","date":"2022-11-11","objectID":"/739.daily-temperatures/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"739.daily temperatures","uri":"/739.daily-temperatures/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: vector\u003cint\u003e dailyTemperatures(vector\u003cint\u003e \u0026temperatures) { vector\u003cint\u003e res(temperatures.size(), 0); stack\u003cint\u003e st; st.push(0); for (int i = 1; i \u003c temperatures.size(); i++) { int j = i; // if (!st.empty()) { while (!st.empty() \u0026\u0026 temperatures[i] \u003e temperatures[st.top()]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); // } } return res; } }; ","date":"2022-11-11","objectID":"/739.daily-temperatures/:3:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"739.daily temperatures","uri":"/739.daily-temperatures/#code"},{"categories":["leetcode"],"content":" 1 问题描述739.每日温度 ","date":"2022-11-11","objectID":"/739.daily-temperatures.zh/:1:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"739.每日温度","uri":"/739.daily-temperatures.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路考虑利用单调栈(monotone stack)来进行处理，如果栈为空或者要入栈的元素小于栈顶元素，那么该元素入栈，否则弹出栈顶元素直到栈为空，或者要入栈的元素小于栈顶元素，再将该元素入栈。 这里应该将数组索引i入栈会比较方便。 ","date":"2022-11-11","objectID":"/739.daily-temperatures.zh/:2:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"739.每日温度","uri":"/739.daily-temperatures.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: vector\u003cint\u003e dailyTemperatures(vector\u003cint\u003e \u0026temperatures) { vector\u003cint\u003e res(temperatures.size(), 0); stack\u003cint\u003e st; st.push(0); for (int i = 1; i \u003c temperatures.size(); i++) { int j = i; // if (!st.empty()) { while (!st.empty() \u0026\u0026 temperatures[i] \u003e temperatures[st.top()]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); // } } return res; } }; ","date":"2022-11-11","objectID":"/739.daily-temperatures.zh/:3:0","series":null,"tags":["data structure and algorithms","monotone stack"],"title":"739.每日温度","uri":"/739.daily-temperatures.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description738.monotone-increasing-digits ","date":"2022-11-07","objectID":"/738.monotone-increasing-digits/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"738.monotone increasing digits","uri":"/738.monotone-increasing-digits/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirst, we need change the number to a vector\u003cint\u003e dec, for example:1234 to {1, 2, 3, 4}. Then we can traverse the vector, until dec[i] \u003e dec[i + 1], then set dec[i + n] = 9(n \u003e= 1). If dec[i] == dec[i - 1] == ... == dec[j], then dec[j]--, set others as 9, else dec[i]--; ","date":"2022-11-07","objectID":"/738.monotone-increasing-digits/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"738.monotone increasing digits","uri":"/738.monotone-increasing-digits/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { private: void vec_dec(int n, vector\u003cint\u003e \u0026res) { while (n != 0) { res.push_back(n % 10); n = n / 10; } } int ten(int i) { int res = 1; while (i != 0) { i--; res *= 10; } return res; } public: int monotoneIncreasingDigits(int n) { vector\u003cint\u003e dec; vec_dec(n, dec); std::reverse(dec.begin(), dec.end()); if (dec.size() \u003c= 1) return n; for (int i = 0; i \u003c dec.size() - 1; i++) { if (dec[i] \u003e dec[i + 1]) { // dec[i] = dec[i + 1]; int j = i + 1; int k = i - 1; while (j \u003c dec.size()) dec[j++] = 9; while (i \u003e 0 \u0026\u0026 dec[i] == dec[i - 1]) dec[i--] = 9; if ((i \u003e 0 \u0026\u0026 dec[i] \u003e dec[i - 1]) || i == 0) dec[i] = dec[i] - 1; break; } } int sum = 0; for (int i = 0; i \u003c dec.size(); i++) { sum += dec[i] * ten(dec.size() - i - 1); } return sum; } }; ","date":"2022-11-07","objectID":"/738.monotone-increasing-digits/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"738.monotone increasing digits","uri":"/738.monotone-increasing-digits/#code"},{"categories":["leetcode"],"content":" 1 问题描述738.单调递增的数字 ","date":"2022-11-07","objectID":"/738.monotone-increasing-digits.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"738.单调递增的数字","uri":"/738.monotone-increasing-digits.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路将该数字的每一位数字变成数组dec\u003cint\u003e的一部分，然后依次遍历，直到dec[i] \u003e dec[i + 1]，然后将dec[i + 1]及以后的数字都变成9，如果dec[i] == dec[i - 1] == ··· == dec[j]，就将dec[j]--，其余全设置为9。 ","date":"2022-11-07","objectID":"/738.monotone-increasing-digits.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"738.单调递增的数字","uri":"/738.monotone-increasing-digits.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { private: void vec_dec(int n, vector\u003cint\u003e \u0026res) { while (n != 0) { res.push_back(n % 10); n = n / 10; } } int ten(int i) { int res = 1; while (i != 0) { i--; res *= 10; } return res; } public: int monotoneIncreasingDigits(int n) { vector\u003cint\u003e dec; vec_dec(n, dec); std::reverse(dec.begin(), dec.end()); if (dec.size() \u003c= 1) return n; for (int i = 0; i \u003c dec.size() - 1; i++) { if (dec[i] \u003e dec[i + 1]) { // dec[i] = dec[i + 1]; int j = i + 1; int k = i - 1; while (j \u003c dec.size()) dec[j++] = 9; while (i \u003e 0 \u0026\u0026 dec[i] == dec[i - 1]) dec[i--] = 9; if ((i \u003e 0 \u0026\u0026 dec[i] \u003e dec[i - 1]) || i == 0) dec[i] = dec[i] - 1; break; } } int sum = 0; for (int i = 0; i \u003c dec.size(); i++) { sum += dec[i] * ten(dec.size() - i - 1); } return sum; } }; ","date":"2022-11-07","objectID":"/738.monotone-increasing-digits.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"738.单调递增的数字","uri":"/738.monotone-increasing-digits.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description56.merge-intervals ","date":"2022-11-06","objectID":"/56.merge-intervals/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"56.merge intervals","uri":"/56.merge-intervals/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe solution is similar to 452.minimum-number-of-arrows-to-burst-balloons, if there is common space, change the res.back()[1] to intervals[i][1], while intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); if there is not common space, res.push_back(). ","date":"2022-11-06","objectID":"/56.merge-intervals/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"56.merge intervals","uri":"/56.merge-intervals/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { private: static bool cmp(vector\u003cint\u003e \u0026a, vector\u003cint\u003e \u0026b) { if (a[0] == b[0]) return a[1] \u003c b[1]; return a[0] \u003c b[0]; } public: vector\u003cvector\u003cint\u003e\u003e merge(vector\u003cvector\u003cint\u003e\u003e \u0026intervals) { std::sort(intervals.begin(), intervals.end()); vector\u003cvector\u003cint\u003e\u003e res; res.push_back(intervals[0]); for (int i = 1; i \u003c intervals.size(); i++) { if (intervals[i - 1][1] \u003c intervals[i][0]) res.push_back(intervals[i]); else { intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); res[res.size() - 1][1] = intervals[i][1]; } } return res; } }; ","date":"2022-11-06","objectID":"/56.merge-intervals/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"56.merge intervals","uri":"/56.merge-intervals/#code"},{"categories":["leetcode"],"content":" 1 问题描述56.合并区间 ","date":"2022-11-06","objectID":"/56.merge-intervals.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"56.合并区间","uri":"/56.merge-intervals.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路思路与452.用最少的箭引爆气球，只不过这里intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])，如果存在重叠，修改res最后一个元素的右端点值；如果不存在重叠，就往res里添加一个新的区间。 ","date":"2022-11-06","objectID":"/56.merge-intervals.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"56.合并区间","uri":"/56.merge-intervals.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { private: static bool cmp(vector\u003cint\u003e \u0026a, vector\u003cint\u003e \u0026b) { if (a[0] == b[0]) return a[1] \u003c b[1]; return a[0] \u003c b[0]; } public: vector\u003cvector\u003cint\u003e\u003e merge(vector\u003cvector\u003cint\u003e\u003e \u0026intervals) { std::sort(intervals.begin(), intervals.end()); vector\u003cvector\u003cint\u003e\u003e res; res.push_back(intervals[0]); for (int i = 1; i \u003c intervals.size(); i++) { if (intervals[i - 1][1] \u003c intervals[i][0]) res.push_back(intervals[i]); else { intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); res[res.size() - 1][1] = intervals[i][1]; } } return res; } }; ","date":"2022-11-06","objectID":"/56.merge-intervals.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"56.合并区间","uri":"/56.merge-intervals.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description763.partition-label ","date":"2022-11-05","objectID":"/763.partition-labels/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.partition labels","uri":"/763.partition-labels/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2022-11-05","objectID":"/763.partition-labels/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.partition labels","uri":"/763.partition-labels/#solution"},{"categories":["leetcode"],"content":" 2.1 solution 1First, we need traverse the string, record the maximum index of each letter in the string. Then we need declare a variable right to record the maximum index of letter traversed. When the maximum index is the same as current index, we can partition the string. ","date":"2022-11-05","objectID":"/763.partition-labels/:2:1","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.partition labels","uri":"/763.partition-labels/#solution-1"},{"categories":["leetcode"],"content":" 2.2 solution 2First, we need traverse the string, record the number of occurrence of each letter, and record whether the letter occur. Then, we need traverse the string again, if it’s the first time the letter occurs, push(s[i]);, if it is the last time the letter occurs, pop();. If the stack is empty, we can partition the string. ","date":"2022-11-05","objectID":"/763.partition-labels/:2:2","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.partition labels","uri":"/763.partition-labels/#solution-2"},{"categories":["leetcode"],"content":" 3 Code","date":"2022-11-05","objectID":"/763.partition-labels/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.partition labels","uri":"/763.partition-labels/#code"},{"categories":["leetcode"],"content":" 3.1 code 1 cpp class Solution { public: vector\u003cint\u003e partitionLabels(string S) { int hash[27] = {0}; for (int i = 0; i \u003c S.size(); i++) { hash[S[i] - 'a'] = i; } vector\u003cint\u003e result; int left = 0; int right = 0; for (int i = 0; i \u003c S.size(); i++) { right = max(right, hash[S[i] - 'a']); if (i == right) { result.push_back(right - left + 1); left = i + 1; } } return result; } }; ","date":"2022-11-05","objectID":"/763.partition-labels/:3:1","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.partition labels","uri":"/763.partition-labels/#code-1"},{"categories":["leetcode"],"content":" 3.2 code 2 cpp class Solution { public: vector\u003cint\u003e partitionLabels(string s) { vector\u003cint\u003e res; int arr[26] = {0}; int arr_bool[26] = {0}; int len = 0; stack\u003cchar\u003e st; for (int i = 0; i \u003c s.size(); i++) { arr[s[i] - 'a']++; arr_bool[s[i] - 'a'] = 1; } for (int i = 0; i \u003c s.size(); i++) { len++; arr[s[i] - 'a']--; if (arr_bool[s[i] - 'a'] != 0) { st.push(s[i]); arr_bool[s[i] - 'a'] = 0; } if (arr[s[i] - 'a'] == 0) st.pop(); if (st.empty()) { res.push_back(len); len = 0; } } return res; } }; ","date":"2022-11-05","objectID":"/763.partition-labels/:3:2","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.partition labels","uri":"/763.partition-labels/#code-2"},{"categories":["leetcode"],"content":" 1 问题描述763.划分字母区间 ","date":"2022-11-05","objectID":"/763.partition-labels.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.划分字母区间","uri":"/763.partition-labels.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2022-11-05","objectID":"/763.partition-labels.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.划分字母区间","uri":"/763.partition-labels.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 思路一首先遍历一遍数组，记录每个字母在字符串中出现的最远位置。 声明一个变量right，用来记录已经遍历的字符中，最远的位置，当遍历到的位置与记录的最远位置重叠时，就说明可以划分数组了。 ","date":"2022-11-05","objectID":"/763.partition-labels.zh/:2:1","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.划分字母区间","uri":"/763.partition-labels.zh/#思路一"},{"categories":["leetcode"],"content":" 2.2 思路二首先遍历一遍数组，记录每个字母出现的次数，并记录是否出现； 再遍历一次数组，当第一次碰到该字符时，该字符入栈，最后一次碰到该字符时，弹出栈顶的字符，栈空时，说明可以分割了。 ","date":"2022-11-05","objectID":"/763.partition-labels.zh/:2:2","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.划分字母区间","uri":"/763.partition-labels.zh/#思路二"},{"categories":["leetcode"],"content":" 3 代码","date":"2022-11-05","objectID":"/763.partition-labels.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.划分字母区间","uri":"/763.partition-labels.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 代码一 cpp class Solution { public: vector\u003cint\u003e partitionLabels(string S) { int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置 for (int i = 0; i \u003c S.size(); i++) { // 统计每一个字符最后出现的位置 hash[S[i] - 'a'] = i; } vector\u003cint\u003e result; int left = 0; int right = 0; for (int i = 0; i \u003c S.size(); i++) { right = max(right, hash[S[i] - 'a']); // 找到字符出现的最远边界 if (i == right) { result.push_back(right - left + 1); left = i + 1; } } return result; } }; ","date":"2022-11-05","objectID":"/763.partition-labels.zh/:3:1","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.划分字母区间","uri":"/763.partition-labels.zh/#代码一"},{"categories":["leetcode"],"content":" 3.2 代码二 cpp class Solution { public: vector\u003cint\u003e partitionLabels(string s) { vector\u003cint\u003e res; int arr[26] = {0}; int arr_bool[26] = {0}; int len = 0; stack\u003cchar\u003e st; for (int i = 0; i \u003c s.size(); i++) { arr[s[i] - 'a']++; arr_bool[s[i] - 'a'] = 1; } for (int i = 0; i \u003c s.size(); i++) { len++; arr[s[i] - 'a']--; if (arr_bool[s[i] - 'a'] != 0) { st.push(s[i]); arr_bool[s[i] - 'a'] = 0; } if (arr[s[i] - 'a'] == 0) st.pop(); if (st.empty()) { res.push_back(len); len = 0; } } return res; } }; ","date":"2022-11-05","objectID":"/763.partition-labels.zh/:3:2","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"763.划分字母区间","uri":"/763.partition-labels.zh/#代码二"},{"categories":["tutorial"],"content":" 1 部署博客到vercel","date":"2022-11-04","objectID":"/create_blog_with_papermod.zh/:1:0","series":null,"tags":["geek","hugo","tips"],"title":"基于 hugo 和 papermod 主题搭建自己的博客","uri":"/create_blog_with_papermod.zh/#部署博客到vercel"},{"categories":["tutorial"],"content":" 1.1 FreeNom申请域名首先，梯子最好选择美国的，并且freenom选择地址时最好与ip所在州可以对应得上； 进入FreeNom，输入zwyb.tk，然后点击检查可用性，这里要记得输入后缀，能避免点击现在获取显示不可用的问题。 如下图所示: ","date":"2022-11-04","objectID":"/create_blog_with_papermod.zh/:1:1","series":null,"tags":["geek","hugo","tips"],"title":"基于 hugo 和 papermod 主题搭建自己的博客","uri":"/create_blog_with_papermod.zh/#freenom申请域名"},{"categories":["tutorial"],"content":" 1.2 Cloudfare管理域名cloudfare添加站点zwyyy456.ml，然后添加DNS record，内容如下图所示： 下一步，进入freenom, Services-\u003eMy Domains-\u003eManage Domain-\u003eManagement Tools-\u003eNameservers，选择Use custom nameservers(enter blow)，填入cloudfare生成的nameservers。注意cloudfare的SSL/TLS策略必须是Full。 ","date":"2022-11-04","objectID":"/create_blog_with_papermod.zh/:1:2","series":null,"tags":["geek","hugo","tips"],"title":"基于 hugo 和 papermod 主题搭建自己的博客","uri":"/create_blog_with_papermod.zh/#cloudfare管理域名"},{"categories":["tutorial"],"content":" 1.3 vercel部署博客和绑定域名将整个项目，如papermod这个文件夹，作为一个git仓库上传到github，然后vercel创建新项目，选择continue with github，就能将对应的仓库导入到vercel，部署的时候注意添加Environment Variables text HUGO_VERSION 0.93.0 项目部署好之后，点击该项目，Settings-\u003eDomains，添加之前FreeNom申请的域名，DNS record在上一步cloudfare管理域名那里已经添加过了。 ","date":"2022-11-04","objectID":"/create_blog_with_papermod.zh/:1:3","series":null,"tags":["geek","hugo","tips"],"title":"基于 hugo 和 papermod 主题搭建自己的博客","uri":"/create_blog_with_papermod.zh/#vercel部署博客和绑定域名"},{"categories":["tutorial"],"content":" 1 前言Hugo 是用 Go 语言写的静态网站生成器（Static Site Generator）。可以把 Markdown 文件转化成 HTML 文件，因此有很多人利用 Hugo 来搭建自己的博客网站。 ","date":"2022-11-04","objectID":"/create_blog_with_hugo.zh/:1:0","series":null,"tags":["geek","hugo","tips"],"title":"基于 Hugo 搭建自己的博客","uri":"/create_blog_with_hugo.zh/#前言"},{"categories":["tutorial"],"content":" 2 安装 HugoMac 上，执行 brew install hugo，Win 上执行 scoop install hugo 即可。使用 hugo new site test-coder 即可创建博客，该命令会在当前目录创建一个名为 test-coder 的子目录，该目录就是创建的博客的源文件仓库。其中，test-coder 可以自行修改为你希望的名称。该目录中的内容如下： txt test-coder on  main [+?] ❯ ls archetypes assets content data hugo.toml i18n layouts public resources static themes archetypes：存放 front matter 模板，hugo 命令创建 .md 文件时会根据该模板来创建； content：存放博客内容； layouts：存放定义为网站的样式，写在 layouts 目录下的样式文件会覆盖安装的主题中的 layouts 目录下的同名样式文件； static：存放静态文件，static 目录中的内容会在编译时会被移动到 public 目录，而本地的 public 目录对应着网站的根目录； public：存放 hugo 生成的静态网页； themes：存放主题文件； config.toml：网站配置文件，也可能是 hugo.toml。 ","date":"2022-11-04","objectID":"/create_blog_with_hugo.zh/:2:0","series":null,"tags":["geek","hugo","tips"],"title":"基于 Hugo 搭建自己的博客","uri":"/create_blog_with_hugo.zh/#安装-hugo"},{"categories":["tutorial"],"content":" 3 安装 Hugo 主题这里我选择的是简洁纯粹的 hugo-coder 主题。 在 test-coder 目录下执行 git submodule add https://github.com/luizdepra/hugo-coder.git themes/coder 即可安装主题。 安装好主题之后，则需要根据自己的需求修改 hugo.toml，可以参考 hugo-coder 作者给出的 示例，注意 baseURL 处要修改成自己的博客网址。 toml baseURL = \"http://blog.zwyyy456.tech\" # 改为自己的博客域名 title = \"zwyyy456's blog\" theme = \"coder\" # 注意你选择的主题名 languageCode = \"en\" defaultContentLanguage = \"en\" paginate = 6 enableEmoji = true [services] [services.disqus] [markup.highlight] noClasses = false [params] author = \"zwyyy456\" # license = '\u003ca rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\"\u003eCC BY-SA-4.0\u003c/a\u003e' description = \"笔记与杂谈\" keywords = \"tech, blog, life\" info = [\"IT\", \"Running\"] avatarURL = \"img/Quirrel.jpg\" #gravatar = \"john.doe@example.com\" dateFormat = \"January 2, 2006\" since = 2022 # Git Commit in Footer, uncomment the line below to enable it commit = \"https://github.com/luizdepra/hugo-coder/tree/\" # Right To Left, shift content direction for languages such as Arabic rtl = false colorScheme = \"auto\" # Hide the toggle button, along with the associated vertical divider hideColorSchemeToggle = false # Series see also post count maxSeeAlsoItems = 5 # Custom CSS customCSS = [] # Custom SCSS, file path is relative to Hugo's asset folder (default: {your project root}/assets) customSCSS = [] # Custom JS customJS = [] # Custom remote JS files customRemoteJS = [] [taxonomies] category = \"categories\" series = \"series\" tag = \"tags\" author = \"authors\" [[params.social]] name = \"Github\" icon = \"fa-brands fa-github fa-2x\" weight = 1 url = \"https://github.com/zwyyy456/\" [[params.social]] name = \"Twitter\" icon = \"fa-brands fa-x-twitter fa-2x\" weight = 3 url = \"https://twitter.com/zwyyy456/\" [[params.social]] name = \"LinkedIn\" icon = \"fa-brands fa-linkedin fa-2x\" weight = 4 url = \"https://www.linkedin.com/in/zwyyy456/\" [[params.social]] name = \"RSS\" icon = \"fa-solid fa-rss fa-2x\" weight = 6 url = \"https://myhugosite.com/index.xml\" rel = \"alternate\" type = \"application/rss+xml\" [languages.en] languageName = \":us:\" [[languages.en.menu.main]] name = \"Search\" weight = 1 url = \"search/\" [[languages.en.menu.main]] name = \"About\" weight = 2 url = \"about/\" [[languages.en.menu.main]] name = \"Blog\" weight = 3 url = \"posts/\" [[languages.en.menu.main]] name = \"Tech\" weight = 4 url = \"posts/tech\" [[languages.en.menu.main]] name = \"Fun\" weight = 5 url = \"posts/blog\" [languages.zh] languageName = \":cn:\" title = \"翼仔的博客\" [languages.zh.params] author = \"翼仔\" info = \"何以解忧\" description = \"唯有杜康\" keywords = \"tech, blog, life\" [[languages.zh.menu.main]] name = \"搜索\" weight = 1 url = \"search/\" [[languages.zh.menu.main]] name = \"关于\" weight = 2 url = \"about/\" [[languages.zh.menu.main]] name = \"文章\" weight = 3 url = \"posts/blog\" [[languages.zh.menu.main]] name = \"技术\" weight = 4 url = \"posts/tech\" [[languages.zh.menu.main]] name = \"折腾\" weight = 5 url = \"posts/blog\" 通过 hugo new posts/tech/xxx.md 会在 content/posts/tech 目录下根据 archetypes 中的 front matter 模板生成 xxx.md 文件，默认语言是 en，该博客对应的网址是 https://blog.zwyyy456.tech/posts/tech/xxx/，如果执行 hugo new posts/tech/xxx.zh.md，则会生成 zh-cn 版的博客，对应网址为 https://blog.zwyyy456.tech/zh/posts/tech/xxx，点击如下图的旗帜图标，可以切换博客的语言版本（假如有的话）。 对 PaperMod 主题，是由 archetypes 中的 default.md 作为 font matter 模板，然而 hugo-coder 主题是 posts.md。模板内容如下： yaml --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} lastmod: {{ .Date }} #更新时间 authors: [\"zwyyy456\"] #作者 categories: [\"\"] tags: [\"\"] description: \"\" #描述 weight: # 输入 1 可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \"\" draft: false # 是否为草稿 comments: false #是否展示评论 showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: false #顶部显示当前路径 --- 注意这里 comments 暂时不能设置为 true，否则会编译失败，留待后续解决，毕竟我也不需要评论系统。 ","date":"2022-11-04","objectID":"/create_blog_with_hugo.zh/:3:0","series":null,"tags":["geek","hugo","tips"],"title":"基于 Hugo 搭建自己的博客","uri":"/create_blog_with_hugo.zh/#安装-hugo-主题"},{"categories":["tutorial"],"content":" 4 目录设置在 content/posts 目录下，我创建了 tech、blog、read 这四个目录，对于 papermod 主题，以 tech 目录为例，我们需要在对应目录下创建 _index.md 和 _index.zh.md，才能访问到 https://blog.zwyyy456.tech/zh/posts/tech 和 https://blog.zwyyy456.tech/posts/tech，否则对应地址会显示为 404。index.zh.md 的内容如下： yaml --- title: \"技术\" description: \"种一棵树最好的时间是十年前，其次是现在\" hidemeta: true --- 而 hugo-coder 主题则不需要创建 _index.md。 ","date":"2022-11-04","objectID":"/create_blog_with_hugo.zh/:4:0","series":null,"tags":["geek","hugo","tips"],"title":"基于 Hugo 搭建自己的博客","uri":"/create_blog_with_hugo.zh/#目录设置"},{"categories":["tutorial"],"content":" 5 部署博客到 vercel","date":"2022-11-04","objectID":"/create_blog_with_hugo.zh/:5:0","series":null,"tags":["geek","hugo","tips"],"title":"基于 Hugo 搭建自己的博客","uri":"/create_blog_with_hugo.zh/#部署博客到-vercel"},{"categories":["tutorial"],"content":" 5.1 购买域名我的域名 zwyyy456.tech 是在阿里云处购买的，同时也是托管在阿里云上的，价格为 10 年 188 元，根据自己的需求购买即可。我的域名解析也是在阿里云上的。 ","date":"2022-11-04","objectID":"/create_blog_with_hugo.zh/:5:1","series":null,"tags":["geek","hugo","tips"],"title":"基于 Hugo 搭建自己的博客","uri":"/create_blog_with_hugo.zh/#购买域名"},{"categories":["tutorial"],"content":" 5.2 Netlify 部署博客将整个项目，如 test-coder 这个文件夹，作为一个 git 仓库上传到 GitHub，然后 Netlify 点击 Add new site -\u003e Import an existing project，选择 Deploy with GitHub，就能将对应的仓库导入到 Netlify，部署的时候设置一下站点名，其他默认即可。 项目部署好之后，添加自己的域名，以 test-blog.zwyyy456.tech 为例，添加为 subdomain，然后点击 External DNS，根据给出的 CNAME 信息去阿里云添加域名解析，如下图所示： 解析生效之后就能通过 test-blog.zwyyy456.tech 域名访问博客了，之后，每次 git push 到 GitHub，Netlify 都会重新部署网站以使内容保持最新。 ","date":"2022-11-04","objectID":"/create_blog_with_hugo.zh/:5:2","series":null,"tags":["geek","hugo","tips"],"title":"基于 Hugo 搭建自己的博客","uri":"/create_blog_with_hugo.zh/#netlify-部署博客"},{"categories":["tutorial"],"content":" 6 添加图床以及网站备案我使用的图床是白嫖的又拍云，而使用又拍云国内图床，需要一个备案过的域名，因此就需要对前面申请的域名进行备案。考虑到域名是通过阿里云购买的，因此也通过阿里云进行备案，于是，我们需要一个阿里云的备案服务号，而备案服务号则需要你有阿里云的服务器（至少一年），当然，闲鱼似乎也有卖备案服务号。 由于之前备案的时候没有做记录，这里就不再演示，跟着阿里云的备案流程走即可，注意备案时网站名称不要出现博客或者论坛等字样，建议“项目笔记”。 又拍云图床的使用教程参见 将博客的图床从 SM.MS 迁移到又拍云 。 由于免费使用又拍云图床以及备案，都需要在网站底部显示对应内容，因此在 layouts/partials 目录下创建 footer.html，内容如下： html \u003cfooter class=\"footer\"\u003e \u003csection class=\"container\"\u003e © {{ if (and .Site.Params.since (lt .Site.Params.since now.Year)) }} {{ .Site.Params.since }} - {{ end }} {{ now.Year }} {{ with .Site.Params.author }} {{ . }} {{ end }} · {{ if (and .Site.Params.license) }} {{ i18n \"licensed_under\" }} {{ .Site.Params.license | safeHTML }} · {{ end }} {{ i18n \"powered_by\" }} \u003ca href=\"https://gohugo.io/\" target=\"_blank\" rel=\"noopener\"\u003eHugo\u003c/a\u003e \u0026 \u003ca href=\"https://github.com/luizdepra/hugo-coder/\" target=\"_blank\" rel=\"noopener\"\u003eCoder\u003c/a\u003e \u0026 \u003ca href=\"https://www.upyun.com/?utm_source=lianmeng\u0026utm_medium=referral\"\u003e \u003cimg src='/img/upyun.svg' alt=\"又拍云\" width=\"53\" height=\"18\" style=\"fill: currentColor; position: relative; top: +3.5px;\"\u003e \u003c/a\u003e. {{ if (and .Site.Params.commit .GitInfo) }} [\u003ca href=\"{{ .Site.Params.commit }}/{{ .GitInfo.Hash }}\" target=\"_blank\" rel=\"noopener\"\u003e{{ .GitInfo.AbbreviatedHash }}\u003c/a\u003e] {{ end }} \u003cbr\u003e \u003ca href=\"https://beian.miit.gov.cn/\" target=\"_blank\"\u003e湘 ICP 备 2023038416 号\u003c/a\u003e \u003c/section\u003e \u003c/footer\u003e 最后显示效果如下： 为博客添加内容搜索功能参见 使博客被搜索引擎收录。 ","date":"2022-11-04","objectID":"/create_blog_with_hugo.zh/:6:0","series":null,"tags":["geek","hugo","tips"],"title":"基于 Hugo 搭建自己的博客","uri":"/create_blog_with_hugo.zh/#添加图床以及网站备案"},{"categories":["tutorial"],"content":" 7 参考 如何用 GitHub Pages + Hugo 搭建个人博客 hugo 博客搭建 | PaperMod 主题 ","date":"2022-11-04","objectID":"/create_blog_with_hugo.zh/:7:0","series":null,"tags":["geek","hugo","tips"],"title":"基于 Hugo 搭建自己的博客","uri":"/create_blog_with_hugo.zh/#参考"},{"categories":["leetcode"],"content":" 1 Description435.non-overlapping-intervals ","date":"2022-11-04","objectID":"/435.non-overlapping-intervals/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"435.non overlapping intervals","uri":"/435.non-overlapping-intervals/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem is almost the same with 452.minimum-number-of-arrows-to-burst-balloons, the number intervals minus the result of 452.minimum-number-of-arrows-to-burst-balloons is the result of this problem. Attention, [1, 3], [3, 5] is not overlapping intervals in this problem. ","date":"2022-11-04","objectID":"/435.non-overlapping-intervals/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"435.non overlapping intervals","uri":"/435.non-overlapping-intervals/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { private: static bool cmp(vector\u003cint\u003e \u0026a, vector\u003cint\u003e \u0026b) { if (a[0] == b[0]) return a[1] \u003c b[1]; return a[0] \u003c b[0]; } public: int eraseOverlapIntervals(vector\u003cvector\u003cint\u003e\u003e \u0026intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i \u003c intervals.size(); i++) { if (intervals[i][0] \u003e= intervals[i - 1][1]) cnt++; else { intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); } } return intervals.size() - cnt; } }; ","date":"2022-11-04","objectID":"/435.non-overlapping-intervals/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"435.non overlapping intervals","uri":"/435.non-overlapping-intervals/#code"},{"categories":["leetcode"],"content":" 1 问题描述435.无重叠区间 ","date":"2022-11-04","objectID":"/435.non-overlapping-intervals.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"435.无重叠区间","uri":"/435.non-overlapping-intervals.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题和452.用最少数量的箭引爆气球可以说解题思路一模一样，区间数减去452.用最少数量的箭引爆气球就可以说是本题要求的答案，但是要注意的是，在本题中，区间端点相同是不认为重叠的。 ","date":"2022-11-04","objectID":"/435.non-overlapping-intervals.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"435.无重叠区间","uri":"/435.non-overlapping-intervals.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { private: static bool cmp(vector\u003cint\u003e \u0026a, vector\u003cint\u003e \u0026b) { if (a[0] == b[0]) return a[1] \u003c b[1]; return a[0] \u003c b[0]; } public: int eraseOverlapIntervals(vector\u003cvector\u003cint\u003e\u003e \u0026intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i \u003c intervals.size(); i++) { if (intervals[i][0] \u003e= intervals[i - 1][1]) cnt++; else { intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); } } return intervals.size() - cnt; } }; ","date":"2022-11-04","objectID":"/435.non-overlapping-intervals.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"435.无重叠区间","uri":"/435.non-overlapping-intervals.zh/#代码"},{"categories":[""],"content":" 1 Description[452.minimum-number-of-arrows-to-burst-balloons] ","date":"2022-11-03","objectID":"/452.minimum-number-of-arrows-to-burst-balloons/:1:0","series":null,"tags":[""],"title":"452.minimum number of arrows to burst balloons","uri":"/452.minimum-number-of-arrows-to-burst-balloons/#description"},{"categories":[""],"content":" 2 SolutionFirst, sort points array by x_start from smallest to largest, then we need analyze how many arrows we need. if (points[i][0] \u003e points[i - 1]), there is no common space between two balloons, we need to arrow, result++; else, then there is common space between two balloons, we need a new arrow. How about the next balloon? if (points[i + 1][0] \u003e min(points[i - 1][1], points[i][1])), then we need new arrow; if not , we don’t need. So we can make points[i][1] = min(points[i - 1][1], points[i][1]). ","date":"2022-11-03","objectID":"/452.minimum-number-of-arrows-to-burst-balloons/:2:0","series":null,"tags":[""],"title":"452.minimum number of arrows to burst balloons","uri":"/452.minimum-number-of-arrows-to-burst-balloons/#solution"},{"categories":[""],"content":" 3 Code cpp #include \u003calgorithm\u003e #include \u003cvector\u003e using std::sort; using std::vector; class Solution { private: static bool cmp(vector\u003cint\u003e \u0026a, vector\u003cint\u003e \u0026b) { return a[0] \u003c b[0]; } public: int findMinArrowShots(vector\u003cvector\u003cint\u003e\u003e \u0026points) { int result = 1; sort(points.begin(), points.end(), cmp); for (int i = 1; i \u003c points.size(); i++) { if (points[i - 1][1] \u003c points[i][0]) result++; else { points[i][1] = min(points[i][1], points[i - 1][1]); } } return result; } }; ","date":"2022-11-03","objectID":"/452.minimum-number-of-arrows-to-burst-balloons/:3:0","series":null,"tags":[""],"title":"452.minimum number of arrows to burst balloons","uri":"/452.minimum-number-of-arrows-to-burst-balloons/#code"},{"categories":["leetcode"],"content":" 1 问题描述452.用最少数量的箭引爆气球 ","date":"2022-11-03","objectID":"/452.minimum-number-of-arrows-to-burst-balloons.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"452.用最少数量的箭引爆气球","uri":"/452.minimum-number-of-arrows-to-burst-balloons.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，按照$x_start$从小到大的顺序排序，然后开始分析需要的弓箭数。 if (points[i][0] \u003e points[i - 1])，说明两个气球不存在重叠，需要两支箭，箭数result++; else，说明两个气球存在重叠，只需要一支箭，但此时，如何判断下一个气球是否需要新的箭呢: if (points[i + 1][0] \u003e min(points[i - 1][1], points[i][1]))，那么就需要新的箭，反之就不需要，因此，令points[i][1] = min(points[i - 1][1], points[i][1])。 ","date":"2022-11-03","objectID":"/452.minimum-number-of-arrows-to-burst-balloons.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"452.用最少数量的箭引爆气球","uri":"/452.minimum-number-of-arrows-to-burst-balloons.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003calgorithm\u003e #include \u003cvector\u003e using std::sort; using std::vector; class Solution { private: static bool cmp(vector\u003cint\u003e \u0026a, vector\u003cint\u003e \u0026b) { return a[0] \u003c b[0]; } public: int findMinArrowShots(vector\u003cvector\u003cint\u003e\u003e \u0026points) { int result = 1; sort(points.begin(), points.end(), cmp); for (int i = 1; i \u003c points.size(); i++) { if (points[i - 1][1] \u003c points[i][0]) result++; else { points[i][1] = min(points[i][1], points[i - 1][1]); } } return result; } }; ","date":"2022-11-03","objectID":"/452.minimum-number-of-arrows-to-burst-balloons.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"452.用最少数量的箭引爆气球","uri":"/452.minimum-number-of-arrows-to-burst-balloons.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description406.queue-reconstruction-by-height ","date":"2022-11-01","objectID":"/406.queue-reconstruction-by-height/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"406.queue reconstruction by height","uri":"/406.queue-reconstruction-by-height/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirst, we need sort the vector by height, then do insertion according to ki. When sorting, we need rewrite the comparing method, in reference to the use of sort() method in C++ Since there may be performance problem when doing insertion frequently in vector, we should use list based on linked list. ","date":"2022-11-01","objectID":"/406.queue-reconstruction-by-height/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"406.queue reconstruction by height","uri":"/406.queue-reconstruction-by-height/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: static bool cmp(const vector\u003cint\u003e \u0026a, const vector\u003cint\u003e \u0026b) { if (a[0] == b[0]) return a[1] \u003c b[1]; return a[0] \u003e b[0]; } vector\u003cvector\u003cint\u003e\u003e reconstructQueue(vector\u003cvector\u003cint\u003e\u003e \u0026people) { sort(people.begin(), people.end(), cmp); vector\u003cvector\u003cint\u003e\u003e queue; for (int i = 0; i \u003c people.size(); i++) { int tmp = people[i][1]; queue.insert(tmp + queue.begin(), people[i]); } return queue; } }; cpp class Solution { public: // sort by height; static bool cmp(const vector\u003cint\u003e\u0026 a, const vector\u003cint\u003e\u0026 b) { if (a[0] == b[0]) return a[1] \u003c b[1]; return a[0] \u003e b[0]; } vector\u003cvector\u003cint\u003e\u003e reconstructQueue(vector\u003cvector\u003cint\u003e\u003e\u0026 people) { sort (people.begin(), people.end(), cmp); list\u003cvector\u003cint\u003e\u003e que; // list is based on linked list for (int i = 0; i \u003c people.size(); i++) { int position = people[i][1]; // std::list\u003cvector\u003cint\u003e\u003e::iterator it = que.begin(); while (position--) { // it++; } que.insert(it, people[i]); } return vector\u003cvector\u003cint\u003e\u003e(que.begin(), que.end()); } }; ","date":"2022-11-01","objectID":"/406.queue-reconstruction-by-height/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"406.queue reconstruction by height","uri":"/406.queue-reconstruction-by-height/#code"},{"categories":["leetcode"],"content":" 1 问题描述406.根据身高重建队列 ","date":"2022-11-01","objectID":"/406.queue-reconstruction-by-height.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"406.根据身高重建队列","uri":"/406.queue-reconstruction-by-height.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先根据身高对数组重新排序，再根据ki进行插入操作。 排序时，需要对排序的比较方法重写，参见C++ sort排序函数用法。 同时，考虑到基于使用vector来进行频繁的插入操作可能会存在性能问题，应该使用基于链表的list。 ","date":"2022-11-01","objectID":"/406.queue-reconstruction-by-height.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"406.根据身高重建队列","uri":"/406.queue-reconstruction-by-height.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: static bool cmp(const vector\u003cint\u003e \u0026a, const vector\u003cint\u003e \u0026b) { if (a[0] == b[0]) return a[1] \u003c b[1]; return a[0] \u003e b[0]; } vector\u003cvector\u003cint\u003e\u003e reconstructQueue(vector\u003cvector\u003cint\u003e\u003e \u0026people) { sort(people.begin(), people.end(), cmp); vector\u003cvector\u003cint\u003e\u003e queue; for (int i = 0; i \u003c people.size(); i++) { int tmp = people[i][1]; queue.insert(tmp + queue.begin(), people[i]); } return queue; } }; cpp class Solution { public: // 身高从大到小排（身高相同k小的站前面） static bool cmp(const vector\u003cint\u003e\u0026 a, const vector\u003cint\u003e\u0026 b) { if (a[0] == b[0]) return a[1] \u003c b[1]; return a[0] \u003e b[0]; } vector\u003cvector\u003cint\u003e\u003e reconstructQueue(vector\u003cvector\u003cint\u003e\u003e\u0026 people) { sort (people.begin(), people.end(), cmp); list\u003cvector\u003cint\u003e\u003e que; // list底层是链表实现，插入效率比vector高的多 for (int i = 0; i \u003c people.size(); i++) { int position = people[i][1]; // 插入到下标为position的位置 std::list\u003cvector\u003cint\u003e\u003e::iterator it = que.begin(); while (position--) { // 寻找在插入位置 it++; } que.insert(it, people[i]); } return vector\u003cvector\u003cint\u003e\u003e(que.begin(), que.end()); } }; ","date":"2022-11-01","objectID":"/406.queue-reconstruction-by-height.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"406.根据身高重建队列","uri":"/406.queue-reconstruction-by-height.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description860.lemonade-change ","date":"2022-10-31","objectID":"/860.lemonade-change/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"860.lemonade change","uri":"/860.lemonade-change/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe can create an array to show the number of $5, $10, $20. When the number of $5 is less than 0, return false. When we receive $20, we should provide change with $10 preferentially. ","date":"2022-10-31","objectID":"/860.lemonade-change/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"860.lemonade change","uri":"/860.lemonade-change/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: bool lemonadeChange(vector\u003cint\u003e \u0026bills) { vector\u003cint\u003e num(3, 0); for (int i = 0; i \u003c bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] \u003e 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] \u003e 0) { if (num[0] \u003e 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] \u003e 2) num[0] -= 3; else return false; } } } return true; } }; ","date":"2022-10-31","objectID":"/860.lemonade-change/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"860.lemonade change","uri":"/860.lemonade-change/#code"},{"categories":["leetcode"],"content":" 1 问题描述860.柠檬水找零 ","date":"2022-10-31","objectID":"/860.lemonade-change.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"860.柠檬水找零","uri":"/860.lemonade-change.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路创建一个数组，表示手中的5元纸币、10元纸币、20元纸币的数目，当其中5元纸币数目小于0，说明无法找零，遇到20元纸币时，优先使用10元纸币找零。 ","date":"2022-10-31","objectID":"/860.lemonade-change.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"860.柠檬水找零","uri":"/860.lemonade-change.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: bool lemonadeChange(vector\u003cint\u003e \u0026bills) { vector\u003cint\u003e num(3, 0); for (int i = 0; i \u003c bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] \u003e 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] \u003e 0) { if (num[0] \u003e 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] \u003e 2) num[0] -= 3; else return false; } } } return true; } }; ","date":"2022-10-31","objectID":"/860.lemonade-change.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"860.柠檬水找零","uri":"/860.lemonade-change.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description135.candy ","date":"2022-10-30","objectID":"/135.candy/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"135.candy","uri":"/135.candy/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe key point of this problem is that we need traverse two times, one from front to back, the other from back to front. ","date":"2022-10-30","objectID":"/135.candy/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"135.candy","uri":"/135.candy/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int candy(vector\u003cint\u003e\u0026 ratings) { vector\u003cint\u003e candyVec(ratings.size(), 1); // front to back for (int i = 1; i \u003c ratings.size(); i++) { if (ratings[i] \u003e ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // back to front for (int i = ratings.size() - 2; i \u003e= 0; i--) { if (ratings[i] \u003e ratings[i + 1] ) { candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1); } } int result = 0; for (int i = 0; i \u003c candyVec.size(); i++) result += candyVec[i]; return result; } }; ","date":"2022-10-30","objectID":"/135.candy/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"135.candy","uri":"/135.candy/#code"},{"categories":["leetcode"],"content":" 1 问题描述135.分发糖果 ","date":"2022-10-30","objectID":"/135.candy.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"135.分发糖果","uri":"/135.candy.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题的关键在于，需要一次从前往后的遍历，第一次确定最少糖果数，同时还需要从后往前遍历，再一次确定最少糖果数。 ","date":"2022-10-30","objectID":"/135.candy.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"135.分发糖果","uri":"/135.candy.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int candy(vector\u003cint\u003e\u0026 ratings) { vector\u003cint\u003e candyVec(ratings.size(), 1); // 从前向后 for (int i = 1; i \u003c ratings.size(); i++) { if (ratings[i] \u003e ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // 从后向前 for (int i = ratings.size() - 2; i \u003e= 0; i--) { if (ratings[i] \u003e ratings[i + 1] ) { candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1); } } // 统计结果 int result = 0; for (int i = 0; i \u003c candyVec.size(); i++) result += candyVec[i]; return result; } }; ","date":"2022-10-30","objectID":"/135.candy.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"135.分发糖果","uri":"/135.candy.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1005.maximize-sum-of-array-after-k-negations ","date":"2022-10-30","objectID":"/1005.maximize-sum-of-array-after-k-negations/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1005.maximize sum of array after k negations","uri":"/1005.maximize-sum-of-array-after-k-negations/#description"},{"categories":["leetcode"],"content":" 2 SolutionGreedy algorithm. ","date":"2022-10-30","objectID":"/1005.maximize-sum-of-array-after-k-negations/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1005.maximize sum of array after k negations","uri":"/1005.maximize-sum-of-array-after-k-negations/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { static bool cmp(int a, int b) { return abs(a) \u003e abs(b); } public: int largestSumAfterKNegations(vector\u003cint\u003e\u0026 A, int K) { sort(A.begin(), A.end(), cmp); // first step for (int i = 0; i \u003c A.size(); i++) { // second step if (A[i] \u003c 0 \u0026\u0026 K \u003e 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // third step int result = 0; for (int a : A) result += a; // forth step return result; } }; ","date":"2022-10-30","objectID":"/1005.maximize-sum-of-array-after-k-negations/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1005.maximize sum of array after k negations","uri":"/1005.maximize-sum-of-array-after-k-negations/#code"},{"categories":["leetcode"],"content":" 1 问题描述1005.K次取反后最大化的数组和 ","date":"2022-10-30","objectID":"/1005.maximize-sum-of-array-after-k-negations.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1005.K次取反后的最大化的数组和","uri":"/1005.maximize-sum-of-array-after-k-negations.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路贪心算法 ","date":"2022-10-30","objectID":"/1005.maximize-sum-of-array-after-k-negations.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1005.K次取反后的最大化的数组和","uri":"/1005.maximize-sum-of-array-after-k-negations.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { static bool cmp(int a, int b) { return abs(a) \u003e abs(b); } public: int largestSumAfterKNegations(vector\u003cint\u003e\u0026 A, int K) { sort(A.begin(), A.end(), cmp); // 第一步 for (int i = 0; i \u003c A.size(); i++) { // 第二步 if (A[i] \u003c 0 \u0026\u0026 K \u003e 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步 int result = 0; for (int a : A) result += a; // 第四步 return result; } }; ","date":"2022-10-30","objectID":"/1005.maximize-sum-of-array-after-k-negations.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"1005.K次取反后的最大化的数组和","uri":"/1005.maximize-sum-of-array-after-k-negations.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description45.jump-game-ii ","date":"2022-10-30","objectID":"/45.jump-game-ii/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"45.jump game ii","uri":"/45.jump-game-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionIn outer loop, we traverse from back to front, while in inner loop, we traverse from front to back, to find the station with minimum index that can arrive at destination. Make the station the new destination, and cnt++. ","date":"2022-10-30","objectID":"/45.jump-game-ii/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"45.jump game ii","uri":"/45.jump-game-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: int jump(vector\u003cint\u003e \u0026nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i \u003c nums.size(); i++) { if (nums[i] + i \u003e= cur_end) { cur_end = i; cnt++; break; } } } return cnt; } }; ","date":"2022-10-30","objectID":"/45.jump-game-ii/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"45.jump game ii","uri":"/45.jump-game-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述45.跳跃游戏II ","date":"2022-10-30","objectID":"/45.jump-game-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"45.跳跃游戏II","uri":"/45.jump-game-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路外循环还是从末尾向前遍历，内循环从前往后遍历，每次找能到达终点的索引最小的位置，该位置作为新的终点，同时步数cnt++。 ","date":"2022-10-30","objectID":"/45.jump-game-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"45.跳跃游戏II","uri":"/45.jump-game-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: int jump(vector\u003cint\u003e \u0026nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i \u003c nums.size(); i++) { if (nums[i] + i \u003e= cur_end) { cur_end = i; cnt++; break; } } } return cnt; } }; ","date":"2022-10-30","objectID":"/45.jump-game-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"45.跳跃游戏II","uri":"/45.jump-game-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description55.jump-game ","date":"2022-10-30","objectID":"/55.jump-game/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"55.jump game","uri":"/55.jump-game/#description"},{"categories":["leetcode"],"content":" 2 SolutionTraversing from back to front, if nums[j] can be achieved from nums[j - 1] or nums in the front, then destination change from nums[j] to nums[j - 1] or num in the front. ","date":"2022-10-30","objectID":"/55.jump-game/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"55.jump game","uri":"/55.jump-game/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: bool canJump(vector\u003cint\u003e \u0026nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i \u003e= 0; i--) { while (i \u003e= 0 \u0026\u0026 nums[i] + i \u003e= r) { r = i; i--; } } if (r != 0) return false; else return true; } }; ","date":"2022-10-30","objectID":"/55.jump-game/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"55.jump game","uri":"/55.jump-game/#code"},{"categories":["leetcode"],"content":" 1 问题描述55.跳跃游戏 ","date":"2022-10-30","objectID":"/55.jump-game.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"55.跳跃游戏","uri":"/55.jump-game.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路从后向前遍历，只要nums[j]能由nums[j - 1]或者更前面的点跳到，那么终点就从nums[j]变成nums[j - 1]或更前面的点。 ","date":"2022-10-30","objectID":"/55.jump-game.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"55.跳跃游戏","uri":"/55.jump-game.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: bool canJump(vector\u003cint\u003e \u0026nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i \u003e= 0; i--) { while (i \u003e= 0 \u0026\u0026 nums[i] + i \u003e= r) { r = i; i--; } } if (r != 0) return false; else return true; } }; ","date":"2022-10-30","objectID":"/55.jump-game.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"55.跳跃游戏","uri":"/55.jump-game.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description72.edit-distance ","date":"2022-10-30","objectID":"/72.edit-distance/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"72.edit distance","uri":"/72.edit-distance/#description"},{"categories":["leetcode"],"content":" 2 SolutionIt’s easy to consider what dp[i][j] should denotes. if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else, we can consider in three cases: replace the word1[i - 1]: dp[i][j] = dp[i - 1][j - 1] + 1; remove word1[i - 1]: dp[i][j] = dp[i - 1][j] + 1; insert word2[j - 1] between word[i - 1] and word[i], it’s the same as remove word2[j - 1]: dp[i][j] = dp[i][j - 1] + 1; We should also pay attention to the initialzation of dp[i][j]. ","date":"2022-10-30","objectID":"/72.edit-distance/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"72.edit distance","uri":"/72.edit-distance/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minDistance(string word1, string word2) { vector\u003cvector\u003cint\u003e\u003e dp(word1.size() + 1, vector\u003cint\u003e(word2.size() + 1, 0)); for (int i = 1; i \u003c= word1.size(); i++) { dp[i][0] = i; } for (int j = 1; j \u003c= word2.size(); j++) { dp[0][j] = j; } for (int i = 1; i \u003c= word1.size(); i++) { for (int j = 1; j \u003c= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else { dp[i][j] = min(min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1; } } } return dp[word1.size()][word2.size()]; } }; ","date":"2022-10-30","objectID":"/72.edit-distance/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"72.edit distance","uri":"/72.edit-distance/#code"},{"categories":["leetcode"],"content":" 1 问题描述72.编辑距离 ","date":"2022-10-30","objectID":"/72.edit-distance.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"72.编辑距离","uri":"/72.edit-distance.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路dp[i][j]的含义不再赘述: if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else,分为三种操作情况: 替换末尾字符: dp[i][j] = dp[i - 1][j - 1] + 1; 删除word1的第i个字符: dp[i][j] = dp[i - 1][j] + 1; 删除word2的第j个字符，即相当于在第i个字符后插入word2[j - 1]: dp[i][j] = dp[i][j - 1] ","date":"2022-10-30","objectID":"/72.edit-distance.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"72.编辑距离","uri":"/72.edit-distance.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minDistance(string word1, string word2) { vector\u003cvector\u003cint\u003e\u003e dp(word1.size() + 1, vector\u003cint\u003e(word2.size() + 1, 0)); for (int i = 1; i \u003c= word1.size(); i++) { dp[i][0] = i; } for (int j = 1; j \u003c= word2.size(); j++) { dp[0][j] = j; } for (int i = 1; i \u003c= word1.size(); i++) { for (int j = 1; j \u003c= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else { dp[i][j] = min(min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1; } } } return dp[word1.size()][word2.size()]; } }; ","date":"2022-10-30","objectID":"/72.edit-distance.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"72.编辑距离","uri":"/72.edit-distance.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description583.delete-operation-for-two-strings ","date":"2022-10-30","objectID":"/583.delete-operations-for-two-strings/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"583.delete operations for two strings","uri":"/583.delete-operations-for-two-strings/#description"},{"categories":["leetcode"],"content":" 2 Solutiondp[i][j] denotes minimum number of options to make strings the same when considering the first i characters of word1 and the first j characters of word2. if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; ","date":"2022-10-30","objectID":"/583.delete-operations-for-two-strings/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"583.delete operations for two strings","uri":"/583.delete-operations-for-two-strings/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int minDistance(string word1, string word2) { vector\u003cvector\u003cint\u003e\u003e dp(word1.size() + 1, vector\u003cint\u003e(word2.size() + 1, 0)); for (int i = 0; i \u003c= word1.size(); i++) { dp[i][0] = i; } for (int j = 0; j \u003c= word2.size(); j++) { dp[0][j] = j; } for (int i = 1; i \u003c= word1.size(); i++) { for (int j = 1; j \u003c= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; } } return dp[word1.size()][word2.size()]; } }; ","date":"2022-10-30","objectID":"/583.delete-operations-for-two-strings/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"583.delete operations for two strings","uri":"/583.delete-operations-for-two-strings/#code"},{"categories":["leetcode"],"content":" 1 问题描述583.两个字符串的删除操作 ","date":"2022-10-30","objectID":"/583.delete-operations-for-two-strings.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"583.两个字符串的删除操作","uri":"/583.delete-operations-for-two-strings.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路dp[i][j]表示对word1的前i个字符，word2的前j个字符，使得它们相同的最小步数: if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; ","date":"2022-10-30","objectID":"/583.delete-operations-for-two-strings.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"583.两个字符串的删除操作","uri":"/583.delete-operations-for-two-strings.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int minDistance(string word1, string word2) { vector\u003cvector\u003cint\u003e\u003e dp(word1.size() + 1, vector\u003cint\u003e(word2.size() + 1, 0)); for (int i = 0; i \u003c= word1.size(); i++) { dp[i][0] = i; } for (int j = 0; j \u003c= word2.size(); j++) { dp[0][j] = j; } for (int i = 1; i \u003c= word1.size(); i++) { for (int j = 1; j \u003c= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; } } return dp[word1.size()][word2.size()]; } }; ","date":"2022-10-30","objectID":"/583.delete-operations-for-two-strings.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"583.两个字符串的删除操作","uri":"/583.delete-operations-for-two-strings.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description115.distinct-subsequence ","date":"2022-10-30","objectID":"/115.distinct-subsequences/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"115.distinct subsequences","uri":"/115.distinct-subsequences/#description"},{"categories":["leetcode"],"content":" 2 Solutiondp[i][j] denotes the occurrences of the first j characters of t in the first i characters of s: if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(uses[i - 1] and not use s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; ","date":"2022-10-30","objectID":"/115.distinct-subsequences/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"115.distinct subsequences","uri":"/115.distinct-subsequences/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int numDistinct(string s, string t) { if (s.size() \u003c t.size()) return 0; vector\u003cvector\u003cuint32_t\u003e\u003e dp(s.size() + 1, vector\u003cuint32_t\u003e(t.size() + 1, 0)); // dp[0][0] = 1; for (int i = 0; i \u003c= s.size(); i++) { dp[i][0] = 1; } for (int i = 1; i \u003c= s.size(); i++) { for (int j = 1; j \u003c= i \u0026\u0026 j \u003c= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; else dp[i][j] = dp[i - 1][j]; } } return dp[s.size()][t.size()]; } }; ","date":"2022-10-30","objectID":"/115.distinct-subsequences/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"115.distinct subsequences","uri":"/115.distinct-subsequences/#code"},{"categories":["leetcode"],"content":" 1 问题描述115.不同的子序列 ","date":"2022-10-30","objectID":"/115.distinct-subsequences.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"115.不同的子序列","uri":"/115.distinct-subsequences.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路dp[i][j]表示考虑考虑t的前j个字符在s的前i个字符中的出现个数: if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(表示使用s[i - 1]匹配和不使用s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; ","date":"2022-10-30","objectID":"/115.distinct-subsequences.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"115.不同的子序列","uri":"/115.distinct-subsequences.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int numDistinct(string s, string t) { if (s.size() \u003c t.size()) return 0; vector\u003cvector\u003cuint32_t\u003e\u003e dp(s.size() + 1, vector\u003cuint32_t\u003e(t.size() + 1, 0)); // dp[0][0] = 1; for (int i = 0; i \u003c= s.size(); i++) { dp[i][0] = 1; } for (int i = 1; i \u003c= s.size(); i++) { for (int j = 1; j \u003c= i \u0026\u0026 j \u003c= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; else dp[i][j] = dp[i - 1][j]; } } return dp[s.size()][t.size()]; } }; ","date":"2022-10-30","objectID":"/115.distinct-subsequences.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"115.不同的子序列","uri":"/115.distinct-subsequences.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description392.is-subsequence ","date":"2022-10-30","objectID":"/392.is-subsequence/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"392.is subsequence","uri":"/392.is-subsequence/#description"},{"categories":["leetcode"],"content":" 2 SolutionIt’s similar to 1143.longest-common-subsequence. We just need to judge whether the result is equal to s.size(). ","date":"2022-10-30","objectID":"/392.is-subsequence/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"392.is subsequence","uri":"/392.is-subsequence/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: bool isSubsequence(string s, string t) { if (s.size() \u003e t.size()) return false; else { vector\u003cvector\u003cint\u003e\u003e dp(s.size() + 1, vector\u003cint\u003e(t.size() + 1, 0)); for (int i = 1; i \u003c= s.size(); i++) { for (int j = 1; j \u003c= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.size()][t.size()] == s.size(); } } }; ","date":"2022-10-30","objectID":"/392.is-subsequence/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"392.is subsequence","uri":"/392.is-subsequence/#code"},{"categories":["leetcode"],"content":" 1 问题描述392.判断子序列 ","date":"2022-10-30","objectID":"/392.is-subsequence.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"392.判断子序列","uri":"/392.is-subsequence.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路与1143.最长公共子序列基本一样，只需要再判断结果是否和s.size()相等就好了。 ","date":"2022-10-30","objectID":"/392.is-subsequence.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"392.判断子序列","uri":"/392.is-subsequence.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: bool isSubsequence(string s, string t) { if (s.size() \u003e t.size()) return false; else { vector\u003cvector\u003cint\u003e\u003e dp(s.size() + 1, vector\u003cint\u003e(t.size() + 1, 0)); for (int i = 1; i \u003c= s.size(); i++) { for (int j = 1; j \u003c= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.size()][t.size()] == s.size(); } } }; ","date":"2022-10-30","objectID":"/392.is-subsequence.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"392.判断子序列","uri":"/392.is-subsequence.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description53.maximum-subarray ","date":"2022-10-30","objectID":"/53.maximum-subarray/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"53.maximum subarray","uri":"/53.maximum-subarray/#description"},{"categories":["leetcode"],"content":" 2 Solutiondp[i] denotes maximum sum of subarray ending with nums[i - 1], then: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); ","date":"2022-10-30","objectID":"/53.maximum-subarray/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"53.maximum subarray","uri":"/53.maximum-subarray/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maxSubArray(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i \u003c= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] \u003e m) m = dp[i]; } return m; } }; ","date":"2022-10-30","objectID":"/53.maximum-subarray/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"53.maximum subarray","uri":"/53.maximum-subarray/#code"},{"categories":["leetcode"],"content":" 1 问题描述53.最大子数组和 ","date":"2022-10-30","objectID":"/53.maximum-subarray.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"53.最大子数组和","uri":"/53.maximum-subarray.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2022-10-30","objectID":"/53.maximum-subarray.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"53.最大子数组和","uri":"/53.maximum-subarray.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 动态规划令dp[i]表示以nums[i - 1]结尾的连续子数组的最大和，则: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); ","date":"2022-10-30","objectID":"/53.maximum-subarray.zh/:2:1","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"53.最大子数组和","uri":"/53.maximum-subarray.zh/#动态规划"},{"categories":["leetcode"],"content":" 2.2 贪心算法以第一个正数为起点，开始记录和sum_temp，同时记录最大和sum，当sum_temp小于0时，起点变为新的正数。 ","date":"2022-10-30","objectID":"/53.maximum-subarray.zh/:2:2","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"53.最大子数组和","uri":"/53.maximum-subarray.zh/#贪心算法"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxSubArray(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i \u003c= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] \u003e m) m = dp[i]; } return m; } }; ","date":"2022-10-30","objectID":"/53.maximum-subarray.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"53.最大子数组和","uri":"/53.maximum-subarray.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1035.uncrossed-lines ","date":"2022-10-29","objectID":"/1035.uncrossed-lines/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1035.uncrossed lines","uri":"/1035.uncrossed-lines/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe same as 1143.longest-common-subsequence ","date":"2022-10-29","objectID":"/1035.uncrossed-lines/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1035.uncrossed lines","uri":"/1035.uncrossed-lines/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: int maxUncrossedLines(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { vector\u003cvector\u003cint\u003e\u003e dp(nums1.size() + 1, vector\u003cint\u003e(nums2.size() + 1, 0)); for (int i = 1; i \u003c= nums1.size(); i++) { for (int j = 1; j \u003c= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.size()][nums2.size()]; } }; ","date":"2022-10-29","objectID":"/1035.uncrossed-lines/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1035.uncrossed lines","uri":"/1035.uncrossed-lines/#code"},{"categories":["leetcode"],"content":" 1 问题描述1035.不相交的线 ","date":"2022-10-29","objectID":"/1035.uncrossed-lines.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1035.不相交的线","uri":"/1035.uncrossed-lines.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路只是1143.最长公共子序列的另一种描述 ","date":"2022-10-29","objectID":"/1035.uncrossed-lines.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1035.不相交的线","uri":"/1035.uncrossed-lines.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: int maxUncrossedLines(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { vector\u003cvector\u003cint\u003e\u003e dp(nums1.size() + 1, vector\u003cint\u003e(nums2.size() + 1, 0)); for (int i = 1; i \u003c= nums1.size(); i++) { for (int j = 1; j \u003c= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.size()][nums2.size()]; } }; ","date":"2022-10-29","objectID":"/1035.uncrossed-lines.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1035.不相交的线","uri":"/1035.uncrossed-lines.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description1143.longest-common-subsequence ","date":"2022-10-29","objectID":"/1143.longest-common-subsequence/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1143.longest common subsequence","uri":"/1143.longest-common-subsequence/#description"},{"categories":["leetcode"],"content":" 2 Solutiondp[i][j] denotes the length of longest common subsequence of first i characters of text1 and first j characters of text2: if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); ","date":"2022-10-29","objectID":"/1143.longest-common-subsequence/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1143.longest common subsequence","uri":"/1143.longest-common-subsequence/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector\u003cvector\u003cint\u003e\u003e dp(text1.size() + 1, vector\u003cint\u003e(text2.size() + 1, 0)); int m = 0; int res = 0; for (int i = 1; i \u003c= text1.size(); i++) { for (int j = 1; j \u003c= text2.size(); j++) { if (text1[i - 1] == text2[j - 1]) { //dp[i][j] = max(dp[i - 1][j - 1] + 1, max(dp[i - 1][j], dp[i][1])); dp[i][j] = dp[i - 1][j - 1] + 1; } else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[text1.size()][text2.size()]; } }; ","date":"2022-10-29","objectID":"/1143.longest-common-subsequence/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1143.longest common subsequence","uri":"/1143.longest-common-subsequence/#code"},{"categories":["leetcode"],"content":" 1 问题描述1143.最长公共子序列 ","date":"2022-10-29","objectID":"/1143.longest-common-subsequence.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1143.最长公共子序列","uri":"/1143.longest-common-subsequence.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路dp[i][j]表示text1的前i个字符和text2的前j个字符里最长公共子序列长度: if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); ","date":"2022-10-29","objectID":"/1143.longest-common-subsequence.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1143.最长公共子序列","uri":"/1143.longest-common-subsequence.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector\u003cvector\u003cint\u003e\u003e dp(text1.size() + 1, vector\u003cint\u003e(text2.size() + 1, 0)); int m = 0; int res = 0; for (int i = 1; i \u003c= text1.size(); i++) { for (int j = 1; j \u003c= text2.size(); j++) { if (text1[i - 1] == text2[j - 1]) { //dp[i][j] = max(dp[i - 1][j - 1] + 1, max(dp[i - 1][j], dp[i][1])); dp[i][j] = dp[i - 1][j - 1] + 1; // 这里必须保证，假设m = dp[a][b], 必须a, b分别小于i, j才行 } else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[text1.size()][text2.size()]; } }; ","date":"2022-10-29","objectID":"/1143.longest-common-subsequence.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1143.最长公共子序列","uri":"/1143.longest-common-subsequence.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description134.gas-station ","date":"2022-10-29","objectID":"/134.gas-station/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"134.gas station","uri":"/134.gas-station/#description"},{"categories":["leetcode"],"content":" 2 SolutionWe should consider total oil consumption total_oil, and remaining oil from new start station cur_oil(not replenish oil in new station): total_oil \u003c 0, can’t complete; cur_oil \u003c 0, start at the new station; ","date":"2022-10-29","objectID":"/134.gas-station/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"134.gas station","uri":"/134.gas-station/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i \u003c n; ++i) { //total_oil need \u003e 0, or can't complete total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank \u003c 0) { // start from i + 1 starting_station = i + 1; // restore to first state cur_oil = 0; } } return total_oil \u003e= 0 ? starting_station : -1; } } ","date":"2022-10-29","objectID":"/134.gas-station/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"134.gas station","uri":"/134.gas-station/#code"},{"categories":["leetcode"],"content":" 1 问题描述134.加油站 ","date":"2022-10-29","objectID":"/134.gas-station.zh/:1:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"134.加油站","uri":"/134.gas-station.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路考虑两个变量，一个是总油耗total_oil，一个是从起点到下一个站点后汽车内部剩余的汽油cur_oil(没有在目标站点补充油耗)。 总油耗total_oil \u003c 0，说明不可能到; cur_oil \u003c 0，则以到达的站点作为新的起点再出发; ","date":"2022-10-29","objectID":"/134.gas-station.zh/:2:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"134.加油站","uri":"/134.gas-station.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i \u003c n; ++i) { //总和必须大于等于0，否则不能完成绕行 total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank \u003c 0) { // 一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。 starting_station = i + 1; // 还原到初始状态 cur_oil = 0; } } return total_oil \u003e= 0 ? starting_station : -1; } } ","date":"2022-10-29","objectID":"/134.gas-station.zh/:3:0","series":null,"tags":["data structure and algorithms","greedy algorithm"],"title":"134.加油站","uri":"/134.gas-station.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description718.maximum-length-of-repeated-subarray ","date":"2022-10-17","objectID":"/718.maximum-length-of-repeated-subarray/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"718.maximum length of repeated subarray","uri":"/718.maximum-length-of-repeated-subarray/#description"},{"categories":["leetcode"],"content":" 2 Solutiondp[i][j] denotes the length of longest public subarray of two subarray ending with nums1[i - 1], nums2[j - 1]; Recurrence formula cpp if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; ","date":"2022-10-17","objectID":"/718.maximum-length-of-repeated-subarray/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"718.maximum length of repeated subarray","uri":"/718.maximum-length-of-repeated-subarray/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int findLength(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { vector\u003cvector\u003cint\u003e\u003e dp(nums1.size() + 1, vector\u003cint\u003e(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i \u003c= nums1.size(); i++) { for (int j = 1; j \u003c= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) // dp[i][j] = max(dp[i - 1][j - 1] + 1, dp[i][j]); dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] \u003e m) m = dp[i][j]; } } return m; } }; ","date":"2022-10-17","objectID":"/718.maximum-length-of-repeated-subarray/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"718.maximum length of repeated subarray","uri":"/718.maximum-length-of-repeated-subarray/#code"},{"categories":["leetcode"],"content":" 1 问题描述718.最长重复子数组 ","date":"2022-10-17","objectID":"/718.maximum-length-of-repeated-subarray.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"718.最长重复子数组","uri":"/718.maximum-length-of-repeated-subarray.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路dp[i][j]表示分别以nums1[i - 1], nums2[j - 1]结尾的两个子数组的最长公共子数组的长度； 递推关系: cpp if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; ","date":"2022-10-17","objectID":"/718.maximum-length-of-repeated-subarray.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"718.最长重复子数组","uri":"/718.maximum-length-of-repeated-subarray.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int findLength(vector\u003cint\u003e \u0026nums1, vector\u003cint\u003e \u0026nums2) { vector\u003cvector\u003cint\u003e\u003e dp(nums1.size() + 1, vector\u003cint\u003e(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i \u003c= nums1.size(); i++) { for (int j = 1; j \u003c= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) // dp[i][j] = max(dp[i - 1][j - 1] + 1, dp[i][j]); dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] \u003e m) m = dp[i][j]; } } return m; } }; ","date":"2022-10-17","objectID":"/718.maximum-length-of-repeated-subarray.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"718.最长重复子数组","uri":"/718.maximum-length-of-repeated-subarray.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description674.longest-continuous-increasing-subsequence ","date":"2022-10-17","objectID":"/674.longest-continuous-increasing-subsequence/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"674.longest continuous increasing subsequence","uri":"/674.longest-continuous-increasing-subsequence/#description"},{"categories":["leetcode"],"content":" 2 Solutiondp[i] denotes the length of longest continuous increasing subsequence ending with nums[i - 1]; Recurrence formula: cpp if (nums[i - 1] \u003e nums[i - 2]) dp[i] = dp[i - 1] + 1; ","date":"2022-10-17","objectID":"/674.longest-continuous-increasing-subsequence/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"674.longest continuous increasing subsequence","uri":"/674.longest-continuous-increasing-subsequence/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int findLengthOfLCIS(vector\u003cint\u003e \u0026nums) { vector\u003cint\u003e dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i \u003c= nums.size(); i++) { if (nums[i - 1] \u003e nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] \u003e m) m = dp[i]; } return m; } }; ","date":"2022-10-17","objectID":"/674.longest-continuous-increasing-subsequence/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"674.longest continuous increasing subsequence","uri":"/674.longest-continuous-increasing-subsequence/#code"},{"categories":["leetcode"],"content":" 1 问题描述674.最长连续递增序列 ","date":"2022-10-17","objectID":"/674.longest-continuous-increasing-subsequence.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"674.最长连续递增序列","uri":"/674.longest-continuous-increasing-subsequence.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路dp[i]表示以nums[i - 1]结尾的最长连续递增子序列长度; 递推关系为: cpp if (nums[i - 1] \u003e nums[i - 2]) dp[i] = dp[i - 1] + 1; ","date":"2022-10-17","objectID":"/674.longest-continuous-increasing-subsequence.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"674.最长连续递增序列","uri":"/674.longest-continuous-increasing-subsequence.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int findLengthOfLCIS(vector\u003cint\u003e \u0026nums) { vector\u003cint\u003e dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i \u003c= nums.size(); i++) { if (nums[i - 1] \u003e nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] \u003e m) m = dp[i]; } return m; } }; ","date":"2022-10-17","objectID":"/674.longest-continuous-increasing-subsequence.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"674.最长连续递增序列","uri":"/674.longest-continuous-increasing-subsequence.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description300.longest-increasing-subsequence ","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.longest increasing subsequence","uri":"/300.longest-increasing-subsequence/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe key point is: what dp[i] means is conducive to solving this problem. Since subsequence may be not continuous, dp[i] should denotes maximum length increaing subsequence ending with nums[i - 1]; Recurrence formula: cpp if (nums[i - 1] \u003e nums[j - 1]) // j \u003c i dp[i] = max(dp[j] + 1, dp[i]) ","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.longest increasing subsequence","uri":"/300.longest-increasing-subsequence/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int lengthOfLIS(vector\u003cint\u003e \u0026nums) { vector\u003cint\u003e dp(nums.size() + 1, 1); // initialize dp[i] as 1 since there is one element at least // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i \u003c= nums.size(); i++) { for (int j = 1; j \u003c i; j++) { if (nums[i - 1] \u003e nums[j - 1]) dp[i] = max(dp[j] + 1, dp[i]); } if (dp[i] \u003e m) m = dp[i]; } return m; } }; ","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.longest increasing subsequence","uri":"/300.longest-increasing-subsequence/#code"},{"categories":["leetcode"],"content":" 1 问题描述300.最长递增子序列 本题简写为LIS问题，与LCS问题（最长公共子序列）相对。 ","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.最长递增子序列","uri":"/300.longest-increasing-subsequence.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.最长递增子序列","uri":"/300.longest-increasing-subsequence.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 动态规划关键在于，dp[i]表示什么含义便于解这道题，子序列不一定连续，所以为了便于求解，dp[i]应该表示为以nums[i - 1]结尾的最长严格递增子序列的长度； 递推关系为: cpp if (nums[i - 1] \u003e nums[j - 1]) // j \u003c i，表示nums[i - 1]前的任意一个元素 dp[i] = max(dp[j] + 1, dp[i]) ","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence.zh/:2:1","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.最长递增子序列","uri":"/300.longest-increasing-subsequence.zh/#动态规划"},{"categories":["leetcode"],"content":" 2.2 贪心动态规划的时间复杂度为$O(n^2)$，这里存在一个时间复杂度更低的贪心解法： 动态规划的时间$O(n^2)$的时间复杂度中，$O(n)$的时间复杂度在与遍历整个数组，这是无法避免的；剩下的$O(n)$的时间复杂度，实际上在找一个满足j \u003c i以及nums[j] \u003c nums[i]的并且使dp[j]最大的j； 那么，可以转化为找dp[j]固定的情况下，最小的一个nums[j]，这样必然能够优先满足，nums[i] \u003e nums[j]；因此我们构造一个贪心数组：min_len，min_len[i] = x表示长度为i的上升子序列的最小结尾元素为x。考虑到min_len一定是个单调递增的数组（易证），那么我们可以基于这个单调递增的特性，利用二分查找，找到满足min_len[j] \u003c nums[i]的最大的j，即利用$O(\\log n)$找到最佳转移位置。 ","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence.zh/:2:2","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.最长递增子序列","uri":"/300.longest-increasing-subsequence.zh/#贪心"},{"categories":["leetcode"],"content":" 3 代码","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.最长递增子序列","uri":"/300.longest-increasing-subsequence.zh/#代码"},{"categories":["leetcode"],"content":" 3.1 动态规划 cpp class Solution { public: int lengthOfLIS(vector\u003cint\u003e \u0026nums) { vector\u003cint\u003e dp(nums.size() + 1, 1); // dp[0]不考虑，至少有一个元素，所以初始化为1 // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i \u003c= nums.size(); i++) { for (int j = 1; j \u003c i; j++) { if (nums[i - 1] \u003e nums[j - 1]) dp[i] = max(dp[j] + 1, dp[i]); } if (dp[i] \u003e m) m = dp[i]; } return m; } }; ","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence.zh/:3:1","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.最长递增子序列","uri":"/300.longest-increasing-subsequence.zh/#动态规划-1"},{"categories":["leetcode"],"content":" 3.2 贪心+二分 cpp class Solution { public: int GetIdx(vector\u003cint\u003e \u0026min_len_tail, int len, int target) { int left = 1, right = len; int mid = left + (right - left) / 2; while (left \u003c right) { if (min_len_tail[mid] \u003c target) { left = mid + 1; } else { right = mid; } mid = left + (right - left) / 2; } return left; } int lengthOfLIS(vector\u003cint\u003e\u0026 nums) { // 贪心，要让序列上升得尽可能慢 // 先找到第一个波谷 int n = nums.size(); vector\u003cint\u003e min_len_tail(n + 1, nums[0]); //min_len_tail[i]表示长度为i的上升子序列的末尾元素的最小值 int len = 1; for (int i = 1; i \u003c n; i++) { if (nums[i] \u003e min_len_tail[len]) { min_len_tail[++len] = nums[i]; } else { int idx = GetIdx(min_len_tail, len, nums[i]); min_len_tail[idx] = nums[i]; } } return len; } }; ","date":"2022-10-17","objectID":"/300.longest-increasing-subsequence.zh/:3:2","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"300.最长递增子序列","uri":"/300.longest-increasing-subsequence.zh/#贪心二分"},{"categories":["leetcode"],"content":" 1 问题描述714.买卖股票的最佳时机含手续费 ","date":"2022-10-14","objectID":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"714.买卖股票的最佳时机含手续费","uri":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路分为手中有股票和无股票两种情况讨论，设定在卖出股票时支出手续费: 手中有股票:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); 手中无股票:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); 初始化: dp[0][0] = -prices[0]; dp[0][1] = -fee; ","date":"2022-10-14","objectID":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"714.买卖股票的最佳时机含手续费","uri":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxProfit(vector\u003cint\u003e \u0026prices, int fee) { vector\u003cvector\u003cint\u003e\u003e dp(prices.size() + 1, vector\u003cint\u003e(2, 0)); dp[0][0] = -prices[0]; dp[0][1] = -fee; for (int i = 1; i \u003c= prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); } return dp[prices.size()][1]; } }; ","date":"2022-10-14","objectID":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"714.买卖股票的最佳时机含手续费","uri":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description714.best-time-to-buy-and-sell-stock-with-transaction-fee ","date":"2022-10-14","objectID":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"714.best time to buy and sell stock with transaction fee","uri":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee/#description"},{"categories":["leetcode"],"content":" 2 解题思路We can consider this problem in two cases: owning stock and not owning stock, assuming that you need to pay transaction fee when selling stock. owning stock:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); not owning stock:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); Initializing dp: dp[0][0] = -prices[0]; dp[0][1] = -fee; ","date":"2022-10-14","objectID":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"714.best time to buy and sell stock with transaction fee","uri":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee/#解题思路"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maxProfit(vector\u003cint\u003e \u0026prices, int fee) { vector\u003cvector\u003cint\u003e\u003e dp(prices.size() + 1, vector\u003cint\u003e(2, 0)); dp[0][0] = -prices[0]; dp[0][1] = -fee; for (int i = 1; i \u003c= prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); } return dp[prices.size()][1]; } }; ","date":"2022-10-14","objectID":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"714.best time to buy and sell stock with transaction fee","uri":"/714.best-time-to-buy-and-sell-stock-with-transaction-fee/#code"},{"categories":["leetcode"],"content":" 1 Description309.best-time-to-buy-and-sell-stock-with-cooldown ","date":"2022-10-13","objectID":"/309.best-time-to-buy-and-sell-stock-with-cooldown/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"309.best time to buy and sell stock with cooldown","uri":"/309.best-time-to-buy-and-sell-stock-with-cooldown/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe key point is find what dp should denote and its recurrence formula. dp[i] indicates only considering first i days, and is devided into five cases: no operation, bought but not sold (stock in hand), exactly sold, cooling off period, and idle, which are noted as dp[i][0], dp[i][1], dp[i][2], dp[i][3], and dp[i][4] correspondingly. Recurrence formula: dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // last day can be on operation, bought but not sold, cooling off period, idle dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // last day can be cooling off period adn idle. ","date":"2022-10-13","objectID":"/309.best-time-to-buy-and-sell-stock-with-cooldown/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"309.best time to buy and sell stock with cooldown","uri":"/309.best-time-to-buy-and-sell-stock-with-cooldown/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { private: int max3(int a, int b, int c) { if (a \u003e b) return a \u003e c ? a : c; else return b \u003e c ? b : c; } int max4(int a, int b, int c, int d) { int l = a \u003e b ? a : b; int r = c \u003e d ? c : d; return l \u003e r ? l : r; } public: int maxProfit(vector\u003cint\u003e \u0026prices) { vector\u003cvector\u003cint\u003e\u003e dp(prices.size() + 1, vector\u003cint\u003e(5, 0)); dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; dp[0][3] = 0; dp[0][4] = 0; for (int i = 1; i \u003c= prices.size(); i++) { dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); } return max3(dp[prices.size()][2], dp[prices.size()][3], dp[prices.size()][4]); } }; ","date":"2022-10-13","objectID":"/309.best-time-to-buy-and-sell-stock-with-cooldown/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"309.best time to buy and sell stock with cooldown","uri":"/309.best-time-to-buy-and-sell-stock-with-cooldown/#code"},{"categories":["leetcode"],"content":" 1 问题描述309.最佳买卖股票时机含冷冻期 ","date":"2022-10-13","objectID":"/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"309.最佳买卖股票时机含冷冻期","uri":"/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题的关键在于找到dp的实际含义，以及它的递推关系; dp[i]表示只考虑前i天的情况，分为无操作、买入未卖出(手中有股票)、正好卖出、冷静期、空闲五种情况，分别记为dp[i][0], dp[i][1], dp[i][2], dp[i][3], dp[i][4]. 递推关系如下: dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // 上一天的可能情况有无操作、买入未卖出、冷静期、空闲四种情况 dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // 上一天可能有冷静期和空闲两种情况 ","date":"2022-10-13","objectID":"/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"309.最佳买卖股票时机含冷冻期","uri":"/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { private: int max3(int a, int b, int c) { if (a \u003e b) return a \u003e c ? a : c; else return b \u003e c ? b : c; } int max4(int a, int b, int c, int d) { int l = a \u003e b ? a : b; int r = c \u003e d ? c : d; return l \u003e r ? l : r; } public: int maxProfit(vector\u003cint\u003e \u0026prices) { vector\u003cvector\u003cint\u003e\u003e dp(prices.size() + 1, vector\u003cint\u003e(5, 0)); dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; dp[0][3] = 0; dp[0][4] = 0; for (int i = 1; i \u003c= prices.size(); i++) { dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); } return max3(dp[prices.size()][2], dp[prices.size()][3], dp[prices.size()][4]); } }; ","date":"2022-10-13","objectID":"/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"309.最佳买卖股票时机含冷冻期","uri":"/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/#代码"},{"categories":[""],"content":" 1 DescriptionAfter version 2021a, in order to reduce the file size, Webots set resource files such as textures and sounds up for network download by github. However, for well-known reasons, github is very inaccessible in China, so there will be errors like: text ERROR: Error downloading EXTERNPROTO 'StraightStairs': Cannot download 'https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/objects/stairs/protos/StraightStairs.proto', error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO 'Spot': Cannot download 'https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/robots/boston_dynamics/spot/protos/Spot.proto', error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO 'Roughcast': Cannot download 'https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/appearances/protos/Roughcast.proto', error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO 'ThreadMetalPlate': Cannot download 'https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/appearances/protos/ThreadMetalPlate.proto', error code: 1: Connection refused which means you can’t download resource files from github. ","date":"2022-10-13","objectID":"/webots_assets_dl/:1:0","series":null,"tags":[""],"title":"solve the problem of downloading assets from github","uri":"/webots_assets_dl/#description"},{"categories":[""],"content":" 2 SolutionWe can change the network preferences in Webots. Click preferences-\u003enetwork, in the proxy column, check SOCKS v5, fill in 127.0.0.1 for Hostname and 7890 for Port. Attention:First of all your own computer should have a proxy, and the port is related to your own settings. ","date":"2022-10-13","objectID":"/webots_assets_dl/:2:0","series":null,"tags":[""],"title":"solve the problem of downloading assets from github","uri":"/webots_assets_dl/#solution"},{"categories":[""],"content":" 1 问题描述Webots在2021a版本后，为了缩小文件大小，将纹理、声音等资源文件设置成网络下载，即需要通过github进行下载，然而由于众所周知的原因，github在国内的可访问性非常差，因此会出现 text ERROR: Error downloading EXTERNPROTO 'StraightStairs': Cannot download 'https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/objects/stairs/protos/StraightStairs.proto', error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO 'Spot': Cannot download 'https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/robots/boston_dynamics/spot/protos/Spot.proto', error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO 'Roughcast': Cannot download 'https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/appearances/protos/Roughcast.proto', error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO 'ThreadMetalPlate': Cannot download 'https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/appearances/protos/ThreadMetalPlate.proto', error code: 1: Connection refused 即无法从github上把资源文件下载下来。 ","date":"2022-10-13","objectID":"/webots_assets_dl.zh/:1:0","series":null,"tags":[""],"title":"解决webots无法从github下载外部资源的问题","uri":"/webots_assets_dl.zh/#问题描述"},{"categories":[""],"content":" 2 解决方案webots的preferences中有关于代理的设置(这也就是为什么系统代理没有生效)，点击preferences-\u003enetwork，在proxy那一栏，勾选SOCKS v5, Hostname填入127.0.0.1，Port填入7890。 注:首先你自己的电脑要有代理，端口(Port)与你自己的设置有关系。 ","date":"2022-10-13","objectID":"/webots_assets_dl.zh/:2:0","series":null,"tags":[""],"title":"解决webots无法从github下载外部资源的问题","uri":"/webots_assets_dl.zh/#解决方案"},{"categories":["leetcode"],"content":" 1 问题描述123.买卖股票的最佳时机III ","date":"2022-10-12","objectID":"/123.best-time-to-buy-and-sell-stock-iii.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"123.买卖股票的最佳时机III","uri":"/123.best-time-to-buy-and-sell-stock-iii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题的关键在于找到dp的实际含义，以及它的递推关系; dp[i]表示只考虑前i天的情况，那么到了第i天，有五种可能的情况: 没有做任何操作，记为dp[i][0]; 前i天发生了一次买入，记为dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) 前i天发生了一次卖出，记为dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) 前i天发生了两次买入，记为dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) 前i天发生了两次卖出，记为dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) 初始化: dp[0][0] = 0; dp[0][1] = -prices[0]; // 发生了一次买入 dp[0][2] = 0; // 买入又卖出 dp[0][3] = -prices[0]; // 买入-\u003e卖出-\u003e买入 dp[0][4] = 0; // 买入-\u003e卖出-\u003e买入-\u003e卖出 ","date":"2022-10-12","objectID":"/123.best-time-to-buy-and-sell-stock-iii.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"123.买卖股票的最佳时机III","uri":"/123.best-time-to-buy-and-sell-stock-iii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: int maxProfit(vector\u003cint\u003e \u0026prices) { vector\u003cvector\u003cint\u003e\u003e dp(prices.size() + 1, vector\u003cint\u003e(5, 0)); dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i \u003c= prices.size(); i++) { dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]); dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]); dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]); dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]); } return dp[prices.size()][4]; } }; ","date":"2022-10-12","objectID":"/123.best-time-to-buy-and-sell-stock-iii.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"123.买卖股票的最佳时机III","uri":"/123.best-time-to-buy-and-sell-stock-iii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description122.best-time-to-buy-and-sell-stock-ii ","date":"2022-10-08","objectID":"/122.best-time-to-buy-and-sell-stock-ii/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"122.best time to buy and sell stock ii","uri":"/122.best-time-to-buy-and-sell-stock-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe key point of this problem is to find the recurrence formula of dp[i]. Let’s discuss this problem in two cases. if prices[i - 1] is not selected, then dp[i] = dp[i - 1]. It shows that: prices[i - 1] \u003c prices[i - 2]; if prices[i - 1] is selected, then prices[i - 1] \u003e= prices[i - 2], dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]. ","date":"2022-10-08","objectID":"/122.best-time-to-buy-and-sell-stock-ii/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"122.best time to buy and sell stock ii","uri":"/122.best-time-to-buy-and-sell-stock-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int maxProfit(vector\u003cint\u003e \u0026prices) { if (prices.size() == 1) return 0; vector\u003cint\u003e dp(prices.size() + 1, 0); for (int i = 2; i \u003c= prices.size(); i++) { if (prices[i - 1] \u003e= prices[i - 2]) dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]; else dp[i] = dp[i - 1]; } return dp[prices.size()]; } }; ","date":"2022-10-08","objectID":"/122.best-time-to-buy-and-sell-stock-ii/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"122.best time to buy and sell stock ii","uri":"/122.best-time-to-buy-and-sell-stock-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述122.买卖股票的最佳时机II ","date":"2022-10-08","objectID":"/122.best-time-to-buy-and-sell-stock-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"122.买卖股票的最佳时机II","uri":"/122.best-time-to-buy-and-sell-stock-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题的关键是要找dp的递推关系，分两种情况讨论: prices[i - 1]不会被选择，那么dp[i] = dp[i - 1]，其实也说明，prices[i - 1] \u003c prices[i - 2]； prices[i - 1]被选择，那么prices[i - 1] \u003e= prices[i - 2]，dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]。 ","date":"2022-10-08","objectID":"/122.best-time-to-buy-and-sell-stock-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"122.买卖股票的最佳时机II","uri":"/122.best-time-to-buy-and-sell-stock-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int maxProfit(vector\u003cint\u003e \u0026prices) { if (prices.size() == 1) return 0; vector\u003cint\u003e dp(prices.size() + 1, 0); for (int i = 2; i \u003c= prices.size(); i++) { if (prices[i - 1] \u003e= prices[i - 2]) dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]; else dp[i] = dp[i - 1]; } return dp[prices.size()]; } }; ","date":"2022-10-08","objectID":"/122.best-time-to-buy-and-sell-stock-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"122.买卖股票的最佳时机II","uri":"/122.best-time-to-buy-and-sell-stock-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description123.best-time-to-buy-and-sell-stock-iii ","date":"2022-10-08","objectID":"/123.best-time-to-buy-and-sell-stock-iii/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"123.best time to buy and sell stock iii","uri":"/123.best-time-to-buy-and-sell-stock-iii/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe key point is to find what dp should denotes and the recursion formula: dp[i] denotes only considering first i days, then by day i, there are five possible cases: no operation, written as dp[i][0]; buy stock once in first i days, written as dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) sell stock once in first i days, written as dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) by stock twice in first i days, written as dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) sell stock twice in first i days, written as dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) Initializaiton: dp[0][0] = 0; dp[0][1] = -prices[0]; // buy once dp[0][2] = 0; // buy-\u003esell dp[0][3] = -prices[0]; // buy-\u003esell-\u003ebuy dp[0][4] = 0; // buy-\u003esell-\u003ebuy-\u003esell ","date":"2022-10-08","objectID":"/123.best-time-to-buy-and-sell-stock-iii/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"123.best time to buy and sell stock iii","uri":"/123.best-time-to-buy-and-sell-stock-iii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: int maxProfit(vector\u003cint\u003e \u0026prices) { vector\u003cvector\u003cint\u003e\u003e dp(prices.size() + 1, vector\u003cint\u003e(5, 0)); dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i \u003c= prices.size(); i++) { dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]); dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]); dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]); dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]); } return dp[prices.size()][4]; } }; ","date":"2022-10-08","objectID":"/123.best-time-to-buy-and-sell-stock-iii/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"123.best time to buy and sell stock iii","uri":"/123.best-time-to-buy-and-sell-stock-iii/#code"},{"categories":["leetcode"],"content":" 1 Description121.best-time-to-buy-and-sell-stock ","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.best time to buy and sell stock","uri":"/121.best-time-to-buy-and-sell-stock/#description"},{"categories":["leetcode"],"content":" 2 Solution","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.best time to buy and sell stock","uri":"/121.best-time-to-buy-and-sell-stock/#solution"},{"categories":["leetcode"],"content":" 2.1 dynamic programmingdp[i] denotes maximum profit in first i days, so the recurrence relation of dp[i] is: dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0). ","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock/:2:1","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.best time to buy and sell stock","uri":"/121.best-time-to-buy-and-sell-stock/#dynamic-programming"},{"categories":["leetcode"],"content":" 2.2 greedy algorithmLet’s use cur to record the minimum element and replace the value of cur if the element is smaller, if the element is larger than cur, calculate the profit, save the maximum profit. ","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock/:2:2","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.best time to buy and sell stock","uri":"/121.best-time-to-buy-and-sell-stock/#greedy-algorithm"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { private: int min(int a, int b) { return a \u003c b ? a : b; } int max(int a, int b, int c) { if (a \u003e b) return a \u003e c ? a : c; else return b \u003e c ? b : c; } public: int maxProfit(vector\u003cint\u003e \u0026prices) { if (prices.size() == 1) return 0; vector\u003cint\u003e min_arr(prices.size() + 1, prices[0]); min_arr[0] = prices[0]; for (int i = 1; i \u003c= prices.size(); i++) { min_arr[i] = min(min_arr[i - 1], prices[i - 1]); } vector\u003cint\u003e dp(prices.size() + 1, 0); for (int i = 1; i \u003c= prices.size(); i++) { dp[i] = max(dp[i - 1], prices[i - 1] - min_arr[i - 1], 0); } return dp[prices.size()]; } }; ","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.best time to buy and sell stock","uri":"/121.best-time-to-buy-and-sell-stock/#code"},{"categories":["leetcode"],"content":" 1 问题描述121.买卖股票的最佳时机 ","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.买卖股票的最佳时机","uri":"/121.best-time-to-buy-and-sell-stock.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.买卖股票的最佳时机","uri":"/121.best-time-to-buy-and-sell-stock.zh/#解题思路"},{"categories":["leetcode"],"content":" 2.1 动态规划dp[i]表示前i天的最大收益，那么dp[i]的递推公式为:dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0)。 ","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock.zh/:2:1","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.买卖股票的最佳时机","uri":"/121.best-time-to-buy-and-sell-stock.zh/#动态规划"},{"categories":["leetcode"],"content":" 2.2 贪心算法利用cur记录最小元素，碰到更小的就替换cur的值，遇到比它大的就进行一次利润计算，保存最大的利润。 ","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock.zh/:2:2","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.买卖股票的最佳时机","uri":"/121.best-time-to-buy-and-sell-stock.zh/#贪心算法"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { private: int min(int a, int b) { return a \u003c b ? a : b; } int max(int a, int b, int c) { if (a \u003e b) return a \u003e c ? a : c; else return b \u003e c ? b : c; } public: int maxProfit(vector\u003cint\u003e \u0026prices) { if (prices.size() == 1) return 0; vector\u003cint\u003e min_arr(prices.size() + 1, prices[0]); min_arr[0] = prices[0]; for (int i = 1; i \u003c= prices.size(); i++) { min_arr[i] = min(min_arr[i - 1], prices[i - 1]); } vector\u003cint\u003e dp(prices.size() + 1, 0); for (int i = 1; i \u003c= prices.size(); i++) { dp[i] = max(dp[i - 1], prices[i - 1] - min_arr[i - 1], 0); } return dp[prices.size()]; } }; ","date":"2022-10-07","objectID":"/121.best-time-to-buy-and-sell-stock.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"121.买卖股票的最佳时机","uri":"/121.best-time-to-buy-and-sell-stock.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述337.打家劫舍III ","date":"2022-10-07","objectID":"/337.house-robber-iii.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"337.打家劫舍III","uri":"/337.house-robber-iii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路严格来说，这一题和198.打家劫舍，213.打家劫舍II的思路并不一致。 首先，这一道题遍历的是树，而不是一个数组。要比较的是选择目前节点和目前节点左子节点+右子节点，因此在遍历方式上需要采取后序遍历。 同时，作为二叉树的问题，一般是考虑递归进行处理： 递归的终止条件： 当前节点为空； 递归函数的返回值： 返回一个长度为2的数组dp，dp[0]表示不偷当前节点的最大金钱，dp[1]表示偷当前节点的最大金钱； 本级递归做什么： 计算偷当前节点的收益val1，不偷当前节点的收益val2，返回{val2, val1}。 ","date":"2022-10-07","objectID":"/337.house-robber-iii.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"337.打家劫舍III","uri":"/337.house-robber-iii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int rob(TreeNode* root) { vector\u003cint\u003e result = robTree(root); return max(result[0], result[1]); } // 长度为2的数组，0：不偷，1：偷 vector\u003cint\u003e robTree(TreeNode* cur) { if (cur == NULL) return vector\u003cint\u003e{0, 0}; vector\u003cint\u003e left = robTree(cur-\u003eleft); vector\u003cint\u003e right = robTree(cur-\u003eright); // 偷cur，那么就不能偷左右节点。 int val1 = cur-\u003eval + left[0] + right[0]; // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况 int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; } }; ","date":"2022-10-07","objectID":"/337.house-robber-iii.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"337.打家劫舍III","uri":"/337.house-robber-iii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description337.house-robber-iii ","date":"2022-10-07","objectID":"/337.house-robber-iii/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"337.house robber iii","uri":"/337.house-robber-iii/#description"},{"categories":["leetcode"],"content":" 2 SolutionStrictly speaking, the idea of this problem is different from 198.house-robber，213.house-robber-ii. At first, what this problem need to traverse is tree, rather than an array. We need to compare selecting curent node with selecting left-child node and right-child node rather than current node. So, we should select postorder traversal. And as a problem of binary tree, we consider recursion. termination conditions of recursion current node is null; return value of recursion function return an array dp of length 2, dp[0] denotes maximum amount when not stealing current node, dp[1] denotes maximum amount when stealing current node; what this level of recursion does calculate the amount val1 when stealing current node, val2 for not stealing current node, return {val2, val1}. ","date":"2022-10-07","objectID":"/337.house-robber-iii/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"337.house robber iii","uri":"/337.house-robber-iii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int rob(TreeNode* root) { vector\u003cint\u003e result = robTree(root); return max(result[0], result[1]); } // array of length 2，0：not stealing，1：stealing vector\u003cint\u003e robTree(TreeNode* cur) { if (cur == NULL) return vector\u003cint\u003e{0, 0}; vector\u003cint\u003e left = robTree(cur-\u003eleft); vector\u003cint\u003e right = robTree(cur-\u003eright); // steal cur，not cur-left, cur-\u003eright int val1 = cur-\u003eval + left[0] + right[0]; // not steal cur，get max(left, right) int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; } }; ","date":"2022-10-07","objectID":"/337.house-robber-iii/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"337.house robber iii","uri":"/337.house-robber-iii/#code"},{"categories":["leetcode"],"content":" 1 Description213.house-robber-ii ","date":"2022-10-07","objectID":"/213.house-robber-ii/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"213.house robber ii","uri":"/213.house-robber-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionReferring to 198.house-robber, there be another constraint that first and last can’t be selected at the same time. So we can split the array into two part: one for [0, n - 1), another for [1, n), corresponding to dp0 and dp1 respectively, just return max(dp0, dp1). ","date":"2022-10-07","objectID":"/213.house-robber-ii/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"213.house robber ii","uri":"/213.house-robber-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int rob(vector\u003cint\u003e\u0026 nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.size() - 2); int result2 = robRange(nums, 1, nums.size() - 1); return max(result1, result2); } int robRange(vector\u003cint\u003e\u0026 nums, int start, int end) { if (end == start) return nums[start]; vector\u003cint\u003e dp(nums.size()); dp[start] = nums[start]; dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i \u003c= end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; } }; ","date":"2022-10-07","objectID":"/213.house-robber-ii/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"213.house robber ii","uri":"/213.house-robber-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述213.打家劫舍II ","date":"2022-10-07","objectID":"/213.house-robber-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"213.打家劫舍II","uri":"/213.house-robber-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路参照198.打家劫舍，但是这里多了一个首尾不能同时选择的选项，因此可以考虑将数组分成两部分，一个包含[0, n - 1)，一个包含[1, n)，分别对应dp0和dp1，取最后两者的最大值即可。 ","date":"2022-10-07","objectID":"/213.house-robber-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"213.打家劫舍II","uri":"/213.house-robber-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int rob(vector\u003cint\u003e\u0026 nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.size() - 2); int result2 = robRange(nums, 1, nums.size() - 1); return max(result1, result2); } int robRange(vector\u003cint\u003e\u0026 nums, int start, int end) { if (end == start) return nums[start]; vector\u003cint\u003e dp(nums.size()); dp[start] = nums[start]; dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i \u003c= end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; } }; ","date":"2022-10-07","objectID":"/213.house-robber-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"213.打家劫舍II","uri":"/213.house-robber-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description198.house-robber ","date":"2022-10-07","objectID":"/198.house-robber/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"198.house robber","uri":"/198.house-robber/#description"},{"categories":["leetcode"],"content":" 2 Solutiondp[i] denotes the maximum amount when the first i houses are considered. Let’s consider the recursive relationship: If the i-th house was stolen, it means that the i - 1th house was not stolen, so dp[i] = dp[i - 2] + a[i - 1]. If the i-th house was not stolen, then dp[i] = dp[i - 1]. So, dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]). ","date":"2022-10-07","objectID":"/198.house-robber/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"198.house robber","uri":"/198.house-robber/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { private: int max(int a, int b) { return a \u003e b ? a : b; } public: int rob(vector\u003cint\u003e \u0026nums) { vector\u003cint\u003e dp(nums.size() + 1, 0); if (nums.size() == 1) return nums[0]; if (nums.size() == 2) return nums[0] \u003e nums[1] ? nums[0] : nums[1]; dp[1] = nums[0]; for (int i = 2; i \u003c= nums.size(); i++) { dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]); } return dp[nums.size()]; } }; ","date":"2022-10-07","objectID":"/198.house-robber/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"198.house robber","uri":"/198.house-robber/#code"},{"categories":["leetcode"],"content":" 1 问题描述198.打家劫舍 ","date":"2022-10-07","objectID":"/198.house-robber.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"198.打家劫舍","uri":"/198.house-robber.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路dp[i]表示考虑前i个房间，能窃取到的最大金额。 考虑递推关系: 假设第要窃取第i个房间，那么说明第i - 1个房间，肯定没有被窃取，dp[i] = dp[i - 2] + nums[i - 1]。 假设不窃取第i个房间，则dp[i] = dp[i - 1]。 综上，dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1])。 ","date":"2022-10-07","objectID":"/198.house-robber.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"198.打家劫舍","uri":"/198.house-robber.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { private: int max(int a, int b) { return a \u003e b ? a : b; } public: int rob(vector\u003cint\u003e \u0026nums) { vector\u003cint\u003e dp(nums.size() + 1, 0); if (nums.size() == 1) return nums[0]; if (nums.size() == 2) return nums[0] \u003e nums[1] ? nums[0] : nums[1]; dp[1] = nums[0]; for (int i = 2; i \u003c= nums.size(); i++) { dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]); } return dp[nums.size()]; } }; ","date":"2022-10-07","objectID":"/198.house-robber.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"198.打家劫舍","uri":"/198.house-robber.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description139.word-break ","date":"2022-10-05","objectID":"/139.word-break/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"139.word Break","uri":"/139.word-break/#description"},{"categories":["leetcode"],"content":" 2 SolutionFirst, we should determine what dp array means. In this problem, dp[i] = 1 denotes that a string of length i can be split into words that appear in the dictionary. So, we can get the recursive relationship:dp[j] = dp[i] \u0026\u0026 substr in [i, j) can be split. To initialize dp array: dp[0] = 1. Attention: we should traverse volume first, then traverse items; if in the reverse order, it’s not convenient to judge whether string can be split. ","date":"2022-10-05","objectID":"/139.word-break/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"139.word Break","uri":"/139.word-break/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cstring\u003e #include \u003cunordered_set\u003e #include \u003cvector\u003e using std::string; using std::unordered_set; using std::vector; class Solution { public: bool wordBreak(string s, vector\u003cstring\u003e \u0026wordDict) { unordered_set\u003cstring\u003e wordSet(wordDict.begin(), wordDict.end()); vector\u003cint\u003e dp(s.length() + 1, 0); // 0 means false dp[0] = 1; // traverse volume first, then items for (int j = 0; j \u003c= s.length(); j++) { for (int i = 0; i \u003c= j; i++) { string word = s.substr(i, j - i); if (wordSet.find(word) != wordSet.end() \u0026\u0026 dp[i]) dp[j] = 1; } } return dp[s.size()]; } }; ","date":"2022-10-05","objectID":"/139.word-break/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"139.word Break","uri":"/139.word-break/#code"},{"categories":["leetcode"],"content":" 1 问题描述139.单词拆分 ","date":"2022-10-05","objectID":"/139.word-break.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"139.单词拆分","uri":"/139.word-break.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先确定dp数组的含义，dp[i] = 1应该表示长度为i的字符串，可以拆分成字典中出现的单词; 则，dp的递推公式为:dp[j] = dp[i] \u0026\u0026 [i, j]区间的字串可以拆分成字典中的单词 初始化dp数组:dp[0] = 1。 这里要注意，先遍历体积，再遍历物品；如果倒过来，是不方便判断字串是否可以拆分的。 ","date":"2022-10-05","objectID":"/139.word-break.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"139.单词拆分","uri":"/139.word-break.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cstring\u003e #include \u003cunordered_set\u003e #include \u003cvector\u003e using std::string; using std::unordered_set; using std::vector; class Solution { public: bool wordBreak(string s, vector\u003cstring\u003e \u0026wordDict) { unordered_set\u003cstring\u003e wordSet(wordDict.begin(), wordDict.end()); vector\u003cint\u003e dp(s.length() + 1, 0); // 0 为false dp[0] = 1; // 先遍历体积，再遍历物品 for (int j = 0; j \u003c= s.length(); j++) { for (int i = 0; i \u003c= j; i++) { string word = s.substr(i, j - i); if (wordSet.find(word) != wordSet.end() \u0026\u0026 dp[i]) dp[j] = 1; } } return dp[s.size()]; } }; ","date":"2022-10-05","objectID":"/139.word-break.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"139.单词拆分","uri":"/139.word-break.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述279.完全平方数 ","date":"2022-10-05","objectID":"/279.perfect-squares.zh/:1:0","series":null,"tags":["data structure and algorithms"],"title":"279.完全平方数","uri":"/279.perfect-squares.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题可以转化成一个完全背包问题，“物品”即{1, 4, 9, 16,...}等完全平方数，体积限制即所给的整数$n$。 ","date":"2022-10-05","objectID":"/279.perfect-squares.zh/:2:0","series":null,"tags":["data structure and algorithms"],"title":"279.完全平方数","uri":"/279.perfect-squares.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { private: int min(int a, int b) { return a \u003c b ? a : b; } public: int numSquares(int n) { int num = 1; for (int i = 1; i * i \u003c= n; i++) num = i; vector\u003cint\u003e nums(num, 0); for (int i = 0; i \u003c num; i++) // nums[i] \u003c= n nums[i] = (i + 1) * (i + 1); vector\u003cint\u003e dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 0; i \u003c num; i++) { for (int j = nums[i]; j \u003c= n; j++) { if (dp[j - nums[i]] \u003c INT_MAX) dp[j] = min(dp[j], dp[j - nums[i]] + 1); } } return dp[n]; } }; ","date":"2022-10-05","objectID":"/279.perfect-squares.zh/:3:0","series":null,"tags":["data structure and algorithms"],"title":"279.完全平方数","uri":"/279.perfect-squares.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description322.coin-change ","date":"2022-10-05","objectID":"/322.coin-change/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"322.coin change","uri":"/322.coin-change/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe recursive relationship change from max to min: dp[j] = min(dp[j], dp[j - coins[i]] + 1). We need pay attention to issue about initializing dp array. To ensure that if j - coins[i] can’t be come up with, dp[j] is still dp[j] in last loop, we should initialize dp as INT_MAX, and dp[0] = 0. Attention: INT_MAX + 1 \u003c INT_MAX(in C++) ","date":"2022-10-05","objectID":"/322.coin-change/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"322.coin change","uri":"/322.coin-change/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003climits.h\u003e #include \u003cvector\u003e using std::vector; class Solution { private: int min(int a, int b) { return a \u003c b ? a : b; } public: int coinChange(vector\u003cint\u003e \u0026coins, int amount) { if (amount == 0) return 0; vector\u003cint\u003e dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i \u003c coins.size(); i++) { for (int j = coins[i]; j \u003c= amount; j++) { // since that we may add dp[j - coins[i]] + 1, // we should ensure that dp[j - coins[i]] is not INT_MAX if (dp[j - coins[i]] != INT_MAX) dp[j] = min(dp[j], dp[j - coins[i]] + 1); } } return dp[amount] != INT_MAX ? dp[amount] : -1; } }; ","date":"2022-10-05","objectID":"/322.coin-change/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"322.coin change","uri":"/322.coin-change/#code"},{"categories":["leetcode"],"content":" 1 问题描述322.零钱兑换 ","date":"2022-10-05","objectID":"/322.coin-change.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"322.零钱兑换","uri":"/322.coin-change.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路首先，递推关系从最大变成了最小，即dp[j] = min(dp[j], dp[j - coins[i]] + 1)。 同时，要注意对dp数组的初始化问题，为了保证j - coins[i]无法组成时，dp[j]选择的仍是上一次i循环的dp[j]，因此要将dp数组初始化为INT_MAX，同时dp[0] = 0。 要注意INT_MAX + 1 \u003c INT_MAX(在C++中) ","date":"2022-10-05","objectID":"/322.coin-change.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"322.零钱兑换","uri":"/322.coin-change.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003climits.h\u003e #include \u003cvector\u003e using std::vector; class Solution { private: int min(int a, int b) { return a \u003c b ? a : b; } public: int coinChange(vector\u003cint\u003e \u0026coins, int amount) { if (amount == 0) return 0; vector\u003cint\u003e dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i \u003c coins.size(); i++) { for (int j = coins[i]; j \u003c= amount; j++) { // 因为可能执行+1的操作， 所以判断dp[j - coins[i]]而不是dp[j] if (dp[j - coins[i]] != INT_MAX) dp[j] = min(dp[j], dp[j - coins[i]] + 1); // else // dp[j] = dp[j - coins[i]]; } } return dp[amount] != INT_MAX ? dp[amount] : -1; } }; ","date":"2022-10-05","objectID":"/322.coin-change.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"322.零钱兑换","uri":"/322.coin-change.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description377.combination-sum-iv ","date":"2022-10-05","objectID":"/377.combination-sum-iv/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"377.combination sum iv","uri":"/377.combination-sum-iv/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem is still a unbounded-knapsack-problem, however, what this problem want to get is permutations rather than combinations. With reference to 518.coin-change-ii, traverse volume first, than traverse items. ","date":"2022-10-05","objectID":"/377.combination-sum-iv/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"377.combination sum iv","uri":"/377.combination-sum-iv/#solution"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int combinationSum4(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cint\u003edp (target + 1, 0); dp[0] = 1; for (int j = 0; j \u003c= target; j++) { for (int i = 0; i \u003c nums.size(); i++) { // prevent overflow, not dp[j] + dp[j - nums[i]] \u003c INT_MAX if (j \u003e= nums[i] \u0026\u0026 dp[j] \u003c INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; ","date":"2022-10-05","objectID":"/377.combination-sum-iv/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"377.combination sum iv","uri":"/377.combination-sum-iv/#代码"},{"categories":["leetcode"],"content":" 1 问题描述377.组合总和IV ","date":"2022-10-05","objectID":"/377.combination-sum-iv.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"377.组合总和IV","uri":"/377.combination-sum-iv.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题依旧是一个完全背包问题，但是本题求的是排列而非组合。 参考518.零钱兑换II，先遍历体积，再遍历物品。 ","date":"2022-10-05","objectID":"/377.combination-sum-iv.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"377.组合总和IV","uri":"/377.combination-sum-iv.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int combinationSum4(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cint\u003edp (target + 1, 0); dp[0] = 1; for (int j = 0; j \u003c= target; j++) { for (int i = 0; i \u003c nums.size(); i++) { // 防止溢出 if (j \u003e= nums[i] \u0026\u0026 dp[j] \u003c INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; ","date":"2022-10-05","objectID":"/377.combination-sum-iv.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"377.组合总和IV","uri":"/377.combination-sum-iv.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description518.coin-change-ii ","date":"2022-10-05","objectID":"/518.coin-change-ii/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"518.coin change ii","uri":"/518.coin-change-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem is still a unbounded-knapsack-problem. What this problem need to solve is combination rather than combination. If we want to get the number of combination, we should traverse items first, than traverse volume. But if you want to get the number of permutation, you should traverse volume first, than traverse items. For example, assume that nums = {1, 2}, target = 3 cpp dp[0] = 1; for (int i = 0; i \u003c 2; i++) { for (int j = nums[i]; j \u003c= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2, combnations: {1, 1, 1}, {1, 2}. cpp dp[0] = 1; for (int j = 0; j \u003c= target; j++) { for (int i = 0; i \u003c 2; i++) { if (j \u003e= nums[i]) dp[j] = dp[j] + dp[j - nums[i]]; } } dp[3] = 3, permutations: {1, 1, 1}, {1, 2}, {2, 1}. ","date":"2022-10-05","objectID":"/518.coin-change-ii/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"518.coin change ii","uri":"/518.coin-change-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int change(int amount, vector\u003cint\u003e\u0026 coins) { vector\u003cint\u003e dp(amount + 1, 0); dp[0] = 1; // attention when initialize for (int i = 0; i \u003c coins.size(); i++) { // traverse items for (int j = coins[i]; j \u003c= amount; j++) { // traverse volume dp[j] += dp[j - coins[i]]; } } return dp[amount]; } }; ","date":"2022-10-05","objectID":"/518.coin-change-ii/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"518.coin change ii","uri":"/518.coin-change-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述518.零钱兑换II ","date":"2022-10-05","objectID":"/518.coin-change-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"518.零钱兑换II","uri":"/518.coin-change-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题依旧是一个完全背包问题，但是本题求的是组合而非排列。 求组合时，先遍历物品，再遍历体积；求排列时，则是先遍历体积，再遍历物品。 例如：假设nums = {1, 2}, target = 3 cpp dp[0] = 1; for (int i = 0; i \u003c 2; i++) { for (int j = nums[i]; j \u003c= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2，选择组合方式为{1, 1, 1}, {1, 2}。 cpp dp[0] = 1; for (int j = 0; j \u003c= target; j++) { for (int i = 0; i \u003c 2; i++) { if (j \u003e= nums[i]) dp[j] = dp[j] + dp[j - nums[i]]; } } dp[3] = 3，选择的排列方式为{1, 1, 1}, {1, 2}, {2, 1}。 ","date":"2022-10-05","objectID":"/518.coin-change-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"518.零钱兑换II","uri":"/518.coin-change-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int change(int amount, vector\u003cint\u003e\u0026 coins) { vector\u003cint\u003e dp(amount + 1, 0); dp[0] = 1; // 初始化要注意 for (int i = 0; i \u003c coins.size(); i++) { // 遍历物品 for (int j = coins[i]; j \u003c= amount; j++) { // 遍历背包 dp[j] += dp[j - coins[i]]; } } return dp[amount]; } }; ","date":"2022-10-05","objectID":"/518.coin-change-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"518.零钱兑换II","uri":"/518.coin-change-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description474.ones-and-zeroes ","date":"2022-10-05","objectID":"/474.ones-and-zeroes/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"474.ones and zeroes","uri":"/474.ones-and-zeroes/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem can be viewed as a two-dimensional 01-knapsack-problem. There are two-dimensional limits about “volume”: numbers of $0$ can not exceed $m$ and numbers of $1$ can not exceed $n$. Recursive relation: dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1) ","date":"2022-10-05","objectID":"/474.ones-and-zeroes/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"474.ones and zeroes","uri":"/474.ones-and-zeroes/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a \u003e= b ? a : b; } public: int findMaxForm(vector\u003cstring\u003e \u0026strs, int m, int n) { vector\u003cvector\u003cint\u003e\u003e str_num(strs.size() + 1, vector\u003cint\u003e(2, 0)); for (int i = 0; i \u003c strs.size(); i++) { for (int j = 0; j \u003c strs[i].size(); j++) { if (strs[i][j] == '0') str_num[i + 1][0]++; else str_num[i + 1][1]++; } } // vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e dp(101, vector\u003cvector\u003cint\u003e\u003e(strs.size() + 1, vector\u003cint\u003e(101, 0))); vector\u003cvector\u003cint\u003e\u003e dp(101, vector\u003cint\u003e(101, 0)); for (int i = 1; i \u003c= strs.size(); i++) { for (int j = m; j \u003e= str_num[i][0]; j--) { for (int k = n; k \u003e= str_num[i][1]; k--) { dp[j][k] = max(dp[j][k], dp[j - str_num[i][0]][k - str_num[i][1]] + 1); } } } // for (int i = 1; i \u003c= strs.size(); i++) { // for (int j = 0; j \u003c=) // } return dp[m][n]; } }; ","date":"2022-10-05","objectID":"/474.ones-and-zeroes/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"474.ones and zeroes","uri":"/474.ones-and-zeroes/#code"},{"categories":["leetcode"],"content":" 1 问题描述474.一和零 ","date":"2022-10-04","objectID":"/474.ones-and-zeroes.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"474.一和零","uri":"/474.ones-and-zeroes.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题可以看成一个二维的01背包问题，体积存在两个维度的限制，即$0$的个数不能超过$m$，$1$的个数不超过$n$。 递推关系:dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1) ","date":"2022-10-04","objectID":"/474.ones-and-zeroes.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"474.一和零","uri":"/474.ones-and-zeroes.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a \u003e= b ? a : b; } public: int findMaxForm(vector\u003cstring\u003e \u0026strs, int m, int n) { vector\u003cvector\u003cint\u003e\u003e str_num(strs.size() + 1, vector\u003cint\u003e(2, 0)); for (int i = 0; i \u003c strs.size(); i++) { for (int j = 0; j \u003c strs[i].size(); j++) { if (strs[i][j] == '0') str_num[i + 1][0]++; else str_num[i + 1][1]++; } } // vector\u003cvector\u003cvector\u003cint\u003e\u003e\u003e dp(101, vector\u003cvector\u003cint\u003e\u003e(strs.size() + 1, vector\u003cint\u003e(101, 0))); vector\u003cvector\u003cint\u003e\u003e dp(101, vector\u003cint\u003e(101, 0)); for (int i = 1; i \u003c= strs.size(); i++) { for (int j = m; j \u003e= str_num[i][0]; j--) { for (int k = n; k \u003e= str_num[i][1]; k--) { dp[j][k] = max(dp[j][k], dp[j - str_num[i][0]][k - str_num[i][1]] + 1); } } } // for (int i = 1; i \u003c= strs.size(); i++) { // for (int j = 0; j \u003c=) // } return dp[m][n]; } }; ","date":"2022-10-04","objectID":"/474.ones-and-zeroes.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"474.一和零","uri":"/474.ones-and-zeroes.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description494.target-sum ","date":"2022-10-04","objectID":"/494.target-sum/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"494.target sum","uri":"/494.target-sum/#description"},{"categories":["leetcode"],"content":" 2 SolutionActually, what we need to do is choose some numbers whose sum is $\\max((sum + target) / 2, (sum - target) / 2)$ in this array. So we can change this problem to a 01-knapsack-problem, and dynamic programming can be used to solve this problem. Also, backtracking can be used to solve this problem. In this problem, dp[i][j] should denotes the number of methods to make the sum of number selected to be j when considering the first i numbers. ","date":"2022-10-04","objectID":"/494.target-sum/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"494.target sum","uri":"/494.target-sum/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { private: int max(int a, int b) { return a \u003e b ? a : b; } public: int findTargetSumWays(vector\u003cint\u003e \u0026nums, int target) { int sum = 0; vector\u003cint\u003e my_num(nums.size() + 1, 0); for (int i = 0; i \u003c nums.size(); i++) { sum += nums[i]; my_num[i + 1] = nums[i]; } if ((sum + target) % 2 == 1) return 0; vector\u003cint\u003e res(1001, 0); res[0] = 1; target = max((sum + target) / 2, (sum - target) / 2); // int cnt = 0; for (int i = 1; i \u003c= nums.size(); i++) { for (int j = target; j \u003e= my_num[i]; j--) { // if (my_num[i] == 0) // res[j] = res[j] + 1; // else // res[j] = max(res[j], res[j - my_num[i]]); res[j] = res[j] + res[j - my_num[i]]; } } return res[target]; } }; ","date":"2022-10-04","objectID":"/494.target-sum/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"494.target sum","uri":"/494.target-sum/#code"},{"categories":["leetcode"],"content":" 1 问题描述494.目标和 ","date":"2022-10-04","objectID":"/494.target-sum.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"494.目标和","uri":"/494.target-sum.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题表面上说添加’+‘或者’-’，实际上就是在这个数组中选择一些数，使这些数的总和为$\\max((sum + target) / 2, (sum - target) / 2)$。从而转换成01背包问题，利用动态规划求解，当然也可以利用回溯法求解。 在本题中，dp[i][j]应该表示为考虑前i个数时，使选择的数总和为j的方法数。 ","date":"2022-10-04","objectID":"/494.target-sum.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"494.目标和","uri":"/494.target-sum.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { private: int max(int a, int b) { return a \u003e b ? a : b; } public: int findTargetSumWays(vector\u003cint\u003e \u0026nums, int target) { int sum = 0; vector\u003cint\u003e my_num(nums.size() + 1, 0); for (int i = 0; i \u003c nums.size(); i++) { sum += nums[i]; my_num[i + 1] = nums[i]; } if ((sum + target) % 2 == 1) return 0; vector\u003cint\u003e res(1001, 0); res[0] = 1; target = max((sum + target) / 2, (sum - target) / 2); // int cnt = 0; for (int i = 1; i \u003c= nums.size(); i++) { for (int j = target; j \u003e= my_num[i]; j--) { // if (my_num[i] == 0) // res[j] = res[j] + 1; // else // res[j] = max(res[j], res[j - my_num[i]]); res[j] = res[j] + res[j - my_num[i]]; } } return res[target]; } }; ","date":"2022-10-04","objectID":"/494.target-sum.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"494.目标和","uri":"/494.target-sum.zh/#代码"},{"categories":["notes"],"content":"UKP","date":"2022-10-04","objectID":"/unbounded-knapsack-problem/","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"unbounded knapsack problem","uri":"/unbounded-knapsack-problem/"},{"categories":["notes"],"content":" 1 DescriptionUnbounded Knapsack Problem There are $N$ kinds of items and a knapsack with the capacity of $V$, each item has unlimited pieces available. The volume of the $i$-th item is $v_i$, and value is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen’t exceed the capacity of the pack. ","date":"2022-10-04","objectID":"/unbounded-knapsack-problem/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"unbounded knapsack problem","uri":"/unbounded-knapsack-problem/#description"},{"categories":["notes"],"content":" 2 SolutionIt’s a classic problem of dynamic programming and knapsack problem. We can solve the problem in two ways. ","date":"2022-10-04","objectID":"/unbounded-knapsack-problem/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"unbounded knapsack problem","uri":"/unbounded-knapsack-problem/#solution"},{"categories":["notes"],"content":" 2.1 Create a new inner loopFor 01-pack-problem, each item can be used only once, while for UKP, we just need to add another layer of loops to the inner loop about volume, enumerating how many items $i$ are used in total. cpp for (int i = 1; i \u003c= n; i++) { for (int j = m; j \u003e= v[i]; j--) { for (k = 1; k * v[i] \u003c= j; k++) { dp[j] = max(dp[j], dp[j - k * v[i] + k * w[i]); } } } ","date":"2022-10-04","objectID":"/unbounded-knapsack-problem/:2:1","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"unbounded knapsack problem","uri":"/unbounded-knapsack-problem/#create-a-new-inner-loop"},{"categories":["notes"],"content":" 2.2 Change traversing directionFor 01-pack-problem, the inner loop about volume, is from large to small. This is to ensure that when dp[j - v[i] + w[i] is compared with dp[j], the value used is the same as that in last loop. While in UKP, the inner loop about volume, we can just change it to “from small to large”, then in dp = max(dp[j], dp[j - v[i] + w[i]]), the value of dp[j - v[i]] + w[i] is that in current loop. While in i loop, dp[j - v[i]] = max(dp[j - v[i]], dp[(j - v[i]) - v[i]] + w[i]), in descending order, we can always find the maximum value: dp[j - k * v[i]] + k * w[i]($k$ could be 0). Actually, in inner loop about volume, traversing from large to small ensures that each item can be used only once, while traversing from small to large ensures that each item can be used unlimitedly. cpp for (int i = 1; i \u003c= n; i++) { for (int j = v[i]; j \u003c= m; j++) { dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } ","date":"2022-10-04","objectID":"/unbounded-knapsack-problem/:2:2","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"unbounded knapsack problem","uri":"/unbounded-knapsack-problem/#change-traversing-direction"},{"categories":["notes"],"content":" 3 Examples 518.coin-change-ii 518.coin-change-ii-solution 377.combination-sum-iv 377.combination-sum-iv-solution 322.coin-change 322.coin-change-solution ","date":"2022-10-04","objectID":"/unbounded-knapsack-problem/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"unbounded knapsack problem","uri":"/unbounded-knapsack-problem/#examples"},{"categories":["notes"],"content":"UKP","date":"2022-10-03","objectID":"/unbounded-knapsack-problem.zh/","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"完全背包问题","uri":"/unbounded-knapsack-problem.zh/"},{"categories":["notes"],"content":" 1 问题描述完全背包问题 有$N$件物品和一个容量是$V$的背包，每件物品都有无限件可用。 第$i$种物品的体积是$v_i$，价值是$w_i$。求解将哪些物品装入背包，可使这些物品总体积不超过背包容量，且总价值最大。 ","date":"2022-10-03","objectID":"/unbounded-knapsack-problem.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"完全背包问题","uri":"/unbounded-knapsack-problem.zh/#问题描述"},{"categories":["notes"],"content":" 2 解题思路","date":"2022-10-03","objectID":"/unbounded-knapsack-problem.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"完全背包问题","uri":"/unbounded-knapsack-problem.zh/#解题思路"},{"categories":["notes"],"content":" 2.1 内层嵌套循环01背包问题 每样物品只能使用一件，而针对完全背包问题，我们只需要在内层有关体积的循环中，再添加一层循环，枚举一共使用了多少件物品$i$即可。 cpp for (int i = 1; i \u003c= n; i++) { for (int j = m; j \u003e= v[i]; j--) { for (k = 1; k * v[i] \u003c= j; k++) { dp[j] = max(dp[j], dp[j - k * v[i] + k * w[i]); } } } ","date":"2022-10-03","objectID":"/unbounded-knapsack-problem.zh/:2:1","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"完全背包问题","uri":"/unbounded-knapsack-problem.zh/#内层嵌套循环"},{"categories":["notes"],"content":" 2.2 更改遍历方向在01背包问题中，我们内层关于体积的循环，是从大到小的，这是为了保证在比较max(dp[j], dp[j - v[i]] + w[i])时，使用的是上一次i循环的数值； 而在完全背包问题中，内层关于体积的循环，修改成从小到大即可，此时dp = max(dp[j], dp[j - v[i]] + w[i])中，dp[j - v[i]] + w[i]使用的就是本次i循环中的数值，而i循环中,dp[j - v[i]] = max(dp[j - v[i]], dp[(j - v[i]) - v[i]] + w[i]),依次往前递推，总能找到那个最大值dp[j - k * v[i]] + k * w[i]。 事实上，内层的体积循环中，遍历方向由大到小就是保证每个物品只使用一次，由小到大则是可以使用无限次。 cpp for (int i = 1; i \u003c= n; i++) { for (int j = v[i]; j \u003c= m; j++) { dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } ","date":"2022-10-03","objectID":"/unbounded-knapsack-problem.zh/:2:2","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"完全背包问题","uri":"/unbounded-knapsack-problem.zh/#更改遍历方向"},{"categories":["notes"],"content":" 3 例题 518.零钱兑换II 518.零钱兑换II-题解 377.组合总和IV 377.组合总和IV-题解 322.零钱兑换 322.零钱兑换-题解 ","date":"2022-10-03","objectID":"/unbounded-knapsack-problem.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"完全背包问题","uri":"/unbounded-knapsack-problem.zh/#例题"},{"categories":["leetcode"],"content":" 1 Description1049.last-stone-weight-ii ","date":"2022-10-01","objectID":"/1049.last-stone-weight-ii/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1049.last stone weight ii","uri":"/1049.last-stone-weight-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionIn reality, it’s still a 01-pack-problem. What it want to get is when you divide the array into two part with least difference of their sum, what the difference is. If you are aware of this, just write code similar to 416.partition-equal-subset-sum. ","date":"2022-10-01","objectID":"/1049.last-stone-weight-ii/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1049.last stone weight ii","uri":"/1049.last-stone-weight-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { private: int max(int a, int b) { return a \u003e b ? a : b; } public: int lastStoneWeightII(vector\u003cint\u003e \u0026stones) { int sum = 0; for (int i = 0; i \u003c stones.size(); i++) { sum += stones[i]; } vector\u003cint\u003e dp(sum / 2 + 1, 0); for (int i = 0; i \u003c stones.size(); i++) { for (int j = sum / 2; j \u003e= stones[i]; j--) dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); } return sum - 2 * dp[sum / 2]; } }; ","date":"2022-10-01","objectID":"/1049.last-stone-weight-ii/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1049.last stone weight ii","uri":"/1049.last-stone-weight-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述1049.最后一块石头的重量II ","date":"2022-10-01","objectID":"/1049.last-stone-weight-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1049.最后一块石头的重量II","uri":"/1049.last-stone-weight-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路实际上还是一个01背包问题。本质上是在求将数组分成差值最小的两部分之后，这两部分的差值，理解了这一点之后，参照416.分割等和子集写代码就好了。 ","date":"2022-10-01","objectID":"/1049.last-stone-weight-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1049.最后一块石头的重量II","uri":"/1049.last-stone-weight-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { private: int max(int a, int b) { return a \u003e b ? a : b; } public: int lastStoneWeightII(vector\u003cint\u003e \u0026stones) { int sum = 0; for (int i = 0; i \u003c stones.size(); i++) { sum += stones[i]; } vector\u003cint\u003e dp(sum / 2 + 1, 0); for (int i = 0; i \u003c stones.size(); i++) { for (int j = sum / 2; j \u003e= stones[i]; j--) dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); } return sum - 2 * dp[sum / 2]; } }; ","date":"2022-10-01","objectID":"/1049.last-stone-weight-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"1049.最后一块石头的重量II","uri":"/1049.last-stone-weight-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述416.分割等和子集 ","date":"2022-10-01","objectID":"/416.partition-equal-subset-sum.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"416.分割等和子集","uri":"/416.partition-equal-subset-sum.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路本题实际上是一个01背包问题，在这个问题中，背包的体积$V$是数组中所有数的的和的一半(向下取整)，物品的价值就是数组中数的取值： ","date":"2022-10-01","objectID":"/416.partition-equal-subset-sum.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"416.分割等和子集","uri":"/416.partition-equal-subset-sum.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003calgorithm\u003e #include \u003cvector\u003e using std::vector; class Solution { private: int max(int a, int b) { return a \u003e= b ? a : b; } public: bool canPartition(vector\u003cint\u003e \u0026nums) { int sum = 0; int sum_half = 0; for (int i = 0; i \u003c nums.size(); i++) { sum += nums[i]; } if (sum % 2 == 1) return false; sum_half = sum / 2; vector\u003cint\u003e dp(sum_half + 1, 0); for (int i = 0; i \u003c nums.size(); i++) { for (int j = sum_half; j \u003e= nums[i]; j--) dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); } return dp[sum_half] == sum_half; } }; ","date":"2022-10-01","objectID":"/416.partition-equal-subset-sum.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"416.分割等和子集","uri":"/416.partition-equal-subset-sum.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description416.partition-equal-subset-sum ","date":"2022-10-01","objectID":"/416.partition-equal-subset-sum/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"416.partition equal subset sum","uri":"/416.partition-equal-subset-sum/#description"},{"categories":["leetcode"],"content":" 2 SolutionThis problem can be viewed as one case of 01-pack-problem In this problem, the volume of pack $V$ is half of sum of all integers in the array(rounded down), the value of item is just value of integer in the array. ","date":"2022-10-01","objectID":"/416.partition-equal-subset-sum/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"416.partition equal subset sum","uri":"/416.partition-equal-subset-sum/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003calgorithm\u003e #include \u003cvector\u003e using std::vector; class Solution { private: int max(int a, int b) { return a \u003e= b ? a : b; } public: bool canPartition(vector\u003cint\u003e \u0026nums) { int sum = 0; int sum_half = 0; for (int i = 0; i \u003c nums.size(); i++) { sum += nums[i]; } if (sum % 2 == 1) return false; sum_half = sum / 2; vector\u003cint\u003e dp(sum_half + 1, 0); for (int i = 0; i \u003c nums.size(); i++) { for (int j = sum_half; j \u003e= nums[i]; j--) dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); } return dp[sum_half] == sum_half; } }; ","date":"2022-10-01","objectID":"/416.partition-equal-subset-sum/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"416.partition equal subset sum","uri":"/416.partition-equal-subset-sum/#code"},{"categories":["notes"],"content":"notes and thoughts about 01-pack-problem","date":"2022-10-01","objectID":"/01-pack-problem/","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"01 kanpsack problem","uri":"/01-pack-problem/"},{"categories":["notes"],"content":" 1 Description01-pack-problem There are $N$ items and a pack with capacity of $V$, and each item can only be used once. The volume of the $i$-th item is $v_i$, and vaule is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen’t exceed the capacity of the pack. ","date":"2022-10-01","objectID":"/01-pack-problem/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"01 kanpsack problem","uri":"/01-pack-problem/#description"},{"categories":["notes"],"content":" 2 SolutionIt’s a classic problem of dynamic programming. First, let’s consider the sense of dp[i][j], which i means we only consider the first i items(i: $1\\sim N$). So, dp[i][j] denotes the greatest value of items in pack in circumstance that total volume of items in pack is $j$ and only the first i items are considered(There may not be i items in pack). We can consider the recursive relation of dp[i][j] in two cases. When i-th item is not in pack: dp[i][j] = dp[i - 1][j] In this case, only first i - 1 items are considered and total volume is still j. When i-th item is in pack, dp[i][j] = dp[i - 1][j - v[i]] + w[i] In this case, volume of the first i - 1 items considered is j - v[i]. ","date":"2022-10-01","objectID":"/01-pack-problem/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"01 kanpsack problem","uri":"/01-pack-problem/#solution"},{"categories":["notes"],"content":" 3 Code cpp #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; const int N = 1010; // volume is less than 1000， number of items is small than 1000. int main() { int n, m; // n denotes number of items，m denotes capacity of pack cin \u003e\u003e n \u003e\u003e m; int dp[N][N] = {0}; int v[N] = {0}; // volume int w[N] = {0}; // value for (int i = 1; i \u003c=n; i++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; if (j \u003e= v[i]) // Total volume can't be less than v[i] dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } // int res = 0; // for (int j = 1; j \u003c=m; j++) { // res = max(res, dp[n][j]); // Traversal is not needed, just dp[n][m] // } cout \u003c\u003c dp[n][m] \u003c\u003c endl; return 0; } ","date":"2022-10-01","objectID":"/01-pack-problem/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"01 kanpsack problem","uri":"/01-pack-problem/#code"},{"categories":["notes"],"content":" 4 OptimizationIf we analyze the code above, we can find only dp[i - 1][j] is needed to caculate dp[i][j], dp[i - 2][j], dp[i - 3][j] is not needed. So one dimension is enough for dp array, which the total volume is index of array. So, what if it’s directly written as: cpp for (int i = 1; i \u003c n; i++) { for (int j = 1; j \u003c= m; j++) if (j \u003e= v[i]) // max actually: // max(dp[i][j], dp[i][j - v[i]] + w[i]) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } The answer is NO! The reason is showed in the comment in the code above. It should be max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]). The correct way to write it should be: cpp for (int i = 1; i \u003c n; i++) { for (int j = m; j \u003e= v[i]; j--) // Because dp[j], dp[j - v[i]] was assigned value in last outer `i` loop， // so it's the same with dp[i - 1][j - v[i]]. dp[j] = max(dp[j], dp[j - v[i]] + w[i]) } If dp[0] = 0, dp[i] = -INF，so the state can only be transformed from dp[0], which can solve for the case that the total volume is exactly $V$. The whole code after optimization: cpp #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; const int N = 1010; // volume is less than 1000， number of items is small than 1000. int main() { int n, m; // n denotes number of items，m denotes capacity of pack cin \u003e\u003e n \u003e\u003e m; int dp[N][N] = {0}; int v[N] = {0}; // volume int w[N] = {0}; // value for (int i = 1; i \u003c=n; i++) cin \u003e\u003e v[i] \u003e\u003e w[i]; for (int i = 1; i \u003c= n; i++) { for (int j = m; j \u003e= v[i]; j--) { // Total volume can't be less than v[i] dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } // int res = 0; // for (int j = 1; j \u003c=m; j++) { // res = max(res, dp[n][j]); // Traversal is not needed, just dp[n][m] // } cout \u003c\u003c dp[m] \u003c\u003c endl; return 0; } ","date":"2022-10-01","objectID":"/01-pack-problem/:4:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"01 kanpsack problem","uri":"/01-pack-problem/#optimization"},{"categories":["notes"],"content":" 5 Examples 416.partition-equal-subset-sum 416.partition-equal-subset-sum-solution 1049.last-stone-weight-ii 1049.last-stone-weight-ii-solution 494.target-sum 494.target-sum-solution 474.ones-and-zeroes 474.ones-and-zeroes-solution ","date":"2022-10-01","objectID":"/01-pack-problem/:5:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"01 kanpsack problem","uri":"/01-pack-problem/#examples"},{"categories":["notes"],"content":" 1 DescriptionUsually, One-dimensional dynamic planning problem, the parameter is always $n$, the result is similar to number sequence $a_n$, or $f(n)$($f$ can be viewed as function or corresponding relationship). At the same time, there will be certain corresponding relationship between $a_n$ and $a_{n - 1}, a_{n - 2}…a_{1}$, such as $a_n = a_{n-1} + a_{n-2}$(fibonacci sequence). ","date":"2022-09-29","objectID":"/dynamic-programming/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"Dynamic Programming","uri":"/dynamic-programming/#description"},{"categories":["notes"],"content":" 2 SolutionNumber sequence can be corresponded with array in programming language such as C++. If you find the recursive relationship among number sequence, you can write traversal code using for loop to get the answer. ","date":"2022-09-29","objectID":"/dynamic-programming/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"Dynamic Programming","uri":"/dynamic-programming/#solution"},{"categories":["notes"],"content":" 3 Examples 509.fibonacci-number 509.fibonacci-number-solution 70.climbing-stairs 70.climbing-stairs-solution 746.min-cost-climbing-stairs 746.min-cost-climbing-stairs-solution 343.integer-break 343.integer-break-solution 62.unique-paths 62.unique-paths-solution 63.unique-paths-ii 63.unique-paths-ii-solution ","date":"2022-09-29","objectID":"/dynamic-programming/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"Dynamic Programming","uri":"/dynamic-programming/#examples"},{"categories":["leetcode"],"content":" 1 Description746.min-cost-climbing-stairs ","date":"2022-09-29","objectID":"/746.min-cost-climbing-stairs/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"746.min cost climbing stairs","uri":"/746.min-cost-climbing-stairs/#description"},{"categories":["leetcode"],"content":" 2 SolutionIt’s like 70.climbing-stairs plus, the recursive relationship becomes more complicated, but the essence is the same. $$dp_n = \\min\\[dp_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2]\\]$$ After get the recursive relationship, we can write traversal code to get the answer using for loop. ","date":"2022-09-29","objectID":"/746.min-cost-climbing-stairs/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"746.min cost climbing stairs","uri":"/746.min-cost-climbing-stairs/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: int minCostClimbingStairs(vector\u003cint\u003e \u0026cost) { int sz = cost.size(); vector\u003cint\u003e dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] \u003c cost[1] ? cost[0] : cost[1]; for (int i = 2; i \u003c= sz; i++) { // Original, space: O(n) // dp[i] = (dp[i - 2] + cost[i - 2]) \u003c (dp[i - 1] + cost[i - 1]) ? (dp[i - 2] + cost[i - 2]) : (dp[i - 1] + cost[i - 1]); // Space optimized: int res = dp[0] + cost[i - 2] \u003c dp[1] + cost[i - 1] ? dp[0] + cost[i - 2] : dp[1] + cost[i - 1]; dp[0] = dp[1]; dp[1] = res; } return dp[1]; } }; ","date":"2022-09-29","objectID":"/746.min-cost-climbing-stairs/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"746.min cost climbing stairs","uri":"/746.min-cost-climbing-stairs/#code"},{"categories":["leetcode"],"content":" 1 Description509.fibonacci number ","date":"2022-09-29","objectID":"/509.fibonacci-number/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"509.fibonacci number","uri":"/509.fibonacci-number/#description"},{"categories":["leetcode"],"content":" 2 Solution$a_n = a_{n - 1} + a_{n - 2}$. Based on the recursive relationship, we can easily write traversal code using for loop. ","date":"2022-09-29","objectID":"/509.fibonacci-number/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"509.fibonacci number","uri":"/509.fibonacci-number/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int fib(int N) { if (N \u003c= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i \u003c= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; ","date":"2022-09-29","objectID":"/509.fibonacci-number/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"509.fibonacci number","uri":"/509.fibonacci-number/#code"},{"categories":["leetcode"],"content":" 1 Description343.integer-break ","date":"2022-09-29","objectID":"/343.integer-break/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"343.integer break","uri":"/343.integer-break/#description"},{"categories":["leetcode"],"content":" 2 SolutionThe key point is still find the recursive relationship. Notice that when $n \u003e 4$, $dp_n = \\max \\[dp_{n - 3} * 3,\\ dp_{n - 4} * 4\\] $. So we can easily write traversal code using for loop. ","date":"2022-09-29","objectID":"/343.integer-break/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"343.integer break","uri":"/343.integer-break/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int get_max(int a, int b) { return a \u003e b ? a : b; } int integerBreak(int n) { vector\u003cint\u003e res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i \u003c 4; i++) res[i] = i + 1; for (int i = 4; i \u003c n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; ","date":"2022-09-29","objectID":"/343.integer-break/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"343.integer break","uri":"/343.integer-break/#code"},{"categories":["leetcode"],"content":" 1 Description70.climbing-stairs ","date":"2022-09-29","objectID":"/70.climbing-stairs/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"70.climbing stairs","uri":"/70.climbing-stairs/#description"},{"categories":["leetcode"],"content":" 2 SolutionActually, it’s the same with 509.fibonacci-number. Let $dp_n$ be the number of ways to get to the top, then we have: $$dp_n = dp_{n - 1} + dp_{n - 2}$$ So we can write the traversal code of for loop. ","date":"2022-09-29","objectID":"/70.climbing-stairs/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"70.climbing stairs","uri":"/70.climbing-stairs/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i \u003c n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; ","date":"2022-09-29","objectID":"/70.climbing-stairs/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"70.climbing stairs","uri":"/70.climbing-stairs/#code"},{"categories":["leetcode"],"content":" 1 Description63.unique-paths-ii ","date":"2022-09-29","objectID":"/63.unique-paths-ii/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"63.unique paths ii","uri":"/63.unique-paths-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionCompared with 62.unique-paths, the main difference is that you need to change $dp_{mn}$ when hitting an obstacle(obstacleGrid[i][j] = 0). Just set dp[i][j] = 0. And you need pay attention to judging the conditionality in for loop. When i = 0 or j = 0, dp[i][j] = dp[i][j - 1] or dp[i][j] = dp[i - 1][j]. dp[0][0] = 0. ","date":"2022-09-29","objectID":"/63.unique-paths-ii/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"63.unique paths ii","uri":"/63.unique-paths-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: int uniquePathsWithObstacles(vector\u003cvector\u003cint\u003e\u003e \u0026obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector\u003cvector\u003cint\u003e\u003e dp(m, vector\u003cint\u003e(n, 0)); dp[0][0] = 1; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (i == 0 \u0026\u0026 j == 0) { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = 1; } else { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else { if (i == 0) dp[i][j] = dp[i][j - 1]; else if (j == 0) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } } return dp[m - 1][n - 1]; } }; ","date":"2022-09-29","objectID":"/63.unique-paths-ii/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"63.unique paths ii","uri":"/63.unique-paths-ii/#code"},{"categories":["leetcode"],"content":" 1 Description62.unique-paths ","date":"2022-09-29","objectID":"/62.unique-paths/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"62.unique paths","uri":"/62.unique-paths/#description"},{"categories":["leetcode"],"content":" 2 Solution$dp_{mn}$ means the number of paths from (1, 1) to (m, n). Just find the connection among $dp_{mn}, dp_{(m-1)n}, dp_{m(n-1)}$. We have: $$dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$$ Based on the relationship, we can write the traversal code using for loop. ","date":"2022-09-29","objectID":"/62.unique-paths/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"62.unique paths","uri":"/62.unique-paths/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector\u003cvector\u003cint\u003e\u003e dp(m + 1, vector\u003cint\u003e(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i \u003c= m; i++) { for (int j = 1; j \u003c= n; j++) { if (i == 1 \u0026\u0026 j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; ","date":"2022-09-29","objectID":"/62.unique-paths/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"62.unique paths","uri":"/62.unique-paths/#code"},{"categories":["leetcode"],"content":" 1 题目描述343.整数拆分 ","date":"2022-09-29","objectID":"/343.integer-break.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"343.整数拆分","uri":"/343.integer-break.zh/#题目描述"},{"categories":["leetcode"],"content":" 2 解题思路还是寻找递推关系,设$dp_n$为正整数$n$所求的最大乘积。 这里可以注意到:$n \u003e 4$时， $dp_n = \\max \\[dp_{n - 3} * 3,\\ dp_{n - 4} * 4\\] $。 根据递推关系写出for循环递推求解。 ","date":"2022-09-29","objectID":"/343.integer-break.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"343.整数拆分","uri":"/343.integer-break.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int get_max(int a, int b) { return a \u003e b ? a : b; } int integerBreak(int n) { vector\u003cint\u003e res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i \u003c 4; i++) res[i] = i + 1; for (int i = 4; i \u003c n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; ","date":"2022-09-29","objectID":"/343.integer-break.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"343.整数拆分","uri":"/343.integer-break.zh/#代码"},{"categories":["leetcode"],"content":" 1 题目描述63.不同路径II ","date":"2022-09-29","objectID":"/63.unique-paths-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"63.不同路径II","uri":"/63.unique-paths-ii.zh/#题目描述"},{"categories":["leetcode"],"content":" 2 解题思路相比62.不同路径II， 主要是多了障碍物地判断，设$obstacleGrid[i][j] = 0$，则$dp_{{i}{j}} = 0$，其余递推关系相同。 注意for循环遍历地过程中的条件判断。当i = 0或j = 0，dp[i][j] = dp[i][j - 1]或dp[i][j] = dp[i - 1][j]。 dp[0][0] = 0。 ","date":"2022-09-29","objectID":"/63.unique-paths-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"63.不同路径II","uri":"/63.unique-paths-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: int uniquePathsWithObstacles(vector\u003cvector\u003cint\u003e\u003e \u0026obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector\u003cvector\u003cint\u003e\u003e dp(m, vector\u003cint\u003e(n, 0)); dp[0][0] = 1; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (i == 0 \u0026\u0026 j == 0) { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = 1; } else { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else { if (i == 0) dp[i][j] = dp[i][j - 1]; else if (j == 0) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } } return dp[m - 1][n - 1]; } }; ","date":"2022-09-29","objectID":"/63.unique-paths-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"63.不同路径II","uri":"/63.unique-paths-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 问题描述62.不同路径 ","date":"2022-09-29","objectID":"/62.unique-paths.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"62.不同路径","uri":"/62.unique-paths.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路还是找递推关系： $dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$ ","date":"2022-09-29","objectID":"/62.unique-paths.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"62.不同路径","uri":"/62.unique-paths.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector\u003cvector\u003cint\u003e\u003e dp(m + 1, vector\u003cint\u003e(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i \u003c= m; i++) { for (int j = 1; j \u003c= n; j++) { if (i == 1 \u0026\u0026 j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; ","date":"2022-09-29","objectID":"/62.unique-paths.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"62.不同路径","uri":"/62.unique-paths.zh/#代码"},{"categories":["leetcode"],"content":" 1 题目描述746.使用最小花费爬楼梯 ","date":"2022-09-29","objectID":"/746.min-cost-climbing-stairs.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"746.使用最小花费爬楼梯","uri":"/746.min-cost-climbing-stairs.zh/#题目描述"},{"categories":["leetcode"],"content":" 2 解题思路相当于爬楼梯的进阶版，递推关系变复杂了一些，但本质没有变。 $a_n = min(a_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2])$ 写出递推关系后就能很方便地写出for循环来遍历求解。 ","date":"2022-09-29","objectID":"/746.min-cost-climbing-stairs.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"746.使用最小花费爬楼梯","uri":"/746.min-cost-climbing-stairs.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e using std::vector; class Solution { public: int minCostClimbingStairs(vector\u003cint\u003e \u0026cost) { int sz = cost.size(); vector\u003cint\u003e dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] \u003c cost[1] ? cost[0] : cost[1]; for (int i = 2; i \u003c= sz; i++) { // 原始版本 // dp[i] = (dp[i - 2] + cost[i - 2]) \u003c (dp[i - 1] + cost[i - 1]) ? (dp[i - 2] + cost[i - 2]) : (dp[i - 1] + cost[i - 1]); // 空间优化版本： int res = dp[0] + cost[i - 2] \u003c dp[1] + cost[i - 1] ? dp[0] + cost[i - 2] : dp[1] + cost[i - 1]; dp[0] = dp[1]; dp[1] = res; } return dp[1]; } }; ","date":"2022-09-29","objectID":"/746.min-cost-climbing-stairs.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"746.使用最小花费爬楼梯","uri":"/746.min-cost-climbing-stairs.zh/#代码"},{"categories":["leetcode"],"content":" 1 题目描述70.爬楼梯 ","date":"2022-09-28","objectID":"/70.climbing-stairs.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"70.爬楼梯","uri":"/70.climbing-stairs.zh/#题目描述"},{"categories":["leetcode"],"content":" 2 解题思路本质上与斐波那契数是一样的：$a_n = a_{n - 1} + a_{n - 2}$ 构建for循环来遍历。 ","date":"2022-09-28","objectID":"/70.climbing-stairs.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"70.爬楼梯","uri":"/70.climbing-stairs.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i \u003c n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; ","date":"2022-09-28","objectID":"/70.climbing-stairs.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"70.爬楼梯","uri":"/70.climbing-stairs.zh/#代码"},{"categories":["leetcode"],"content":" 1 题目描述509.斐波那契数 ","date":"2022-09-28","objectID":"/509.fibonacci-number.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"509.斐波那契数","uri":"/509.fibonacci-number.zh/#题目描述"},{"categories":["leetcode"],"content":" 2 解题思路$a_n = a_{n-1} + a_{n-2}$，利用这一递推关系构建for循环即可，实际上只需要容量为2的数组。 ","date":"2022-09-28","objectID":"/509.fibonacci-number.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"509.斐波那契数","uri":"/509.fibonacci-number.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { public: int fib(int N) { if (N \u003c= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i \u003c= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; ","date":"2022-09-28","objectID":"/509.fibonacci-number.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"509.斐波那契数","uri":"/509.fibonacci-number.zh/#代码"},{"categories":["notes"],"content":" 1 问题描述一般来说，一维动态规划的问题，其输入的参数一般是$n$，而所求结果有点像数列$a_n$，或者说$f(n)$($f$可以认为是函数或者说对应关系)，同时$a_n$与之前的$a_{n-1},a_{n-2},…a_{1}$有一个确定的对应的关系，例如$a_n = a_{n-1} + a_{n-2}$(斐波那契数列) ","date":"2022-09-28","objectID":"/dynamic-programming.zh/:1:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"一维动态规划-基础版","uri":"/dynamic-programming.zh/#问题描述"},{"categories":["notes"],"content":" 2 解题步骤数列即可与编程语言中的数组对应起来，在找到数列之间的迭代关系时，即可编写for循环来求解。 ","date":"2022-09-28","objectID":"/dynamic-programming.zh/:2:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"一维动态规划-基础版","uri":"/dynamic-programming.zh/#解题步骤"},{"categories":["notes"],"content":" 3 例题 509.斐波那契数 509.斐波那契数-题解 70.爬楼梯 70.爬楼梯-题解 746.使用最小花费爬楼梯 746.使用最小花费爬楼梯-题解 343.整数拆分 343.整数拆分-题解 62.不同路径 62.不同路径-题解 63.不同路径II 63.不同路径II-题解 ","date":"2022-09-28","objectID":"/dynamic-programming.zh/:3:0","series":null,"tags":["data structure and algorithms","dynamic programming"],"title":"一维动态规划-基础版","uri":"/dynamic-programming.zh/#例题"},{"categories":["leetcode","tutorial"],"content":" 1 安装插件vscode 安装leetcode插件。 ","date":"2022-09-27","objectID":"/vscode-leetcode-cookie.zh/:1:0","series":null,"tags":["vscode","tips"],"title":"Vscdoe 通过cookie 登陆美区 LeetCode","uri":"/vscode-leetcode-cookie.zh/#安装插件"},{"categories":["leetcode","tutorial"],"content":" 2 使用cookie登陆如果选择使用github登陆leetcode.com，似乎会有无法提交和测试的bug，而用cookie登陆就没有这个问题 ","date":"2022-09-27","objectID":"/vscode-leetcode-cookie.zh/:2:0","series":null,"tags":["vscode","tips"],"title":"Vscdoe 通过cookie 登陆美区 LeetCode","uri":"/vscode-leetcode-cookie.zh/#使用cookie登陆"},{"categories":["leetcode","tutorial"],"content":" 2.1 使用edge获取cookie使用Firefox获取的cookie有问题，无法正常登陆 右键，选择检查 选择网络 打开leetcode的problem页面 下滑找到cookie那一栏，复制cookie ","date":"2022-09-27","objectID":"/vscode-leetcode-cookie.zh/:2:1","series":null,"tags":["vscode","tips"],"title":"Vscdoe 通过cookie 登陆美区 LeetCode","uri":"/vscode-leetcode-cookie.zh/#使用edge获取cookie"},{"categories":[""],"content":" 1 安装Hugomac非常方便， ","date":"2022-09-26","objectID":"/my_blog_powered_by_hugopapermod/:1:0","series":null,"tags":[""],"title":"My_blog_powered_by_Hugo\u0026PaperMod","uri":"/my_blog_powered_by_hugopapermod/#安装hugo"},{"categories":[""],"content":" 1 安装Hugomac非常方便， ","date":"2022-09-26","objectID":"/my_blog_powered_by_hugopapermod.zh/:1:0","series":null,"tags":[""],"title":"My_blog_powered_by_Hugo\u0026PaperMod","uri":"/my_blog_powered_by_hugopapermod.zh/#安装hugo"},{"categories":["leetcode"],"content":" 1 题目描述链接：37.Sodoku Solver ","date":"2022-09-26","objectID":"/37.sudoku-solver.zh/:1:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"37.sudoku Solver 解数独","uri":"/37.sudoku-solver.zh/#题目描述"},{"categories":["leetcode"],"content":" 2 解题思路相比一般的回溯，需要两层for循环，一个处理行，一个处理列，递归的过程来决定，空格处到底填哪个数字； 本递归函数用bool作为返回值类型，要注意返回值在递归中的作用； 另外还有一个判断board是否合规的函数。 ","date":"2022-09-26","objectID":"/37.sudoku-solver.zh/:2:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"37.sudoku Solver 解数独","uri":"/37.sudoku-solver.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { private: bool isValid(int row, int col, char val, vector\u003cvector\u003cchar\u003e\u003e \u0026board) { for (int i = 0; i \u003c 9; i++) { // 判断行里是否重复 if (board[row][i] == val) { return false; } } for (int j = 0; j \u003c 9; j++) { // 判断列里是否重复 if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i \u003c startRow + 3; i++) { // 判断9方格里是否重复 for (int j = startCol; j \u003c startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector\u003cvector\u003cchar\u003e\u003e \u0026board) { for (int i = 0; i \u003c 9; i++) { // 逐行 for (int j = 0; j \u003c 9; j++) { // 逐列 if (board[i][j] != '.') continue; for (char k = '1'; k \u003c= '9'; k++) { if (isValid(i, j, k, board)) { board[i][j] = k; if (track_back(board)) return true; board[i][j] = '.'; } } return false; } } return true; } public: void solveSudoku(vector\u003cvector\u003cchar\u003e\u003e \u0026board) { track_back(board); } }; ","date":"2022-09-26","objectID":"/37.sudoku-solver.zh/:3:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"37.sudoku Solver 解数独","uri":"/37.sudoku-solver.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description链接：37.Sodoku Solver ","date":"2022-09-26","objectID":"/37.sudoku-solver/:1:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"37.解数独","uri":"/37.sudoku-solver/#description"},{"categories":["leetcode"],"content":" 2 SolutionCompared with usual backtracking, we need for loop of two layers, one for row and another for column. A recursive process is used to determine exactly which number to fill in the space. This return type of this function is bool, please pay attention to the role of return value in recursion. Also a function to determine whether board is legal is required. ","date":"2022-09-26","objectID":"/37.sudoku-solver/:2:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"37.解数独","uri":"/37.sudoku-solver/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { private: bool isValid(int row, int col, char val, vector\u003cvector\u003cchar\u003e\u003e \u0026board) { for (int i = 0; i \u003c 9; i++) { // judge whether there are duplicates in a row if (board[row][i] == val) { return false; } } for (int j = 0; j \u003c 9; j++) { // judge whether there are duplicates in a column if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; // judge whether there are duplicates in ninepin for (int i = startRow; i \u003c startRow + 3; i++) { for (int j = startCol; j \u003c startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector\u003cvector\u003cchar\u003e\u003e \u0026board) { for (int i = 0; i \u003c 9; i++) { // traverse in row for (int j = 0; j \u003c 9; j++) { // traverse in column if (board[i][j] != '.') continue; for (char k = '1'; k \u003c= '9'; k++) { if (isValid(i, j, k, board)) { board[i][j] = k; if (track_back(board)) return true; board[i][j] = '.'; } } return false; } } return true; } public: void solveSudoku(vector\u003cvector\u003cchar\u003e\u003e \u0026board) { track_back(board); } }; ","date":"2022-09-26","objectID":"/37.sudoku-solver/:3:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"37.解数独","uri":"/37.sudoku-solver/#code"},{"categories":["tutorial"],"content":" 1 steps to follow在themes/PaperMod/layouts/partials目录下创建math.html文件，文件内容如下 html \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css\" integrity=\"sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X\" crossorigin=\"anonymous\"\u003e \u003cscript defer src=\"https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js\" integrity=\"sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript defer src=\"https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js\" integrity=\"sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript\u003e document.addEventListener(\"DOMContentLoaded\", function() { renderMathInElement(document.body, { // customised options // • auto-render specific keys, e.g.: delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\\\(', right: '\\\\)', display: false}, {left: '\\\\[', right: '\\\\]', display: true} ], // • rendering keys, e.g.: throwOnError : false }); }); \u003c/script\u003e 编辑themes/PaperMod/layouts/partials目录下的extend_head.html文件，添加如下内容： html {{ if or .Params.math .Site.Params.math }} {{ partial \"math.html\" . }} {{ end }} 编辑config.toml，添加如下内容 toml [params] math = true # 添加latex支持 ","date":"2022-09-26","objectID":"/latex_support_papermod.zh/:1:0","series":null,"tags":["hugo","geek","tips"],"title":"为 papermod 主题添加 Latex 支持","uri":"/latex_support_papermod.zh/#steps-to-follow"},{"categories":["tutorial"],"content":" 2 Referencekatex-hugo-papermod math-typesetting ","date":"2022-09-26","objectID":"/latex_support_papermod.zh/:2:0","series":null,"tags":["hugo","geek","tips"],"title":"为 papermod 主题添加 Latex 支持","uri":"/latex_support_papermod.zh/#reference"},{"categories":["tutorial"],"content":" 1 steps to follow在themes/PaperMod/layouts/partials目录下创建math.html文件，文件内容如下 html \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css\" integrity=\"sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X\" crossorigin=\"anonymous\"\u003e \u003cscript defer src=\"https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js\" integrity=\"sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript defer src=\"https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js\" integrity=\"sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript\u003e document.addEventListener(\"DOMContentLoaded\", function() { renderMathInElement(document.body, { // customised options // • auto-render specific keys, e.g.: delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\\\(', right: '\\\\)', display: false}, {left: '\\\\[', right: '\\\\]', display: true} ], // • rendering keys, e.g.: throwOnError : false }); }); \u003c/script\u003e 编辑themes/PaperMod/layouts/partials目录下的extend_head.html文件，添加如下内容： html {{ if or .Params.math .Site.Params.math }} {{ partial \"math.html\" . }} {{ end }} 编辑config.toml，添加如下内容 toml [params] math = true # 添加latex支持 ","date":"2022-09-26","objectID":"/latex_support_papermod/:1:0","series":null,"tags":["hugo","geek","tips"],"title":"为 PaperMod 主题添加 LaTeX 支持","uri":"/latex_support_papermod/#steps-to-follow"},{"categories":["tutorial"],"content":" 2 Referencekatex-hugo-papermod math-typesetting ","date":"2022-09-26","objectID":"/latex_support_papermod/:2:0","series":null,"tags":["hugo","geek","tips"],"title":"为 PaperMod 主题添加 LaTeX 支持","uri":"/latex_support_papermod/#reference"},{"categories":["notes"],"content":" 1 math_test中文测试 $a_b$ $$a_b + c_d$$ aaa ","date":"2022-09-26","objectID":"/math_test/:1:0","series":null,"tags":["mit","git"],"title":"Math_test","uri":"/math_test/#math_test"},{"categories":["leetcode"],"content":" 1 Description47.permutations-ii ","date":"2022-09-25","objectID":"/47.permutations-ii/:1:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"47.permutations-ii","uri":"/47.permutations-ii/#description"},{"categories":["leetcode"],"content":" 2 SolutionCompared with 47.permutations, there is interference from duplicate numbers. So we should de-duplicate such as combination-sum-ii Judge whether nums[i] is in path by if (used[i] == 1), de-duplicate by if (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1] \u0026\u0026 used[i - 1] == 0). Attention: we should sort the array first. ","date":"2022-09-25","objectID":"/47.permutations-ii/:2:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"47.permutations-ii","uri":"/47.permutations-ii/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp #include \u003cvector\u003e #include \u003calgorithm\u003e using std::vector; class Solution { private: vector\u003cint\u003e path; vector\u003cvector\u003cint\u003e\u003e res; int used[8] = {0}; void track_back(vector\u003cint\u003e nums, int index) { if (path.size() \u003e= nums.size()) { res.push_back(path); return; } for (int i = 0; i \u003c nums.size(); i++) { if (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1] \u0026\u0026 used[i - 1] == 0) continue; if (used[i] == 1) continue; path.push_back(nums[i]); used[i] = 1; track_back(nums, 0); path.pop_back(); used[i] = 0; } return; } public: vector\u003cvector\u003cint\u003e\u003e permuteUnique(vector\u003cint\u003e\u0026 nums) { std::sort(nums.begin(), nums.end()); track_back(nums, 0); return res; } }; ","date":"2022-09-25","objectID":"/47.permutations-ii/:3:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"47.permutations-ii","uri":"/47.permutations-ii/#code"},{"categories":["leetcode"],"content":" 1 问题描述47.全排列II ","date":"2022-09-25","objectID":"/47.permutations-ii.zh/:1:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"47.permutations-ii 全排列II","uri":"/47.permutations-ii.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路相比全排列，多了重复数字的干扰，可以参照带重复数字的组合问题来进行去重: if (used[i] == 1)判断nums[i]是否已经在path中，if (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1] \u0026\u0026 used[i - 1] == 0)来进行去重。 注意，要先对目标数组排序。 ","date":"2022-09-25","objectID":"/47.permutations-ii.zh/:2:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"47.permutations-ii 全排列II","uri":"/47.permutations-ii.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp #include \u003cvector\u003e #include \u003calgorithm\u003e using std::vector; class Solution { private: vector\u003cint\u003e path; vector\u003cvector\u003cint\u003e\u003e res; int used[8] = {0}; void track_back(vector\u003cint\u003e nums, int index) { if (path.size() \u003e= nums.size()) { res.push_back(path); return; } for (int i = 0; i \u003c nums.size(); i++) { if (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1] \u0026\u0026 used[i - 1] == 0) continue; if (used[i] == 1) continue; path.push_back(nums[i]); used[i] = 1; track_back(nums, 0); path.pop_back(); used[i] = 0; } return; } public: vector\u003cvector\u003cint\u003e\u003e permuteUnique(vector\u003cint\u003e\u0026 nums) { std::sort(nums.begin(), nums.end()); track_back(nums, 0); return res; } }; ","date":"2022-09-25","objectID":"/47.permutations-ii.zh/:3:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"47.permutations-ii 全排列II","uri":"/47.permutations-ii.zh/#代码"},{"categories":["leetcode"],"content":" 1 Description51.n-queens ","date":"2022-09-25","objectID":"/51.n-queens/:1:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"51.n Queens","uri":"/51.n-queens/#description"},{"categories":["leetcode"],"content":" 2 SolutionBacktracking, please pay attention to how to judge whether chess is in the same diagonal. ","date":"2022-09-25","objectID":"/51.n-queens/:2:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"51.n Queens","uri":"/51.n-queens/#solution"},{"categories":["leetcode"],"content":" 3 Code cpp class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = \".........\"; vector\u003cstring\u003e row_str; vector\u003cvector\u003cstring\u003e\u003e res; void track_back(int n, int index) { if (index \u003e= n) { res.push_back(row_str); return; } for (int i = 0; i \u003c n; i++) { // i for column, index for row if (col_arr[i] != 0 || row_col[i - index + 8] != 0 || row_plus_col[i + index] != 0) continue; col_arr[i] = 1; row_col[i - index + 8] = 1; row_plus_col[i + index] = 1; string path_tmp = path.substr(0, n); path_tmp[i] = 'Q'; row_str.push_back(path_tmp); track_back(n, index + 1); col_arr[i] = 0; row_col[i - index + 8] = 0; row_plus_col[i + index] = 0; path_tmp[i] = '.'; row_str.pop_back(); } return; } public: vector\u003cvector\u003cstring\u003e\u003e solveNQueens(int n) { track_back(n, 0); return res; } }; ","date":"2022-09-25","objectID":"/51.n-queens/:3:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"51.n Queens","uri":"/51.n-queens/#code"},{"categories":["leetcode"],"content":" 1 问题描述51.n皇后 ","date":"2022-09-25","objectID":"/51.n-queens.zh/:1:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"51.n皇后","uri":"/51.n-queens.zh/#问题描述"},{"categories":["leetcode"],"content":" 2 解题思路典型的回溯，注意如何判断棋子在同一斜线上。 ","date":"2022-09-25","objectID":"/51.n-queens.zh/:2:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"51.n皇后","uri":"/51.n-queens.zh/#解题思路"},{"categories":["leetcode"],"content":" 3 代码 cpp class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = \".........\"; vector\u003cstring\u003e row_str; vector\u003cvector\u003cstring\u003e\u003e res; void track_back(int n, int index) { if (index \u003e= n) { res.push_back(row_str); return; } for (int i = 0; i \u003c n; i++) { // i表示在第几列，index表示在第几行 if (col_arr[i] != 0 || row_col[i - index + 8] != 0 || row_plus_col[i + index] != 0) continue; col_arr[i] = 1; row_col[i - index + 8] = 1; row_plus_col[i + index] = 1; string path_tmp = path.substr(0, n); path_tmp[i] = 'Q'; row_str.push_back(path_tmp); track_back(n, index + 1); col_arr[i] = 0; row_col[i - index + 8] = 0; row_plus_col[i + index] = 0; path_tmp[i] = '.'; row_str.pop_back(); } return; } public: vector\u003cvector\u003cstring\u003e\u003e solveNQueens(int n) { track_back(n, 0); return res; } }; ","date":"2022-09-25","objectID":"/51.n-queens.zh/:3:0","series":null,"tags":["data structure and algorithms","backtracking algorithm"],"title":"51.n皇后","uri":"/51.n-queens.zh/#代码"},{"categories":null,"content":"谁谓河广，一苇杭之","date":"0001-01-01","objectID":"/_index.zh/","series":null,"tags":null,"title":"Leetcode","uri":"/_index.zh/"},{"categories":null,"content":"种一棵树最好的时间是十年前，其次是现在","date":"0001-01-01","objectID":"/_index.zh/","series":null,"tags":null,"title":"技术","uri":"/_index.zh/"},{"categories":null,"content":"生命不息，折腾不止","date":"0001-01-01","objectID":"/_index.zh/","series":null,"tags":null,"title":"折腾","uri":"/_index.zh/"},{"categories":null,"content":"记住生活，留住感动","date":"0001-01-01","objectID":"/_index.zh/","series":null,"tags":null,"title":"生活","uri":"/_index.zh/"},{"categories":null,"content":"不积跬步，无以至千里","date":"0001-01-01","objectID":"/_index.zh/","series":null,"tags":null,"title":"阅读","uri":"/_index.zh/"}]