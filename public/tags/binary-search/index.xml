<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Search on My New Hugo Site</title>
    <link>http://localhost:1313/tags/binary-search/</link>
    <description>Recent content in Binary Search on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Oct 2023 11:10:46 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/binary-search/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1201. 丑数 III (Medium)</title>
      <link>http://localhost:1313/posts/leet/1201.ugly-number-iii.zh/</link>
      <pubDate>Tue, 17 Oct 2023 11:10:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1201.ugly-number-iii.zh/</guid>
      <description>问题描述 1201. 丑数 III (Medium)&#xA;给你四个整数： n 、 a 、 b 、 c ，请你设计一个算法来找出第 n 个丑数。&#xA;丑数是可以被 a 或 b 或 c 整除的 正整数 。&#xA;示例 1：&#xA;输入：n = 3, a = 2, b = 3, c = 5 输出：4 解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2：&#xA;输入：n = 4, a = 2, b = 3, c = 4 输出：6 解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12.</description>
    </item>
    <item>
      <title>287. 寻找重复数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/287.find-the-duplicate-number.zh/</link>
      <pubDate>Fri, 04 Aug 2023 10:59:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/287.find-the-duplicate-number.zh/</guid>
      <description>问题描述 287. 寻找重复数 (Medium)&#xA;给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存 在一个重复的整数。&#xA;假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。&#xA;你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。&#xA;示例 1：&#xA;输入：nums = [1,3,4,2,2] 输出：2 示例 2：&#xA;输入：nums = [3,1,3,4,2] 输出：3 提示：&#xA;1 &amp;lt;= n &amp;lt;= 10⁵ nums.length == n + 1 1 &amp;lt;= nums[i] &amp;lt;= n nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 进阶：&#xA;如何证明 nums 中至少存在一个重复的数字?</description>
    </item>
    <item>
      <title>354. Russian Doll Envelopes (Hard)</title>
      <link>http://localhost:1313/posts/leet/354.russian-doll-envelopes/</link>
      <pubDate>Fri, 23 Jun 2023 23:38:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/354.russian-doll-envelopes/</guid>
      <description>Description 354. Russian Doll Envelopes (Hard)&#xA;Solution The initial reaction to this problem is definitely sorting. The question is, should the second dimension be sorted in ascending or descending order?&#xA;Firstly, let&amp;rsquo;s observe the question. It states that both dimensions must be strictly smaller. When I attempted the problem myself, I didn&amp;rsquo;t notice this point and got stuck for a while. However, once we consider this requirement, it becomes much clearer.</description>
    </item>
    <item>
      <title>354. 俄罗斯套娃信封问题 (Hard)</title>
      <link>http://localhost:1313/posts/leet/354.russian-doll-envelopes.zh/</link>
      <pubDate>Fri, 23 Jun 2023 23:38:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/354.russian-doll-envelopes.zh/</guid>
      <description>问题描述 354. 俄罗斯套娃信封问题 (Hard)&#xA;给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wᵢ, hᵢ] ，表示第 i 个信封的宽度和高度。&#xA;当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。&#xA;请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。&#xA;注意：不允许旋转信封。&#xA;示例 1：&#xA;输入：envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出：3 解释：最多信封的个数为 3, 组合为: [2,3] =&amp;gt; [5,4] =&amp;gt; [6,7]。 示例 2：&#xA;输入：envelopes = [[1,1],[1,1],[1,1]] 输出：1 提示：&#xA;1 &amp;lt;= envelopes.length &amp;lt;= 10⁵ envelopes[i].length == 2 1 &amp;lt;= wᵢ, hᵢ &amp;lt;= 10⁵ 解题思路 本题的第一反应肯定是排序，按照第数组的第一个维度升序排序，问题在于，第二个维度是应该升序还是降序呢？&#xA;首先，观察题目，题目要求是两个维度都必须严格小于才行，我自己做的时候就没观察到这一点，卡了很久，注意到这一点的话，其实就好想很多了。&#xA;我们先假设按照第二个升序排列，当我们选择了 $(w_i, h_i)$ 之后，那么我们就是要找满足 $(w_j, h_j)$ 两个维度都严格小于 $(w_i, h_i)$ 的最大的 $(w_j, h_j)$，这里就可以联系到 LIS 问题了。</description>
    </item>
    <item>
      <title>2517. Maximum Tastiness of Candy Basket (Medium)</title>
      <link>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket/</guid>
      <description>Description 2517. Maximum Tastiness of Candy Basket (Medium) You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.&#xA;The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.&#xA;Return the maximum tastiness of a candy basket.&#xA;Example 1:</description>
    </item>
    <item>
      <title>517. 礼盒的最大甜蜜度 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket.zh/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket.zh/</guid>
      <description>问题描述 2517. 礼盒的最大甜蜜度 (Medium) 给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖 果的价格，另给你一个正整数 k 。&#xA;商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 **甜蜜度 ** 是礼盒中任意两种糖果 价格 绝对差的最小值。&#xA;返回礼盒的 最大 甜蜜度。&#xA;示例 1：&#xA;输入：price = [13,5,1,8,21,2], k = 3 输出：8 解释：选出价格分别为 [13,5,21] 的三类糖果。 礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8 , 16) = 8 。 可以证明能够取得的最大甜蜜度就是 8 。 示例 2：&#xA;输入：price = [1,3,1], k = 2 输出：2 解释：选出价格分别为 [1,3] 的两类糖果。 礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。 可以证明能够取得的最大甜蜜度就是 2 。 示例 3：</description>
    </item>
    <item>
      <title>二分答案</title>
      <link>http://localhost:1313/posts/tech/binary_search.zh/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/binary_search.zh/</guid>
      <description>概述 二分答案即利用二分查找来得到答案，一般情况下，左边界 $left$ 是 $0$ 或者 $1$；右边界 $right$ 则视题目条件而定，取一个很大的数，然后利用二分查找的思想，来找到答案。&#xA;二分答案的要求 如果题目能够使用二分答案的思想来解决，那么 $[left, right]$ 范围内，要满足二段性，即对 $[left, res]$ 满足条件 $A$，而 $(res, right]$ 不满足条件 $A$，并且 res 的取值范围是连续的。&#xA;适用情况 如果题目要求满足 xxx 条件下的最大值或者最小值，就可以考虑二分答案，特别的，如果题目要求最小化的最大值或者最大化的最小值，那么要首先考虑使用二分答案。&#xA;例题 2517. 礼盒的最大甜蜜度 (Medium)&#xA;class Solution { public: int Bsearch(int target, vector&amp;lt;int&amp;gt; &amp;amp;price, int left) { int right = price.size(); while (left &amp;lt; right) { int mid = left + (right - left) / 2; if (price[mid] &amp;lt; target) { left = mid + 1; } else { right = mid; } } return left; } bool Check(int mid, vector&amp;lt;int&amp;gt; &amp;amp;price, int k, int n) { int start = 0; for (int i = 0; i &amp;lt; k - 1; ++i) { start = Bsearch(price[start] + mid, price, start); // cout &amp;lt;&amp;lt; start &amp;lt;&amp;lt; &amp;#34; start\n&amp;#34;; if (start &amp;gt;= n) { return false; } } return true; } int maximumTastiness(vector&amp;lt;int&amp;gt; &amp;amp;price, int k) { // 先排序，然后考虑是二分答案还是双指针 sort(price.</description>
    </item>
    <item>
      <title>2071.Maximum Number of Tasks You Can Assign (Hard)</title>
      <link>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign/</link>
      <pubDate>Wed, 22 Mar 2023 19:49:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign/</guid>
      <description>Description Maximum Number of Tasks You Can Assign (Hard) You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task&amp;rsquo;s strength requirement (i.</description>
    </item>
    <item>
      <title>2071.你可以安排的最多任务数目 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign.zh/</link>
      <pubDate>Wed, 22 Mar 2023 19:49:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign.zh/</guid>
      <description>问题描述 2071. 你可以安排的最多任务数目 (Hard)&#xA;给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] &amp;gt;= tasks[i] ）。&#xA;除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。&#xA;给你下标从 0 开始的整数数组 tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。&#xA;示例 1：&#xA;输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1 输出：3 解释： 我们可以按照如下方案安排药丸： - 给 0 号工人药丸。 - 0 号工人完成任务 2（0 + 1 &amp;gt;= 1） - 1 号工人完成任务 1（3 &amp;gt;= 2） - 2 号工人完成任务 0（3 &amp;gt;= 3） 示例 2：</description>
    </item>
    <item>
      <title>2389.Longest Subsequence With Limited Sum (Easy)</title>
      <link>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum/</link>
      <pubDate>Fri, 17 Mar 2023 15:44:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum/</guid>
      <description>Description 2389. Longest Subsequence With Limited Sum (Easy)&#xA;You are given an integer array nums of length n, and an integer array queries of length m.&#xA;Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].&#xA;A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</description>
    </item>
    <item>
      <title>2389.和有限的最长子序列 (Easy)</title>
      <link>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum.zh/</link>
      <pubDate>Fri, 17 Mar 2023 15:44:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum.zh/</guid>
      <description>问题描述 和有限的最长子序列 (Easy) 给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。&#xA;返回一个长度为 m 的数组 answer，其中 answer[i] 是 nums 中元素之和小于等于 queries[i] 的 子序列 的 最大 长度。&#xA;子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。&#xA;示例 1：&#xA;输入：nums = [4,5,2,1], queries = [3,10,21] 输出：[2,3,4] 解释：queries 对应的 answer 如下： - 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。 - 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。 - 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。 示例 2：</description>
    </item>
    <item>
      <title>778.Swim in Rising Water (Hard)</title>
      <link>http://localhost:1313/posts/leet/778.swim-in-rising-water/</link>
      <pubDate>Fri, 17 Mar 2023 15:29:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/778.swim-in-rising-water/</guid>
      <description>Description 778. Swim in Rising Water (Hard)&#xA;You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).&#xA;The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time.</description>
    </item>
    <item>
      <title>778.水位上升的泳池中游泳 (Hard)</title>
      <link>http://localhost:1313/posts/leet/778.swim-in-rising-water.zh/</link>
      <pubDate>Fri, 17 Mar 2023 15:29:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/778.swim-in-rising-water.zh/</guid>
      <description>问题描述 778. 水位上升的泳池中游泳 (Hard)&#xA;在一个 n x n 的整数矩阵 grid 中，每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。&#xA;当开始下雨时，在时间为 t 时，水池中的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。&#xA;你从坐标方格的左上平台 (0，0) 出发。返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间 。&#xA;示例 1:&#xA;输入: grid = [[0,2],[1,3]] 输出: 3 解释: 时间为0时，你位于坐标方格的位置为 (0, 0)。 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。 等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置 示例 2:&#xA;输入: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] 输出: 16 解释: 最终的路线用加粗进行了标记。 我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的 提示:</description>
    </item>
    <item>
      <title>1631.Path With Minimum Effort (Medium)</title>
      <link>http://localhost:1313/posts/leet/1631.path-with-minimum-effort/</link>
      <pubDate>Thu, 16 Mar 2023 13:53:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1631.path-with-minimum-effort/</guid>
      <description>Solution 1631. Path With Minimum Effort (Medium)&#xA;You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.</description>
    </item>
    <item>
      <title>1631.最小体力消耗路径 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1631.path-with-minimum-effort.zh/</link>
      <pubDate>Thu, 16 Mar 2023 13:49:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1631.path-with-minimum-effort.zh/</guid>
      <description>问题描述 1631. 最小体力消耗路径 (Medium)&#xA;你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上， 下， 左， 右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。&#xA;一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。&#xA;请你返回从左上角走到右下角的最小 体力消耗值 。&#xA;示例 1：&#xA;输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。 示例 2：&#xA;输入：heights = [[1,2,3],[3,8,4],[5,3,5]] 输出：1 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3：</description>
    </item>
    <item>
      <title>162.Find Peak Element (Medium)</title>
      <link>http://localhost:1313/posts/leet/162.find-peak-element/</link>
      <pubDate>Mon, 06 Mar 2023 19:43:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/162.find-peak-element/</guid>
      <description>Description 162. Find Peak Element (Medium)&#xA;A peak element is an element that is strictly greater than its neighbors.&#xA;Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.&#xA;You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</description>
    </item>
    <item>
      <title>162.寻找峰值 (Medium)</title>
      <link>http://localhost:1313/posts/leet/162.find-peak-element.zh/</link>
      <pubDate>Mon, 06 Mar 2023 19:39:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/162.find-peak-element.zh/</guid>
      <description>问题描述 162. 寻找峰值 (Medium)&#xA;峰值元素是指其值严格大于左右相邻值的元素。&#xA;给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。&#xA;你可以假设 nums[-1] = nums[n] = -∞ 。&#xA;你必须实现时间复杂度为 O(log n) 的算法来解决此问题。&#xA;示例 1：&#xA;输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2：&#xA;输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 1000 -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1] 解题思路 本题要求实现时间复杂度为$O(\log n)$的算法来解决问题，因此我们很容易想到二分，二分本质上并不要求单调性，而是要求二段性。&#xA;代码 class Solution { public: int findPeakElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.</description>
    </item>
    <item>
      <title>209.Minimum Size Subarray Sum (Medium)</title>
      <link>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum/</link>
      <pubDate>Mon, 06 Mar 2023 19:11:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum/</guid>
      <description>Description 209. Minimum Size Subarray Sum (Medium)&#xA;Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.&#xA;Example 1:&#xA;Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. Example 2:&#xA;Input: target = 4, nums = [1,4,4] Output: 1 Example 3:</description>
    </item>
    <item>
      <title>209.长度最小的子数组 (Medium)</title>
      <link>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum.zh/</link>
      <pubDate>Mon, 06 Mar 2023 19:11:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum.zh/</guid>
      <description>问题描述 209. 长度最小的子数组 (Medium)&#xA;给定一个含有 n 个正整数的数组和一个正整数 target 。&#xA;找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsₗ, numsₗ+₁, ..., numsr-₁, numsr] ，并返回其长度 。 如果不存在符合条件的子数组，返回 0 。&#xA;示例 1：&#xA;输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：&#xA;输入：target = 4, nums = [1,4,4] 输出：1 示例 3：&#xA;输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示：&#xA;1 &amp;lt;= target &amp;lt;= 10⁹ 1 &amp;lt;= nums.length &amp;lt;= 10⁵ 1 &amp;lt;= nums[i] &amp;lt;= 10⁵ 进阶：</description>
    </item>
    <item>
      <title>154.寻找旋转排序数组中的最小值 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii.zh/</link>
      <pubDate>Sat, 04 Mar 2023 15:57:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii.zh/</guid>
      <description>问题描述 154. 寻找旋转排序数组中的最小值 II (Hard)&#xA;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：&#xA;若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。&#xA;给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。&#xA;你必须尽可能减少整个过程的操作步骤。&#xA;示例 1：&#xA;输入：nums = [1,3,5] 输出：1 示例 2：&#xA;输入：nums = [2,2,2,0,1] 输出：0 提示：&#xA;n == nums.length 1 &amp;lt;= n &amp;lt;= 5000 -5000 &amp;lt;= nums[i] &amp;lt;= 5000 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶： 这道题与 寻找旋转排序数组中的最小值 类似，但 nums 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</description>
    </item>
    <item>
      <title>153.Find Minimum in Rotated Sorted Array (Medium)</title>
      <link>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array/</link>
      <pubDate>Sat, 04 Mar 2023 15:26:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array/</guid>
      <description>Description 153. Find Minimum in Rotated Sorted Array (Medium)&#xA;Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].</description>
    </item>
    <item>
      <title>153.寻找旋转排序数组中的最小值 (Medium)</title>
      <link>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array.zh/</link>
      <pubDate>Sat, 04 Mar 2023 15:26:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array.zh/</guid>
      <description>问题描述 153. 寻找旋转排序数组中的最小值 (Medium)&#xA;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：&#xA;若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。&#xA;给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。&#xA;你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。&#xA;示例 1：&#xA;输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2：&#xA;输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3：</description>
    </item>
    <item>
      <title>1751.最多可以参加的会议数目II</title>
      <link>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:09:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</guid>
      <description>问题描述 1751.最多可以参加的会议数目II&#xA;解题思路 动态规划+二分法 令dp[i][j]表示在前i个会议，最多参加j个会议，收获的最大价值:&#xA;考虑选择不参加events[i - 1]，dp[i][j] = dp[i - 1][j]; 选择参加events[i - 1]，dp[i][j] = dp[idx][j - 1] + events[i - 1][2]; 其中idx表示结束日期小于events[i - 1][0]且最接近events[i - 1][0]的会议的索引号，因此这里需要按照结束日期从小到大对events排序; 寻找idx可以使用二分查找; 二分查找要注意其中的不变量，即l左侧的值都小于target，r右侧的值都大于或等于target(这里是否等于取决于具体实现&amp;gt;=或者&amp;gt;)&#xA;代码 class Solution { public: int maxValue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;events, int k) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(events.size() + 1, vector&amp;lt;int&amp;gt;(k + 1, 0)); // 按照会议结束顺序排序 std::sort(events.begin(), events.end(), [](auto &amp;amp;a, auto &amp;amp;b) { return a[1] &amp;lt; b[1]; }); // for (int i = 1; i &amp;lt;= events.</description>
    </item>
  </channel>
</rss>
