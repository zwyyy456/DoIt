<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hash Table on My New Hugo Site</title>
    <link>http://localhost:1313/tags/hash-table/</link>
    <description>Recent content in Hash Table on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 31 May 2023 16:36:04 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/hash-table/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LRU 算法与 LFU 算法</title>
      <link>http://localhost:1313/posts/tech/lru_lfu.zh/</link>
      <pubDate>Wed, 31 May 2023 16:36:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/lru_lfu.zh/</guid>
      <description>算法介绍 LRU LRU 全称是 Least Recently Used，即最近最久未使用算法。&#xA;LRU 根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高，它是页面置换算法的一种，也常用于缓存设计。&#xA;LFU LFU 全称是 Least Frequently Used，根据频率来选择要淘汰的元素，即删除访问频率最低的元素，如果两个元素的访问频率相同，则淘汰访问频率最低的元素中最久没有被访问的元素。&#xA;数据结构 不管是 LRU 还是 LFU 算法，我们都需要使用到双向链表作为基础数据结构，由于 LRU 与 LFU 涉及的对双向链表的元素的操作比较复杂，还涉及对链表结点的其他操作，因此选择自己手写一个简单的双向链表，同时复习双向链表的实现（阿里一面就被问到了，半天没写对😅）。&#xA;这里根据 LRU 和 LFU 的需要，简单封装了删除结点、尾部插入结点、和判断双向链表是否为空三个函数，很大程度上简化了 LRU 和 LFU 的实现，降低了写算法实现代码的出错概率。&#xA;struct Node { Node() { } Node(int val, int key) : val_(val), key_(key), next_(nullptr), pre_(nullptr) { } int val_; int freq_; Node *next_; Node *pre_; int key_; }; struct List { Node *vhead_; // 虚拟头结点 Node *vtail_; // 虚拟尾结点 int size_ = 0; // 链表中有效结点的数量 List() : vhead_(new Node()), vtail_(new Node()) { vhead_-&amp;gt;next_ = vtail_; vtail_-&amp;gt;pre_ = vhead_; vhead_-&amp;gt;pre_ = nullptr; vtail_-&amp;gt;next_ = nullptr; } ~List() { delete vtail_; delete vhead_; vhead_ = nullptr; vtail_ = nullptr; } void Insert(Node *node) { // 双向链表的插入, node 表示待插入结点，插入作为双向链表的尾结点 node-&amp;gt;pre_ = vtail_-&amp;gt;pre_; vtail_-&amp;gt;pre_-&amp;gt;next_ = node; vtail_-&amp;gt;pre_ = node; node-&amp;gt;next_ = vtail_; ++size_; } void Delete(Node *node) { // node 指向待删除结点 node-&amp;gt;next_-&amp;gt;pre_ = node-&amp;gt;pre_; node-&amp;gt;pre_-&amp;gt;next_ = node-&amp;gt;next_; --size_; } bool Empty() { return size_ &amp;lt;= 0; } }; LRU 实现 对于 LRU 的实现，我们需要借助两个数组结构哈希表和双向链表来组成一个新的数据结构。我们利用哈希表实现 $O(1)$ 时间复杂度的查找，获取元素的 val 以及在双向链表中的位置；利用双向链表实现 $O(1)$ 时间复杂度内的元素插入和删除。</description>
    </item>
    <item>
      <title>字符串哈希算法</title>
      <link>http://localhost:1313/posts/tech/string_hash.zh/</link>
      <pubDate>Mon, 15 May 2023 11:52:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/string_hash.zh/</guid>
      <description>问题描述 考虑 1044. 最长重复子串 (Hard)，本题思路并不难，可以使用二分答案来解决，假设答案为 mid，那么长度大于 mid 的子串在 s 中只会出现一次，否则至少出现两次。&#xA;因此只需要考虑子串在 s 中的出现次数即可，比较直接的想法是使用 key 为 string 的 unordered_map，然而 unoredere_map 自带的哈希函数，其时间复杂度和空间复杂度都很高，为 $O(len)$，因此，需要一个简单一点的哈希函数。&#xA;字符串哈希 参照宫水三叶大佬的 字符串哈希。&#xA;我们需要使用一个比字符串 s 略长的哈希数组 vector&amp;lt;int&amp;gt; h(s.size() + 10)，以及次方数组 vector&amp;lt;int&amp;gt; p(s.size() + 10)。 对长度为 len 的数组，只需要利用前缀和思想 h[i + len] - h[i] * p[len] 即可在 $O(1)$ 时间内计算出哈希值。&#xA;其中 p[0] = 1，h[i] = h[i - 1] * P + s[i - 1]；p[i] = p[i - 1] * P。&#xA;$P$ 可以依次取 $131,\ 13131,\ 1313131$ 等，出现哈希碰撞就考虑取更大的质数。</description>
    </item>
    <item>
      <title>442.Find All Duplicates in an Array (Medium)</title>
      <link>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array/</link>
      <pubDate>Tue, 28 Mar 2023 14:45:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array/</guid>
      <description>Description 442. Find All Duplicates in an Array (Medium)&#xA;Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.&#xA;You must write an algorithm that runs in O(n) time and uses only constant extra space.&#xA;Example 1:&#xA;Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Example 2:</description>
    </item>
    <item>
      <title>442.数组中重复的数据 (Medium)</title>
      <link>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array.zh/</link>
      <pubDate>Tue, 28 Mar 2023 14:45:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array.zh/</guid>
      <description>问题描述 442. 数组中重复的数据 (Medium)&#xA;给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。&#xA;你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。&#xA;示例 1：&#xA;输入：nums = [4,3,2,7,8,2,3,1] 输出：[2,3] 示例 2：&#xA;输入：nums = [1,1,2] 输出：[1] 示例 3：&#xA;输入：nums = [1] 输出：[] 提示：&#xA;n == nums.length 1 &amp;lt;= n &amp;lt;= 10⁵ 1 &amp;lt;= nums[i] &amp;lt;= n nums 中的每个元素出现 一次 或 两次 解题思路 参照41.缺失的第一个正数 (Hard)，将数置反，如果已经是负数了，再减去nums.size()。&#xA;这里要注意nums.size()是无符号整数，直接加上负号结果也不是负数。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>41.First Missing Positive (Hard)</title>
      <link>http://localhost:1313/posts/leet/41.first-missing-positive/</link>
      <pubDate>Tue, 28 Mar 2023 11:44:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/41.first-missing-positive/</guid>
      <description>Description 41. First Missing Positive (Hard)&#xA;Given an unsorted integer array nums, return the smallest missing positive integer.&#xA;You must implement an algorithm that runs in O(n) time and uses constant extra space.&#xA;Example 1:&#xA;Input: nums = [1,2,0] Output: 3 Explanation: The numbers in the range [1,2] are all in the array. Example 2:&#xA;Input: nums = [3,4,-1,1] Output: 2 Explanation: 1 is in the array but 2 is missing.</description>
    </item>
    <item>
      <title>41.缺失的第一个正数 (Hard)</title>
      <link>http://localhost:1313/posts/leet/41.first-missing-positive.zh/</link>
      <pubDate>Tue, 28 Mar 2023 11:44:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/41.first-missing-positive.zh/</guid>
      <description>问题描述 41. 缺失的第一个正数 (Hard)&#xA;给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。&#xA;请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。&#xA;示例 1：&#xA;输入：nums = [1,2,0] 输出：3 示例 2：&#xA;输入：nums = [3,4,-1,1] 输出：2 示例 3：&#xA;输入：nums = [7,8,9,11,12] 输出：1 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 5 * 10⁵ -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 解题思路 标记 在nums[i]数组上做标记，我们可以将nums数组中的负数都设为n + 1，令num = abs(nums[i])，然后将nums[num - 1]取反，最后遍历修改后的nums[i]，如果都是负数，返回n + 1，否则返回碰到的第一个非负数的索引加一；&#xA;置换 如果nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp; nums[i] &amp;gt; 0，那么就将它与nums[num[i] - 1]置换，为了防止死循环，还要判断nums[i] != nums[nums[i] - 1]&#xA;代码 标记 class Solution { public: int firstMissingPositive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description>
    </item>
    <item>
      <title>面试题 17.05.  字母与数字 (Medium)</title>
      <link>http://localhost:1313/posts/leet/interview-17.05.zh/</link>
      <pubDate>Sat, 11 Mar 2023 15:31:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/interview-17.05.zh/</guid>
      <description>问题描述 面试题 17.05. 字母与数字 (Medium)&#xA;给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。&#xA;返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。&#xA;示例 1:&#xA;输入: [&amp;#34;A&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;2&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;4&amp;#34;,&amp;#34;E&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;F&amp;#34;,&amp;#34;G&amp;#34;,&amp;#34;6&amp;#34;,&amp;#34;7&amp;#34;,&amp;#34;H&amp;#34;,&amp;#34;I&amp;#34;,&amp;#34;J&amp;#34;,&amp;#34;K&amp;#34;,&amp;#34;L&amp;#34;,&amp;#34;M&amp;#34;] 输出: [&amp;#34;A&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;2&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;4&amp;#34;,&amp;#34;E&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;F&amp;#34;,&amp;#34;G&amp;#34;,&amp;#34;6&amp;#34;,&amp;#34;7&amp;#34;] 示例 2:&#xA;输入: [&amp;#34;A&amp;#34;,&amp;#34;A&amp;#34;] 输出: [] 提示：&#xA;array.length &amp;lt;= 100000 解题思路 首先使用一个前缀和数组prefix，prefix[i]表示前i个数里，数字的数量减去字母的数量，遍历array，更新prefix，同时在哈希表中查找key-&amp;gt;prefix[i]是否存在：&#xA;如果存在，比较记录的最长长度len，如果大于len，则更新idx = ump[prefix[i]]，并更新len = i - ump[prefix[i]]； 否则，更新哈希表，即ump[prefix[i]] = i； 代码 class Solution { public: vector&amp;lt;string&amp;gt; findLongestSubarray(vector&amp;lt;string&amp;gt; &amp;amp;array) { int n = array.size(); vector&amp;lt;string&amp;gt; res; if (n &amp;lt; 2) { return res; } unordered_set&amp;lt;string&amp;gt; ust; for (char c = &amp;#39;a&amp;#39;; c &amp;lt;= &amp;#39;z&amp;#39;; c++) { // 统计所有的字母 string s(1, c); ust.</description>
    </item>
    <item>
      <title>1590. Make Sum Divisible by P (Medium)</title>
      <link>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p/</link>
      <pubDate>Fri, 10 Mar 2023 09:31:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p/</guid>
      <description>Description 1590. Make Sum Divisible by P (Medium)&#xA;Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.&#xA;Return the length of the smallest subarray that you need to remove, or -1 if it&amp;rsquo;s impossible.&#xA;A subarray is defined as a contiguous block of elements in the array.</description>
    </item>
    <item>
      <title>1590.使数组和能被 P 整除 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p.zh/</link>
      <pubDate>Fri, 10 Mar 2023 09:31:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p.zh/</guid>
      <description>问题描述 1590. 使数组和能被 P 整除 (Medium)&#xA;给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。&#xA;请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。&#xA;子数组 定义为原数组中连续的一组元素。&#xA;示例 1：&#xA;输入：nums = [3,1,4,2], p = 6 输出：1 解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。 示例 2：&#xA;输入：nums = [6,3,5,2], p = 9 输出：2 解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。 示例 3：&#xA;输入：nums = [1,2,3], p = 3 输出：0 解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。 示例 4：</description>
    </item>
    <item>
      <title>560. Subarray Sum Equals K (Medium)</title>
      <link>http://localhost:1313/posts/leet/560.subarray-sum-equals-k/</link>
      <pubDate>Tue, 07 Mar 2023 15:28:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/560.subarray-sum-equals-k/</guid>
      <description>Description 560. Subarray Sum Equals K (Medium)&#xA;Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.&#xA;A subarray is a contiguous non-empty sequence of elements within an array.&#xA;Example 1:&#xA;Input: nums = [1,1,1], k = 2 Output: 2 Example 2:&#xA;Input: nums = [1,2,3], k = 3 Output: 2 Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁴ -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -10⁷ &amp;lt;= k &amp;lt;= 10⁷ Solution We only need traverse once.</description>
    </item>
    <item>
      <title>560. 和为 K 的子数组 (Medium)</title>
      <link>http://localhost:1313/posts/leet/560.subarray-sum-equals-k.zh/</link>
      <pubDate>Tue, 07 Mar 2023 15:28:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/560.subarray-sum-equals-k.zh/</guid>
      <description>问题描述 560. 和为 K 的子数组 (Medium)&#xA;给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。&#xA;示例 1：&#xA;输入：nums = [1,1,1], k = 2 输出：2 示例 2：&#xA;输入：nums = [1,2,3], k = 3 输出：2 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁴ -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -10⁷ &amp;lt;= k &amp;lt;= 10⁷ 解题思路 一次遍历，记录数组的前缀和prefix[i]，然后在ump中查找key为prefix[i] - target的元素是否存在，如果存在res += ump[prefix[i] - k]，++ump[prefix[i]]。&#xA;代码 class Solution { public: int subarraySum(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { vector&amp;lt;int&amp;gt; prefix(nums.</description>
    </item>
    <item>
      <title>2584.分割数组使乘积互质 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products.zh/</link>
      <pubDate>Mon, 06 Mar 2023 18:56:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products.zh/</guid>
      <description>问题描述 2584. 分割数组使乘积互质 (Medium)&#xA;给你一个长度为 n 的整数数组 nums ，下标从 0 开始。&#xA;如果在下标 i 处 分割 数组，其中 0 &amp;lt;= i &amp;lt;= n - 2 ，使前 i + 1 个元素的乘积和剩余元素的乘积互质，则认为该分割 有效 。&#xA;例如，如果 nums = [2, 3, 3] ，那么在下标 i = 0 处的分割有效，因为 2 和 9 互质，而在下标 i = 1 处的分割无效，因为 6 和 3 不互质。在下标 i = 2 处的分割也无效，因为 i == n - 1 。 返回可以有效分割数组的最小下标 i ，如果不存在有效分割，则返回 -1 。&#xA;当且仅当 gcd(val1, val2) == 1 成立时， val1 和 val2 这两个值才是互质的，其中 gcd(val1, val2) 表示 val1 和 val2 的最大公约数。</description>
    </item>
    <item>
      <title>982.Triples with Bitwise AND Equal To Zero (Hard)</title>
      <link>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero/</link>
      <pubDate>Sat, 04 Mar 2023 14:43:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero/</guid>
      <description>Description 982. Triples with Bitwise AND Equal To Zero (Hard)&#xA;Given an integer array nums, return the number of AND triples.&#xA;An AND triple is a triple of indices (i, j, k) such that:&#xA;0 &amp;lt;= i &amp;lt; nums.length 0 &amp;lt;= j &amp;lt; nums.length 0 &amp;lt;= k &amp;lt; nums.length nums[i] &amp;amp; nums[j] &amp;amp; nums[k] == 0, where &amp;amp; represents the bitwise-AND operator. Example 1:&#xA;Input: nums = [2,1,3] Output: 12 Explanation: We could choose the following i, j, k triples: (i=0, j=0, k=1) : 2 &amp;amp; 2 &amp;amp; 1 (i=0, j=1, k=0) : 2 &amp;amp; 1 &amp;amp; 2 (i=0, j=1, k=1) : 2 &amp;amp; 1 &amp;amp; 1 (i=0, j=1, k=2) : 2 &amp;amp; 1 &amp;amp; 3 (i=0, j=2, k=1) : 2 &amp;amp; 3 &amp;amp; 1 (i=1, j=0, k=0) : 1 &amp;amp; 2 &amp;amp; 2 (i=1, j=0, k=1) : 1 &amp;amp; 2 &amp;amp; 1 (i=1, j=0, k=2) : 1 &amp;amp; 2 &amp;amp; 3 (i=1, j=1, k=0) : 1 &amp;amp; 1 &amp;amp; 2 (i=1, j=2, k=0) : 1 &amp;amp; 3 &amp;amp; 2 (i=2, j=0, k=1) : 3 &amp;amp; 2 &amp;amp; 1 (i=2, j=1, k=0) : 3 &amp;amp; 1 &amp;amp; 2 Example 2:</description>
    </item>
    <item>
      <title>982.按位与为零的三元组 (Hard)</title>
      <link>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero.zh/</link>
      <pubDate>Sat, 04 Mar 2023 14:41:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero.zh/</guid>
      <description>问题描述 982. 按位与为零的三元组 (Hard)&#xA;给你一个整数数组 nums ，返回其中 按位与三元组 的数目。&#xA;按位与三元组 是由下标 (i, j, k) 组成的三元组，并满足下述全部条件：&#xA;0 &amp;lt;= i &amp;lt; nums.length 0 &amp;lt;= j &amp;lt; nums.length 0 &amp;lt;= k &amp;lt; nums.length nums[i] &amp;amp; nums[j] &amp;amp; nums[k] == 0 ，其中 &amp;amp; 表示按位与运算符。 示例 1：&#xA;输入：nums = [2,1,3] 输出：12 解释：可以选出如下 i, j, k 三元组： (i=0, j=0, k=1) : 2 &amp;amp; 2 &amp;amp; 1 (i=0, j=1, k=0) : 2 &amp;amp; 1 &amp;amp; 2 (i=0, j=1, k=1) : 2 &amp;amp; 1 &amp;amp; 1 (i=0, j=1, k=2) : 2 &amp;amp; 1 &amp;amp; 3 (i=0, j=2, k=1) : 2 &amp;amp; 3 &amp;amp; 1 (i=1, j=0, k=0) : 1 &amp;amp; 2 &amp;amp; 2 (i=1, j=0, k=1) : 1 &amp;amp; 2 &amp;amp; 1 (i=1, j=0, k=2) : 1 &amp;amp; 2 &amp;amp; 3 (i=1, j=1, k=0) : 1 &amp;amp; 1 &amp;amp; 2 (i=1, j=2, k=0) : 1 &amp;amp; 3 &amp;amp; 2 (i=2, j=0, k=1) : 3 &amp;amp; 2 &amp;amp; 1 (i=2, j=1, k=0) : 3 &amp;amp; 1 &amp;amp; 2 示例 2：</description>
    </item>
    <item>
      <title>1487.Making File Names Unique (Medium)</title>
      <link>http://localhost:1313/posts/leet/1487.making-file-names-unique/</link>
      <pubDate>Fri, 03 Mar 2023 09:40:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1487.making-file-names-unique/</guid>
      <description>Description 1487. Making File Names Unique (Medium)&#xA;Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].&#xA;Since two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.</description>
    </item>
    <item>
      <title>1487.保证文件名唯一 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1487.making-file-names-unique.zh/</link>
      <pubDate>Fri, 03 Mar 2023 09:40:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1487.making-file-names-unique.zh/</guid>
      <description>问题描述 1487. 保证文件名唯一 (Medium)&#xA;给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。&#xA;由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。&#xA;返回长度为n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。&#xA;示例 1：&#xA;输入：names = [&amp;#34;pes&amp;#34;,&amp;#34;fifa&amp;#34;,&amp;#34;gta&amp;#34;,&amp;#34;pes(2019)&amp;#34;] 输出：[&amp;#34;pes&amp;#34;,&amp;#34;fifa&amp;#34;,&amp;#34;gta&amp;#34;,&amp;#34;pes(2019)&amp;#34;] 解释：文件系统将会这样创建文件名： &amp;#34;pes&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;pes&amp;#34; &amp;#34;fifa&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;fifa&amp;#34; &amp;#34;gta&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;gta&amp;#34; &amp;#34;pes(2019)&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;pes(2019)&amp;#34; 示例 2：&#xA;输入：names = [&amp;#34;gta&amp;#34;,&amp;#34;gta(1)&amp;#34;,&amp;#34;gta&amp;#34;,&amp;#34;avalon&amp;#34;] 输出：[&amp;#34;gta&amp;#34;,&amp;#34;gta(1)&amp;#34;,&amp;#34;gta(2)&amp;#34;,&amp;#34;avalon&amp;#34;] 解释：文件系统将会这样创建文件名： &amp;#34;gta&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;gta&amp;#34; &amp;#34;gta(1)&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;gta(1)&amp;#34; &amp;#34;gta&amp;#34; --&amp;gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &amp;#34;gta(1)&amp;#34; 也被占用，所以 k = 2 。实际创建的文件名为 &amp;#34;gta(2)&amp;#34; 。 &amp;#34;avalon&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;avalon&amp;#34; 示例 3：</description>
    </item>
    <item>
      <title>2363.merge similar items</title>
      <link>http://localhost:1313/posts/leet/2363.merge-similar-items/</link>
      <pubDate>Tue, 28 Feb 2023 09:22:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2363.merge-similar-items/</guid>
      <description>Description 2363. Merge Similar Items (Easy)&#xA;You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:&#xA;items[i] = [valueᵢ, weightᵢ] where valueᵢ represents the value and weightᵢ represents the weight of the ith item. The value of each item in items is unique. Return a 2D integer array retwhere ret[i] = [valueᵢ, weightᵢ],with weightᵢbeing the sum of weights of all items with value valueᵢ.</description>
    </item>
    <item>
      <title>2363.合并相似的物品</title>
      <link>http://localhost:1313/posts/leet/2363.merge-similar-items.zh/</link>
      <pubDate>Tue, 28 Feb 2023 09:22:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2363.merge-similar-items.zh/</guid>
      <description>问题描述 2363. 合并相似的物品 (Easy)&#xA;给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质：&#xA;items[i] = [valueᵢ, weightᵢ] 其中 valueᵢ 表示第 i 件物品的 价值 ， weightᵢ 表示第 i 件物品的 重量 。 items 中每件物品的价值都是 唯一的 。 请你返回一个二维数组 ret，其中 ret[i] = [valueᵢ, weightᵢ]， weightᵢ 是所有价值为 valueᵢ 物品的 重量之和 。&#xA;注意： ret 应该按价值 升序 排序后返回。&#xA;示例 1：&#xA;输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] 输出：[[1,6],[3,9],[4,5]] 解释： value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。 value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。 value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。 所以，我们返回 [[1,6],[3,9],[4,5]] 。 示例 2：</description>
    </item>
    <item>
      <title>765.couples holding hands</title>
      <link>http://localhost:1313/posts/leet/765.couples-holding-hands/</link>
      <pubDate>Mon, 27 Feb 2023 16:39:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/765.couples-holding-hands/</guid>
      <description>Description 765. Couples Holding Hands (Hard)&#xA;There are n couples sitting in 2n seats arranged in a row and want to hold hands.&#xA;The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).</description>
    </item>
    <item>
      <title>765.情侣牵手</title>
      <link>http://localhost:1313/posts/leet/765.couples-holding-hands.zh/</link>
      <pubDate>Mon, 27 Feb 2023 16:39:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/765.couples-holding-hands.zh/</guid>
      <description>问题描述 765. 情侣牵手 (Hard)&#xA;n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。&#xA;人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。&#xA;返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次 交换可选择任意两人，让他们站起来交换座位。&#xA;示例 1:&#xA;输入: row = [0,2,1,3] 输出: 1 解释: 只需要交换row[1]和row[2]的位置即可。 示例 2:&#xA;输入: row = [3,2,0,1] 输出: 0 解释: 无需交换座位，所有的情侣都已经可以手牵手了。 提示:&#xA;2n == row.length 2 &amp;lt;= n &amp;lt;= 30 n 是偶数 0 &amp;lt;= row[i] &amp;lt; 2n row 中所有元素均 无重复 解题思路 我们只需要遍历i = 0, 2, 4, 6, .</description>
    </item>
    <item>
      <title>2347.best poker hand</title>
      <link>http://localhost:1313/posts/leet/2347.best-poker-hand/</link>
      <pubDate>Mon, 20 Feb 2023 09:38:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2347.best-poker-hand/</guid>
      <description>Description 2347. Best Poker Hand (Easy)&#xA;You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i]. The following are the types of poker hands you can make from best to worst:&#xA;&amp;quot;Flush&amp;quot;: Five cards of the same suit. &amp;quot;Three of a Kind&amp;quot;: Three cards of the same rank. &amp;quot;Pair&amp;quot;: Two cards of the same rank.</description>
    </item>
    <item>
      <title>2347.最好的扑克手牌</title>
      <link>http://localhost:1313/posts/leet/2347.best-poker-hand.zh/</link>
      <pubDate>Mon, 20 Feb 2023 09:38:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2347.best-poker-hand.zh/</guid>
      <description>问题描述 2347. 最好的扑克手牌 (Easy)&#xA;给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。 下述是从好到坏你可能持有的 手牌类型：&#xA;&amp;quot;Flush&amp;quot;：同花，五张相同花色的扑克牌。 &amp;quot;Three of a Kind&amp;quot;：三条，有 3 张大小相同的扑克牌。 &amp;quot;Pair&amp;quot;：对子，两张大小一样的扑克牌。 &amp;quot;High Card&amp;quot;：高牌，五张大小互不相同的扑克牌。 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。 注意： 返回的字符串 大小写 需与题目描述相同。 示例 1： 输入：ranks = [13,2,3,1,9], suits = [&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;] 输出：&amp;#34;Flush&amp;#34; 解释：5 张扑克牌的花色相同，所以返回 &amp;#34;Flush&amp;#34; 。 示例 2：&#xA;输入：ranks = [4,4,2,4,4], suits = [&amp;#34;d&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 输出：&amp;#34;Three of a Kind&amp;#34; 解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 &amp;#34;Three of a Kind&amp;#34; 。 注意我们也可以得到 &amp;#34;Pair&amp;#34; ，但是 &amp;#34;Three of a Kind&amp;#34; 是更好的手牌类型。 有其他的 3 张牌也可以组成 &amp;#34;Three of a Kind&amp;#34; 手牌类型。 示例 3：</description>
    </item>
    <item>
      <title>781.rabbits in forest</title>
      <link>http://localhost:1313/posts/leet/781.rabbits-in-forest/</link>
      <pubDate>Sat, 18 Feb 2023 18:14:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/781.rabbits-in-forest/</guid>
      <description>Solution 781. Rabbits in Forest (Medium)&#xA;There is a forest with an unknown number of rabbits. We asked n rabbits &amp;ldquo;How many rabbits have the same color as you?&amp;rdquo; and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit. Given the array answers, return the minimum number of rabbits that could be in the forest. Example 1:&#xA;Input: answers = [1,1,2] Output: 5 Explanation: The two rabbits that answered &amp;#34;1&amp;#34; could both be the same color, say red.</description>
    </item>
    <item>
      <title>781.森林中的兔子</title>
      <link>http://localhost:1313/posts/leet/781.rabbits-in-forest.zh/</link>
      <pubDate>Sat, 18 Feb 2023 18:14:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/781.rabbits-in-forest.zh/</guid>
      <description>问题描述 781. 森林中的兔子 (Medium)&#xA;森林中有未知数量的兔子。提问其中若干只兔子 &amp;ldquo;还有多少只兔子与你（指被提问的兔子）颜色相同?&amp;rdquo; ，将答案收集到一个整数数组 answers 中，其中 answers[i] 是第 i 只兔子的回答。 给你数组 answers ，返回森林中兔子的最少数量。 示例 1：&#xA;输入：answers = [1,1,2] 输出：5 解释： 两只回答了 &amp;#34;1&amp;#34; 的兔子可能有相同的颜色，设为红色。 之后回答了 &amp;#34;2&amp;#34; 的兔子不会是红色，否则他们的回答会相互矛盾。 设回答了 &amp;#34;2&amp;#34; 的兔子为蓝色。 此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。 因此森林中兔子的最少数量是 5 只：3 只回答的和 2 只没有回答的。 示例 2：&#xA;输入：answers = [10,10,10] 输出：11 提示：&#xA;1 &amp;lt;= answers.length &amp;lt;= 1000 0 &amp;lt;= answers[i] &amp;lt; 1000 解题思路 从题目中给出的例子我们可以发现，要想让兔子数量最小，那么要尽量让回答结果相同的兔子是同一个颜色的；&#xA;我们用一个哈希表unordered_map&amp;lt;int, int&amp;gt; ump来记录每种结果有多少只兔子回答了，key为回答结果，value是回答该结果的兔子的数量；&#xA;如果ump[i] &amp;gt; i + 1，说明这批兔子至少有不止一种颜色，颜色数为(ump[i] - 1) / (i + 1) + 1，每种颜色有i + 1个兔子。</description>
    </item>
    <item>
      <title>1996.the number of weak characters in the game</title>
      <link>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game/</link>
      <pubDate>Sat, 18 Feb 2023 17:23:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game/</guid>
      <description>Description 1223. Dice Roll Simulation (Hard)&#xA;A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] ( 1-indexed) consecutive times. Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 10⁹ + 7.</description>
    </item>
    <item>
      <title>1996.游戏中弱角色的数量</title>
      <link>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game.zh/</link>
      <pubDate>Sat, 18 Feb 2023 17:23:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game.zh/</guid>
      <description>问题描述 1996. 游戏中弱角色的数量 (Medium)&#xA;你正在参加一个多角色游戏，每个角色都有两个主要属性： 攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attackᵢ, defenseᵢ] 表示游戏中第 i 个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackⱼ &amp;gt; attackᵢ 且 defenseⱼ &amp;gt; defenseᵢ 。 返回 弱角色 的数量。 示例 1：&#xA;输入：properties = [[5,5],[6,3],[3,6]] 输出：0 解释：不存在攻击和防御都严格高于其他角色的角色。 示例 2：&#xA;输入：properties = [[2,2],[3,3]] 输出：1 解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 示例 3：&#xA;输入：properties = [[1,5],[10,4],[4,3]] 输出：1 解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 提示：&#xA;2 &amp;lt;= properties.length &amp;lt;= 10⁵ properties[i].length == 2 1 &amp;lt;= attackᵢ, defenseᵢ &amp;lt;= 10⁵ 解题思路 首先将角色按照攻击值从大到小排序，至于相同攻击值之间的角色的排序，有两种思路</description>
    </item>
    <item>
      <title>1797.design authentication manager</title>
      <link>http://localhost:1313/posts/leet/1797.design-authentication-manager/</link>
      <pubDate>Sat, 18 Feb 2023 16:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1797.design-authentication-manager/</guid>
      <description>Description 1797. Design Authentication Manager (Medium)&#xA;There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime. Implement the AuthenticationManager class:&#xA;AuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive. generate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.</description>
    </item>
    <item>
      <title>1797.设计一个验证系统</title>
      <link>http://localhost:1313/posts/leet/1797.design-authentication-manager.zh/</link>
      <pubDate>Sat, 18 Feb 2023 16:43:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1797.design-authentication-manager.zh/</guid>
      <description>问题描述 1797. 设计一个验证系统 (Medium)&#xA;你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。 请你实现 AuthenticationManager 类：&#xA;AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。 generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。 renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。 countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻， 未过期 的验证码数目。 如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（ renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。 示例 1： 输入： [&amp;#34;AuthenticationManager&amp;#34;, &amp;#34;renew&amp;#34;, &amp;#34;generate&amp;#34;, &amp;#34;countUnexpiredTokens&amp;#34;, &amp;#34;generate&amp;#34;, &amp;#34;renew&amp;#34;, &amp;#34;renew&amp;#34;, &amp;#34;countUnexpiredTokens&amp;#34;] [[5], [&amp;#34;aaa&amp;#34;, 1], [&amp;#34;aaa&amp;#34;, 2], [6], [&amp;#34;bbb&amp;#34;, 7], [&amp;#34;aaa&amp;#34;, 8], [&amp;#34;bbb&amp;#34;, 10], [15]] 输出： [null, null, null, 1, null, null, null, 0] 解释： AuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 timeToLive = 5 秒。 authenticationManager.</description>
    </item>
    <item>
      <title>1233.remove sub folders from the filesystem</title>
      <link>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem/</link>
      <pubDate>Sat, 18 Feb 2023 16:37:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem/</guid>
      <description>Description 1233. Remove Sub-Folders from the Filesystem (Medium)&#xA;Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order. If a folder[i] is located within another folder[j], it is called a sub-folder of it. The format of a path is one or more concatenated strings of the form: &#39;/&#39; followed by one or more lowercase English letters.</description>
    </item>
    <item>
      <title>1233.删除子文件夹</title>
      <link>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem.zh/</link>
      <pubDate>Sat, 18 Feb 2023 16:37:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem.zh/</guid>
      <description>问题描述 [1233. 删除子文件夹 (Medium)]&#xA;你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：&amp;rsquo;/&amp;rsquo; 后跟一个或者多个小写英文字母。&#xA;例如， &amp;quot;/leetcode&amp;quot; 和 &amp;quot;/leetcode/problems&amp;quot; 都是有效的路径，而空字符串和 &amp;quot;/&amp;quot; 不是。 示例 1： 输入：folder = [&amp;#34;/a&amp;#34;,&amp;#34;/a/b&amp;#34;,&amp;#34;/c/d&amp;#34;,&amp;#34;/c/d/e&amp;#34;,&amp;#34;/c/f&amp;#34;] 输出：[&amp;#34;/a&amp;#34;,&amp;#34;/c/d&amp;#34;,&amp;#34;/c/f&amp;#34;] 解释：&amp;#34;/a/b&amp;#34; 是 &amp;#34;/a&amp;#34; 的子文件夹，而 &amp;#34;/c/d/e&amp;#34; 是 &amp;#34;/c/d&amp;#34; 的子文件夹。 示例 2：&#xA;输入：folder = [&amp;#34;/a&amp;#34;,&amp;#34;/a/b/c&amp;#34;,&amp;#34;/a/b/d&amp;#34;] 输出：[&amp;#34;/a&amp;#34;] 解释：文件夹 &amp;#34;/a/b/c&amp;#34; 和 &amp;#34;/a/b/d&amp;#34; 都会被删除，因为它们都是 &amp;#34;/a&amp;#34; 的子文件夹。 示例 3：&#xA;输入: folder = [&amp;#34;/a/b/c&amp;#34;,&amp;#34;/a/b/ca&amp;#34;,&amp;#34;/a/b/d&amp;#34;] 输出: [&amp;#34;/a/b/c&amp;#34;,&amp;#34;/a/b/ca&amp;#34;,&amp;#34;/a/b/d&amp;#34;] 提示：&#xA;1 &amp;lt;= folder.length &amp;lt;= 4 * 10⁴ 2 &amp;lt;= folder[i].</description>
    </item>
    <item>
      <title>1124.longest well performing interval</title>
      <link>http://localhost:1313/posts/leet/1124.longest-well-performing-interval/</link>
      <pubDate>Fri, 17 Feb 2023 16:13:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1124.longest-well-performing-interval/</guid>
      <description>Description 1124. Longest Well-Performing Interval (Medium)&#xA;We are given hours, a list of the number of hours worked per day for a given employee. A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8. A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</description>
    </item>
    <item>
      <title>1124.表现良好的最长时间段</title>
      <link>http://localhost:1313/posts/leet/1124.longest-well-performing-interval.zh/</link>
      <pubDate>Fri, 17 Feb 2023 16:13:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1124.longest-well-performing-interval.zh/</guid>
      <description>问题描述 1124. 表现良好的最长时间段 (Medium)&#xA;给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「 劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。 示例 1：&#xA;输入：hours = [9,9,6,0,6,6,9] 输出：3 解释：最长的表现良好时间段是 [9,9,6]。 示例 2：&#xA;输入：hours = [6,6,6] 输出：0 提示：&#xA;1 &amp;lt;= hours.length &amp;lt;= 10⁴ 0 &amp;lt;= hours[i] &amp;lt;= 16 解题思路 单调栈 首先，将原数组中大于8的值设为1，小于或等于8的值设为-1，分别表示劳累的一天和不劳累的一天，然后求这个新数组的前缀和，得到一个前缀和数组prefix；&#xA;那么我们就是要求满足prefix[j] &amp;gt; prefix[i]条件下的最大的j - i，首先，我们考虑左端点，如果prefix[i1] &amp;lt; prefix[i2]且i1 &amp;lt;= i2，那么我们完全不需要考虑使用i2作为左端点，因为选择i1作为左端点的res一定更大，所以我们可以正向遍历prefix，并将索引idx压入单调栈，满足栈底到栈顶单调递减；&#xA;然后，我们从从右往左遍历prefix找右端点，如果prefix[j1] &amp;gt; prefix[stk.top()]，那就弹出栈顶元素并更新res = std::max(res, r - stk.top())，如果选择从左往右遍历的话，prefix[j2] &amp;lt; prefix[stk.top()]的时候，最终结果可能是j2 - i，其中i是一个被弹出的元素，从左往右遍历右端点，这种情况无法考虑到。&#xA;哈希表 如果prefix[i] &amp;gt; 0，说明这i天内都是表现良好的时间段，那么res = max(i, res)； 如果prefix[i] &amp;lt;= 0，如果key prefix[i]之前未在哈希表ump中出现过，那么ump[prefix[i]] = i, 否则不更新ump[prefix[i]]，因为哈希表中key对应的value一定更小，对应的差值即时间长度会更大， 以第i天结尾表现良好的时间段的最大长度即为ump[prefix[i]] - ump[prefix[i] - 1]（要求key prefix[i] - 1在哈希表中，否则为0，即不存在这样的时间段），这是因为由于新数组中只有1和-1两种元素，那么值prefix[i] - 1一定比prefix[i] - 2先出现在前缀和数组中。 代码 单调栈 class Solution { public: int longestWPI(vector&amp;lt;int&amp;gt; &amp;amp;hours) { int n = hours.</description>
    </item>
    <item>
      <title>1218.longest arithmetic subsequence of given difference</title>
      <link>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference/</link>
      <pubDate>Thu, 16 Feb 2023 20:01:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference/</guid>
      <description>Description 1218. Longest Arithmetic Subsequence of Given Difference (Medium)&#xA;Longest Arithmetic Subsequence of Given Difference (Medium) Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference. A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.</description>
    </item>
    <item>
      <title>1218.最长定差子序列</title>
      <link>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference.zh/</link>
      <pubDate>Thu, 16 Feb 2023 20:01:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference.zh/</guid>
      <description>问题描述 1218. 最长定差子序列 (Medium)&#xA;给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。 子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。 示例 1：&#xA;输入：arr = [1,2,3,4], difference = 1 输出：4 解释：最长的等差子序列是 [1,2,3,4]。 示例 2：&#xA;输入：arr = [1,3,5,7], difference = 1 输出：1 解释：最长的等差子序列是任意单个元素。 示例 3：&#xA;输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2 输出：4 解释：最长的等差子序列是 [7,5,3,1]。 提示：&#xA;1 &amp;lt;= arr.length &amp;lt;= 10⁵ -10⁴ &amp;lt;= arr[i], difference &amp;lt;= 10⁴ 解题思路 利用哈希表，记录数组中每个元素，作为子序列末尾元素时，该元素对应的最长子序列的长度，有&#xA;if (ump.find(num - difference) != ump.end()) { ump[num] = ump[num - difference] + 1; } else { ump[num] = 1; } 代码 class Solution { public: int longestSubsequence(vector&amp;lt;int&amp;gt; &amp;amp;arr, int difference) { unordered_map&amp;lt;int, int&amp;gt; ump; for (auto &amp;amp;num : arr) { if (ump.</description>
    </item>
    <item>
      <title>2341.maximum Number of Pairs in Array</title>
      <link>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array/</link>
      <pubDate>Thu, 16 Feb 2023 19:19:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array/</guid>
      <description>Description 2341. Maximum Number of Pairs in Array (Easy)&#xA;You are given a 0-indexed integer array nums. In one operation, you may do the following:&#xA;Choose two integers in nums that are equal. Remove both integers from nums, forming a pair. The operation is done on nums as many times as possible. Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.</description>
    </item>
    <item>
      <title>2341.maximum Number of Pairs in Array</title>
      <link>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array.zh/</link>
      <pubDate>Thu, 16 Feb 2023 19:18:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array.zh/</guid>
      <description>问题描述 2341. 数组能形成多少数对 (Easy)&#xA;给你一个下标从 0 开始的整数数组 nums 。在一步操作中，你可以执行以下步骤：&#xA;从 nums 选出 两个 相等的 整数 从 nums 中移除这两个整数，形成一个 数对 请你在 nums 上多次执行此操作直到无法继续执行。 返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目， answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。 示例 1： 输入：nums = [1,3,2,1,3,2,2] 输出：[3,1] 解释： nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。 nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。 nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。 无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。 示例 2：</description>
    </item>
    <item>
      <title>1604.alert using same key card three or more times in a one hour period</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</guid>
      <description>Description 1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period&#xA;Solution Analog, hash table + sort.&#xA;Code class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>1604.警告一小时内使用相同员工卡大于等于三次的人</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</guid>
      <description>问题描述 1604.警告一小时内使用相同员工卡大于等于三次的人&#xA;解题思路 模拟，哈希表+排序&#xA;代码 class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>2325.decode the message</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message/</guid>
      <description>Description 2325.decode-the-message&#xA;Solution We use arrya as a hash table, to keep track of the order in which the letter appear.&#xA;Code class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // -1 means the letter never appears, other value means the order in which the letter appears for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c !</description>
    </item>
    <item>
      <title>2325.解密消息</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</guid>
      <description>问题描述 2325.解密消息&#xA;解题思路 利用数组作为哈希表，记录每个字母是第几个出现的&#xA;代码 class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // 为-1表示这个字母从未出现过，0，1，2等表示这个字母对应的解密字母 for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c != &amp;#39; &amp;#39;) res.push_back(&amp;#39;a&amp;#39; + arr[c - &amp;#39;a&amp;#39;]); else res.</description>
    </item>
    <item>
      <title>1817.查找用户活跃分钟数</title>
      <link>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes.zh/</link>
      <pubDate>Fri, 20 Jan 2023 12:32:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes.zh/</guid>
      <description>问题描述 1817. 查找用户活跃分钟数 (Medium)&#xA;给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDᵢ, timeᵢ] 表示 ID 为 IDᵢ 的用户在 timeᵢ 分钟时执行了某个操作。&#xA;多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。&#xA;指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。&#xA;请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（ 1 &amp;lt;= j &amp;lt;= k）， answer[j] 表示 用户活跃分钟数 等于 j 的用户数。&#xA;返回上面描述的答案数组 answer。&#xA;示例 1：&#xA;输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5 输出：[0,2,0,0,0] 解释： ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次） ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2 2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0 示例 2：</description>
    </item>
    <item>
      <title>1814.count nice pairs in an array</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</link>
      <pubDate>Tue, 17 Jan 2023 17:19:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</guid>
      <description>Description 1814.count-nice-pairs-in-an-array&#xA;Solution We can change the requirements to nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]).&#xA;Then we use hash tables to record the times of occurrence of the value.&#xA;Code class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>1814.统计一个数组中好对子的数目</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</link>
      <pubDate>Tue, 17 Jan 2023 17:12:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</guid>
      <description>问题描述 1814.统计一个数组中好对子的数目&#xA;解题思路 首先，变换一下题目的需求，nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])，然后利用哈希表记录每个值出现了多少次就可以了。&#xA;代码 class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
  </channel>
</rss>
