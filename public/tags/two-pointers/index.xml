<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Two Pointers on My New Hugo Site</title>
    <link>http://localhost:1313/tags/two-pointers/</link>
    <description>Recent content in Two Pointers on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 04 Aug 2023 10:59:11 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/two-pointers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>287. 寻找重复数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/287.find-the-duplicate-number.zh/</link>
      <pubDate>Fri, 04 Aug 2023 10:59:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/287.find-the-duplicate-number.zh/</guid>
      <description>问题描述 287. 寻找重复数 (Medium)&#xA;给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存 在一个重复的整数。&#xA;假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。&#xA;你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。&#xA;示例 1：&#xA;输入：nums = [1,3,4,2,2] 输出：2 示例 2：&#xA;输入：nums = [3,1,3,4,2] 输出：3 提示：&#xA;1 &amp;lt;= n &amp;lt;= 10⁵ nums.length == n + 1 1 &amp;lt;= nums[i] &amp;lt;= n nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 进阶：&#xA;如何证明 nums 中至少存在一个重复的数字?</description>
    </item>
    <item>
      <title>1156. Swap For Longest Repeated Character Substring (Medium)</title>
      <link>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring/</link>
      <pubDate>Sat, 03 Jun 2023 14:02:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring/</guid>
      <description>Description 1156. Swap For Longest Repeated Character Substring (Medium) You are given a string text. You can swap two of the characters in the text.&#xA;Return the length of the longest substring with repeated characters.&#xA;Example 1:&#xA;Input: text = &amp;#34;ababa&amp;#34; Output: 3 Explanation: We can swap the first &amp;#39;b&amp;#39; with the last &amp;#39;a&amp;#39;, or the last &amp;#39;b&amp;#39; with the first &amp;#39;a&amp;#39;. Then, the longest repeated character substring is &amp;#34;aaa&amp;#34; with length 3.</description>
    </item>
    <item>
      <title>1156. 单字符重复子串的最大长度 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring.zh/</link>
      <pubDate>Sat, 03 Jun 2023 14:02:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring.zh/</guid>
      <description>问题描述 1156. 单字符重复子串的最大长度 (Medium) 如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字 符串。&#xA;给你一个字符串 text，你只能交换其中两个字符一次或者什么都 不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度 。&#xA;示例 1：&#xA;输入：text = &amp;#34;ababa&amp;#34; 输出：3 示例 2：&#xA;输入：text = &amp;#34;aaabaaa&amp;#34; 输出：6 示例 3：&#xA;输入：text = &amp;#34;aaabbaaa&amp;#34; 输出：4 示例 4：&#xA;输入：text = &amp;#34;aaaaa&amp;#34; 输出：5 示例 5：&#xA;输入：text = &amp;#34;abcdef&amp;#34; 输出：1 提示：&#xA;1 &amp;lt;= text.length &amp;lt;= 20000 text 仅由小写英文字母组成。 解题思路 可以利用双指针解决，我们先用数组 $cnt$ 统计 $text$ 中每个字符的出现的次数。&#xA;然后我们定一个三个指针，分别为 $i$，$j$，$k$。初始时都为 $0$，然后我们让 $j$ 右移，直到 $text[j] \neq text[i]$，然后令 $k = j + 1$，再右移 $k$，直到 $text[k] \neq text[i]$，这里可以统计一次结果，$res = \max(res, \min(k - i, cnt[text[i]]))$，然后令 $i = j$，重复以上步骤直到 $i &amp;gt;= text.</description>
    </item>
    <item>
      <title>795.区间子数组个数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum.zh/</link>
      <pubDate>Sun, 21 May 2023 18:30:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum.zh/</guid>
      <description>问题描述 795. 区间子数组个数 (Medium) 给你一个整数数组 nums 和两个整数： left 及 right 。找 出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。&#xA;生成的测试用例保证结果符合 32-bit 整数范围。&#xA;示例 1：&#xA;输入：nums = [2,1,4,3], left = 2, right = 3 输出：3 解释：满足条件的三个子数组：[2], [2, 1], [3] 示例 2：&#xA;输入：nums = [2,9,2,5,6], left = 2, right = 8 输出：7 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 10⁵ 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ 0 &amp;lt;= left &amp;lt;= right &amp;lt;= 10⁹ 解题思路 单调栈 当我们看到这种连续区间中的最大值的题目时，就可以考虑使用单调栈。&#xA;对 nums[idx]，我们需要找到以 nums[idx] 为最大值的子数组的数量，设 lidx 为满足 nums[l] &amp;gt;= nums[idx] 且 l &amp;lt; idx 的最大的 l；设 ridx 为满足 nums[r] &amp;gt; nums[idx] 且 r &amp;gt; idx 中的最小的 r。我们要做的就是枚举满足 0 &amp;lt;= idx &amp;lt; n 的所有的 idx，找到对应的 lidx 和 ridx，从而计算出子数组的数量。</description>
    </item>
    <item>
      <title>795.number of Subarrays With Bounded Maximum</title>
      <link>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum/</link>
      <pubDate>Sun, 21 May 2023 18:30:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum/</guid>
      <description>Description 795. Number of Subarrays with Bounded Maximum (Medium) Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right].&#xA;The test cases are generated so that the answer will fit in a 32-bit integer.&#xA;Example 1:&#xA;Input: nums = [2,1,4,3], left = 2, right = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].</description>
    </item>
    <item>
      <title>524.longest word in dictionary through deleting</title>
      <link>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting/</link>
      <pubDate>Tue, 28 Feb 2023 16:26:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting/</guid>
      <description>Description 524. Longest Word in Dictionary through Deleting (Medium)&#xA;Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.&#xA;Example 1:&#xA;Input: s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] Output: &amp;#34;apple&amp;#34; Example 2:</description>
    </item>
    <item>
      <title>524.通过删除字母匹配到字典里最长单词</title>
      <link>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting.zh/</link>
      <pubDate>Tue, 28 Feb 2023 16:26:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting.zh/</guid>
      <description>问题描述 524. 通过删除字母匹配到字典里最长单词 (Medium)&#xA;给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。&#xA;如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。&#xA;示例 1：&#xA;输入：s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] 输出：&amp;#34;apple&amp;#34; 示例 2：&#xA;输入：s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 输出：&amp;#34;a&amp;#34; 提示：&#xA;1 &amp;lt;= s.length &amp;lt;= 1000 1 &amp;lt;= dictionary.length &amp;lt;= 1000 1 &amp;lt;= dictionary[i].length &amp;lt;= 1000 s 和 dictionary[i] 仅由小写英文字母组成 解题思路 首先将dictionary按长度从大到小排序，相同长度的字符串，字典序小的在前面；&#xA;判断dictionary中的字符串是否能通过删除s中的某些字符得到可以利用双指针优化时间复杂度为$O(n)$，n为s的长度。&#xA;代码 class Solution { public: bool IsSub(string &amp;amp;s, string &amp;amp;word) { for (int i = 0, j = 0; j &amp;lt; word.</description>
    </item>
    <item>
      <title>881.boats to save people</title>
      <link>http://localhost:1313/posts/leet/881.boats-to-save-people/</link>
      <pubDate>Sat, 25 Feb 2023 10:24:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/881.boats-to-save-people/</guid>
      <description>Description 881. Boats to Save People (Medium)&#xA;You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.&#xA;Return the minimum number of boats to carry every given person.</description>
    </item>
    <item>
      <title>881.救生艇</title>
      <link>http://localhost:1313/posts/leet/881.boats-to-save-people.zh/</link>
      <pubDate>Sat, 25 Feb 2023 10:23:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/881.boats-to-save-people.zh/</guid>
      <description>问题描述 881. 救生艇 (Medium)&#xA;给定数组 people 。 people[i] 表示第 i 个人的体重 ， 船的数量不限，每艘船可以承载的最大重量为 limit。&#xA;每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。&#xA;返回 承载所有人所需的最小船数 。&#xA;示例 1：&#xA;输入：people = [1,2], limit = 3 输出：1 解释：1 艘船载 (1, 2) 示例 2：&#xA;输入：people = [3,2,2,1], limit = 3 输出：3 解释：3 艘船分别载 (1, 2), (2) 和 (3) 示例 3：&#xA;输入：people = [3,5,3,4], limit = 5 输出：4 解释：4 艘船分别载 (3), (3), (4), (5) 提示：&#xA;1 &amp;lt;= people.length &amp;lt;= 5 * 10⁴ 1 &amp;lt;= people[i] &amp;lt;= limit &amp;lt;= 3 * 10⁴ 解题思路 每次必定选择最轻的的和二者重量和不超过limit的最重的人上船，因此可以将数组排序，然后一左一右双指针向中间遍历。</description>
    </item>
    <item>
      <title>443.压缩字符串</title>
      <link>http://localhost:1313/posts/leet/443.string-compression.zh/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression.zh/</guid>
      <description>问题描述 443.压缩字符串&#xA;解题思路 双指针、滑动窗口，注意for循环中不需要fast++。&#xA;代码 class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.push_back(chars[slow]); res.push_back(cnt + &amp;#39;0&amp;#39;); } else if (cnt &amp;gt;= 10 &amp;amp;&amp;amp; cnt &amp;lt;= 99) { res.</description>
    </item>
    <item>
      <title>443.string compression</title>
      <link>http://localhost:1313/posts/leet/443.string-compression/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression/</guid>
      <description>Description 443.string-compression&#xA;Solution Sliding window, please pay attention to that fast++ is not needed in for loop.&#xA;Code class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.</description>
    </item>
    <item>
      <title>3.longest substring without repeating characters</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</guid>
      <description>Description 3.longest-substring-withou-repeating-characters&#xA;Solution We use arr[96] to record the number of occurence of each character. If the number is larger than 1, than there is repeating character between l and r; else, update res, if current length of substr is larger than res.&#xA;Code class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.</description>
    </item>
    <item>
      <title>3.无重复字符的最长子串</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</guid>
      <description>问题描述 3.无重复字符的最长子串&#xA;解题思路 用arr[96]记录每个字符出现的次数，如果字符次数大于1，说明已经包含了重复字符，则要更新l，否则递增r，并记录最大的子串长度。&#xA;代码 class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.size(); r++) { arr[s[r] - &amp;#39; &amp;#39;]++; if (arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) { while (l &amp;lt; r &amp;amp;&amp;amp; arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) arr[s[l++] - &amp;#39; &amp;#39;]--; } else { res = max(r - l + 1, res); } } return res; } }; </description>
    </item>
    <item>
      <title>30.substring with concatenation of all words</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</guid>
      <description>Description 30.substring-with-concatenation-of-all-words&#xA;Solution For each word sequence {s.substr(i, word_len), s.substr(i + word_len, word_len)...} of i($[0, word_len - 1]$), we use sliding window to judge;&#xA;We should pay attention to the detail when judging. We can use mp to determine whether substr is in words, and mp_tmp to determine whether it is concatenated substring, if mp is empty, then it is;&#xA;For key-value in mp_tmp, if value becomes 0, then erase(key);</description>
    </item>
    <item>
      <title>30.串联所有单词串</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</guid>
      <description>问题描述 30.串联所有单词串&#xA;解题思路 首先，由于words中所有字符串长度相同，要比较words与s: - s从i = 0开始，可以划分为一系列的长为word_len = words[0].size()的单词; - s从i = 1开始，可以划分为一系列的长为word_len = words[0].size()的单词; - &amp;hellip;&amp;hellip; - s从i = word_len - 1开始&amp;hellip;&amp;hellip;&#xA;然后要注意利用unordered_map&amp;lt;string, int&amp;gt;判断是否满足条件的细节，mp用于判断word是否在words中;&#xA;mp_tmp的键值对中，如果值为0，就删掉该键;&#xA;还要注意l的处理，分为在mp_tmp为空，和mp_tmp不为空，但是word已经出现了超过words中的次数.&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findSubstring(string s, vector&amp;lt;string&amp;gt; &amp;amp;words) { unordered_map&amp;lt;string, int&amp;gt; mp; int word_len = words[0].size(); int cnt = 0; vector&amp;lt;int&amp;gt; res; for (int i = 0; i &amp;lt; words.size(); i++) { mp[words[i]]++; cnt++; } if (cnt * word_len &amp;gt; s.</description>
    </item>
    <item>
      <title>1610.maximum Number of Visible Points</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</guid>
      <description>Descripiton 1610.maximum-number-of-visible-points&#xA;Soluiton We can use function atan2 to change slope to angle in $-\pi ~ \pi$.&#xA;We need also expand arrays, let angle[n + i] = angle[i] + 360, and the length of array to be 2 * n, so we can avoid omission.&#xA;Code class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>1610.可见点的最大数目</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</guid>
      <description>问题描述 1610.可见点的最大数目&#xA;解题思路 利用atan2函数，即可将斜率转化为$-\pi ~ \pi$的角度;&#xA;扩充数组，令angle[n + i] = angle[i] + 360，使角度数组长度为2 * n，这样就能避免遗漏一四象限。&#xA;代码 class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>424.替换后的最长重复字符</title>
      <link>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:47:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</guid>
      <description>问题描述 424.替换后的最长重复字符&#xA;解题思路 首先，注意一点，子串如果能通过k次替换变成只包含相同字母的子串，那么一定有max_cnt + k &amp;gt;= subarray.size();那么不满足条件的子串一定有max_cnt + k &amp;lt; subarray.size()，根据这一点，我们可以采用滑动窗口法;&#xA;如果满足条件，那么只增加right，如果不满足条件，right++、left++，这样right - left一定是递增的，并且会遍历搜寻到所有的不同字符。&#xA;代码 class Solution { public: int characterReplacement(string s, int k) { vector&amp;lt;int&amp;gt; num(26); int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right &amp;lt; n) { num[s[right] - &amp;#39;A&amp;#39;]++; maxn = max(maxn, num[s[right] - &amp;#39;A&amp;#39;]); if (right - left + 1 - maxn &amp;gt; k) { num[s[left] - &amp;#39;A&amp;#39;]--; left++; } right++; } return right - left; } }; </description>
    </item>
    <item>
      <title>413.arithmetic slices</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices/</guid>
      <description>Descritpion 413.arithmetic slices&#xA;Solution We should notice that the number of subarray $cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$(len) is the length of arithmetic array.&#xA;Code class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>413.等差数列划分</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</guid>
      <description>问题描述 413.等差数列划分&#xA;解题思路 注意到子数组个数$cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$，其中len是等差数组的长度，则cnt = (n - 1) * (n - 2) / 2，每次遍历找出连续的等差数组的长度即可。 测试test&#xA;代码 class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.size(); i++) { if (nums[i] - nums[i - 1] == dif) len++; else { if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; len = 2; dif = nums[i] - nums[i - 1]; } } if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; return cnt; } }; </description>
    </item>
    <item>
      <title>88.merge sorted array</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array/</guid>
      <description>Description 88.merge-sorted-array&#xA;Solution We use pointers, assign values of nums1 from end to front, so we use only $\Theta(1)$ extra space.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>88.合并两个有序数组</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</guid>
      <description>问题描述 88.合并两个有序数组&#xA;解题思路 双指针，由于num1的长度是m + n，因此遍历时，可以考虑针对nums1，从后往前赋值，从而只需要$\Theta(1)$的额外空间。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>142.linked list cycle ii</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</guid>
      <description>Description 142.linked-list-cycle-ii&#xA;Solution Like 141.linked-list-cycle, when fast and slow meet each other, we make a pointer p start from virtual head node, traverse one by one, the same as slow. slow and p will meet at the entrance of the cycle.&#xA;Code class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead !</description>
    </item>
    <item>
      <title>142.环形链表II</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</guid>
      <description>问题描述 142.环形链表II&#xA;解题思路 判断是否链表是否存在环的方式与141.环形链表一致，当两个指针相遇时，再让一个指针从虚拟头节点开始一个节点一个节点的遍历，slow指针也是，两个指针会在环的入口处相遇。&#xA;代码 class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead != slow) { vhead = vhead-&amp;gt;next; slow = slow-&amp;gt;next; } delete vhead; return slow; } } return nullptr; } }; </description>
    </item>
    <item>
      <title>141.linked list cycle</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle/</guid>
      <description>Description 141.linked-list-cycle&#xA;Solution We can use two pointers, one fast, one slow. For each time, fast move to next next node, slow move to next node. If there is cycle, fast will be equal to slow, or fast will be nullptr.&#xA;Code class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>141.环形链表</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</guid>
      <description>问题描述 141.环形链表&#xA;解题思路 使用快慢两个指针，fast一次移动两个节点，slow一次移动一个节点，如果链表存在环，那么fast和slow一定会有相等的时候，否则fast会运动到链表末尾。&#xA;代码 class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>345.reverse vowels of a string</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</guid>
      <description>Description 345.reverse-vowels-of-a-string&#xA;Solution We use unordered_set to determine whether it is vowel, two pointers.&#xA;Code class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.</description>
    </item>
    <item>
      <title>345.反转字符串中的元音字母</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</guid>
      <description>问题描述 345.反转字符串中的元音字母&#xA;解题思路 双指针法，使用unordered_set(底层实现为哈希表)来判断是否是元音字母。&#xA;代码 class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) == mset.end()) r--; else if (mset.</description>
    </item>
    <item>
      <title>75.sort colors</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors/</link>
      <pubDate>Fri, 25 Nov 2022 15:27:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors/</guid>
      <description>Description 75.sort-colors&#xA;Solution Here, we need three pointers l, r, idx, l for 0, r for 2, idx for traversing.&#xA;When traversing:&#xA;if nums[idx] == 0,swap(nums[idx], nums[l]);, and idx++; l++ if nums[idx] == 1, idx++; if nums[idx] == 2, swap(nums[idx], nums[r]);, and only r--, because new nums[idx] may be 0 or 1 or 2, so we need determine the value of nums[idx] again. if swap(nums[idx], nums[l]);, new nums[idx] will be 0 only when idx == l, or nums[idx] == 1, so we can increase idx.</description>
    </item>
    <item>
      <title>75.颜色分类</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors.zh/</link>
      <pubDate>Fri, 25 Nov 2022 15:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors.zh/</guid>
      <description>问题描述 75.颜色分类&#xA;解题思路 这里，我们需要三个指针l, r, idx, l用来存放0,r用来存放2，idx用来进行遍历数组。&#xA;要注意的是，在遍历数组时:&#xA;if nums[idx] == 0，需要交换nums[idx]和nums[l]的值，同时idx++; l++; if nums[idx] == 1，idx++即可 if nums[idx] == 2，需要交换nums[idx]和nums[l]的值，但此时只是r--，不会idx++，这是因为新的交换后的nums[idx]的值可能是0、1、2中的任意一个，因此还需要重新判断nums[idx] 如果idx == l，那么[0, idx]区间范围内的数都是0，如果idx != l，那么[0, l - 1]区间范围内都是0，[l, idx)区间范围内都是1，因此可以进行idx++; 代码 class Solution { public: void sortColors(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int tmp = 0, index = 0; int l = 0, r = nums.size() - 1; while (index &amp;lt;= r) { if (nums[index] == 0) { tmp = nums[l]; nums[l++] = 0; nums[index++] = tmp; } else if (nums[index] == 2) { tmp = nums[r]; nums[r--] = 2; nums[index] = tmp; } else index++; } } }; </description>
    </item>
    <item>
      <title>26.remove duplicates from sorted array</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</guid>
      <description>Description 26.remove-duplicates-from-sorted-array&#xA;Solution We use two pointers fast and slow, fast used to check if duplicated, slow use for assignment.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>26.删除有序数组中的重复项</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</guid>
      <description>问题描述 26.删除有序数组中的重复项&#xA;解题思路 采用双指针法，一快一慢，fast用于检测是否重复，slow用来被赋值。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>18.4sum</title>
      <link>http://localhost:1313/posts/leet/18.4sum/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum/</guid>
      <description>Description 18.4sum&#xA;Solution Two pointers, i, j = i + 1, l = j + 1, r = nums.size() - 1;&#xA;Pay attention to overflow exception and deduplication.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    <item>
      <title>18.4四数之和</title>
      <link>http://localhost:1313/posts/leet/18.4sum.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum.zh/</guid>
      <description>问题描述 18.四数之和&#xA;解题思路 双指针法，i, j = i + 1, l, r;&#xA;注意去重和溢出。&#xA;代码 class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.size() - 2; j++) { if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) continue; int l = j + 1, r = nums.</description>
    </item>
    <item>
      <title>19.remove nth node from end of list</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</guid>
      <description>Description 19.remove-nth-node-from-end-of-list&#xA;Solution For convenience, we create a virtual head node pre, pre-&amp;gt;next = head.&#xA;We will use two pointers fast and slow. First, fast go head for n times, then fast and slow go ahead together. When fast arrives at last node, slow points to the last node of the node we need delete.&#xA;Code class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next !</description>
    </item>
    <item>
      <title>19.删除链表的倒数第N个节点</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</guid>
      <description>问题描述 19.删除链表的倒数第N个节点&#xA;解题思路 首先设置一个虚拟头节点pre，pre-&amp;gt;next = head;&#xA;双指针法，考虑使用两个指针fast，slow，一快一慢，fast指针先前进n个位置，然后fast和slow一起遍历，当fast到达最后一个节点的时候，slow刚好位于要删除的节点的前一个节点。&#xA;代码 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next; slow = slow-&amp;gt;next; } slow-&amp;gt;next = slow-&amp;gt;next-&amp;gt;next; return pre-&amp;gt;next; } }; </description>
    </item>
    <item>
      <title>16.3sum closest</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest/</guid>
      <description>Description 16.3sum-closest&#xA;Solution The violent solution: triple cycle, $\Theta(n^3)$&#xA;We should notice that we don&amp;rsquo;t care the original index of array, so we can use two pointers to reduce the time complexity.&#xA;First, we need sort the array, in outer loop, i iterates from 0 to nums.size() - 3, in inner loop, l and r come together from end to the middle.&#xA;Code class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.</description>
    </item>
    <item>
      <title>16.最接近的三数之和</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest.zh/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest.zh/</guid>
      <description>问题描述 16.最接近的三数之和&#xA;解题思路 暴力解法，三重循环，时间复杂度为$\Theta(n^3)$;&#xA;注意到本题不关注数组中元素的初始索引，因此可以考虑利用双指针来降低时间复杂度: 首先将数组排序，最外层i从0遍历到nums.size() - 3，内层循环采用相向双指针l，r从两端向中间靠拢，并且要注意如何去重，(当然，此题可以不关注)。&#xA;代码 class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.begin(), nums.end()); int sum = nums[0] + nums[1] + nums[2]; // 记录三数之和 for (int i = 0; i &amp;lt; nums.size() - 2; i++) { // 跳过重复的 if (i !</description>
    </item>
    <item>
      <title>11.container with most water</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water/</link>
      <pubDate>Sat, 19 Nov 2022 09:46:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water/</guid>
      <description>Description 11.container-with-most-water&#xA;Solution The violent solution of this problem has a time complexity of $O(n^2)$, to reduce the time complexity, we consider two-pointers.&#xA;So, we need determine how left pointer l and right pointer r will meet each other:&#xA;if (height[l] &amp;gt;= height[r]), the capacity depends on height[r]. If l++, the capacity will become smaller, so we should r--. if (height[l] &amp;lt; height[r]), the capacity depends on height[l]. If r--, the capacity will become smaller, so we should l++.</description>
    </item>
    <item>
      <title>11.盛最多水的容器</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</link>
      <pubDate>Sat, 19 Nov 2022 09:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</guid>
      <description>问题描述 11.盛最多水的容器&#xA;解题思路 本题暴力解法，时间复杂度为$O(n^2)$(会超时，没试过)，为了降低时间复杂度，考虑使用双指针。&#xA;那么，本题需要考虑的就是左指针l和右指针r如何向中间靠拢：&#xA;if (height[l] &amp;gt;= height[r])，说明容器容积是由height[r]来决定的，这时候，l向中间考虑，只可能会缩小容积，因此应该r--; if (height[l] &amp;lt; height[r])，说明容器容积由height[l]来决定，这时候，r向中间靠拢，只会缩小容积，因此应该l++; 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int l = 0, r = height.size() - 1; int res = 0; while (l &amp;lt; r) { if (height[l] &amp;gt;= height[r]) { res = max(res, (r - l) * height[r]); r--; // 因为此时，增加l只可能缩小res，所以减少r } else { res = max(res, (r - l) * height[l]); l++; // height[l] &amp;lt; height[r], 此时减少r也只会缩小res，所以增加l } } return res; } }; </description>
    </item>
  </channel>
</rss>
