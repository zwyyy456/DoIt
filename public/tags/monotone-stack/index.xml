<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Monotone Stack on My New Hugo Site</title>
    <link>http://localhost:1313/tags/monotone-stack/</link>
    <description>Recent content in Monotone Stack on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 May 2023 15:24:16 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/monotone-stack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>85. Maximal Rectangle (Hard)</title>
      <link>http://localhost:1313/posts/leet/85.maximal-rectangle/</link>
      <pubDate>Tue, 23 May 2023 15:24:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/85.maximal-rectangle/</guid>
      <description>Description Maximal Rectangle (Hard) Given a rows x cols binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest rectangle containing only 1&amp;rsquo;s and return its area. Example 1:&#xA;Input: matrix = [[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Example 2:&#xA;Input: matrix = [[&amp;#34;0&amp;#34;]] Output: 0 Example 3:&#xA;Input: matrix = [[&amp;#34;1&amp;#34;]] Output: 1 Constraints:&#xA;rows == matrix.length cols == matrix[i].length 1 &amp;lt;= row, cols &amp;lt;= 200 matrix[i][j] is &#39;0&#39; or &#39;1&#39;.</description>
    </item>
    <item>
      <title>85. 最大矩形 (Hard)</title>
      <link>http://localhost:1313/posts/leet/85.maximal-rectangle.zh/</link>
      <pubDate>Tue, 23 May 2023 15:24:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/85.maximal-rectangle.zh/</guid>
      <description>问题描述 85. 最大矩形 (Hard) 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进 制矩阵，找出只包含 1 的最大矩形，并返回其面积。&#xA;示例 1：&#xA;![](https://assets.leetcode.com/uploads/2020/09/14/maximal.j pg)&#xA;输入：matrix = [[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;]] 输出：6 解释：最大矩形如上图所示。 示例 2：&#xA;输入：matrix = [] 输出：0 示例 3：&#xA;输入：matrix = [[&amp;#34;0&amp;#34;]] 输出：0 示例 4：&#xA;输入：matrix = [[&amp;#34;1&amp;#34;]] 输出：1 示例 5：&#xA;输入：matrix = [[&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;]] 输出：0 提示：&#xA;rows == matrix.length cols == matrix[0].length 1 &amp;lt;= row, cols &amp;lt;= 200 matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39; 解题思路 其实本题就相当于是 84.</description>
    </item>
    <item>
      <title>84. Largest Rectangle in Histogram (Hard)</title>
      <link>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram/</link>
      <pubDate>Tue, 23 May 2023 15:08:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram/</guid>
      <description>Description 84. Largest Rectangle in Histogram (Hard) Given an array of integers heights representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.&#xA;Example 1:&#xA;Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.</description>
    </item>
    <item>
      <title>84. 柱状图中最大的矩形 (Hard)</title>
      <link>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram.zh/</link>
      <pubDate>Tue, 23 May 2023 15:08:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram.zh/</guid>
      <description>问题描述 84. 柱状图中最大的矩形 (Hard) 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子 彼此相邻，且宽度为 1 。&#xA;求在该柱状图中，能够勾勒出来的矩形的最大面积。&#xA;示例 1:&#xA;![](https://assets.leetcode.com/uploads/2021/01/04/histogram .jpg)&#xA;输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2：&#xA;![](https://assets.leetcode.com/uploads/2021/01/04/histogram -1.jpg)&#xA;输入： heights = [2,4] 输出： 4 提示：&#xA;1 &amp;lt;= heights.length &amp;lt;=10⁵ 0 &amp;lt;= heights[i] &amp;lt;= 10⁴ 解题思路 本题其实还是求一个连续变长区间的最小值，以及该区间的长度，可以考虑到使用单调栈来解决，至于使用单调递增还是单调递减栈，代入题目中的示例模拟一下就知道了，本题应该使用单调递增栈（栈底到栈顶单调递增）。&#xA;在本题中，我们遍历数组，对 nums[i]，找到满足 nums[r] &amp;lt; nums[i] 且 r &amp;gt; i 的最小的 r，记为 ridx，找到满足 nums[l] &amp;lt; nums[i] 且 l &amp;lt; i 的最大的 l，记为 lidx，则 res = max(res, nums[i] * (ridx - lidx - 1))，我们可以利用单调栈在 $O(n)$ 时间内完成求解。</description>
    </item>
    <item>
      <title>2104. Sum of Subarray Ranges (Medium)</title>
      <link>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges/</link>
      <pubDate>Sun, 21 May 2023 19:00:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges/</guid>
      <description>Description 2104. Sum of Subarray Ranges (Medium) You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.&#xA;Return the sum of all subarray ranges of nums.&#xA;A subarray is a contiguous non-empty sequence of elements within an array.&#xA;Example 1:&#xA;Input: nums = [1,2,3] Output: 4 Explanation: The 6 subarrays of nums are the following: [1], range = largest - smallest = 1 - 1 = 0 [2], range = 2 - 2 = 0 [3], range = 3 - 3 = 0 [1,2], range = 2 - 1 = 1 [2,3], range = 3 - 2 = 1 [1,2,3], range = 3 - 1 = 2 So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.</description>
    </item>
    <item>
      <title>2104. 子数组范围和 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges.zh/</link>
      <pubDate>Sun, 21 May 2023 19:00:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges.zh/</guid>
      <description>问题描述 2104. 子数组范围和 (Medium) 给你一个整数数组 nums 。 nums 中，子数组的 范围 是子 数组中最大元素和最小元素的差值。&#xA;返回 nums 中 所有 子数组范围的 和。&#xA;子数组是数组中一个连续 非空 的元素序列。&#xA;示例 1：&#xA;输入：nums = [1,2,3] 输出：4 解释：nums 的 6 个子数组如下所示： [1]，范围 = 最大 - 最小 = 1 - 1 = 0 [2]，范围 = 2 - 2 = 0 [3]，范围 = 3 - 3 = 0 [1,2]，范围 = 2 - 1 = 1 [2,3]，范围 = 3 - 2 = 1 [1,2,3]，范围 = 3 - 1 = 2 所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4 示例 2：</description>
    </item>
    <item>
      <title>795.区间子数组个数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum.zh/</link>
      <pubDate>Sun, 21 May 2023 18:30:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum.zh/</guid>
      <description>问题描述 795. 区间子数组个数 (Medium) 给你一个整数数组 nums 和两个整数： left 及 right 。找 出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。&#xA;生成的测试用例保证结果符合 32-bit 整数范围。&#xA;示例 1：&#xA;输入：nums = [2,1,4,3], left = 2, right = 3 输出：3 解释：满足条件的三个子数组：[2], [2, 1], [3] 示例 2：&#xA;输入：nums = [2,9,2,5,6], left = 2, right = 8 输出：7 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 10⁵ 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ 0 &amp;lt;= left &amp;lt;= right &amp;lt;= 10⁹ 解题思路 单调栈 当我们看到这种连续区间中的最大值的题目时，就可以考虑使用单调栈。&#xA;对 nums[idx]，我们需要找到以 nums[idx] 为最大值的子数组的数量，设 lidx 为满足 nums[l] &amp;gt;= nums[idx] 且 l &amp;lt; idx 的最大的 l；设 ridx 为满足 nums[r] &amp;gt; nums[idx] 且 r &amp;gt; idx 中的最小的 r。我们要做的就是枚举满足 0 &amp;lt;= idx &amp;lt; n 的所有的 idx，找到对应的 lidx 和 ridx，从而计算出子数组的数量。</description>
    </item>
    <item>
      <title>795.number of Subarrays With Bounded Maximum</title>
      <link>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum/</link>
      <pubDate>Sun, 21 May 2023 18:30:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum/</guid>
      <description>Description 795. Number of Subarrays with Bounded Maximum (Medium) Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right].&#xA;The test cases are generated so that the answer will fit in a 32-bit integer.&#xA;Example 1:&#xA;Input: nums = [2,1,4,3], left = 2, right = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].</description>
    </item>
    <item>
      <title>654.Maximum Binary Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/654.maximum-binary-tree/</link>
      <pubDate>Sun, 19 Mar 2023 17:25:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/654.maximum-binary-tree/</guid>
      <description>Description 654. Maximum Binary Tree (Medium)&#xA;You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:&#xA;Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value.</description>
    </item>
    <item>
      <title>654.最大二叉树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/654.maximum-binary-tree.zh/</link>
      <pubDate>Sun, 19 Mar 2023 17:25:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/654.maximum-binary-tree.zh/</guid>
      <description>问题描述 654. 最大二叉树 (Medium)&#xA;给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:&#xA;创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树。&#xA;示例 1：&#xA;输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2：</description>
    </item>
    <item>
      <title>1124.longest well performing interval</title>
      <link>http://localhost:1313/posts/leet/1124.longest-well-performing-interval/</link>
      <pubDate>Fri, 17 Feb 2023 16:13:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1124.longest-well-performing-interval/</guid>
      <description>Description 1124. Longest Well-Performing Interval (Medium)&#xA;We are given hours, a list of the number of hours worked per day for a given employee. A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8. A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</description>
    </item>
    <item>
      <title>1124.表现良好的最长时间段</title>
      <link>http://localhost:1313/posts/leet/1124.longest-well-performing-interval.zh/</link>
      <pubDate>Fri, 17 Feb 2023 16:13:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1124.longest-well-performing-interval.zh/</guid>
      <description>问题描述 1124. 表现良好的最长时间段 (Medium)&#xA;给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「 劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。 示例 1：&#xA;输入：hours = [9,9,6,0,6,6,9] 输出：3 解释：最长的表现良好时间段是 [9,9,6]。 示例 2：&#xA;输入：hours = [6,6,6] 输出：0 提示：&#xA;1 &amp;lt;= hours.length &amp;lt;= 10⁴ 0 &amp;lt;= hours[i] &amp;lt;= 16 解题思路 单调栈 首先，将原数组中大于8的值设为1，小于或等于8的值设为-1，分别表示劳累的一天和不劳累的一天，然后求这个新数组的前缀和，得到一个前缀和数组prefix；&#xA;那么我们就是要求满足prefix[j] &amp;gt; prefix[i]条件下的最大的j - i，首先，我们考虑左端点，如果prefix[i1] &amp;lt; prefix[i2]且i1 &amp;lt;= i2，那么我们完全不需要考虑使用i2作为左端点，因为选择i1作为左端点的res一定更大，所以我们可以正向遍历prefix，并将索引idx压入单调栈，满足栈底到栈顶单调递减；&#xA;然后，我们从从右往左遍历prefix找右端点，如果prefix[j1] &amp;gt; prefix[stk.top()]，那就弹出栈顶元素并更新res = std::max(res, r - stk.top())，如果选择从左往右遍历的话，prefix[j2] &amp;lt; prefix[stk.top()]的时候，最终结果可能是j2 - i，其中i是一个被弹出的元素，从左往右遍历右端点，这种情况无法考虑到。&#xA;哈希表 如果prefix[i] &amp;gt; 0，说明这i天内都是表现良好的时间段，那么res = max(i, res)； 如果prefix[i] &amp;lt;= 0，如果key prefix[i]之前未在哈希表ump中出现过，那么ump[prefix[i]] = i, 否则不更新ump[prefix[i]]，因为哈希表中key对应的value一定更小，对应的差值即时间长度会更大， 以第i天结尾表现良好的时间段的最大长度即为ump[prefix[i]] - ump[prefix[i] - 1]（要求key prefix[i] - 1在哈希表中，否则为0，即不存在这样的时间段），这是因为由于新数组中只有1和-1两种元素，那么值prefix[i] - 1一定比prefix[i] - 2先出现在前缀和数组中。 代码 单调栈 class Solution { public: int longestWPI(vector&amp;lt;int&amp;gt; &amp;amp;hours) { int n = hours.</description>
    </item>
    <item>
      <title>456.132 pattern</title>
      <link>http://localhost:1313/posts/leet/456.132-pattern/</link>
      <pubDate>Fri, 17 Feb 2023 14:46:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/456.132-pattern/</guid>
      <description>Description 456. 132 Pattern (Medium)&#xA;Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false. Example 1:&#xA;Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Example 2:</description>
    </item>
    <item>
      <title>456.132模式</title>
      <link>http://localhost:1313/posts/leet/456.132-pattern.zh/</link>
      <pubDate>Fri, 17 Feb 2023 14:46:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/456.132-pattern.zh/</guid>
      <description>问题描述 456. 132 模式 (Medium)&#xA;给你一个整数数组 nums ，数组中共有 n 个整数。 132 模式的子序列 由三个整数 nums[i]、 nums[j] 和 nums[k] 组成，并同时满足： i &amp;lt; j &amp;lt; k 和 nums[i] &amp;lt; nums[k] &amp;lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 示例 1：&#xA;输入：nums = [1,2,3,4] 输出：false 解释：序列中不存在 132 模式的子序列。 示例 2：&#xA;输入：nums = [3,1,4,2] 输出：true 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3：&#xA;输入：nums = [-1,3,2,0] 输出：true 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示：</description>
    </item>
    <item>
      <title>768.max chunks to make sorted ii</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</guid>
      <description>Description 768.max-chunks-to-make-sorted-ii&#xA;Solution A sufficient condition for an array to be divisible into blocks that satisfy the condition is that all elements in the block are less than or equal to any of the undivided elements in the right-hand array.&#xA;Code class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.</description>
    </item>
    <item>
      <title>768.最多能完成排序的块 II</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</guid>
      <description>问题描述 768.最多能完成排序的块II&#xA;解题思路 可以划分成满足条件的块的充分必要条件是，块内所有元素都小于等于右侧数组中未划分的任一元素。&#xA;本题中使用了map来进行处理，实际上使用单调栈就可以了。&#xA;代码 class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.size(); i++) r_map[arr[i]]++; while (idx &amp;lt; arr.size()) { for (int i = idx; i &amp;lt; arr.size(); i++) { l_map[arr[i]]++; r_map[arr[i]]--; if (r_map[arr[i]] == 0) r_map.erase(arr[i]); if (r_map.empty()) break; if (l_map.begin()-&amp;gt;first &amp;lt;= r_map.begin()-&amp;gt;first) { idx = i + 1; ans++; break; } } if (r_map.</description>
    </item>
    <item>
      <title>42.trapping rain water</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water/</guid>
      <description>Description 42.trapping-rain-water&#xA;Solution We can use monotone stack&#xA;The capacity of unit cosist of height[stk.top()] is (min(height[r], height[l]) - height[stk.top()]) * (l - r - 1), l is next element below the top of the stack, since height[l] &amp;gt;= height[stk.top()] r is the index of first column which height[r] &amp;gt;= height[stk.top()].&#xA;The result is the sum.&#xA;Code ```cpp #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.</description>
    </item>
    <item>
      <title>42.接雨水</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</guid>
      <description>问题描述 42.接雨水&#xA;解题思路 本题考虑使用单调栈(monotone stack)，栈顶到栈底依次递增。&#xA;由height[stk.top()]存放雨水的单元，其计算方式为(min(height[r], height[l]) - height[stk.top()]) * (l - r - 1)，其中l即栈顶的下一个元素，r则是第一个高度大于height[stk.top()]的柱子的索引。&#xA;结果为所有柱子能存放的雨水的累加。&#xA;代码 #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.push(0); int res = 0; for (int i = 1; i &amp;lt; height.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; height[i] &amp;gt; height[stk.top()]) { int mid = stk.top(); stk.pop(); if (!stk.empty()) { int h = min(height[i], height[stk.top()]) - height[mid]; int w = i - stk.</description>
    </item>
    <item>
      <title>503.下一个更大元素II</title>
      <link>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:59:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</guid>
      <description>问题描述 503.下一个更大元素II&#xA;解题思路 相比496.下一个更大元素I，在遍历数组上有所区别，如果i &amp;gt;= nums.size()，用j = i - nums.size();来代替i，因此i的取值范围是[0, 2 * nums.size())。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElements(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; res(nums.size(), -1); stack&amp;lt;int&amp;gt; stk; stk.push(0); int j = 0; for (int i = 1; i &amp;lt; 2 * nums.size(); i++) { if (i &amp;gt;= nums.size()) { j = i - nums.size(); while (!stk.empty() &amp;amp;&amp;amp; nums[j] &amp;gt; nums[stk.top()]) { res[stk.top()] = nums[j]; stk.pop(); } stk.push(j); } else { while (!</description>
    </item>
    <item>
      <title>496.next greater element i</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i/</guid>
      <description>Description 496.next-greater-element-i&#xA;Solution We can use monotone stack to traverse nums2, and use unordered_map to store the element in nums1 and corresponding result.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.</description>
    </item>
    <item>
      <title>496.下一个更大元素I</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</guid>
      <description>问题描述 496.下一个更大元素I&#xA;解题思路 本题利用单调栈(monotone stack)来遍历nums2，并且利用unordered_map来存储nums1中元素和对应的结果。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.find(nums2[stk.top()]) != umap.end()) { umap[nums2[stk.top()]] = nums2[i]; } stk.pop(); } stk.push(i); } vector&amp;lt;int&amp;gt; res(nums1.size(), -1); for (int i = 0; i &amp;lt; nums1.</description>
    </item>
    <item>
      <title>monotone stack</title>
      <link>http://localhost:1313/posts/tech/monotone-stack/</link>
      <pubDate>Fri, 11 Nov 2022 15:55:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/monotone-stack/</guid>
      <description>Description brief Monotone stack is a stack whose elements(from top to bottom) are (strictly) monotonically increasing or decreasing.&#xA;Monotone increasing stack: the element which is smaller than the element in the top can be pushed into stack, else we will pop the element in the top, until the stack is empty or the element is smaller than the element in the top, then we push the element into the stack. This data structure is usually used for problems to find first element that is larger than certain element.</description>
    </item>
    <item>
      <title>单调栈</title>
      <link>http://localhost:1313/posts/tech/monotone-stack.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:54:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/monotone-stack.zh/</guid>
      <description>问题描述 简述 单调栈(monotone stack)是指栈内元素(栈顶到栈底)都是(严格)单调递增或者递减的栈。&#xA;单调递增栈(从栈顶到栈底)：只有比栈顶小的才能入栈，否把栈顶元素弹出，直到栈为空或者或者待处理的元素小于栈顶元素，将元素入栈，适用于求解第一个大于某元素的数的情况；&#xA;单调递减栈，与递增栈相反，适用于求解第一个小于某位置元素的数；&#xA;判断方法 单调递增/递减栈一般根据出栈后顺序来决定，例如栈内顺序[1, 2, 6]，出栈后顺序[6, 2, 1]，这就是单调递减栈。&#xA;哨兵技巧 对于有些时候，如果会用到数组的全部元素，即栈中的元素最后都要出栈，那么很可能因为没有考虑边界而无法通过。所以我们可以使用哨兵法。&#xA;例如在{1, 3, 4, 5, 2, 9, 6}末尾添加一个-1作为哨兵，变成了 {1, 3, 4, 5, 2, 9, 6, -1}，这种技巧可以简化代码逻辑。&#xA;例题 </description>
    </item>
    <item>
      <title>739.daily temperatures</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures/</guid>
      <description>Description 739.dail-temperatures&#xA;Solution We can consider monotone stack. If the stack is empty or the element to deal with is smaller than the element in the top of the stack, we can push the element to the stack, else we should pop the element in the top of the stack until the stack is empty or the element is smaller than the element in the top of the stack.&#xA;It&amp;rsquo;s convenient to push the index i into the stack.</description>
    </item>
    <item>
      <title>739.每日温度</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</guid>
      <description>问题描述 739.每日温度&#xA;解题思路 考虑利用单调栈(monotone stack)来进行处理，如果栈为空或者要入栈的元素小于栈顶元素，那么该元素入栈，否则弹出栈顶元素直到栈为空，或者要入栈的元素小于栈顶元素，再将该元素入栈。&#xA;这里应该将数组索引i入栈会比较方便。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt; &amp;amp;temperatures) { vector&amp;lt;int&amp;gt; res(temperatures.size(), 0); stack&amp;lt;int&amp;gt; st; st.push(0); for (int i = 1; i &amp;lt; temperatures.size(); i++) { int j = i; // if (!st.empty()) { while (!st.empty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[st.top()]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); // } } return res; } }; </description>
    </item>
  </channel>
</rss>
