<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dynamic Programming on My New Hugo Site</title>
    <link>http://localhost:1313/tags/dynamic-programming/</link>
    <description>Recent content in Dynamic Programming on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Oct 2023 10:27:41 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>446. Arithmetic Slices II - Subsequence (Hard)</title>
      <link>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence/</link>
      <pubDate>Tue, 17 Oct 2023 10:27:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence/</guid>
      <description>Description 446. Arithmetic Slices II - Subsequence (Hard)&#xA;Given an integer array nums, return the number of all the arithmetic subsequences of nums.&#xA;A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.&#xA;For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences. For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.</description>
    </item>
    <item>
      <title>446. 等差数列划分 II - 子序列 (Hard)</title>
      <link>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence.zh/</link>
      <pubDate>Tue, 17 Oct 2023 10:27:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence.zh/</guid>
      <description>问题描述 446. 等差数列划分 II - 子序列 (Hard)&#xA;给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。&#xA;如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。&#xA;例如， [1, 3, 5, 7, 9]、 [7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。 再例如， [1, 1, 2, 5, 7] 不是等差序列。 数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。&#xA;例如， [2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 题目数据保证答案是一个 32-bit 整数。&#xA;示例 1：&#xA;输入：nums = [2,4,6,8,10] 输出：7 解释：所有的等差子序列为： [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10] 示例 2：&#xA;输入：nums = [7,7,7,7,7] 输出：16 解释：数组中的任意子序列都是等差子序列。 提示：</description>
    </item>
    <item>
      <title>188. Best Time to Buy and Sell Stock IV (Hard)</title>
      <link>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv/</link>
      <pubDate>Thu, 05 Oct 2023 16:16:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv/</guid>
      <description>Description 188. Best Time to Buy and Sell Stock IV (Hard)&#xA;You are given an integer array prices where prices[i] is the price of a given stock on the iᵗʰ day, and an integer k.&#xA;Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.&#xA;Note: You may not engage in multiple transactions simultaneously (i.</description>
    </item>
    <item>
      <title>188. 买卖股票的最佳时机 IV (Hard)</title>
      <link>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv.zh/</link>
      <pubDate>Thu, 05 Oct 2023 16:16:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv.zh/</guid>
      <description>问题描述 188. 买卖股票的最佳时机 IV (Hard)&#xA;给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。&#xA;设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。&#xA;注意： 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&#xA;示例 1：&#xA;输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2：&#xA;输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获 得利润 = 3-0 = 3 。 提示：</description>
    </item>
    <item>
      <title>310. Minimum Height Trees (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees/</guid>
      <description>Description 310. Minimum Height Trees (Medium)&#xA;A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.&#xA;Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [aᵢ, bᵢ] indicates that there is an undirected edge between the two nodes aᵢ and bᵢ in the tree, you can choose any node of the tree as the root.</description>
    </item>
    <item>
      <title>310. 最小高度树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</guid>
      <description>问题描述 310. 最小高度树 (Medium)&#xA;树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵 树。&#xA;给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条无 向边。&#xA;可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中， 具有最小高度的树（即， min(h)）被称为 最小高度树 。&#xA;请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。&#xA;树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。&#xA;示例 1：&#xA;输入：n = 4, edges = [[1,0],[1,2],[1,3]] 输出：[1] 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 示例 2：&#xA;输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] 输出：[3,4] 提示：</description>
    </item>
    <item>
      <title>828. Count Unique Characters of All Substrings of a Given String (Hard)</title>
      <link>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string/</link>
      <pubDate>Thu, 27 Jul 2023 09:30:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string/</guid>
      <description>Description 828. Count Unique Characters of All Substrings of a Given String (Hard)&#xA;Solution DP This problem can be easily solved using dynamic programming. Let&amp;rsquo;s define $dp[i]$ as the sum of countUniqueChar(t) values for substrings $t$ ending at $s[i]$. The next step is to find the recurrence relation:&#xA;Suppose the character corresponding to $s[i]$ is $c$. For substrings ending at $s[i-1]$, if the substring does not contain $c$, then the countUniqueChar value for the substring ending at $s[i]$ is equal to the value for the substring ending at $s[i-1]$ (i.</description>
    </item>
    <item>
      <title>[828. 统计子串中的唯一字符] (Hard)</title>
      <link>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/</link>
      <pubDate>Thu, 27 Jul 2023 09:30:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/</guid>
      <description>问题描述 828. 统计子串中的唯一字符 (Hard)&#xA;我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。&#xA;例如： s = &amp;quot;LEETCODE&amp;quot; ，则其中 &amp;quot;L&amp;quot;, &amp;quot;T&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;O&amp;quot;, &amp;quot;D&amp;quot; 都是唯一字符，因为它们只出现一次 ，所以 countUniqueChars(s) = 5 。&#xA;本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。 输入用例保证返回值为 32 位整数。&#xA;注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的 所有子字符串中的唯一字符）。&#xA;示例 1：&#xA;输入: s = &amp;#34;ABC&amp;#34; 输出: 10 解释: 所有可能的子串为：&amp;#34;A&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;AB&amp;#34;,&amp;#34;BC&amp;#34; 和 &amp;#34;ABC&amp;#34;。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2：&#xA;输入: s = &amp;#34;ABA&amp;#34; 输出: 8 解释: 除了 countUniqueChars(&amp;#34;ABA&amp;#34;) = 1 之外，其余与示例 1 相同。 示例 3：</description>
    </item>
    <item>
      <title>918. Maximum Sum Circular Subarray (Medium)</title>
      <link>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray/</link>
      <pubDate>Thu, 20 Jul 2023 14:07:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray/</guid>
      <description>Description 918. Maximum Sum Circular Subarray (Medium)&#xA;Solution We define $dp[i]$ to represent the maximum sum of subarrays that end at $nums[i]$. Then, we can discuss two cases:&#xA;The subarray is a continuous segment, i.e., $tail \geq head$. The subarray is divided into two segments, i.e., $tail &amp;lt; head$. In each case, we can update the $dp[i]$ value accordingly to find the maximum sum of subarrays that end at each element $nums[i]$.</description>
    </item>
    <item>
      <title>918. 环形子数组的最大和 (Medium)</title>
      <link>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray.zh/</link>
      <pubDate>Thu, 20 Jul 2023 14:07:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray.zh/</guid>
      <description>问题描述 918. 环形子数组的最大和 (Medium)&#xA;给定一个长度为 n 的 环形整数数组 nums ，返回nums 的非空 子数组 的最大可能和 。&#xA;环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。&#xA;子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i &amp;lt;= k1, k2 &amp;lt;= j 其中 k1 % n == k2 % n 。&#xA;示例 1：&#xA;输入：nums = [1,-2,3,-2] 输出：3 解释：从子数组 [3] 得到最大和 3 示例 2：</description>
    </item>
    <item>
      <title>834. Sum of Distances in Tree (Hard)</title>
      <link>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree/</link>
      <pubDate>Tue, 18 Jul 2023 10:09:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree/</guid>
      <description>Description 834. Sum of Distances in Tree (Hard)&#xA;Solution To find the sum of distances to a single node (e.g., $0$) denoted as $dp[0]$, we can easily use DFS to compute it with a time complexity of $O(n)$. However, finding the sum of distances for all $n$ nodes would take $O(n^2)$ time, which would obviously result in a timeout for large graphs.&#xA;However, we notice that there exists a recurrence relationship between the parent node $j$&amp;rsquo;s $dp[j]$ and the child node $i$&amp;rsquo;s $dp[i]$.</description>
    </item>
    <item>
      <title>834. 树中距离之和 (Hard)</title>
      <link>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree.zh/</link>
      <pubDate>Tue, 18 Jul 2023 10:09:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree.zh/</guid>
      <description>问题描述 834. 树中距离之和 (Hard)&#xA;给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。&#xA;给定整数 n 和数组 edges ， edges[i] = [aᵢ, bᵢ] 表示树中的节点 aᵢ 和 bᵢ 之间有一条边。&#xA;返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。&#xA;示例 1:&#xA;输入: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] 输出: [8,12,6,10,10,10] 解释: 树如图所示。 我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。 示例 2:</description>
    </item>
    <item>
      <title>741. Cherry Pickup (Hard)</title>
      <link>http://localhost:1313/posts/leet/741.cherry-pickup/</link>
      <pubDate>Wed, 21 Jun 2023 12:32:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/741.cherry-pickup/</guid>
      <description>Description 741. Cherry Pickup (Hard)&#xA;Solution This problem can be approached using dynamic programming, and although the concept is straightforward, there are several details to consider.&#xA;The process of picking cherries back and forth is equivalent to two individuals moving from $[0, 0]$ to $[n - 1, n - 1]$.&#xA;Let&amp;rsquo;s use $k$ to represent the number of steps taken, $x_1$ to represent the current $x$ coordinate of the first person, and $x_2$ to represent the current $x$ coordinate of the second person.</description>
    </item>
    <item>
      <title>741. 摘樱桃 (Hard)</title>
      <link>http://localhost:1313/posts/leet/741.cherry-pickup.zh/</link>
      <pubDate>Wed, 21 Jun 2023 12:32:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/741.cherry-pickup.zh/</guid>
      <description>问题描述 741. 摘樱桃 (Hard)&#xA;给你一个 n x n 的网格 grid ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：&#xA;0 表示这个格子是空的，所以你可以穿过它。 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 -1 表示这个格子里有荆棘，挡着你的路。 请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：&#xA;从位置 (0, 0) 出发，最后到达 (n - 1, n - 1) ，只能向下或向右走，并且只能穿越有效的格子（即只可 以穿过值为 0 或者 1 的格子）； 当到达 (n - 1, n - 1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的 格子； 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 0 ）； 如果在 (0, 0) 和 (n - 1, n - 1) 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。 示例 1：&#xA;输入：grid = [[0,1,-1],[1,0,-1],[1,1,1]] 输出：5 解释：玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。 在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。 然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。 总共捡到 5 个樱桃，这是最大可能值。 示例 2：</description>
    </item>
    <item>
      <title>1595. Minimum Cost to Connect Two Groups of Points] (Hard)</title>
      <link>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points/</link>
      <pubDate>Wed, 21 Jun 2023 11:43:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points/</guid>
      <description>Description 1595. Minimum Cost to Connect Two Groups of Points (Hard)&#xA;Solution Dynamic Programming + State Compression&#xA;We use a binary number $j$ to represent the set of chosen elements from the second group. $dp[i][j]$ denotes the minimum cost of connecting the first $i$ elements from the first group and the set of elements $j$ from the second group.&#xA;To establish the recurrence relation, we consider the elements from the first group.</description>
    </item>
    <item>
      <title>1595. 连通两组点的最小成本 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points.zh/</link>
      <pubDate>Wed, 21 Jun 2023 11:43:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points.zh/</guid>
      <description>问题描述 1595. 连通两组点的最小成本 (Hard)&#xA;给你两组点，其中第一组中有 size₁ 个点，第二组中有 size₂ 个点，且 size₁ &amp;gt;= size₂ 。&#xA;任意两点间的连接成本 cost 由大小为 size₁ x size₂ 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。 如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是 连通的。 换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一 组中的一个点连接。&#xA;返回连通两组点所需的最小成本。&#xA;示例 1：&#xA;输入：cost = [[15, 96], [36, 2]] 输出：17 解释：连通两组点的最佳方法是： 1--A 2--B 总成本为 17 。 示例 2：&#xA;输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]] 输出：4 解释：连通两组点的最佳方法是： 1--A 2--B 2--C 3--A 最小成本为 4 。 请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需 要关心最低总成本。 示例 3：</description>
    </item>
    <item>
      <title>1494. Parallel Courses II (Hard)</title>
      <link>http://localhost:1313/posts/leet/1494.parallel-courses-ii/</link>
      <pubDate>Fri, 16 Jun 2023 23:54:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1494.parallel-courses-ii/</guid>
      <description>Description 1494. Parallel Courses II (Hard)&#xA;Solution This problem readily brings to mind the concept of topological sorting, followed by a greedy approach. However, this approach is erroneous! In essence, this problem is NP-Hard and can only be solved through brute force.&#xA;Let&amp;rsquo;s consider the application of state-compressed dynamic programming (DP). The subproblems are relatively straightforward to identify. We start by choosing $1, 2$, followed by selecting $3, 4, 5 $(meeting the prerequisites).</description>
    </item>
    <item>
      <title>1494. 并行课程 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/1494.parallel-courses-ii.zh/</link>
      <pubDate>Fri, 16 Jun 2023 23:54:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1494.parallel-courses-ii.zh/</guid>
      <description>问题描述 1494. 并行课程 II (Hard)&#xA;给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 relations 中， relations[i] = [xᵢ, yᵢ] 表示一个先修课的关系，也就是课程 xᵢ 必须在课程 yᵢ 之前上。同时你还有一个整数 k 。&#xA;在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。&#xA;请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。&#xA;示例 1：&#xA;输入：n = 4, relations = [[2,1],[3,1],[1,4]], k = 2 输出：3 解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ， 第三个学期上课程 4 。 示例 2：&#xA;输入：n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2 输出：4 解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课 程 1 ，第四学期上课程 5 。 示例 3：</description>
    </item>
    <item>
      <title>1483. Kth Ancestor of a Tree Node (Hard)</title>
      <link>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node/</link>
      <pubDate>Mon, 12 Jun 2023 13:07:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node/</guid>
      <description>Description 1483. Kth Ancestor of a Tree Node (Hard) You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.&#xA;The kth ancestor of a tree node is the kth node in the path from that node to the root node.</description>
    </item>
    <item>
      <title>1483. 树节点的第 K 个祖先 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node.zh/</link>
      <pubDate>Mon, 12 Jun 2023 13:06:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node.zh/</guid>
      <description>问题描述 1483. 树节点的第 K 个祖先 (Hard) 给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。&#xA;树节点的第 k个祖先节点是从该节点到根节点路径上的第 k 个节点。&#xA;实现 TreeAncestor 类：&#xA;TreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。 getKthAncestor (int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。 示例 1：&#xA;输入： [&amp;#34;TreeAncestor&amp;#34;,&amp;#34;getKthAncestor&amp;#34;,&amp;#34;getKthAncestor&amp;#34;,&amp;#34;getKthAncestor&amp;#34;] [[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]] 输出： [null,1,0,-1] 解释： TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // 返回 1 ，它是 3 的父节点 treeAncestor.</description>
    </item>
    <item>
      <title>数位 DP</title>
      <link>http://localhost:1313/posts/tech/number_dp.zh/</link>
      <pubDate>Tue, 06 Jun 2023 10:37:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/number_dp.zh/</guid>
      <description>引入 数位是指把一个数字按照个、十、百、千、万等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 $0\sim 9$。&#xA;数位 DP 一般是用来解决一类特定问题，以 1012. Numbers With Repeated Digits (Hard) 为例，这一类问题的特征非常明显&#xA;要求统计满足一定条件的数的数量； 这些条件经过转化后可以使用“数位”的思想去理解和判断； 输入会提供一个数字区间（有时候只提供上界）来作为统计的限制； 上界很大（例如 $10^{22}$），暴力枚举会超时。 思路 对 1012. Numbers With Repeated Digits (Hard)，思路如下：&#xA;首先，正难则反，我们可以考虑 $[1, n]$ 范围内无重复数字的正整数的个数，记为 $res$，然后最终结果就是 $n - res + 1$（至于为什么还要再加上 $1$，后面会说明）。&#xA;因此问题转化为求 $[1, n]$ 范围内无重复数字的正整数的个数，符合上述的数位 DP 的特征，我们可以从记忆化搜索的角度去考虑，首先将 $n$ 转化为对应的字符串，对字符串的每一位，枚举每一位可能的数，如果最后组成的数字满足 $num &amp;lt; n$，那么 $res += 1$，这里很容易想到 dfs(string &amp;amp;str, int idx, int mask)，$mask$ 以二进制的形式表示 $0\sim 9$ 范围内的数是否被选择过；&#xA;但是仅仅是这样，我们不能方便的判断当前组成的数字是否满足 $num &amp;lt; n$，因此，我们需要一个额外的参数 $is_limit$。例如对数字 $n = 12345$，如果前面已经选择的数字为 $123$，那么对本次枚举，$is_limit$ 为 $true$，即数字只能选择 $0\sim4$，又因为 $1,\ 2,\ 3$ 已经选择了，$mask = 14$，因此只有 $0,\ 4$ 可以选，事实上，我们可以发现，在递归的过程中，当且仅当当前 $is_limit$ 为 $true$，且当前选择的数字与对应数位上的数字相等时，更深一层递归的 $is_limit$ 仍为 $true$，至此，递归函数为 dfs(string &amp;amp;str, int idx, int mask, bool is_limit)；</description>
    </item>
    <item>
      <title>629. K Inverse Pairs Array (Hard)</title>
      <link>http://localhost:1313/posts/leet/629.k-inverse-pairs-array/</link>
      <pubDate>Wed, 08 Mar 2023 13:09:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/629.k-inverse-pairs-array/</guid>
      <description>Description K Inverse Pairs Array (Hard) For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length and nums[i] &amp;gt; nums[j].&#xA;Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 10⁹ + 7.</description>
    </item>
    <item>
      <title>629.K个逆序对数组 (Hard)</title>
      <link>http://localhost:1313/posts/leet/629.k-inverse-pairs-array.zh/</link>
      <pubDate>Wed, 08 Mar 2023 13:09:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/629.k-inverse-pairs-array.zh/</guid>
      <description>问题描述 629. K个逆序对数组 (Hard)&#xA;给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。&#xA;逆序对的定义如下：对于数组的第 i 个和第 j 个元素，如果满 i &amp;lt; j 且 a[i] &amp;gt; a[j]，则其为一个逆序对；否则不是。&#xA;由于答案可能很大，只需要返回 答案 mod 10 + 7 的值。&#xA;示例 1:&#xA;输入: n = 3, k = 0 输出: 1 解释: 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。 示例 2:&#xA;输入: n = 3, k = 1 输出: 2 解释: 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。 说明:</description>
    </item>
    <item>
      <title>1653.minimum deletions to make string balanced</title>
      <link>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced/</link>
      <pubDate>Mon, 06 Mar 2023 10:36:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced/</guid>
      <description>Description 1653. Minimum Deletions to Make String Balanced (Medium)&#xA;You are given a string s consisting only of characters &#39;a&#39; and &#39;b&#39; .&#xA;You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i &amp;lt; j and s[i] = &#39;b&#39; and s[j]= &#39;a&#39;.&#xA;Return the minimum number of deletions needed to make sbalanced.&#xA;Example 1:</description>
    </item>
    <item>
      <title>1653.使字符串平衡的最少删除次数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced.zh/</link>
      <pubDate>Mon, 06 Mar 2023 10:36:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced.zh/</guid>
      <description>问题描述 1653. 使字符串平衡的最少删除次数 (Medium)&#xA;给你一个字符串 s ，它仅包含字符 &#39;a&#39; 和 &#39;b&#39; 。&#xA;你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i &amp;lt; j ，且 s[i] = &#39;b&#39; 的同时 s[j]= &#39;a&#39; ，此时认为 s 是 平衡 的。&#xA;请你返回使 s 平衡 的 最少 删除次数。&#xA;示例 1：&#xA;输入：s = &amp;#34;aababbab&amp;#34; 输出：2 解释：你可以选择以下任意一种方案： 下标从 0 开始，删除第 2 和第 6 个字符（&amp;#34;aababbab&amp;#34; -&amp;gt; &amp;#34;aaabbb&amp;#34;）， 下标从 0 开始，删除第 3 和第 6 个字符（&amp;#34;aababbab&amp;#34; -&amp;gt; &amp;#34;aabbbb&amp;#34;）。 示例 2：&#xA;输入：s = &amp;#34;bbaaaaabb&amp;#34; 输出：2 解释：唯一的最优解是删除最前面两个字符。 提示：</description>
    </item>
    <item>
      <title>1223.Dice Roll Simulation (Hard)</title>
      <link>http://localhost:1313/posts/leet/1223.dice-roll-simulation/</link>
      <pubDate>Fri, 03 Mar 2023 16:46:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1223.dice-roll-simulation/</guid>
      <description>Description 1223. Dice Roll Simulation (Hard)&#xA;A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] ( 1-indexed) consecutive times.&#xA;Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 10⁹ + 7.</description>
    </item>
    <item>
      <title>1223.掷骰子模拟 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1223.dice-roll-simulation.zh/</link>
      <pubDate>Fri, 03 Mar 2023 16:46:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1223.dice-roll-simulation.zh/</guid>
      <description>问题描述 1223. 掷骰子模拟 (Hard)&#xA;有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。&#xA;不过我们在使用它时有个约束，就是使得投掷骰子时， 连续 掷出数字 i 的次数不能超过 rollMax[i]（ i 从 1 开始编号）。&#xA;现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。&#xA;假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。&#xA;示例 1：&#xA;输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。 示例 2：&#xA;输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30 示例 3：</description>
    </item>
    <item>
      <title>552.Student Attendance Record II (Hard)</title>
      <link>http://localhost:1313/posts/leet/552.student-attendance-record-ii/</link>
      <pubDate>Fri, 03 Mar 2023 14:58:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/552.student-attendance-record-ii/</guid>
      <description>Description 552. Student Attendance Record II (Hard)&#xA;An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:&#xA;&#39;A&#39;: Absent. &#39;L&#39;: Late. &#39;P&#39;: Present. Any student is eligible for an attendance award if they meet both of the following criteria:&#xA;The student was absent ( &#39;A&#39;) for strictly fewer than 2 days total.</description>
    </item>
    <item>
      <title>552.学生出勤记录 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/552.student-attendance-record-ii.zh/</link>
      <pubDate>Fri, 03 Mar 2023 14:58:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/552.student-attendance-record-ii.zh/</guid>
      <description>问题描述 552. 学生出勤记录 II (Hard)&#xA;可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：&#xA;&#39;A&#39;：Absent，缺勤 &#39;L&#39;：Late，迟到 &#39;P&#39;：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：&#xA;按 总出勤 计，学生缺勤（ &#39;A&#39;） 严格 少于两天。 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（ &#39;L&#39;）记录。 给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 10⁹ + 7 取余 的结果。&#xA;示例 1：&#xA;输入：n = 2 输出：8 解释： 有 8 种长度为 2 的记录将被视为可奖励： &amp;#34;PP&amp;#34; , &amp;#34;AP&amp;#34;, &amp;#34;PA&amp;#34;, &amp;#34;LP&amp;#34;, &amp;#34;PL&amp;#34;, &amp;#34;AL&amp;#34;, &amp;#34;LA&amp;#34;, &amp;#34;LL&amp;#34; 只有&amp;#34;AA&amp;#34;不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。 示例 2：&#xA;输入：n = 1 输出：3 示例 3：</description>
    </item>
    <item>
      <title>N Th Tribonacci Number</title>
      <link>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number/</link>
      <pubDate>Fri, 03 Mar 2023 10:03:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number/</guid>
      <description>Description 1137. N-th Tribonacci Number (Easy)&#xA;The Tribonacci sequence T is defined as follows:&#xA;T = 0, T = 1, T = 1, and T = T + T + T for n &amp;gt;= 0.&#xA;Given n, return the value of T.&#xA;Example 1:&#xA;Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2:</description>
    </item>
    <item>
      <title>第 N 个泰波那契数 (Easy)</title>
      <link>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number.zh/</link>
      <pubDate>Fri, 03 Mar 2023 10:03:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number.zh/</guid>
      <description>问题描述 1137. 第 N 个泰波那契数 (Easy)&#xA;泰波那契序列 T 定义如下：&#xA;T = 0, T = 1, T = 1, 且在 n &amp;gt;= 0 的条件下 T = T + T + T&#xA;给你整数 n，请返回第 n 个泰波那契数 T的值。&#xA;示例 1：&#xA;输入：n = 4 输出：4 解释： T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 示例 2：&#xA;输入：n = 25 输出：1389537 提示：&#xA;0 &amp;lt;= n &amp;lt;= 37 答案保证是一个 32 位整数，即 answer &amp;lt;= 2^31 - 1。 解题思路 非常简单的动态规划</description>
    </item>
    <item>
      <title>403.frog jump</title>
      <link>http://localhost:1313/posts/leet/403.frog-jump/</link>
      <pubDate>Wed, 01 Mar 2023 15:08:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/403.frog-jump/</guid>
      <description>Description 403. Frog Jump (Hard)&#xA;A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.&#xA;Given a list of stones&amp;rsquo; positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone.</description>
    </item>
    <item>
      <title>403.青蛙过河</title>
      <link>http://localhost:1313/posts/leet/403.frog-jump.zh/</link>
      <pubDate>Wed, 01 Mar 2023 15:08:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/403.frog-jump.zh/</guid>
      <description>问题描述 403. 青蛙过河 (Hard)&#xA;一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。&#xA;给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。&#xA;如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、 k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。&#xA;示例 1：&#xA;输入：stones = [0,1,3,5,6,8,12,17] 输出：true 解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。 示例 2：</description>
    </item>
    <item>
      <title>1140.stone game ii</title>
      <link>http://localhost:1313/posts/leet/1140.stone-game-ii/</link>
      <pubDate>Mon, 27 Feb 2023 16:02:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1140.stone-game-ii/</guid>
      <description>Description 1140. Stone Game II (Medium)&#xA;Alice and Bob continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.&#xA;Alice and Bob take turns, with Alice starting first. Initially, M = 1.&#xA;On each player&amp;rsquo;s turn, that player can take all the stones in the first X remaining piles, where 1 &amp;lt;= X &amp;lt;= 2M.</description>
    </item>
    <item>
      <title>1140.石子游戏 II</title>
      <link>http://localhost:1313/posts/leet/1140.stone-game-ii.zh/</link>
      <pubDate>Mon, 27 Feb 2023 16:01:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1140.stone-game-ii.zh/</guid>
      <description>问题描述 1140. 石子游戏 II (Medium)&#xA;爱丽丝和鲍勃继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。&#xA;爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初， M = 1。&#xA;在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 &amp;lt;= X &amp;lt;= 2M。然后，令 M = max(M, X)。&#xA;游戏一直持续到所有石子都被拿走。&#xA;假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。&#xA;示例 1：&#xA;输入：piles = [2,7,9,4,4] 输出：10 解释：如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。 示例 2:&#xA;输入：piles = [1,2,3,4,5,100] 输出：104 提示：&#xA;1 &amp;lt;= piles.length &amp;lt;= 100 1 &amp;lt;= piles[i] &amp;lt;= 10⁴ 解题思路 首先这里要明确发挥最佳水平的含义： 如果自己拿了前x块石子之后，对方所能拿到的石子最少，这就是博弈中的发挥最佳水平，对应到dfs，明白了这一点就能写出递归和记忆化搜索，注意这里还需要用到后缀数组。&#xA;写出记忆化搜索之后可以改写成动态规划。&#xA;代码 记忆化搜索 class Solution { public: int dfs(int idx_start, int M, vector&amp;lt;int&amp;gt; &amp;amp;postfix, int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;cach) { if (idx_start &amp;gt;= n) return 0; int minnum = 100001; if (cach[idx_start][M] &amp;gt;= 0) { return cach[idx_start][M]; } for (int i = idx_start + 1; i &amp;lt;= idx_start + 2 * M &amp;amp;&amp;amp; i &amp;lt;= n; i++) { // i表示下一个人拿石子的开始位置，所以i至少为idx_start+1 int tmp = dfs(i, std::max(i - idx_start, M), postfix, n, cach); if (minnum &amp;gt; tmp) { minnum = tmp; } } cach[idx_start][M] = postfix[idx_start] - minnum; return cach[idx_start][M]; } int stoneGameII(vector&amp;lt;int&amp;gt;&amp;amp; piles) { int n = piles.</description>
    </item>
    <item>
      <title>312.戳气球</title>
      <link>http://localhost:1313/posts/leet/312.burst-balloons.zh/</link>
      <pubDate>Fri, 24 Feb 2023 09:26:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/312.burst-balloons.zh/</guid>
      <description>问题描述 312. 戳气球 (Hard)&#xA;有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&#xA;现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1 或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。&#xA;求所能获得硬币的最大数量。&#xA;示例 1：&#xA;输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8] --&amp;gt; [3,5,8] --&amp;gt; [3,8] --&amp;gt; [8] --&amp;gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 示例 2：</description>
    </item>
    <item>
      <title>1326.minimum number of taps to open to water a garden</title>
      <link>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden/</link>
      <pubDate>Tue, 21 Feb 2023 15:35:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden/</guid>
      <description>Description 1326. Minimum Number of Taps to Open to Water a Garden (Hard)&#xA;There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).&#xA;There are n + 1 taps located at points [0, 1, ..., n] in the garden.&#xA;Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.</description>
    </item>
    <item>
      <title>1326.浇灌花园的最少水龙头数目</title>
      <link>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/</link>
      <pubDate>Tue, 21 Feb 2023 15:35:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/</guid>
      <description>问题描述 1326. 灌溉花园的最少水龙头数目 (Hard)&#xA;在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。&#xA;花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。&#xA;给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i - ranges[i], i + ranges[i]] 。&#xA;请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。&#xA;示例 1：&#xA;输入：n = 5, ranges = [3,4,1,1,0,0] 输出：1 解释： 点 0 处的水龙头可以灌溉区间 [-3,3] 点 1 处的水龙头可以灌溉区间 [-3,5] 点 2 处的水龙头可以灌溉区间 [1,3] 点 3 处的水龙头可以灌溉区间 [2,4] 点 4 处的水龙头可以灌溉区间 [4,4] 点 5 处的水龙头可以灌溉区间 [5,5] 只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。 示例 2：</description>
    </item>
    <item>
      <title>646.maximum length of pair chain</title>
      <link>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain/</link>
      <pubDate>Sat, 18 Feb 2023 15:00:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain/</guid>
      <description>Description 646. Maximum Length of Pair Chain (Medium)&#xA;You are given an array of n pairs pairs where pairs[i] = [leftᵢ, rightᵢ] and leftᵢ &amp;lt; rightᵢ. A pair p2 = [c, d] follows a pair p1 = [a, b] if b &amp;lt; c. A chain of pairs can be formed in this fashion. Return the length longest chain which can be formed. You do not need to use up all the given intervals.</description>
    </item>
    <item>
      <title>646.最长数对链</title>
      <link>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain.zh/</link>
      <pubDate>Sat, 18 Feb 2023 15:00:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain.zh/</guid>
      <description>问题描述 646. 最长数对链 (Medium)&#xA;给你一个由 n 个数对组成的数对数组 pairs ，其中 pairs[i] = [leftᵢ, rightᵢ] 且 leftᵢ &amp;lt; rightᵢ 现在，我们定义一种 跟随 关系，当且仅当 b &amp;lt; c 时，数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面。我们用这种形式来构造 数对链 。 找出并返回能够形成的 最长数对链的长度 。 你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例 1：&#xA;输入：pairs = [[1,2], [2,3], [3,4]] 输出：2 解释：最长的数对链是 [1,2] -&amp;gt; [3,4] 。 示例 2：&#xA;输入：pairs = [[1,2],[7,8],[4,5]] 输出：3 解释：最长的数对链是 [1,2] -&amp;gt; [4,5] -&amp;gt; [7,8] 。 提示：&#xA;n == pairs.length 1 &amp;lt;= n &amp;lt;= 1000 -1000 &amp;lt;= leftᵢ &amp;lt; rightᵢ &amp;lt;= 1000 解题思路 贪心 在选择第一个数对时，必定选择使pairs[i][1]最小的那个i，第二个数对则必定选择pairs[j][0] &amp;gt; pairs[i][1]且使pairs[j][0]最小的j，因此类推，因此我们将pairs按照其第二个元素升序排列。</description>
    </item>
    <item>
      <title>926.flip string to monotone increasing</title>
      <link>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing/</link>
      <pubDate>Fri, 17 Feb 2023 16:00:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing/</guid>
      <description>Description 926. Flip String to Monotone Increasing (Medium)&#xA;A binary string is monotone increasing if it consists of some number of 0&amp;rsquo;s (possibly none), followed by some number of 1&amp;rsquo;s (also possibly none). You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0. Return the minimum number of flips to make s monotone increasing. Example 1:&#xA;Input: s = &amp;#34;00110&amp;#34; Output: 1 Explanation: We flip the last digit to get 00111.</description>
    </item>
    <item>
      <title>926.将字符串翻转到单调递增</title>
      <link>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing.zh/</link>
      <pubDate>Fri, 17 Feb 2023 16:00:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing.zh/</guid>
      <description>问题描述 926. 将字符串翻转到单调递增 (Medium)&#xA;如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。 给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。 返回使 s 单调递增的最小翻转次数。 示例 1：&#xA;输入：s = &amp;#34;00110&amp;#34; 输出：1 解释：翻转最后一位得到 00111. 示例 2：&#xA;输入：s = &amp;#34;010110&amp;#34; 输出：2 解释：翻转得到 011111，或者是 000111。 示例 3：&#xA;输入：s = &amp;#34;00011000&amp;#34; 输出：2 解释：翻转得到 00000000。 提示：&#xA;1 &amp;lt;= s.length &amp;lt;= 10⁵ s[i] 为 &#39;0&#39; 或 &#39;1&#39; 解题思路 令dp[i]为将前i个字符翻转成单调递增的字符串所需要的最少翻转次数，cnt表示前i个字符中&#39;1&#39;的个数，其递推关系很容易分析:&#xA;s[i - 1] == &#39;1&#39;，dp[i] = dp[i - 1]; s[i - 1] == &#39;0&#39;，dp[i] = min(dp[i - 1] + 1, cnt); 代码 class Solution { public: int minFlipsMonoIncr(string s) { int cnt = 0, res = 0; // cnt为遍历中1的个数 vector&amp;lt;int&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>871.minimum number of refueling stops</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</guid>
      <description>Description 871.minimum-number-of-refueling-stops&#xA;Solution Dynamic programming In this problem, the number is finite, and there is a recurrence relation, so we can use dynamic programming to solve this problem.&#xA;Let dp[i][j] means the furthest distance we can reach after passing throught i stations and adding fuel for j times. Obviously, i &amp;gt;= j.&#xA;So we can discuss dp[i][j] in two cases:&#xA;We don&amp;rsquo;t add fuel at the ith station: dp[i][j] = dp[i - 1][j] We add fuel in the ith station(We have to arrive at the ith station in the case we have just added fuel for j - 1 times before, that is: dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]): dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1].</description>
    </item>
    <item>
      <title>871.最低加油次数</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</guid>
      <description>问题描述 871.最低加油次数&#xA;解题思路 动态规划 对于这种有限次数，能看出来有递推关系的，可以考虑动态规划。&#xA;这里状态记为dp[i][j]，表示经过前i个加油站，加j次油之后，能够到达的最远距离，这里显然有i &amp;gt;= j。&#xA;那么考虑dp[i][j]的递推关系，可以分在第i个加油站加油和不加油两种情况来讨论：&#xA;在第i个加油站不加油：dp[i][j] = dp[i - 1][j] 在第i个加油站加油（要求第i个加油站可以在之前只加了j - 1次油的情况下到达），即dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]，此时dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1] dp[i][j]取两者中的最大值&#xA;贪心 首先，很容易想到，最佳策略每次加油，都是在油最多的加油站去加油，这里实际上可以认为能直接从经过的加油站中取油，即每次发现到达不了下一个加油站或者终点了，就从已经经过但是没加过油的加油站里加油，直到可以到达下一个加油站或者终点，可以利用优先队列来模拟这个过程，每次需要更新剩余的燃油cur_fuel。&#xA;代码 动态规划 class Solution { public: int minRefuelStops(int target, int startFuel, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;stations) { int n = stations.size(); if (n == 0) { if (startFuel &amp;gt;= target) return 0; return -1; } vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; dp(n + 1, vector&amp;lt;long long&amp;gt;(n + 1, 0)); dp[0][0] = startFuel; for (int i = 1; i &amp;lt;= n; i++) { dp[i][0] = stations[i - 1][0] &amp;lt;= startFuel ?</description>
    </item>
    <item>
      <title>1798.maximum number of consecutive values you can make</title>
      <link>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make/</link>
      <pubDate>Sat, 04 Feb 2023 18:26:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make/</guid>
      <description>Description 1798.maximum-number-of-consecutive-values-you-can-make&#xA;Solution Greedy algorithm + dynamic programming&#xA;First, we sort the array in ascending orders. Let res[n] be the maximum value of consecutive integer that we can make by using the first n numbers.&#xA;if (coins[i - 1] &amp;gt; res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; Code class Solution { public: int getMaximumConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; coins) { std::sort(coins.begin(), coins.</description>
    </item>
    <item>
      <title>1798.你能构造出连续值的最大数目</title>
      <link>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make.zh/</link>
      <pubDate>Sat, 04 Feb 2023 18:26:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make.zh/</guid>
      <description>问题描述 1798.你能构造出连续值的最大数目&#xA;解题思路 贪心+动态规划&#xA;首先将数组按升序排序，令res[n]为前n个数所能构造出的连续整数的最大值:&#xA;if (coins[i - 1] &amp;gt; res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; 代码 class Solution { public: int getMaximumConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; coins) { std::sort(coins.begin(), coins.end()); vector&amp;lt;int&amp;gt; res(coins.size() + 1, 0); // 表示前n个数能表示出来的最大值 for (int i = 1; i &amp;lt;= coins.size(); i++) { if (coins[i - 1] &amp;gt; res[i - 1] + 1) res[i] = res[i - 1]; else res[i] = res[i - 1] + coins[i - 1]; } return res[coins.</description>
    </item>
    <item>
      <title>1751.最多可以参加的会议数目II</title>
      <link>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:09:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</guid>
      <description>问题描述 1751.最多可以参加的会议数目II&#xA;解题思路 动态规划+二分法 令dp[i][j]表示在前i个会议，最多参加j个会议，收获的最大价值:&#xA;考虑选择不参加events[i - 1]，dp[i][j] = dp[i - 1][j]; 选择参加events[i - 1]，dp[i][j] = dp[idx][j - 1] + events[i - 1][2]; 其中idx表示结束日期小于events[i - 1][0]且最接近events[i - 1][0]的会议的索引号，因此这里需要按照结束日期从小到大对events排序; 寻找idx可以使用二分查找; 二分查找要注意其中的不变量，即l左侧的值都小于target，r右侧的值都大于或等于target(这里是否等于取决于具体实现&amp;gt;=或者&amp;gt;)&#xA;代码 class Solution { public: int maxValue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;events, int k) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(events.size() + 1, vector&amp;lt;int&amp;gt;(k + 1, 0)); // 按照会议结束顺序排序 std::sort(events.begin(), events.end(), [](auto &amp;amp;a, auto &amp;amp;b) { return a[1] &amp;lt; b[1]; }); // for (int i = 1; i &amp;lt;= events.</description>
    </item>
    <item>
      <title>396.rotate function</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function/</guid>
      <description>Description 396. rotate-function&#xA;Solution The key is to find the mathematical laws&#xA;Code class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>396.旋转函数</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function.zh/</guid>
      <description>问题描述 396.旋转函数&#xA;解题思路 关键在于找到数学规律&#xA;代码 class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.size(); i++) { res[i] = res[i - 1] + sum - (nums.</description>
    </item>
    <item>
      <title>131.palindrome patitioning</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning/</guid>
      <description>Description 131.palindrome-partitioning&#xA;Solution We can whether it is palindrome by dynamic programming: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;When traversing, pay attention to the order of traversing i;&#xA;Last, we use backtracking to update res.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.</description>
    </item>
    <item>
      <title>131.分割回文串</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</guid>
      <description>问题描述 131.分割回文串&#xA;解题思路 利用动态规划来判断字符串是否是回文串: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;这里遍历的时候要注意i的遍历顺序;&#xA;最后考虑利用回溯法，更新答案。&#xA;代码 class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.size(); i++) { if (dp[index][i]) { res_tmp.push_back(s.substr(index, i - index + 1)); track_back(s, i + 1, dp); res_tmp.pop_back(); } } return; } vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) { vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>72.edit distance</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance/</guid>
      <description>Description 72.edit-distance&#xA;Solution It&amp;rsquo;s easy to consider what dp[i][j] should denotes.&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else, we can consider in three cases: replace the word1[i - 1]: dp[i][j] = dp[i - 1][j - 1] + 1; remove word1[i - 1]: dp[i][j] = dp[i - 1][j] + 1; insert word2[j - 1] between word[i - 1] and word[i], it&amp;rsquo;s the same as remove word2[j - 1]: dp[i][j] = dp[i][j - 1] + 1; We should also pay attention to the initialzation of dp[i][j].</description>
    </item>
    <item>
      <title>72.编辑距离</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance.zh/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance.zh/</guid>
      <description>问题描述 72.编辑距离&#xA;解题思路 dp[i][j]的含义不再赘述:&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else,分为三种操作情况: 替换末尾字符: dp[i][j] = dp[i - 1][j - 1] + 1; 删除word1的第i个字符: dp[i][j] = dp[i - 1][j] + 1; 删除word2的第j个字符，即相当于在第i个字符后插入word2[j - 1]: dp[i][j] = dp[i][j - 1] 代码 class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 1; i &amp;lt;= word1.</description>
    </item>
    <item>
      <title>583.delete operations for two strings</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</guid>
      <description>Description 583.delete-operation-for-two-strings&#xA;Solution dp[i][j] denotes minimum number of options to make strings the same when considering the first i characters of word1 and the first j characters of word2.&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; Code class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.</description>
    </item>
    <item>
      <title>583.两个字符串的删除操作</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</guid>
      <description>问题描述 583.两个字符串的删除操作&#xA;解题思路 dp[i][j]表示对word1的前i个字符，word2的前j个字符，使得它们相同的最小步数:&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; 代码 class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 0; i &amp;lt;= word1.size(); i++) { dp[i][0] = i; } for (int j = 0; j &amp;lt;= word2.</description>
    </item>
    <item>
      <title>115.distinct subsequences</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences/</guid>
      <description>Description 115.distinct-subsequence&#xA;Solution dp[i][j] denotes the occurrences of the first j characters of t in the first i characters of s:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(uses[i - 1] and not use s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; Code class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>115.不同的子序列</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</guid>
      <description>问题描述 115.不同的子序列&#xA;解题思路 dp[i][j]表示考虑考虑t的前j个字符在s的前i个字符中的出现个数:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(表示使用s[i - 1]匹配和不使用s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; 代码 class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;uint32_t&amp;gt;(t.size() + 1, 0)); // dp[0][0] = 1; for (int i = 0; i &amp;lt;= s.size(); i++) { dp[i][0] = 1; } for (int i = 1; i &amp;lt;= s.</description>
    </item>
    <item>
      <title>392.is subsequence</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence/</guid>
      <description>Description 392.is-subsequence&#xA;Solution It&amp;rsquo;s similar to 1143.longest-common-subsequence. We just need to judge whether the result is equal to s.size().&#xA;Code class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>392.判断子序列</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence.zh/</guid>
      <description>问题描述 392.判断子序列&#xA;解题思路 与1143.最长公共子序列基本一样，只需要再判断结果是否和s.size()相等就好了。&#xA;代码 class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>1035.uncrossed lines</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines/</link>
      <pubDate>Sat, 29 Oct 2022 20:45:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines/</guid>
      <description>Description 1035.uncrossed-lines&#xA;Solution The same as 1143.longest-common-subsequence&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1035.不相交的线</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:44:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</guid>
      <description>问题描述 1035.不相交的线&#xA;解题思路 只是1143.最长公共子序列的另一种描述&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1143.longest common subsequence</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</guid>
      <description>Description 1143.longest-common-subsequence&#xA;Solution dp[i][j] denotes the length of longest common subsequence of first i characters of text1 and first j characters of text2:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.</description>
    </item>
    <item>
      <title>1143.最长公共子序列</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</guid>
      <description>问题描述 1143.最长公共子序列&#xA;解题思路 dp[i][j]表示text1的前i个字符和text2的前j个字符里最长公共子序列长度:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); 代码 #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.size() + 1, vector&amp;lt;int&amp;gt;(text2.size() + 1, 0)); int m = 0; int res = 0; for (int i = 1; i &amp;lt;= text1.</description>
    </item>
    <item>
      <title>718.maximum length of repeated subarray</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</guid>
      <description>Description 718.maximum-length-of-repeated-subarray&#xA;Solution dp[i][j] denotes the length of longest public subarray of two subarray ending with nums1[i - 1], nums2[j - 1];&#xA;Recurrence formula&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; Code class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.</description>
    </item>
    <item>
      <title>718.最长重复子数组</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</guid>
      <description>问题描述 718.最长重复子数组&#xA;解题思路 dp[i][j]表示分别以nums1[i - 1], nums2[j - 1]结尾的两个子数组的最长公共子数组的长度；&#xA;递推关系:&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; 代码 class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) // dp[i][j] = max(dp[i - 1][j - 1] + 1, dp[i][j]); dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] &amp;gt; m) m = dp[i][j]; } } return m; } }; </description>
    </item>
    <item>
      <title>674.longest continuous increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</guid>
      <description>Description 674.longest-continuous-increasing-subsequence&#xA;Solution dp[i] denotes the length of longest continuous increasing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; Code class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>674.最长连续递增序列</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</guid>
      <description>问题描述 674.最长连续递增序列&#xA;解题思路 dp[i]表示以nums[i - 1]结尾的最长连续递增子序列长度;&#xA;递推关系为:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; 代码 class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>300.longest increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</guid>
      <description>Description 300.longest-increasing-subsequence&#xA;Solution The key point is: what dp[i] means is conducive to solving this problem. Since subsequence may be not continuous, dp[i] should denotes maximum length increaing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; i dp[i] = max(dp[j] + 1, dp[i]) Code class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // initialize dp[i] as 1 since there is one element at least // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>300.最长递增子序列</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</guid>
      <description>问题描述 300.最长递增子序列 本题简写为LIS问题，与LCS问题（最长公共子序列）相对。&#xA;解题思路 动态规划 关键在于，dp[i]表示什么含义便于解这道题，子序列不一定连续，所以为了便于求解，dp[i]应该表示为以nums[i - 1]结尾的最长严格递增子序列的长度；&#xA;递推关系为:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; i，表示nums[i - 1]前的任意一个元素 dp[i] = max(dp[j] + 1, dp[i]) 贪心 动态规划的时间复杂度为$O(n^2)$，这里存在一个时间复杂度更低的贪心解法：&#xA;动态规划的时间$O(n^2)$的时间复杂度中，$O(n)$的时间复杂度在与遍历整个数组，这是无法避免的；剩下的$O(n)$的时间复杂度，实际上在找一个满足j &amp;lt; i以及nums[j] &amp;lt; nums[i]的并且使dp[j]最大的j；&#xA;那么，可以转化为找dp[j]固定的情况下，最小的一个nums[j]，这样必然能够优先满足，nums[i] &amp;gt; nums[j]；因此我们构造一个贪心数组：min_len，min_len[i] = x表示长度为i的上升子序列的最小结尾元素为x。考虑到min_len一定是个单调递增的数组（易证），那么我们可以基于这个单调递增的特性，利用二分查找，找到满足min_len[j] &amp;lt; nums[i]的最大的j，即利用$O(\log n)$找到最佳转移位置。&#xA;代码 动态规划 class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // dp[0]不考虑，至少有一个元素，所以初始化为1 // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>714.买卖股票的最佳时机含手续费</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</guid>
      <description>问题描述 714.买卖股票的最佳时机含手续费&#xA;解题思路 分为手中有股票和无股票两种情况讨论，设定在卖出股票时支出手续费:&#xA;手中有股票:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); 手中无股票:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); 初始化:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; 代码 class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); dp[0][0] = -prices[0]; dp[0][1] = -fee; for (int i = 1; i &amp;lt;= prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); } return dp[prices.</description>
    </item>
    <item>
      <title>714.best time to buy and sell stock with transaction fee</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</guid>
      <description>Description 714.best-time-to-buy-and-sell-stock-with-transaction-fee&#xA;解题思路 We can consider this problem in two cases: owning stock and not owning stock, assuming that you need to pay transaction fee when selling stock.&#xA;owning stock:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); not owning stock:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); Initializing dp:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; Code class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>309.best time to buy and sell stock with cooldown</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>Description 309.best-time-to-buy-and-sell-stock-with-cooldown&#xA;Solution The key point is find what dp should denote and its recurrence formula.&#xA;dp[i] indicates only considering first i days, and is devided into five cases: no operation, bought but not sold (stock in hand), exactly sold, cooling off period, and idle, which are noted as dp[i][0], dp[i][1], dp[i][2], dp[i][3], and dp[i][4] correspondingly.&#xA;Recurrence formula:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // last day can be on operation, bought but not sold, cooling off period, idle dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // last day can be cooling off period adn idle.</description>
    </item>
    <item>
      <title>309.最佳买卖股票时机含冷冻期</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</guid>
      <description>问题描述 309.最佳买卖股票时机含冷冻期&#xA;解题思路 本题的关键在于找到dp的实际含义，以及它的递推关系; dp[i]表示只考虑前i天的情况，分为无操作、买入未卖出(手中有股票)、正好卖出、冷静期、空闲五种情况，分别记为dp[i][0], dp[i][1], dp[i][2], dp[i][3], dp[i][4].&#xA;递推关系如下:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // 上一天的可能情况有无操作、买入未卖出、冷静期、空闲四种情况 dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // 上一天可能有冷静期和空闲两种情况 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max3(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ?</description>
    </item>
    <item>
      <title>123.买卖股票的最佳时机III</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</link>
      <pubDate>Wed, 12 Oct 2022 20:04:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</guid>
      <description>问题描述 123.买卖股票的最佳时机III&#xA;解题思路 本题的关键在于找到dp的实际含义，以及它的递推关系;&#xA;dp[i]表示只考虑前i天的情况，那么到了第i天，有五种可能的情况:&#xA;没有做任何操作，记为dp[i][0]; 前i天发生了一次买入，记为dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) 前i天发生了一次卖出，记为dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) 前i天发生了两次买入，记为dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) 前i天发生了两次卖出，记为dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) 初始化:&#xA;dp[0][0] = 0; dp[0][1] = -prices[0]; // 发生了一次买入 dp[0][2] = 0; // 买入又卖出 dp[0][3] = -prices[0]; // 买入-&amp;gt;卖出-&amp;gt;买入 dp[0][4] = 0; // 买入-&amp;gt;卖出-&amp;gt;买入-&amp;gt;卖出 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>122.best time to buy and sell stock ii</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sat, 08 Oct 2022 08:14:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Description 122.best-time-to-buy-and-sell-stock-ii&#xA;Solution The key point of this problem is to find the recurrence formula of dp[i]. Let&amp;rsquo;s discuss this problem in two cases.&#xA;if prices[i - 1] is not selected, then dp[i] = dp[i - 1]. It shows that: prices[i - 1] &amp;lt; prices[i - 2]; if prices[i - 1] is selected, then prices[i - 1] &amp;gt;= prices[i - 2], dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2].</description>
    </item>
    <item>
      <title>122.买卖股票的最佳时机II</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</guid>
      <description>问题描述 122.买卖股票的最佳时机II&#xA;解题思路 本题的关键是要找dp的递推关系，分两种情况讨论:&#xA;prices[i - 1]不会被选择，那么dp[i] = dp[i - 1]，其实也说明，prices[i - 1] &amp;lt; prices[i - 2]； prices[i - 1]被选择，那么prices[i - 1] &amp;gt;= prices[i - 2]，dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]。 代码 class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.size() == 1) return 0; vector&amp;lt;int&amp;gt; dp(prices.size() + 1, 0); for (int i = 2; i &amp;lt;= prices.size(); i++) { if (prices[i - 1] &amp;gt;= prices[i - 2]) dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]; else dp[i] = dp[i - 1]; } return dp[prices.</description>
    </item>
    <item>
      <title>123.best time to buy and sell stock iii</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</guid>
      <description>Description 123.best-time-to-buy-and-sell-stock-iii&#xA;Solution The key point is to find what dp should denotes and the recursion formula:&#xA;dp[i] denotes only considering first i days, then by day i, there are five possible cases:&#xA;no operation, written as dp[i][0]; buy stock once in first i days, written as dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) sell stock once in first i days, written as dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) by stock twice in first i days, written as dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) sell stock twice in first i days, written as dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) Initializaiton:</description>
    </item>
    <item>
      <title>121.best time to buy and sell stock</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 07 Oct 2022 16:34:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</guid>
      <description>Description 121.best-time-to-buy-and-sell-stock&#xA;Solution dynamic programming dp[i] denotes maximum profit in first i days, so the recurrence relation of dp[i] is: dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0).&#xA;greedy algorithm Let&amp;rsquo;s use cur to record the minimum element and replace the value of cur if the element is smaller, if the element is larger than cur, calculate the profit, save the maximum profit.&#xA;Code class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>121.买卖股票的最佳时机</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</link>
      <pubDate>Fri, 07 Oct 2022 16:33:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</guid>
      <description>问题描述 121.买卖股票的最佳时机&#xA;解题思路 动态规划 dp[i]表示前i天的最大收益，那么dp[i]的递推公式为:dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0)。&#xA;贪心算法 利用cur记录最小元素，碰到更小的就替换cur的值，遇到比它大的就进行一次利润计算，保存最大的利润。&#xA;代码 class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } int max(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ? a : c; else return b &amp;gt; c ? b : c; } public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.</description>
    </item>
    <item>
      <title>337.打家劫舍III</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</guid>
      <description>问题描述 337.打家劫舍III&#xA;解题思路 严格来说，这一题和198.打家劫舍，213.打家劫舍II的思路并不一致。&#xA;首先，这一道题遍历的是树，而不是一个数组。要比较的是选择目前节点和目前节点左子节点+右子节点，因此在遍历方式上需要采取后序遍历。&#xA;同时，作为二叉树的问题，一般是考虑递归进行处理：&#xA;递归的终止条件： 当前节点为空； 递归函数的返回值： 返回一个长度为2的数组dp，dp[0]表示不偷当前节点的最大金钱，dp[1]表示偷当前节点的最大金钱； 本级递归做什么： 计算偷当前节点的收益val1，不偷当前节点的收益val2，返回{val2, val1}。 代码 class Solution { public: int rob(TreeNode* root) { vector&amp;lt;int&amp;gt; result = robTree(root); return max(result[0], result[1]); } // 长度为2的数组，0：不偷，1：偷 vector&amp;lt;int&amp;gt; robTree(TreeNode* cur) { if (cur == NULL) return vector&amp;lt;int&amp;gt;{0, 0}; vector&amp;lt;int&amp;gt; left = robTree(cur-&amp;gt;left); vector&amp;lt;int&amp;gt; right = robTree(cur-&amp;gt;right); // 偷cur，那么就不能偷左右节点。 int val1 = cur-&amp;gt;val + left[0] + right[0]; // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况 int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; } }; </description>
    </item>
    <item>
      <title>337.house robber iii</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii/</guid>
      <description>Description 337.house-robber-iii&#xA;Solution Strictly speaking, the idea of this problem is different from 198.house-robber，213.house-robber-ii.&#xA;At first, what this problem need to traverse is tree, rather than an array. We need to compare selecting curent node with selecting left-child node and right-child node rather than current node. So, we should select postorder traversal.&#xA;And as a problem of binary tree, we consider recursion.&#xA;termination conditions of recursion current node is null; return value of recursion function return an array dp of length 2, dp[0] denotes maximum amount when not stealing current node, dp[1] denotes maximum amount when stealing current node; what this level of recursion does calculate the amount val1 when stealing current node, val2 for not stealing current node, return {val2, val1}.</description>
    </item>
    <item>
      <title>213.house robber ii</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii/</guid>
      <description>Description 213.house-robber-ii&#xA;Solution Referring to 198.house-robber, there be another constraint that first and last can&amp;rsquo;t be selected at the same time. So we can split the array into two part: one for [0, n - 1), another for [1, n), corresponding to dp0 and dp1 respectively, just return max(dp0, dp1).&#xA;Code class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.</description>
    </item>
    <item>
      <title>213.打家劫舍II</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</guid>
      <description>问题描述 213.打家劫舍II&#xA;解题思路 参照198.打家劫舍，但是这里多了一个首尾不能同时选择的选项，因此可以考虑将数组分成两部分，一个包含[0, n - 1)，一个包含[1, n)，分别对应dp0和dp1，取最后两者的最大值即可。&#xA;代码 class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.size() - 2); int result2 = robRange(nums, 1, nums.size() - 1); return max(result1, result2); } int robRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int end) { if (end == start) return nums[start]; vector&amp;lt;int&amp;gt; dp(nums.size()); dp[start] = nums[start]; dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i &amp;lt;= end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; } }; </description>
    </item>
    <item>
      <title>198.house robber</title>
      <link>http://localhost:1313/posts/leet/198.house-robber/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber/</guid>
      <description>Description 198.house-robber&#xA;Solution dp[i] denotes the maximum amount when the first i houses are considered.&#xA;Let&amp;rsquo;s consider the recursive relationship:&#xA;If the i-th house was stolen, it means that the i - 1th house was not stolen, so dp[i] = dp[i - 2] + a[i - 1]. If the i-th house was not stolen, then dp[i] = dp[i - 1]. So, dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]).</description>
    </item>
    <item>
      <title>198.打家劫舍</title>
      <link>http://localhost:1313/posts/leet/198.house-robber.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber.zh/</guid>
      <description>问题描述 198.打家劫舍&#xA;解题思路 dp[i]表示考虑前i个房间，能窃取到的最大金额。&#xA;考虑递推关系:&#xA;假设第要窃取第i个房间，那么说明第i - 1个房间，肯定没有被窃取，dp[i] = dp[i - 2] + nums[i - 1]。 假设不窃取第i个房间，则dp[i] = dp[i - 1]。 综上，dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1])。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int rob(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); if (nums.size() == 1) return nums[0]; if (nums.</description>
    </item>
    <item>
      <title>139.word Break</title>
      <link>http://localhost:1313/posts/leet/139.word-break/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break/</guid>
      <description>Description 139.word-break&#xA;Solution First, we should determine what dp array means. In this problem, dp[i] = 1 denotes that a string of length i can be split into words that appear in the dictionary.&#xA;So, we can get the recursive relationship:dp[j] = dp[i] &amp;amp;&amp;amp; substr in [i, j) can be split.&#xA;To initialize dp array: dp[0] = 1.&#xA;Attention: we should traverse volume first, then traverse items; if in the reverse order, it&amp;rsquo;s not convenient to judge whether string can be split.</description>
    </item>
    <item>
      <title>139.单词拆分</title>
      <link>http://localhost:1313/posts/leet/139.word-break.zh/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break.zh/</guid>
      <description>问题描述 139.单词拆分&#xA;解题思路 首先确定dp数组的含义，dp[i] = 1应该表示长度为i的字符串，可以拆分成字典中出现的单词;&#xA;则，dp的递推公式为:dp[j] = dp[i] &amp;amp;&amp;amp; [i, j]区间的字串可以拆分成字典中的单词&#xA;初始化dp数组:dp[0] = 1。&#xA;这里要注意，先遍历体积，再遍历物品；如果倒过来，是不方便判断字串是否可以拆分的。&#xA;代码 #include &amp;lt;string&amp;gt; #include &amp;lt;unordered_set&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::unordered_set; using std::vector; class Solution { public: bool wordBreak(string s, vector&amp;lt;string&amp;gt; &amp;amp;wordDict) { unordered_set&amp;lt;string&amp;gt; wordSet(wordDict.begin(), wordDict.end()); vector&amp;lt;int&amp;gt; dp(s.length() + 1, 0); // 0 为false dp[0] = 1; // 先遍历体积，再遍历物品 for (int j = 0; j &amp;lt;= s.length(); j++) { for (int i = 0; i &amp;lt;= j; i++) { string word = s.</description>
    </item>
    <item>
      <title>322.coin change</title>
      <link>http://localhost:1313/posts/leet/322.coin-change/</link>
      <pubDate>Wed, 05 Oct 2022 03:53:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change/</guid>
      <description>Description 322.coin-change&#xA;Solution The recursive relationship change from max to min: dp[j] = min(dp[j], dp[j - coins[i]] + 1).&#xA;We need pay attention to issue about initializing dp array. To ensure that if j - coins[i] can&amp;rsquo;t be come up with, dp[j] is still dp[j] in last loop, we should initialize dp as INT_MAX, and dp[0] = 0.&#xA;Attention: INT_MAX + 1 &amp;lt; INT_MAX(in C++)&#xA;Code #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>322.零钱兑换</title>
      <link>http://localhost:1313/posts/leet/322.coin-change.zh/</link>
      <pubDate>Wed, 05 Oct 2022 03:52:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change.zh/</guid>
      <description>问题描述 322.零钱兑换&#xA;解题思路 首先，递推关系从最大变成了最小，即dp[j] = min(dp[j], dp[j - coins[i]] + 1)。&#xA;同时，要注意对dp数组的初始化问题，为了保证j - coins[i]无法组成时，dp[j]选择的仍是上一次i循环的dp[j]，因此要将dp数组初始化为INT_MAX，同时dp[0] = 0。&#xA;要注意INT_MAX + 1 &amp;lt; INT_MAX(在C++中)&#xA;代码 #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } public: int coinChange(vector&amp;lt;int&amp;gt; &amp;amp;coins, int amount) { if (amount == 0) return 0; vector&amp;lt;int&amp;gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; coins.</description>
    </item>
    <item>
      <title>377.combination sum iv</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv/</guid>
      <description>Description 377.combination-sum-iv&#xA;Solution This problem is still a unbounded-knapsack-problem, however, what this problem want to get is permutations rather than combinations.&#xA;With reference to 518.coin-change-ii, traverse volume first, than traverse items.&#xA;代码 class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // prevent overflow, not dp[j] + dp[j - nums[i]] &amp;lt; INT_MAX if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>377.组合总和IV</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</guid>
      <description>问题描述 377.组合总和IV&#xA;解题思路 本题依旧是一个完全背包问题，但是本题求的是排列而非组合。&#xA;参考518.零钱兑换II，先遍历体积，再遍历物品。&#xA;代码 class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // 防止溢出 if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>518.coin change ii</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii/</guid>
      <description>Description 518.coin-change-ii&#xA;Solution This problem is still a unbounded-knapsack-problem. What this problem need to solve is combination rather than combination.&#xA;If we want to get the number of combination, we should traverse items first, than traverse volume. But if you want to get the number of permutation, you should traverse volume first, than traverse items.&#xA;For example, assume that nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2, combnations: {1, 1, 1}, {1, 2}.</description>
    </item>
    <item>
      <title>518.零钱兑换II</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</guid>
      <description>问题描述 518.零钱兑换II&#xA;解题思路 本题依旧是一个完全背包问题，但是本题求的是组合而非排列。&#xA;求组合时，先遍历物品，再遍历体积；求排列时，则是先遍历体积，再遍历物品。&#xA;例如：假设nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2，选择组合方式为{1, 1, 1}, {1, 2}。&#xA;dp[0] = 1; for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; 2; i++) { if (j &amp;gt;= nums[i]) dp[j] = dp[j] + dp[j - nums[i]]; } } dp[3] = 3，选择的排列方式为{1, 1, 1}, {1, 2}, {2, 1}。</description>
    </item>
    <item>
      <title>474.ones and zeroes</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes/</link>
      <pubDate>Wed, 05 Oct 2022 00:34:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes/</guid>
      <description>Description 474.ones-and-zeroes&#xA;Solution This problem can be viewed as a two-dimensional 01-knapsack-problem. There are two-dimensional limits about &amp;ldquo;volume&amp;rdquo;: numbers of $0$ can not exceed $m$ and numbers of $1$ can not exceed $n$.&#xA;Recursive relation: dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ?</description>
    </item>
    <item>
      <title>474.一和零</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:37:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</guid>
      <description>问题描述 474.一和零&#xA;解题思路 本题可以看成一个二维的01背包问题，体积存在两个维度的限制，即$0$的个数不能超过$m$，$1$的个数不超过$n$。&#xA;递推关系:dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;代码 #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: int findMaxForm(vector&amp;lt;string&amp;gt; &amp;amp;strs, int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; str_num(strs.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); for (int i = 0; i &amp;lt; strs.size(); i++) { for (int j = 0; j &amp;lt; strs[i].</description>
    </item>
    <item>
      <title>494.target sum</title>
      <link>http://localhost:1313/posts/leet/494.target-sum/</link>
      <pubDate>Tue, 04 Oct 2022 04:22:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum/</guid>
      <description>Description 494.target-sum&#xA;Solution Actually, what we need to do is choose some numbers whose sum is $\max((sum + target) / 2, (sum - target) / 2)$ in this array. So we can change this problem to a 01-knapsack-problem, and dynamic programming can be used to solve this problem. Also, backtracking can be used to solve this problem.&#xA;In this problem, dp[i][j] should denotes the number of methods to make the sum of number selected to be j when considering the first i numbers.</description>
    </item>
    <item>
      <title>494.目标和</title>
      <link>http://localhost:1313/posts/leet/494.target-sum.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:09:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum.zh/</guid>
      <description>问题描述 494.目标和&#xA;解题思路 本题表面上说添加&amp;rsquo;+&amp;lsquo;或者&amp;rsquo;-&amp;rsquo;，实际上就是在这个数组中选择一些数，使这些数的总和为$\max((sum + target) / 2, (sum - target) / 2)$。从而转换成01背包问题，利用动态规划求解，当然也可以利用回溯法求解。&#xA;在本题中，dp[i][j]应该表示为考虑前i个数时，使选择的数总和为j的方法数。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int findTargetSumWays(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int sum = 0; vector&amp;lt;int&amp;gt; my_num(nums.size() + 1, 0); for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; my_num[i + 1] = nums[i]; } if ((sum + target) % 2 == 1) return 0; vector&amp;lt;int&amp;gt; res(1001, 0); res[0] = 1; target = max((sum + target) / 2, (sum - target) / 2); // int cnt = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>unbounded knapsack problem</title>
      <link>http://localhost:1313/posts/tech/unbounded-knapsack-problem/</link>
      <pubDate>Tue, 04 Oct 2022 01:33:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/unbounded-knapsack-problem/</guid>
      <description>Description Unbounded Knapsack Problem&#xA;There are $N$ kinds of items and a knapsack with the capacity of $V$, each item has unlimited pieces available.&#xA;The volume of the $i$-th item is $v_i$, and value is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen&amp;rsquo;t exceed the capacity of the pack.&#xA;Solution It&amp;rsquo;s a classic problem of dynamic programming and knapsack problem.</description>
    </item>
    <item>
      <title>完全背包问题</title>
      <link>http://localhost:1313/posts/tech/unbounded-knapsack-problem.zh/</link>
      <pubDate>Mon, 03 Oct 2022 13:50:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/unbounded-knapsack-problem.zh/</guid>
      <description>问题描述 完全背包问题&#xA;有$N$件物品和一个容量是$V$的背包，每件物品都有无限件可用。&#xA;第$i$种物品的体积是$v_i$，价值是$w_i$。求解将哪些物品装入背包，可使这些物品总体积不超过背包容量，且总价值最大。&#xA;解题思路 内层嵌套循环 01背包问题 每样物品只能使用一件，而针对完全背包问题，我们只需要在内层有关体积的循环中，再添加一层循环，枚举一共使用了多少件物品$i$即可。&#xA;for (int i = 1; i &amp;lt;= n; i++) { for (int j = m; j &amp;gt;= v[i]; j--) { for (k = 1; k * v[i] &amp;lt;= j; k++) { dp[j] = max(dp[j], dp[j - k * v[i] + k * w[i]); } } } 更改遍历方向 在01背包问题中，我们内层关于体积的循环，是从大到小的，这是为了保证在比较max(dp[j], dp[j - v[i]] + w[i])时，使用的是上一次i循环的数值；&#xA;而在完全背包问题中，内层关于体积的循环，修改成从小到大即可，此时dp = max(dp[j], dp[j - v[i]] + w[i])中，dp[j - v[i]] + w[i]使用的就是本次i循环中的数值，而i循环中,dp[j - v[i]] = max(dp[j - v[i]], dp[(j - v[i]) - v[i]] + w[i]),依次往前递推，总能找到那个最大值dp[j - k * v[i]] + k * w[i]。</description>
    </item>
    <item>
      <title>1049.last stone weight ii</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</link>
      <pubDate>Sat, 01 Oct 2022 19:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</guid>
      <description>Description 1049.last-stone-weight-ii&#xA;Solution In reality, it&amp;rsquo;s still a 01-pack-problem.&#xA;What it want to get is when you divide the array into two part with least difference of their sum, what the difference is. If you are aware of this, just write code similar to 416.partition-equal-subset-sum.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.</description>
    </item>
    <item>
      <title>1049.最后一块石头的重量II</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:22:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</guid>
      <description>问题描述 1049.最后一块石头的重量II&#xA;解题思路 实际上还是一个01背包问题。本质上是在求将数组分成差值最小的两部分之后，这两部分的差值，理解了这一点之后，参照416.分割等和子集写代码就好了。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.size(); i++) { sum += stones[i]; } vector&amp;lt;int&amp;gt; dp(sum / 2 + 1, 0); for (int i = 0; i &amp;lt; stones.size(); i++) { for (int j = sum / 2; j &amp;gt;= stones[i]; j--) dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); } return sum - 2 * dp[sum / 2]; } }; </description>
    </item>
    <item>
      <title>416.分割等和子集</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</guid>
      <description>问题描述 416.分割等和子集&#xA;解题思路 本题实际上是一个01背包问题，在这个问题中，背包的体积$V$是数组中所有数的的和的一半(向下取整)，物品的价值就是数组中数的取值：&#xA;代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; } if (sum % 2 == 1) return false; sum_half = sum / 2; vector&amp;lt;int&amp;gt; dp(sum_half + 1, 0); for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>416.partition equal subset sum</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</guid>
      <description>Description 416.partition-equal-subset-sum&#xA;Solution This problem can be viewed as one case of 01-pack-problem&#xA;In this problem, the volume of pack $V$ is half of sum of all integers in the array(rounded down), the value of item is just value of integer in the array.&#xA;Code #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>01背包问题</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem.zh/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem.zh/</guid>
      <description>问题描述 01背包问题 有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。&#xA;第$i$件物品的体积是$v_i$，价值是$w_i$，求解将哪些物品装入背包，可使这些物品总体积不超过背包容量，并且总价值最大。&#xA;解题思路 动态规划的经典例题，首先考虑dp[i][j]的含义，这里i表示只考虑前i个物品(i从$1\sim N$)，dp[i][j]表示总体积为j的情况下，考虑前i个物品时，背包里的物品的最大价值。&#xA;可以分成两种情况考虑dp[i][j]的递推关系：&#xA;第i个物品不在背包中时，dp[i][j] = dp[i - 1][j] 此时只有前i - 1个物品，背包中物品体积仍为j。 第i个物品在背包中时，dp[i][j] = dp[i - 1][j - v[i]] + w[i] 前i - 1个物品的体积为j - v[i]。 初始化，显然dp[0][0] = 0。&#xA;根据递推关系和初始化条件写for循环遍历即可。&#xA;代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; const int N = 1010; // 体积不超过1000， 物品件数也不超过1000 int main() { int n, m; // n为物品数量，m为背包体积 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int dp[N][N] = {0}; int v[N] = {0}; // 体积 int w[N] = {0}; // 价值 for (int i = 1; i &amp;lt;=n; i++) cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i]; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { dp[i][j] = dp[i - 1][j]; if (j &amp;gt;= v[i]) // 当前总体积肯定不能小于v[i]，如果小于的话，第i个物品不能放 dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } // int res = 0; // for (int j = 1; j &amp;lt;=m; j++) { // res = max(res, dp[n][j]); // 不需要遍历，直接输出dp[n][m]即可 // } cout &amp;lt;&amp;lt; dp[n][m] &amp;lt;&amp;lt; endl; return 0; } 优化 分析上面的代码，实际上dp[i][j]递推时只会用到dp[i - 1][j]，而不会用到dp[i - 2][j], dp[i - 3][j]等，因此dp数组实际上只需要一维即可，索引为当前总体积。</description>
    </item>
    <item>
      <title>01 kanpsack problem</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem/</guid>
      <description>Description 01-pack-problem&#xA;There are $N$ items and a pack with capacity of $V$, and each item can only be used once.&#xA;The volume of the $i$-th item is $v_i$, and vaule is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen&amp;rsquo;t exceed the capacity of the pack.&#xA;Solution It&amp;rsquo;s a classic problem of dynamic programming.</description>
    </item>
    <item>
      <title>Dynamic Programming</title>
      <link>http://localhost:1313/posts/tech/dynamic-programming/</link>
      <pubDate>Thu, 29 Sep 2022 16:25:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dynamic-programming/</guid>
      <description>Description Usually, One-dimensional dynamic planning problem, the parameter is always $n$, the result is similar to number sequence $a_n$, or $f(n)$($f$ can be viewed as function or corresponding relationship). At the same time, there will be certain corresponding relationship between $a_n$ and $a_{n - 1}, a_{n - 2}&amp;hellip;a_{1}$, such as $a_n = a_{n-1} + a_{n-2}$(fibonacci sequence).&#xA;Solution Number sequence can be corresponded with array in programming language such as C++. If you find the recursive relationship among number sequence, you can write traversal code using for loop to get the answer.</description>
    </item>
    <item>
      <title>746.min cost climbing stairs</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 16:13:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</guid>
      <description>Description 746.min-cost-climbing-stairs&#xA;Solution It&amp;rsquo;s like 70.climbing-stairs plus, the recursive relationship becomes more complicated, but the essence is the same.&#xA;$$dp_n = \min[dp_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2]]$$&#xA;After get the recursive relationship, we can write traversal code to get the answer using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ?</description>
    </item>
    <item>
      <title>509.fibonacci number</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number/</link>
      <pubDate>Thu, 29 Sep 2022 16:10:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number/</guid>
      <description>Description 509.fibonacci number&#xA;Solution $a_n = a_{n - 1} + a_{n - 2}$.&#xA;Based on the recursive relationship, we can easily write traversal code using for loop.&#xA;Code class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>343.integer break</title>
      <link>http://localhost:1313/posts/leet/343.integer-break/</link>
      <pubDate>Thu, 29 Sep 2022 16:05:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break/</guid>
      <description>Description 343.integer-break&#xA;Solution The key point is still find the recursive relationship.&#xA;Notice that when $n &amp;gt; 4$, $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$.&#xA;So we can easily write traversal code using for loop.&#xA;Code class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>70.climbing stairs</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 15:55:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs/</guid>
      <description>Description 70.climbing-stairs&#xA;Solution Actually, it&amp;rsquo;s the same with 509.fibonacci-number. Let $dp_n$ be the number of ways to get to the top, then we have: $$dp_n = dp_{n - 1} + dp_{n - 2}$$ So we can write the traversal code of for loop.&#xA;Code class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>63.unique paths ii</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii/</link>
      <pubDate>Thu, 29 Sep 2022 15:39:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii/</guid>
      <description>Description 63.unique-paths-ii&#xA;Solution Compared with 62.unique-paths, the main difference is that you need to change $dp_{mn}$ when hitting an obstacle(obstacleGrid[i][j] = 0). Just set dp[i][j] = 0.&#xA;And you need pay attention to judging the conditionality in for loop.&#xA;When i = 0 or j = 0, dp[i][j] = dp[i][j - 1] or dp[i][j] = dp[i - 1][j]. dp[0][0] = 0.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.</description>
    </item>
    <item>
      <title>62.unique paths</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths/</link>
      <pubDate>Thu, 29 Sep 2022 15:28:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths/</guid>
      <description>Description 62.unique-paths&#xA;Solution $dp_{mn}$ means the number of paths from (1, 1) to (m, n). Just find the connection among $dp_{mn}, dp_{(m-1)n}, dp_{m(n-1)}$.&#xA;We have: $$dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$$ Based on the relationship, we can write the traversal code using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>343.整数拆分</title>
      <link>http://localhost:1313/posts/leet/343.integer-break.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:59:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break.zh/</guid>
      <description>题目描述 343.整数拆分&#xA;解题思路 还是寻找递推关系,设$dp_n$为正整数$n$所求的最大乘积。 这里可以注意到:$n &amp;gt; 4$时， $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$。 根据递推关系写出for循环递推求解。&#xA;代码 class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>63.不同路径II</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:55:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</guid>
      <description>题目描述 63.不同路径II&#xA;解题思路 相比62.不同路径II， 主要是多了障碍物地判断，设$obstacleGrid[i][j] = 0$，则$dp_{{i}{j}} = 0$，其余递推关系相同。 注意for循环遍历地过程中的条件判断。当i = 0或j = 0，dp[i][j] = dp[i][j - 1]或dp[i][j] = dp[i - 1][j]。 dp[0][0] = 0。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m, vector&amp;lt;int&amp;gt;(n, 0)); dp[0][0] = 1; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (i == 0 &amp;amp;&amp;amp; j == 0) { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = 1; } else { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else { if (i == 0) dp[i][j] = dp[i][j - 1]; else if (j == 0) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } } return dp[m - 1][n - 1]; } }; </description>
    </item>
    <item>
      <title>62.不同路径</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:51:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths.zh/</guid>
      <description>问题描述 62.不同路径&#xA;解题思路 还是找递推关系： $dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>746.使用最小花费爬楼梯</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:36:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</guid>
      <description>题目描述 746.使用最小花费爬楼梯&#xA;解题思路 相当于爬楼梯的进阶版，递推关系变复杂了一些，但本质没有变。 $a_n = min(a_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2])$ 写出递推关系后就能很方便地写出for循环来遍历求解。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ? cost[0] : cost[1]; for (int i = 2; i &amp;lt;= sz; i++) { // 原始版本 // dp[i] = (dp[i - 2] + cost[i - 2]) &amp;lt; (dp[i - 1] + cost[i - 1]) ?</description>
    </item>
    <item>
      <title>70.爬楼梯</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:56:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</guid>
      <description>题目描述 70.爬楼梯&#xA;解题思路 本质上与斐波那契数是一样的：$a_n = a_{n - 1} + a_{n - 2}$ 构建for循环来遍历。&#xA;代码 class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>509.斐波那契数</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:52:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</guid>
      <description>题目描述 509.斐波那契数&#xA;解题思路 $a_n = a_{n-1} + a_{n-2}$，利用这一递推关系构建for循环即可，实际上只需要容量为2的数组。&#xA;代码 class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>一维动态规划-基础版</title>
      <link>http://localhost:1313/posts/tech/dynamic-programming.zh/</link>
      <pubDate>Wed, 28 Sep 2022 19:23:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dynamic-programming.zh/</guid>
      <description>问题描述 一般来说，一维动态规划的问题，其输入的参数一般是$n$，而所求结果有点像数列$a_n$，或者说$f(n)$($f$可以认为是函数或者说对应关系)，同时$a_n$与之前的$a_{n-1},a_{n-2},&amp;hellip;a_{1}$有一个确定的对应的关系，例如$a_n = a_{n-1} + a_{n-2}$(斐波那契数列)&#xA;解题步骤 数列即可与编程语言中的数组对应起来，在找到数列之间的迭代关系时，即可编写for循环来求解。&#xA;例题 509.斐波那契数 509.斐波那契数-题解 70.爬楼梯 70.爬楼梯-题解 746.使用最小花费爬楼梯 746.使用最小花费爬楼梯-题解 343.整数拆分 343.整数拆分-题解 62.不同路径 62.不同路径-题解 63.不同路径II 63.不同路径II-题解 </description>
    </item>
  </channel>
</rss>
