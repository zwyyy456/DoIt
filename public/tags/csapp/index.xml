<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Csapp on My New Hugo Site</title>
    <link>http://localhost:1313/tags/csapp/</link>
    <description>Recent content in Csapp on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Jul 2023 19:55:47 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/csapp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>虚拟内存</title>
      <link>http://localhost:1313/posts/tech/virtual_memory.zh/</link>
      <pubDate>Fri, 28 Jul 2023 19:55:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/virtual_memory.zh/</guid>
      <description>虚拟地址空间与物理地址空间 地址空间（address space）是一个非负整数地址的有序集合：&#xA;$$\lbrace 0, 1, 2, \cdots\rbrace$$&#xA;如果地址空间中的整数是连续的，那么我们说它是个线性地址空间（linear address space），为了简化讨论，我们总是假设我们使用的是线性地址空间。&#xA;地址空间的大小由表示最大地址所需的位数来决定，例如 $N - 1= 2^n - 1$，因此最大地址需要 $n$ 位数来表示，于是一个包含 $N = 2^n$ 个地址的地址空间就叫一个 $n$ 位地址空间。&#xA;虚拟地址空间 在一个带虚拟内存的系统中，CPU 由 $N=2^n$ 的地址空间中生成虚拟地址，这个虚拟地址的有序集合称为虚拟地址空间（virtual address space）：&#xA;$$ \lbrace 0, 1, 2, \cdots N - 1\rbrace$$&#xA;这个地址空间是 $n$ 位的。&#xA;物理地址空间 一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的 $M$ 个字节：&#xA;$$\lbrace0,1,2,\cdots,M-1\rbrace$$&#xA;$M$ 并不要求是 $2$ 的幂，例如可能是 $12GB$，但是为了简化讨论，我们假设 $M=2^m$，即地址空间是 $m$ 位的。&#xA;物理内存作为虚拟内存的缓存 概念上而言，虚拟内存被组织为一个存放在磁盘上的由 $N=2^n$ 个连续字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，作为到数组的索引；对应的，计算机的主存（main memory，后面简称内存）被组织成一个由 $M=2^m$ 个连续的字节大小的单元组成的数组，每字节都有一个唯一的物理地址。&#xA;VM（Virtual Memory）系统通过将虚拟内存分割为称为虚拟页（Virtual Page，VP）的大小固定的块来处理这个问题，每个虚拟页的大小为 $P=2^p$ 字节。相应的，物理内存被分割为物理页（Physical Page，PP）来处理，大小也为 P 字节。这里的物理页就像是 SRAM cache 中的 block。</description>
    </item>
    <item>
      <title>异常控制流（Exceptional Control Flow, ECF）</title>
      <link>http://localhost:1313/posts/tech/exceptional_control_flow.zh/</link>
      <pubDate>Tue, 27 Jun 2023 15:41:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/exceptional_control_flow.zh/</guid>
      <description>异常控制流简介 从给处理器上电起，直到断电，程序计数器（PC）假设一个值的序列： $$ a_0, a_1, \cdots, a_{n - 1}$$&#xA;每个 $a_k$ 是某个相应的指令 $I_k$ 的地址，每次从 $a_k$ 到 $a_{k + 1}$ 的过渡称为控制转移（control transfer）。这样的控制转移序列叫做处理器的控制流（flow of control 或 control flow）。&#xA;最简单的控制流是一个平滑的序列，即 $I_k$ 和 $I_{k + 1}$ 在内存中是连续的。&#xA;现代系统通过使控制流发生突变来应对系统状态的变化。一般而言我们把这些突变称为异常控制流（Exceptional Control Flow, ECF）。&#xA;例如当前程序在执行地址 $a_k$ 对应的指令 $I_k$，正常情况下，下一个指令应该是应该是地址 $a_{k + 1}$ 对应的指令 $I_{a_{k + 1}}$，但是由于发生了 page fault，它转去执行内核态的缺页异常处理程序，对应指令 $I_j$，执行完 $I_j$ 之后，它又回来执行 $I_k$。&#xA;For example, at the hardware level, events detected by the hardware trigger abrupt control transfers to exception handlers.</description>
    </item>
    <item>
      <title>Linux 动态内存分配</title>
      <link>http://localhost:1313/posts/tech/linux_memory_allocate.zh/</link>
      <pubDate>Tue, 20 Jun 2023 15:29:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/linux_memory_allocate.zh/</guid>
      <description>动态内存分配器 进程中名为 heap 的 VM area 就是由动态内存分配器（dynamic memory allocator）来维护的。Heap 会向高地址（向上）增长。对每个进程，内核维护着一个名为 brk 的变量，该变量指向 Heap 的顶部，如下图所示：&#xA;Allocator 将 Heap 视为一组不同大小的 block 组成的集合来维护。这里 block 和 chunk 的概念是等价的，该 block 要么是已分配的（allocated），要么是空闲的（free）。&#xA;Each block is a contiguous chunk of virtual memory that is either allocated or free.&#xA;Allocator 可以分为显式分配器（explicit allocator）和隐式分配器（implicit allocator）。&#xA;显示分配器要求应用显示地释放任何已分配的块，分配也需要手动分配。例如 C 中的 malloc 和 free，C++ 中的 new 和 delete； 隐式分配器又被称为垃圾收集（garbage collection），例如 Java、C#。 malloc 和 free $32$ 位系统中，malloc 返回的地址总是 $8$ 的倍数，即 malloc 返回的地址的最低三位总是 $0$，亦即 malloc 分配的 block 至少占据 $8$ 的倍数个 byte；而 $64$ 位系统中，malloc 返回的地址总是 $16$ 的倍数。</description>
    </item>
    <item>
      <title>Linux 虚拟内存系统</title>
      <link>http://localhost:1313/posts/tech/linux_virtual_memory.zh/</link>
      <pubDate>Sun, 18 Jun 2023 14:50:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/linux_virtual_memory.zh/</guid>
      <description>Linux 虚拟内存系统 首先，对 Linux 的虚拟内存系统做一个概述，以了解一个实际的操作系统是如何组织虚拟内存，以及如何处理缺页（page fault）的。&#xA;Linux 位为每个进程维护了一个单独的虚拟地址空间，形式如下：&#xA;可以看到，虚拟地址空间可以分为内核虚拟内存空间和用户虚拟内存空间两部分，实际上，$64$ 位系统的虚拟空间划分是这样的：&#xA;我们可以看到，在用户内存空间和内核内存空间之间还有一大片的“未定义”的区域，这是为什么呢？（注意，后续图片将有灵魂画手出没！）。&#xA;之前我们提到，AMD 制定的 $64$ 位 CPU 架构时，虽然是 $64$ 位的，即总的虚拟地址空间是 $64$ 位的，但实际上，用到的虚拟地址其实只有其中的低 $48$ 位。&#xA;当我们把 addr_val 解释为一个虚拟地址时，我们使用的真正的虚拟地址，其实只有它的低 $48$ 位，（由 AMD 设计 CPU 架构的时候规定，其实 $48$ 位也完全够用了），后 $16$ 位的值会与 addr_val 的第 $47$ 位保持一致（全 $0$ 或者全 $1$），全 $0$ 表示该虚拟地址处于当前虚拟地址空间的用户态部分，全 $1$ 表示处于内核态部分。&#xA;换言之，虚拟地址的高 $16$ 位是由 CPU 在生成要访问的虚拟地址时，先生成低 $48$ 位的虚拟地址，再根据第 $47$ 位的值是 $0$ 还是 $1$，判断地址属于内核虚拟地址空间还是用户虚拟地址空间（或者说进程虚拟地址空间），再生成虚拟地址的高 $16$ 位。&#xA;如下图所示：&#xA;Linux 虚拟内存区域（area） Linux organizes the virtual memory as a collection of areas (also called segments).</description>
    </item>
    <item>
      <title>CPU 缓存一致性：MESI</title>
      <link>http://localhost:1313/posts/tech/cache_mesi.zh/</link>
      <pubDate>Wed, 07 Jun 2023 10:36:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/cache_mesi.zh/</guid>
      <description>概述 MESI（也称伊利诺斯协议）是一种广泛使用的支持 write-back 策略的缓存一致性协议。&#xA;MESI 状态 我们假设 CPU 中共有 $k$ 个核； CPU 中每个 cacheline 使用 $4$ 种状态进行标记：&#xA;状态 介绍 所有核中该状态的个数 MODIFIED 实际上是 exclusive dirty，说明该核的缓存数据被修改了，且并未写入到更低一层存储中；当某个核的缓存处于该状态时，其余核的对应 cacheline 均为 INVALID 1 EXCLUSIVE 实际上是 exclusive clean，说明该核的缓存刚从更低一层存储中读取到了最新的数据；当某个核的缓存处于该状态时，其余核的对应 cacheline 均为 INVALID 1 SHARED 实际上是 shared clean，说明多个核的缓存从更低一层存储中读到的数据都是最新的，处于该状态的核的数量一定 $\geq 2$，其余核的对应 cacheline 均为 INVALID $\geq 2$ INVALID 说明该核的 cacheline 无效 状态切换 我们以四个核为例，用四元组如 $(M, I, I, I)$ 表示四个核的 cacheline 状态，假设只操作第一个核的 cacheline：&#xA;执行读操作 $(M,I,I,I)$ 执行读，状态仍为 $(M, I, I, I)$； $(E,I,I,I)$ 执行读，状态仍为 $(E, I, I, I)$； $(S,S,I,I)$ 执行读，状态仍为 $(S, S, I, I)$； $(I,M,I,I)$ 执行读，将第二个核的 cacheline 的数值 $val$ 写入内存，然后更新第一个核的 cacheline 的值为 $val$，状态切换为 $(S,S,I,I)$； $(I,E,I,I)$ 执行读，更新第一个核的 cacheline 为第二个核的数值 $val$，状态切换为 $(S,S,I,I)$； $(I,S,S,I)$ 执行读，更新第一个核的 cacheline 为第二个或第三个核的数值 $val$，状态切换为 $(S,S,S,I)$； $(I,I,I,I)$ 执行读，从内存中读取对应的地址的数值 $*addr$ 到 cacheline，状态切换为 $(E, I, I, I)$； 执行写操作 $(M,I,I,I)$ 执行写，状态仍为 $(M, I, I, I)$； $(E,I,I,I)$ 执行写，状态变为 $(M, I, I, I)$； $(S,S,I,I)$ 执行写，将其他所有状态为 $S$ 的 cacheline 的状态全都设置为 $I$，状态变为 $(M, I, I, I)$； $(I,M,I,I)$ 执行写，将第二个核的 cacheline 的数值 $val$ 写入内存（为了防止 ABA 问题，这里为什么要写回 TODO(zwyyy)，是否和指令原子性有关），状态变为 $I$，然后更新第一个核的 cacheline 的值为 $val$，再更新值为待写入的值 $write$_$value$，状态切换为 $(M,I,I,I)$； $(I,E,I,I)$ 执行写，更新第一个核的 cacheline 为第二个核的数值 $val$，将第二个核的状态设为 $I$，状态切换为 $(M,I,I,I)$； $(I,I,I,I)$ 执行写，将 $write$_$val$ 写到 cacheline 中，状态切换为 $(M, I, I, I)$； 执行 evict 操作 </description>
    </item>
    <item>
      <title>ELF 文件结构分析</title>
      <link>http://localhost:1313/posts/tech/elf_file_structure.zh/</link>
      <pubDate>Sun, 28 May 2023 15:59:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/elf_file_structure.zh/</guid>
      <description>目标文件的格式 目前，Linux 平台流行的 可执行文件（Executable）主要包含以下格式：&#xA;Linux 下的 ELF（Executable Linkable Format），注意这里是二进制文件其内容的组织格式，与后缀无关； 目标文件是源代码经过编译后但是未进行链接的那些中间文件（Linux 下为 .o 文件），它与可执行文件格式非常相似，一般与可执行文件一起采用同一种格式存储，Linux 下采用 ELF 文件格式。&#xA;动态链接库（Dynamic Linking Library）、静态链接库（Static Linking Library）均采用可执行文件格式存储，Linux 下均按照 ELF 格式存储。&#xA;Linux 下的 .so、.a； ELF 文件结构 CSAPP 上的 ELF 格式文件结构图：&#xA;更详细的 ELF 文件结构图：&#xA;可以看到，ELF 文件包含四个部分：&#xA;第一部分为 ELF Header； 第二部分为 Program Header Table，Relocatable object file 中该部分不存在，Executable object file 中该部分存在； 第三部分为 ELF Sections，包括 .text、.rodata、.data、.bss等； 第四部分为 ELF Section Header Table（或称节头表，后面以 sht 指代），注意 sht 不像 ELF Header 那样只有一块，它由多个 Section header table entry 组成。 ELF 的 16 进制内容 elf.</description>
    </item>
    <item>
      <title>二进制下的补码、反码、原码——适用于有符号整数</title>
      <link>http://localhost:1313/posts/tech/2_complement.zh/</link>
      <pubDate>Mon, 08 May 2023 18:40:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/2_complement.zh/</guid>
      <description>简单定义 简单起见，我们这里只考虑三位二进制数所能表示的范围，即$[-4, -3, -2, -1, 0,\ 1,\ 2,\ 3]$。&#xA;机器数和真值 一个数在计算机中的二进制表现形式，就是这个数的机器数（相当于数的原码）。 例如，$-3$ 的机器数即为 $111$，$2$ 的机器数为 $010$。&#xA;机器数在考虑最高位为符号位的情况下，换算出来的值就是真值，例如 $111$ 的真值为 $-3$，而形式值为 $7$；$010$ 的形式值和真值都为 $2$。&#xA;原码、反码、补码 有符号整数的原码就是它的机器数，正数的反码与原码相同，而负数的反码则是符号位不变，其余位取反。&#xA;正数的补码（Complement）不变，负数的补码则是它的反码 $+1$，例如 $-1$ 的反码为 $110$，补码为 $111$；也可以说负数的补码是该负数的相反数的原码取反 $+1$。&#xA;为什么要用补码？ 使用补码可以解决减法运算的问题。 例如 $2 - 1 = 2 + (-1) = 010 + 111 = 001 = 1$ （$1001$ 去掉超出的最高位）。&#xA;使用原码或者反码都不好处理这个问题。&#xA;为什么补码会有这个效果？ 我们首先要意识到一点，$-1$ 的补码为 $111$，$111$ 对应的形式值为 $7$，而 $7 - (-1) = 8$。&#xA;例如，当我们使用 $2 - 1$ 时，相当于 $2 + 7 = 9$，然而，由于我们只能表示 $-4 \sim 3$ 这个范围内的所有数，大于 3 的数，就变成了 $9\mod 8 = 1$。</description>
    </item>
  </channel>
</rss>
