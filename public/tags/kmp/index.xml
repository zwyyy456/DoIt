<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kmp on My New Hugo Site</title>
    <link>http://localhost:1313/tags/kmp/</link>
    <description>Recent content in Kmp on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Mar 2023 21:22:38 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/kmp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>686.重复叠加字符串匹配 (Medium)</title>
      <link>http://localhost:1313/posts/leet/686-repeated-string-match.zh/</link>
      <pubDate>Mon, 27 Mar 2023 21:22:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/686-repeated-string-match.zh/</guid>
      <description>问题描述 686. 重复叠加字符串匹配 (Medium)&#xA;给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。&#xA;注意： 字符串 &amp;quot;abc&amp;quot; 重复叠加 0 次是 &amp;quot;&amp;quot;，重复叠加 1 次是 &amp;quot;abc&amp;quot;，重复叠加 2 次是 &amp;quot;abcabc&amp;quot;。&#xA;示例 1：&#xA;输入：a = &amp;#34;abcd&amp;#34;, b = &amp;#34;cdabcdab&amp;#34; 输出：3 解释：a 重复叠加三遍后为 &amp;#34;abcdabcdabcd&amp;#34;, 此时 b 是其子串。 示例 2：&#xA;输入：a = &amp;#34;a&amp;#34;, b = &amp;#34;aa&amp;#34; 输出：2 示例 3：&#xA;输入：a = &amp;#34;a&amp;#34;, b = &amp;#34;a&amp;#34; 输出：1 示例 4：&#xA;输入：a = &amp;#34;abc&amp;#34;, b = &amp;#34;wxyz&amp;#34; 输出：-1 提示：</description>
    </item>
    <item>
      <title>28.Find the Index of the First Occurrence in a String (Easy)</title>
      <link>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string/</link>
      <pubDate>Mon, 27 Mar 2023 21:15:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string/</guid>
      <description>Description 28. Find the Index of the First Occurrence in a String (Easy)&#xA;Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&#xA;Example 1:&#xA;Input: haystack = &amp;#34;sadbutsad&amp;#34;, needle = &amp;#34;sad&amp;#34; Output: 0 Explanation: &amp;#34;sad&amp;#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2:</description>
    </item>
    <item>
      <title>28.找出字符串中第一个匹配项的下标 (Medium)</title>
      <link>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string.zh/</link>
      <pubDate>Mon, 27 Mar 2023 21:15:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string.zh/</guid>
      <description>问题描述 28. 找出字符串中第一个匹配项的下标 (Medium)&#xA;给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1。&#xA;示例 1：&#xA;输入：haystack = &amp;#34;sadbutsad&amp;#34;, needle = &amp;#34;sad&amp;#34; 输出：0 解释：&amp;#34;sad&amp;#34; 在下标 0 和 6 处匹配。 第一个匹配项的下标是 0 ，所以返回 0 。 示例 2：&#xA;输入：haystack = &amp;#34;leetcode&amp;#34;, needle = &amp;#34;leeto&amp;#34; 输出：-1 解释：&amp;#34;leeto&amp;#34; 没有在 &amp;#34;leetcode&amp;#34; 中出现，所以返回 -1 。 提示：&#xA;1 &amp;lt;= haystack.length, needle.length &amp;lt;= 10⁴ haystack 和 needle 仅由小写英文字符组成 解题思路 标准的kmp算法模板题。&#xA;代码 class Solution { public: void SetNext(vector&amp;lt;int&amp;gt; &amp;amp;next, string needle) { int x = 1, now = 0; while (x &amp;lt; needle.</description>
    </item>
    <item>
      <title>kmp 算法</title>
      <link>http://localhost:1313/posts/tech/kmp.zh/</link>
      <pubDate>Mon, 27 Mar 2023 16:45:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/kmp.zh/</guid>
      <description>问题描述 kmp算法解决的是字符串匹配问题，即:字符串P是否是字符串S的子串？如果是，它出现在s的哪些位置？这里我们称 S 为主串，P 为模式串。&#xA;思路 首先是暴力匹配算法（Brute-Force算法），代码如下：&#xA;void BruteForce(string s, string p) { int len_s = s.size(), len_p = p.size(); for (int i = 0; i &amp;lt;= len_s - len_p; ++i) { int flag = true; for (int j = 0; j &amp;lt; len_p; ++j) { if (s[i + j] != p[j]) { flag = false; break; } } if (flag) { printf(&amp;#34;pos = %d\n&amp;#34;, i); } } } 易得时间复杂度的最坏情况是$O(mn)$的，其中$n$为s的长度，$m$为p的长度。</description>
    </item>
  </channel>
</rss>
