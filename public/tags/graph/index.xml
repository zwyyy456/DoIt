<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graph on My New Hugo Site</title>
    <link>http://localhost:1313/tags/graph/</link>
    <description>Recent content in Graph on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Jul 2023 10:09:35 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/graph/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>834. Sum of Distances in Tree (Hard)</title>
      <link>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree/</link>
      <pubDate>Tue, 18 Jul 2023 10:09:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree/</guid>
      <description>Description 834. Sum of Distances in Tree (Hard)&#xA;Solution To find the sum of distances to a single node (e.g., $0$) denoted as $dp[0]$, we can easily use DFS to compute it with a time complexity of $O(n)$. However, finding the sum of distances for all $n$ nodes would take $O(n^2)$ time, which would obviously result in a timeout for large graphs.&#xA;However, we notice that there exists a recurrence relationship between the parent node $j$&amp;rsquo;s $dp[j]$ and the child node $i$&amp;rsquo;s $dp[i]$.</description>
    </item>
    <item>
      <title>834. 树中距离之和 (Hard)</title>
      <link>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree.zh/</link>
      <pubDate>Tue, 18 Jul 2023 10:09:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree.zh/</guid>
      <description>问题描述 834. 树中距离之和 (Hard)&#xA;给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。&#xA;给定整数 n 和数组 edges ， edges[i] = [aᵢ, bᵢ] 表示树中的节点 aᵢ 和 bᵢ 之间有一条边。&#xA;返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。&#xA;示例 1:&#xA;输入: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] 输出: [8,12,6,10,10,10] 解释: 树如图所示。 我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。 示例 2:</description>
    </item>
    <item>
      <title>无向图形式组织的树</title>
      <link>http://localhost:1313/posts/tech/undirected-graph-tree.zh/</link>
      <pubDate>Tue, 18 Jul 2023 09:30:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/undirected-graph-tree.zh/</guid>
      <description>引入 如 数组形式组织的树 中所说，树一般以链表结点的形式组织，定义如下：&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} }; 也可能以数组的形式组织，即使用 $parent$ 数组，$y = parent[x]$ 说明 $y$ 是 $x$ 的父结点，根结点的父结点为 $-1$，表示父结点不存在。&#xA;还可以使用无向图的形式来表示，例如 leetcode 的 834. 树中距离之和。&#xA;昨天做这个题的时候，整体思路挺好想的，但就是有个地方被困住了，那就是，在树的无向图的表示情况下，如何统计以当前结点为根结点的子树的数量？（没办法转化成有向图！）&#xA;统计以当前结点为根结点的子树的结点数 统计方法还是深度优先搜索（dfs），只不过，相比一般的深度优先搜索，我们需要传入一个额外的参数，即上一次搜索的父结点，如下图所示：&#xA;相应的 dfs 代码为&#xA;for (int child : tree[pa]) { if (child == ancestor) { continue; } // 对子结点进行 dfs ... } 这样就确定出了一个遍历方向，因此，整体思路就是，我们可以任意选择一个结点作为 dfs 的起点（这里就选择 $0$ 号结点），依次进行 dfs，利用递归的方法，统计以当前结点为根结点的子树的结点数。&#xA;因此，834. 树中距离之和 的完整解题代码如下：&#xA;class Solution { public: int count(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;tree, vector&amp;lt;int&amp;gt; &amp;amp;dis, vector&amp;lt;int&amp;gt; &amp;amp;cnt, int pa, int grandpa) { int res = 1; for (int child : tree[pa]) { if (child == grandpa) { // 防止重复遍历，保证 dfs 遍历时的单向性 continue; } dis[child] = dis[pa] + 1; res += count(tree, dis, cnt, child, pa); } cnt[pa] = res; return res; } vector&amp;lt;int&amp;gt; sumOfDistancesInTree(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;edges) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; tree(n); for (auto &amp;amp;vec : edges) { tree[vec[0]].</description>
    </item>
    <item>
      <title>拓扑排序</title>
      <link>http://localhost:1313/posts/tech/topo-sort.zh/</link>
      <pubDate>Mon, 10 Apr 2023 14:13:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/topo-sort.zh/</guid>
      <description>定义 拓扑排序（Topological sorting）要解决的问题是给一个有向图的所有节点排序。&#xA;这里直接使用OI-Wiki中举的例子来说明：&#xA;我们可以拿大学选课的例子来描述这个过程，比如学习大学课程中有：单变量微积分，线性代数，离散数学概述，概率论与统计学概述，语言基础，算法导论，机器学习。当我们想要学习 算法导论 的时候，就必须先学会 离散数学概述 和 概率论与统计学概述，不然在课堂就会听的一脸懵逼。当然还有一个更加前的课程 单变量微积分。&#xA;这些课程就相当于几个顶点$u$, 顶点之间的有向边$(u,v)$就相当于学习课程的顺序。显然拓扑排序不是那么的麻烦，不然你是如何选出合适的学习顺序。下面将介绍如何将这个过程抽象出来，用算法来实现。&#xA;但是如果某一天排课的老师打瞌睡了，说想要学习 算法导论，还得先学 机器学习，而 机器学习 的前置课程又是 算法导论，然后你就一万脸懵逼了，我到底应该先学哪一个？当然我们在这里不考虑什么同时学几个课程的情况。在这里，算法导论 和 机器学习 间就出现了一个环，显然你现在没办法弄清楚你需要学什么了，于是你也没办法进行拓扑排序了。因而如果有向图中存在环路，那么我们就没办法进行拓扑排序了。&#xA;因此我们可以说在一个[[DAG（有向无环图）]]中，我们将图中顶点以线性方式排序，使得对于任意顶点$u$到$v$的有向边$(u, v)$，都有$u$在$v$的前面。&#xA;或者说给定一个DAG，如果$i$到$j$有边，则认为$j$依赖于$i$，如果$i$到$j$有路径，则称$j$间接依赖于$i$； 拓扑排序的目标是将所有节点排序，使得在前面的节点不能依赖于排在后面的节点。&#xA;bfs 拓扑排序有广度优先搜索（bfs）和深度优先搜索（dfs）两种实现方式，这里我们先讨论bfs。&#xA;利用bfs实现拓扑排序需要根据节点的入度：&#xA;入度：有多少条边直接指向该节点&#xA;思路 起始时，将所有入度为$0$的点放入队列q_in0； 将队首元素出队，出队序列就是我们要求的拓扑序，对当前弹出的节点u，res.push_back(u)，遍历u的所有出度，即遍历所有由u直接指向的节点v，递减节点v的入度； 如果节点v的入度变为0，将节点v入队； 循环2、3流程直到队列为空； 如果res最后恰好有$n$个节点，说明原图为DAG，res中的节点序列即要求的拓扑序；否则说明图中存在环。&#xA;代码实现 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph; int n = graph.size(); int in[n]; // 存储每个节点的入度 bool toposrot() { vector&amp;lt;int&amp;gt; res; queue&amp;lt;int&amp;gt; q_in0; for (int i = 0; i &amp;lt; n; ++i) { if (in[i] == 0) { q_in0.push(i); } } while (!</description>
    </item>
    <item>
      <title>1615.Maximal Network Rank (Medium)</title>
      <link>http://localhost:1313/posts/leet/1615.maximal-network-rank/</link>
      <pubDate>Wed, 15 Mar 2023 09:46:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1615.maximal-network-rank/</guid>
      <description>Description 1615. Maximal Network Rank (Medium)&#xA;There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [aᵢ, bᵢ] indicates that there is a bidirectional road between cities aᵢ and bᵢ.&#xA;The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.</description>
    </item>
    <item>
      <title>1615.最大网络秩 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1615.maximal-network-rank.zh/</link>
      <pubDate>Wed, 15 Mar 2023 09:46:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1615.maximal-network-rank.zh/</guid>
      <description>问题描述 1615. 最大网络秩 (Medium)&#xA;n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [aᵢ, bᵢ] 都表示在城市 aᵢ 和 bᵢ 之间有一条双向道路。&#xA;两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。&#xA;整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。&#xA;给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。&#xA;示例 1：&#xA;输入：n = 4, roads = [[0,1],[0,3],[1,2],[1,3]] 输出：4 解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。 示例 2：&#xA;输入：n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] 输出：5 解释：共有 5 条道路与城市 1 或 2 相连。 示例 3：</description>
    </item>
    <item>
      <title>787.Cheapest Flights Within K Stops (Medium)</title>
      <link>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops/</link>
      <pubDate>Mon, 13 Mar 2023 14:16:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops/</guid>
      <description>Description 787. Cheapest Flights Within K Stops (Medium)&#xA;There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromᵢ, toᵢ, priceᵢ] indicates that there is a flight from city fromᵢ to city toᵢ with cost priceᵢ.&#xA;You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.</description>
    </item>
    <item>
      <title>787.K 站中转内最便宜的航班 (Medium)</title>
      <link>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops.zh/</link>
      <pubDate>Mon, 13 Mar 2023 14:14:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops.zh/</guid>
      <description>问题描述 787. K 站中转内最便宜的航班 (Medium)&#xA;有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromᵢ, toᵢ, priceᵢ] ，表示该航班都从城市 fromᵢ 开始，以价格 priceᵢ 抵达 toᵢ。&#xA;现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。&#xA;示例 1：&#xA;输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 输出: 200 解释: 城市航班图如下 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 示例 2：&#xA;输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 输出: 500 解释: 城市航班图如下 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。 提示：</description>
    </item>
  </channel>
</rss>
