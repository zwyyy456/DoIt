<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bfs on My New Hugo Site</title>
    <link>http://localhost:1313/tags/bfs/</link>
    <description>Recent content in Bfs on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Sep 2023 14:15:52 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>310. Minimum Height Trees (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees/</guid>
      <description>Description 310. Minimum Height Trees (Medium)&#xA;A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.&#xA;Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [aᵢ, bᵢ] indicates that there is an undirected edge between the two nodes aᵢ and bᵢ in the tree, you can choose any node of the tree as the root.</description>
    </item>
    <item>
      <title>310. 最小高度树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</guid>
      <description>问题描述 310. 最小高度树 (Medium)&#xA;树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵 树。&#xA;给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条无 向边。&#xA;可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中， 具有最小高度的树（即， min(h)）被称为 最小高度树 。&#xA;请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。&#xA;树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。&#xA;示例 1：&#xA;输入：n = 4, edges = [[1,0],[1,2],[1,3]] 输出：[1] 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 示例 2：&#xA;输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] 输出：[3,4] 提示：</description>
    </item>
    <item>
      <title>851.喧闹和富有 (Medium)</title>
      <link>http://localhost:1313/posts/leet/851.loud-and-rich/</link>
      <pubDate>Mon, 10 Apr 2023 15:07:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/851.loud-and-rich/</guid>
      <description>Description 851. Loud and Rich (Medium)&#xA;There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.&#xA;You are given an array richer where richer[i] = [aᵢ, bᵢ] indicates that aᵢ has more money than bᵢ and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.</description>
    </item>
    <item>
      <title>851.喧闹和富有 (Medium)</title>
      <link>http://localhost:1313/posts/leet/851.loud-and-rich.zh/</link>
      <pubDate>Mon, 10 Apr 2023 15:06:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/851.loud-and-rich.zh/</guid>
      <description>问题描述 851. 喧闹和富有 (Medium)&#xA;有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 &amp;ldquo;person x &amp;ldquo;。&#xA;给你一个数组 richer ，其中 richer[i] = [aᵢ, bᵢ] 表示 person aᵢ 比 person bᵢ 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。 richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。&#xA;现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。&#xA;示例 1：</description>
    </item>
    <item>
      <title>802.Find Eventual Safe States (Medium)</title>
      <link>http://localhost:1313/posts/leet/802.find-eventual-safe-states/</link>
      <pubDate>Mon, 10 Apr 2023 14:49:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/802.find-eventual-safe-states/</guid>
      <description>Description 802. Find Eventual Safe States (Medium)&#xA;There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].&#xA;A node is a terminal node if there are no outgoing edges.</description>
    </item>
    <item>
      <title>802.找到最终的安全状态 (Medium)</title>
      <link>http://localhost:1313/posts/leet/802.find-eventual-safe-states.zh/</link>
      <pubDate>Mon, 10 Apr 2023 14:46:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/802.find-eventual-safe-states.zh/</guid>
      <description>问题描述 802. 找到最终的安全状态 (Medium)&#xA;有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph 表示， graph[i] 是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i] 中的每个节点都有一条边。&#xA;如果一个节点没有连出的有向边，则它是 终端节点 。如果没有出边，则节点为终端节点。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。&#xA;返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。&#xA;示例 1：&#xA;输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]] 输出：[2,4,5,6] 解释：示意图如上。 节点 5 和节点 6 是终端节点，因为它们都没有出边。 从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。 示例 2：&#xA;输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] 输出：[4] 解释: 只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。 提示：</description>
    </item>
    <item>
      <title>778.Swim in Rising Water (Hard)</title>
      <link>http://localhost:1313/posts/leet/778.swim-in-rising-water/</link>
      <pubDate>Fri, 17 Mar 2023 15:29:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/778.swim-in-rising-water/</guid>
      <description>Description 778. Swim in Rising Water (Hard)&#xA;You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).&#xA;The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time.</description>
    </item>
    <item>
      <title>778.水位上升的泳池中游泳 (Hard)</title>
      <link>http://localhost:1313/posts/leet/778.swim-in-rising-water.zh/</link>
      <pubDate>Fri, 17 Mar 2023 15:29:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/778.swim-in-rising-water.zh/</guid>
      <description>问题描述 778. 水位上升的泳池中游泳 (Hard)&#xA;在一个 n x n 的整数矩阵 grid 中，每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。&#xA;当开始下雨时，在时间为 t 时，水池中的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。&#xA;你从坐标方格的左上平台 (0，0) 出发。返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间 。&#xA;示例 1:&#xA;输入: grid = [[0,2],[1,3]] 输出: 3 解释: 时间为0时，你位于坐标方格的位置为 (0, 0)。 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。 等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置 示例 2:&#xA;输入: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] 输出: 16 解释: 最终的路线用加粗进行了标记。 我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的 提示:</description>
    </item>
    <item>
      <title>403.frog jump</title>
      <link>http://localhost:1313/posts/leet/403.frog-jump/</link>
      <pubDate>Wed, 01 Mar 2023 15:08:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/403.frog-jump/</guid>
      <description>Description 403. Frog Jump (Hard)&#xA;A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.&#xA;Given a list of stones&amp;rsquo; positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone.</description>
    </item>
    <item>
      <title>403.青蛙过河</title>
      <link>http://localhost:1313/posts/leet/403.frog-jump.zh/</link>
      <pubDate>Wed, 01 Mar 2023 15:08:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/403.frog-jump.zh/</guid>
      <description>问题描述 403. 青蛙过河 (Hard)&#xA;一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。&#xA;给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。&#xA;如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、 k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。&#xA;示例 1：&#xA;输入：stones = [0,1,3,5,6,8,12,17] 输出：true 解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。 示例 2：</description>
    </item>
    <item>
      <title>1210.minimum moves to reach target with rotations</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</guid>
      <description>Description 1210.minimum-moves-to-reach-target-with-rotations&#xA;Solution BFS.&#xA;We can use (x, y state) to denote the position of the snake, x as the abscissa of the tail of the snake, y as the ordinate of the tail of the snake. state indicates whether the snake is vertical or horizontal.&#xA;Code class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.</description>
    </item>
    <item>
      <title>1210.穿过迷宫的最少移动次数</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</guid>
      <description>问题描述 1210.穿过迷宫的最少移动次数&#xA;解题思路 广度优先搜索&#xA;可以用(x, y, state)来表示贪吃蛇当前所处的位置，x为蛇尾的横坐标，y为蛇尾的纵坐标，state表示蛇当前处于水平还是竖直状态。&#xA;代码 class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0) return true; else return false; } } else if (i == 1) { vec_tmp[0] += 1; vec_tmp[2] += 1; if (vec_tmp[2] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0 &amp;amp;&amp;amp; vec_tmp[2] &amp;lt; grid.</description>
    </item>
    <item>
      <title>1129.shortest path with alternating colors</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</guid>
      <description>Description 1129.shortest-path-with-alternating-colors&#xA;Solution First, we need represent the graph as an edge matrix, and we use bfs to find the shortest path.&#xA;In this problem, since the edge color of the shortest path must change along the path, when we judge whether the current node is visited, we should distinguish the cases that the current node is visited by red edges and the cases that the current node is visited by blue edges.</description>
    </item>
    <item>
      <title>1129.颜色交替的最短路径</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</guid>
      <description>问题描述 1129.颜色交替的最短路径&#xA;解题思路 首先，将本题的图结构以边表的形式表现出来，然后采取广度优先搜索的方式寻找最短路径，一般来说广度优先搜索能够保证找到的是最短路径。&#xA;在本题中，由于要求最短路径是交替出现的，那么在判断节点是否已经访问过时，要分红色路径访问节点和蓝色路径访问节点两种情况讨论。&#xA;队列中的元素为三元组tie(point, len, c_flag)，分别表示当前节点的索引、到达当前节点的路径长度（不一定是最短的，本题中存在环）、到达当前节点的路径颜色（0表示蓝色，1表示红色）&#xA;提示bfs(q, red_connect, blue_connect, answer, n)（其中q包含tie(0, 0, 0)和tie(0, 0, 1)）与bfs(q, red_connect, blue_connect, answer, n)执行两次（q分别为tie(0, 0, 0)和tie(0, 0, 1)）的结果是一样的。&#xA;代码 class Solution { public: void bfs(queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;red_connect, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;blue_connect, vector&amp;lt;int&amp;gt; &amp;amp;answer, int n, int i) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; visited(n, vector&amp;lt;int&amp;gt;(2, 0)); // visited[k][1]表示由红到point，visited[k][0]为1表示由蓝到point int tmp_point = 0; while (!q.empty()) { auto [point, len, c_flag] = q.front(); visited[point][c_flag] = 1; q.pop(); if (answer[point] == -1) answer[point] = len; else answer[point] = min(answer[point], len); if (c_flag == 0) { for (int k = 0; k &amp;lt; red_connect[point].</description>
    </item>
    <item>
      <title>847.shortest path visiting all nodes</title>
      <link>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes/</link>
      <pubDate>Mon, 02 Jan 2023 20:38:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes/</guid>
      <description>Description 847.shortest-path-visiting-all-nodes&#xA;Solution solution 1: bitmask + bfs For example, $(0101)_2$ means the nodes numbered 0 and 2 have been accessed, while nodes nubmered 1 and 3 have not been accessed.&#xA;bfs;&#xA;Array seen[x][mask_x] means whether node x and path mask_x have been accessed.&#xA;Code class Solution { public: int shortestPathLength(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) { int n = graph.size(); queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; seen(n, vector&amp;lt;int&amp;gt;(1 &amp;lt;&amp;lt; n)); for (int i = 0; i &amp;lt; n; i++) { q.</description>
    </item>
    <item>
      <title>847.访问所有节点的最短路径</title>
      <link>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes.zh/</link>
      <pubDate>Mon, 02 Jan 2023 20:38:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes.zh/</guid>
      <description>问题描述 847.访问所有节点的最短路径&#xA;解题思路 方法一:状态压缩+bfs 状态压缩 由于本题中，n只有12，且状态只有访问和未访问两种，因此可以使用二进制表示法，利用int的低12位来代指点是否被访问过;&#xA;例如$(000&amp;hellip;0101)_2$表示编号为0和编号为2的节点已经被访问过，而编号为1和3的节点还没有被访问过;&#xA;假设mask存放了当前一系列点的访问状态，假如要检查编号为x的点是否被访问过，可以使用位运算a = (mask &amp;gt;&amp;gt; x) &amp;amp; 1来检查，如果a为1，那么访问过，为0表示未访问;&#xA;假设如果表示在x未被访问的情况下，要去访问x，那么mask_v = mask | (1 &amp;lt;&amp;lt; x)，其中mask_v表示更新后的状态二进制数。&#xA;代码 class Solution { public: int shortestPathLength(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) { int n = graph.size(); queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; seen(n, vector&amp;lt;int&amp;gt;(1 &amp;lt;&amp;lt; n)); for (int i = 0; i &amp;lt; n; i++) { q.emplace(i, 1 &amp;lt;&amp;lt; i, 0); // 索引、二进制掩码、距离 seen[i][1 &amp;lt;&amp;lt; i] = 1; } int ans = 0; while (!</description>
    </item>
  </channel>
</rss>
