<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dfs on My New Hugo Site</title>
    <link>http://localhost:1313/tags/dfs/</link>
    <description>Recent content in Dfs on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Sep 2023 14:15:52 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>310. Minimum Height Trees (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees/</guid>
      <description>Description 310. Minimum Height Trees (Medium)&#xA;A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.&#xA;Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [aᵢ, bᵢ] indicates that there is an undirected edge between the two nodes aᵢ and bᵢ in the tree, you can choose any node of the tree as the root.</description>
    </item>
    <item>
      <title>310. 最小高度树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</guid>
      <description>问题描述 310. 最小高度树 (Medium)&#xA;树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵 树。&#xA;给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条无 向边。&#xA;可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中， 具有最小高度的树（即， min(h)）被称为 最小高度树 。&#xA;请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。&#xA;树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。&#xA;示例 1：&#xA;输入：n = 4, edges = [[1,0],[1,2],[1,3]] 输出：[1] 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 示例 2：&#xA;输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] 输出：[3,4] 提示：</description>
    </item>
    <item>
      <title>331.verify Preorder Serialization of a Binary Tree</title>
      <link>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree.zh/</link>
      <pubDate>Wed, 13 Sep 2023 11:10:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree.zh/</guid>
      <description>问题描述 331. 验证二叉树的前序序列化 (Medium)&#xA;序列化二叉树的一种方法是使用 前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如 果它是一个空节点，我们可以使用一个标记值记录，例如 #。&#xA;例如，上面的二叉树可以被序列化为字符串 &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;，其中 # 代表一个空节点。&#xA;给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法 。&#xA;保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &#39;#&#39; 。&#xA;你可以认为输入格式总是有效的&#xA;例如它永远不会包含两个连续的逗号，比如 &amp;quot;1,,3&amp;quot; 。 注意： 不允许重建树。&#xA;示例 1:&#xA;输入: preorder = &amp;#34;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;#34; 输出: true 示例 2:&#xA;输入: preorder = &amp;#34;1,#&amp;#34; 输出: false 示例 3:&#xA;输入: preorder = &amp;#34;9,#,#,1&amp;#34; 输出: false 提示:&#xA;1 &amp;lt;= preorder.length &amp;lt;= 10⁴ preorder 由以逗号 “，” 分隔的 [0,100] 范围内的整数和 “#” 组成 解题思路 归约 本质上还是一种递归的思想，在前序遍历时，我们可以注意到，每个叶子结点必定跟随两个 null，因此，我们可以反过来，将连续的一个非空结点和两个空结点，归约为一个空结点，这个过程有点像消消乐，可以利用栈来实现这个过程，最后根据栈是否只剩下一个空结点来判断。&#xA;递归 递归的思路参照 剑指 Offer 37.</description>
    </item>
    <item>
      <title>109. Convert Sorted List to Binary Search Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Mon, 11 Sep 2023 14:40:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree/</guid>
      <description>Description 109. Convert Sorted List to Binary Search Tree (Medium)&#xA;Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balancedbinary search tree.&#xA;Example 1:&#xA;Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST. Example 2:&#xA;Input: head = [] Output: [] Constraints:&#xA;The number of nodes in head is in the range [0, 2 * 10⁴].</description>
    </item>
    <item>
      <title>109. 有序链表转换二叉搜索树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree.zh/</link>
      <pubDate>Mon, 11 Sep 2023 14:40:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree.zh/</guid>
      <description>问题描述 109. 有序链表转换二叉搜索树 (Medium)&#xA;给定一个单链表的头节点 head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。&#xA;本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。&#xA;示例 1:&#xA;输入: head = [-10,-3,0,5,9] 输出: [0,-3,9,-10,null,5] 解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。 示例 2:&#xA;输入: head = [] 输出: [] 提示:&#xA;head 中的节点数在 [0, 2 * 10⁴] 范围内 -10⁵ &amp;lt;= Node.val &amp;lt;= 10⁵ 解题思路 首先，如果将链表换成数组，可以很方便地在 $O(n)$ 时间内完成，然后由于链表无法像数组那样在 $O(1)$ 时间内实现随机访问，因此不能套用数组的思路。&#xA;我们首先要想到，对二叉搜索树进行中序遍历，就能得到一个升序链表，那么我们也可以通过一个类似中序遍历的过程，得到二叉搜索树。即先计算左子结点，根结点就是当前遍历到的链表结点，然后计算右子结点。&#xA;代码 class Solution { public: TreeNode *dfs(int l, int r, ListNode **head) { if (l &amp;gt;= r) { return nullptr; } int mid = l + (r - l) / 2; TreeNode *left = dfs(l, mid, head); TreeNode *root = new TreeNode((*head)-&amp;gt;val); root-&amp;gt;left = left; *head = (*head)-&amp;gt;next; root-&amp;gt;right = dfs(mid + 1, r, head); return root; } TreeNode *sortedListToBST(ListNode *head) { // 牢记，二叉搜索树的中序遍历结果是一个升序数组 ListNode *tail = head; int cnt = 0; while (tail !</description>
    </item>
    <item>
      <title>2646. 最小化旅行的价格总和 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips.zh/</link>
      <pubDate>Wed, 31 May 2023 14:05:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips.zh/</guid>
      <description>问题描述 2646. 最小化旅行的价格总和 (Hard) 现有一棵无向、无根的树，树中有 n 个节点，按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数 组 edges ，其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条边。&#xA;每个节点都关联一个价格。给你一个整数数组 price ，其中 pri ce[i] 是第 i 个节点的价格。&#xA;给定路径的 价格总和 是该路径上所有节点的价格之和。&#xA;另给你一个二维整数数组 trips ，其中 trips[i] = [startᵢ, e ndᵢ] 表示您从节点 startᵢ 开始第 i 次旅行，并通过任何你 喜欢的路径前往节点 endᵢ 。&#xA;在执行第一次旅行之前，你可以选择一些 非相邻节点 并将价格 减半。&#xA;返回执行所有旅行的最小价格总和。&#xA;示例 1：&#xA;![](https://assets.leetcode.com/uploads/2023/03/16/diagram2. png)&#xA;输入：n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6] , trips = [[0,3],[2,1],[2,3]] 输出：23 解释： 上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第 二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。 第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。 第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。 第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。 所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实 现的最小答案。 示例 2：</description>
    </item>
    <item>
      <title>297.二叉树的序列化与反序列化 (Hard)</title>
      <link>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree.zh/</link>
      <pubDate>Thu, 23 Mar 2023 10:40:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree.zh/</guid>
      <description>问题描述 297. 二叉树的序列化与反序列化 (Hard)&#xA;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。&#xA;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。&#xA;提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。&#xA;示例 1：&#xA;输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2：&#xA;输入：root = [] 输出：[] 示例 3：&#xA;输入：root = [1] 输出：[1] 示例 4：&#xA;输入：root = [1,2] 输出：[1,2] 提示：&#xA;树中结点数在范围 [0, 10⁴] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 解题思路 首先利用前序遍历的dfs，将节点的值存放到字符串中，如果遇到空节点，则str += &amp;quot;null_&amp;quot;，然后return。&#xA;反序列化时，首先将字符串转化为字符串链表，然后递归地进行反序列化，如果链表首元素为null，则为当前子树的root节点，然后先反序列化左子树，然后反序列化又子树，如果首元素为null，则直接返回。&#xA;可以注意到与前序遍历是相对应的的。&#xA;代码 class Codec { public: void rserialize(TreeNode* root, string&amp;amp; str) { if (root == nullptr) { str += &amp;#34;None,&amp;#34;; } else { str += to_string(root-&amp;gt;val) + &amp;#34;,&amp;#34;; rserialize(root-&amp;gt;left, str); rserialize(root-&amp;gt;right, str); } } string serialize(TreeNode* root) { string ret; rserialize(root, ret); return ret; } TreeNode* rdeserialize(list&amp;lt;string&amp;gt;&amp;amp; dataArray) { if (dataArray.</description>
    </item>
    <item>
      <title>654.Maximum Binary Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/654.maximum-binary-tree/</link>
      <pubDate>Sun, 19 Mar 2023 17:25:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/654.maximum-binary-tree/</guid>
      <description>Description 654. Maximum Binary Tree (Medium)&#xA;You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:&#xA;Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value.</description>
    </item>
    <item>
      <title>654.最大二叉树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/654.maximum-binary-tree.zh/</link>
      <pubDate>Sun, 19 Mar 2023 17:25:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/654.maximum-binary-tree.zh/</guid>
      <description>问题描述 654. 最大二叉树 (Medium)&#xA;给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:&#xA;创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树。&#xA;示例 1：&#xA;输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2：</description>
    </item>
    <item>
      <title>464.Can I Win (Medium)</title>
      <link>http://localhost:1313/posts/leet/464.can-i-win/</link>
      <pubDate>Thu, 02 Mar 2023 17:55:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/464.can-i-win/</guid>
      <description>Description 464. Can I Win (Medium)&#xA;In the &amp;ldquo;100 game&amp;rdquo; two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.&#xA;What if we change the game so that players cannot re-use integers?&#xA;For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &amp;gt;= 100.</description>
    </item>
    <item>
      <title>464.我能赢吗 (Medium)</title>
      <link>http://localhost:1313/posts/leet/464.can-i-win.zh/</link>
      <pubDate>Thu, 02 Mar 2023 16:56:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/464.can-i-win.zh/</guid>
      <description>问题描述 464. 我能赢吗 (Medium)&#xA;在 &amp;ldquo;100 game&amp;rdquo; 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过 100 的玩家，即为胜者。&#xA;如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？&#xA;例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &amp;gt;= 100。&#xA;给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。&#xA;示例 1：&#xA;输入：maxChoosableInteger = 10, desiredTotal = 11 输出：false 解释： 无论第一个玩家选择哪个整数，他都会失败。 第一个玩家可以选择从 1 到 10 的整数。 如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。 第二个玩家可以通过选择整数 10（那么累积和为 11 &amp;gt;= desiredTotal），从而取得胜利. 同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。 示例 2:&#xA;输入：maxChoosableInteger = 10, desiredTotal = 0 输出：true 示例 3:</description>
    </item>
    <item>
      <title>1255.maximum score words formed by letters</title>
      <link>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters/</link>
      <pubDate>Mon, 27 Feb 2023 15:53:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters/</guid>
      <description>Description 1255. Maximum Score Words Formed by Letters (Hard)&#xA;Given a list of words, list of single letters (might be repeating) and score of every character.&#xA;Return the maximum score of any valid set of words formed by using the given letters ( words[i] cannot be used two or more times).&#xA;It is not necessary to use all characters in letters and each letter can only be used once. Score of letters &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &amp;hellip; , &#39;z&#39; is given by score[0], score[1], &amp;hellip; , score[25] respectively.</description>
    </item>
    <item>
      <title>1255.得分最高的单词集合</title>
      <link>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters.zh/</link>
      <pubDate>Mon, 27 Feb 2023 15:53:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters.zh/</guid>
      <description>问题描述 1255. 得分最高的单词集合 (Hard)&#xA;你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。&#xA;请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。&#xA;单词拼写游戏的规则概述如下：&#xA;玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。 可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。 单词表 words 中每个单词只能计分（使用）一次。 根据字母得分情况表 score，字母 &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &amp;hellip; , &#39;z&#39; 对应的得分分别为 score[0], score[1], &amp;hellip;, score[25]。 本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。 示例 1：&#xA;输入：words = [&amp;#34;dog&amp;#34;,&amp;#34;cat&amp;#34;,&amp;#34;dad&amp;#34;,&amp;#34;good&amp;#34;], letters = [&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;c&amp;#34;,&amp;#34;d&amp;#34;,&amp;#34;d&amp;#34;,&amp;#34;d&amp;#34;,&amp;#34;g&amp;#34;,&amp;#34;o&amp;#34;,&amp;#34;o&amp;#34;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] 输出：23 解释： 字母得分为 a=1, c=9, d=5, g=3, o=2 使用给定的字母表 letters，我们可以拼写单词 &amp;#34;dad&amp;#34; (5+1+5)和 &amp;#34;good&amp;#34; (3+2+2+5)，得分为 23 。 而单词 &amp;#34;dad&amp;#34; 和 &amp;#34;dog&amp;#34; 只能得到 21 分。 示例 2：</description>
    </item>
    <item>
      <title>2331.evaluate boolean binary tree</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</guid>
      <description>Description 2331.evaluate-boolean-binary-tree&#xA;Solution dfs(recursion)&#xA;Code class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
    <item>
      <title>2331.计算布尔二叉树的值</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</guid>
      <description>问题描述 2331.计算布尔二叉树的值&#xA;解题思路 递归&#xA;代码 class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
  </channel>
</rss>
