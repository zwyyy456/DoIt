<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Debian on My New Hugo Site</title>
    <link>http://localhost:1313/tags/debian/</link>
    <description>Recent content in Debian on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 17 Nov 2023 16:16:27 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/debian/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Debian 开发环境配置</title>
      <link>http://localhost:1313/posts/blog/debian-dev-config.zh/</link>
      <pubDate>Fri, 17 Nov 2023 16:16:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/debian-dev-config.zh/</guid>
      <description>前言 开发 web server 等项目，由于会使用到 Linux 的一些 API，用 Mac 来开发并不方便。我的 M1 Macbook Pro，由于采用了 arm 架构，使用虚拟机比较麻烦，并且虚拟机总觉得太笨重，不算方便。此外，也是由于 arm 架构的原因，使用 Docker 不方便，Docker Desktop 据说又卡又难用。&#xA;希望能有一个方案能同时解决以上两个问题（毕竟能用 docker 就能直接在 docker 里面跑 Debian 镜像了）。&#xA;经过一番搜索，发现了一个名为 OrbStack 的工具，可以理解为 Mac 上的 WSL，至于实现原理，这里不去深究。&#xA;OrbStack 使用起来非常方便，brew install orbstack 之后，执行 orbstack create debian orb-deb 就可以创建名为 orb-deb 的虚拟机了，虚拟机和 macOS 之间的文件访问非常方便。Linux 中可以直接访问 macOS 中的文件和目录，macOS 中也一样。并且 CPU / 磁盘 / 内存都是按需使用的。&#xA;此外，可以在 Linux 虚拟机中非常方便地执行 macOS 的命令，在 macOS 中执行虚拟机 Linux 中的命令也同样如此。&#xA;后面的内容都是 Debian 开发环境的配置了，不论是 OrbStack 的 Debian 还是 WSL 又或者是物理机、VPS 都适用。</description>
    </item>
    <item>
      <title>Install debian bookworm</title>
      <link>http://localhost:1313/posts/blog/debian_testing/</link>
      <pubDate>Sat, 12 Nov 2022 09:58:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/debian_testing/</guid>
      <description></description>
    </item>
    <item>
      <title>安装 Debian bookworm</title>
      <link>http://localhost:1313/posts/blog/debian_testing.zh/</link>
      <pubDate>Sat, 12 Nov 2022 09:58:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/debian_testing.zh/</guid>
      <description>配置语言环境 我在安装debian的时候，有个地方选择了HK，因此使用locale命令查看当前的区域相关设置时，显示为: 其中:LANG为默认的区域设置，该变量的值会覆盖所有未设置的LC_*变量的值;&#xA;要修改为en_US，首先执行sudo dpkg-reconfigure locales，然后选中en_US.UTF-8，取消en_HK那个，取消inherit的那个，还可以选中zh_CN.UTF-8，这样就启用了en_US.UTF-8和zh_CN.UTF-8;&#xA;由于我的桌面环境为KDE PLasma，其语言设置会覆盖locale.conf的设置，执行vim ~/.config/plasma-localerc，修改该文件为:&#xA;[Formats] LANG=en_US.UTF-8 LC_ADDRESS=en_US.UTF-8 LC_MEASUREMENT=en_US.UTF-8 LC_MONETARY=en_US.UTF-8 LC_NAME=en_US.UTF-8 LC_NUMERIC=en_US.UTF-8 LC_TELEPHONE=en_US.UTF-8 LC_TIME=en_US.UTF-8 [Translations] LANGUAGE=en_US:C:zh_CN 其中LANGUAGE为备用语言，很多软件并未将其英文locale设置为en或en_US，而是使用默认locale C。如果在LANGUAGE中将非英文locale设置到English之后，例如LANGUAGE=en_US:en:es_ES，那么即使英语字符存在，应用程序可能会选择使用后备locale，解决方法是强制在英语locale后面设置C，例如 LANGUAGE=en_US:en:C:es_ES。&#xA;fcitx-rime 安装fcitx-rime sudo apt install fcitx-rime&#xA;安装小鹤双拼 sudo apt-get install librime-data-double-pinyin&#xA;将小鹤双拼官方网盘，3.1-挂接&amp;ndash;音形码，小鹤音形鼠须管for macos里的default.custom.yaml复制到~/.config/fcitx/rime，并修改为:&#xA;patch: menu: page_size: 8 schema_list: - schema: flypy # 添加小鹤音形 - schema: double_pinyin_flypy - schema: luna_pinyin_simp key_binder/bindings: - when: paging accept: bracketleft send: Page_Up - when: has_menu accept: bracketright send: Page_Down - when: has_menu accept: minus send: Page_Up - when: has_menu accept: equal send: Page_Down 启动fcitx，按Ctrl+Space切换为fcitx，Ctrl+`切换选择输入方案。</description>
    </item>
  </channel>
</rss>
