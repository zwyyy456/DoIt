<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Greedy Algorithm on My New Hugo Site</title>
    <link>http://localhost:1313/tags/greedy-algorithm/</link>
    <description>Recent content in Greedy Algorithm on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Oct 2023 18:28:15 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/greedy-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2136.earliest Possible Day of Full Bloom</title>
      <link>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom/</link>
      <pubDate>Thu, 05 Oct 2023 18:28:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom/</guid>
      <description>Descriptio 2136. Earliest Possible Day of Full Bloom (Hard) You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:&#xA;plantTime[i] is the number of full days it takes you to plant the iᵗʰ seed. Every day, you can work on planting exactly one seed.</description>
    </item>
    <item>
      <title>2136. 全部开花的最早一天 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom.zh/</link>
      <pubDate>Thu, 05 Oct 2023 18:28:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom.zh/</guid>
      <description>问题描述 2136. 全部开花的最早一天 (Hard)&#xA;你有 n 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你 两个下标从 0 开始的整数数组 plantTime 和 growTime ，每个数组的长度都是 n ：&#xA;plantTime[i] 是 播种 第 i 枚种子所需的 完整天数 。每天，你只能为播种某一枚种子而劳作。 无须 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 plantTime[i] 之后才算完成。 growTime[i] 是第 i 枚种子完全种下后生长所需的 完整天数。在它生长的最后一天 之后 ，将会 开花并且永远 绽放 。 从第 0 开始，你可以按 任意 顺序播种种子。&#xA;返回所有种子都开花的 最早 一天是第几天。&#xA;示例 1：&#xA;输入：plantTime = [1,4,3], growTime = [2,3,1] 输出：9 解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 一种最优方案是： 第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。 第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。 第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。 因此，在第 9 天，所有种子都开花。 示例 2：</description>
    </item>
    <item>
      <title>2712. 使所有字符相等的最小成本 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal.zh/</link>
      <pubDate>Mon, 29 May 2023 11:57:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal.zh/</guid>
      <description>问题描述 2712. 使所有字符相等的最小成本 (Medium) 给你一个下标从 0 开始、长度为 n 的二进制字符串 s ， 你可以对其执行两种操作：&#xA;选中一个下标 i 并且反转从下标 0 到下标 i（包括下标 0 和下标 i ）的所有字符，成本为 i + 1 。 选中一个下标 i 并且反转从下标 i 到下标 n - 1（包括下 标 i 和下标 n - 1 ）的所有字符，成本为 n - i 。 返回使字符串内所有字符 相等 需要的 最小成本 。&#xA;反转 字符意味着：如果原来的值是 &amp;lsquo;0&amp;rsquo; ，则反转后值变为 &amp;lsquo;1&amp;rsquo; ，反之亦然。&#xA;示例 1：&#xA;输入：s = &amp;#34;0011&amp;#34; 输出：2 解释：执行第二种操作，选中下标 i = 2 ，可以得到 s = &amp;#34;0000&amp;#34; ，成本为 2 。可以证明 2 是使所有字符相等的最小成本。 示例 2：</description>
    </item>
    <item>
      <title>2712. Minimum Cost to Make All Characters Equal (Medium)</title>
      <link>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal/</link>
      <pubDate>Mon, 29 May 2023 11:57:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal/</guid>
      <description>Description 2712. Minimum Cost to Make All Characters Equal (Medium) You are given a 0-indexed binary string s of length n on which you can apply two types of operations:&#xA;Choose an index i and invert all characters from index 0 to index i (both inclusive), with a cost of i + 1 Choose an index i and invert all characters from index i to index n - 1 (both inclusive), with a cost of n - i Return the minimum cost to make all characters of the string equal.</description>
    </item>
    <item>
      <title>2071.Maximum Number of Tasks You Can Assign (Hard)</title>
      <link>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign/</link>
      <pubDate>Wed, 22 Mar 2023 19:49:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign/</guid>
      <description>Description Maximum Number of Tasks You Can Assign (Hard) You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task&amp;rsquo;s strength requirement (i.</description>
    </item>
    <item>
      <title>2071.你可以安排的最多任务数目 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign.zh/</link>
      <pubDate>Wed, 22 Mar 2023 19:49:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign.zh/</guid>
      <description>问题描述 2071. 你可以安排的最多任务数目 (Hard)&#xA;给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] &amp;gt;= tasks[i] ）。&#xA;除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。&#xA;给你下标从 0 开始的整数数组 tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。&#xA;示例 1：&#xA;输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1 输出：3 解释： 我们可以按照如下方案安排药丸： - 给 0 号工人药丸。 - 0 号工人完成任务 2（0 + 1 &amp;gt;= 1） - 1 号工人完成任务 1（3 &amp;gt;= 2） - 2 号工人完成任务 0（3 &amp;gt;= 3） 示例 2：</description>
    </item>
    <item>
      <title>2383. Minimum Hours of Training to Win a Competition (Easy)</title>
      <link>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition/</link>
      <pubDate>Mon, 13 Mar 2023 09:34:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition/</guid>
      <description>Description Minimum Hours of Training to Win a Competition (Easy) You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively.&#xA;You are also given two 0-indexed integer arrays energy and experience, both of length n.&#xA;You will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available.</description>
    </item>
    <item>
      <title>2383.赢得比赛需要的最少训练时长 (Easy)</title>
      <link>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition.zh/</link>
      <pubDate>Mon, 13 Mar 2023 09:34:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition.zh/</guid>
      <description>问题描述 2383. 赢得比赛需要的最少训练时长 (Easy)&#xA;你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。&#xA;另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。&#xA;你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。&#xA;击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少 energy[i] 。&#xA;在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。&#xA;返回击败全部 n 个对手需要训练的 最少 小时数目。&#xA;示例 1：&#xA;输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1] 输出：8 解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。 按以下顺序与对手比赛： - 你的精力与经验都超过第 0 个对手，所以获胜。 精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。 - 你的精力与经验都超过第 1 个对手，所以获胜。 精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。 - 你的精力与经验都超过第 2 个对手，所以获胜。 精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。 - 你的精力与经验都超过第 3 个对手，所以获胜。 精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。 在比赛前进行了 8 小时训练，所以返回 8 。 可以证明不存在更小的答案。 示例 2：</description>
    </item>
    <item>
      <title>1405.longest happy string</title>
      <link>http://localhost:1313/posts/leet/1405.longest-happy-string/</link>
      <pubDate>Wed, 01 Mar 2023 19:29:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1405.longest-happy-string/</guid>
      <description>Description 1405. Longest Happy String (Medium)&#xA;A string s is called happy if it satisfies the following conditions:&#xA;s only contains the letters &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;. s does not contain any of &amp;quot;aaa&amp;quot;, &amp;quot;bbb&amp;quot;, or &amp;quot;ccc&amp;quot; as a substring. s contains at most a occurrences of the letter &#39;a&#39;. s contains at most b occurrences of the letter &#39;b&#39;. s contains at most c occurrences of the letter &#39;c&#39;. Given three integers a, b, and c, return the longest possible happy string.</description>
    </item>
    <item>
      <title>1405.最长快乐字符串</title>
      <link>http://localhost:1313/posts/leet/1405.longest-happy-string.zh/</link>
      <pubDate>Wed, 01 Mar 2023 19:29:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1405.longest-happy-string.zh/</guid>
      <description>问题描述 1405. 最长快乐字符串 (Medium)&#xA;如果字符串中不含有任何 &#39;aaa&#39;， &#39;bbb&#39; 或 &#39;ccc&#39; 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。&#xA;给你三个整数 a， b ， c，请你返回 任意一个 满足下列全部条件的字符串 s：&#xA;s 是一个尽可能长的快乐字符串。 s 中 最多 有 a 个字母 &#39;a&#39;、 b 个字母 &#39;b&#39;、 c 个字母 &#39;c&#39; 。 s 中只含有 &#39;a&#39;、 &#39;b&#39; 、 &#39;c&#39; 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串 &amp;quot;&amp;quot;。&#xA;示例 1：&#xA;输入：a = 1, b = 1, c = 7 输出：&amp;#34;ccaccbcc&amp;#34; 解释：&amp;#34;ccbccacc&amp;#34; 也是一种正确答案。 示例 2：&#xA;输入：a = 2, b = 2, c = 1 输出：&amp;#34;aabbc&amp;#34; 示例 3：</description>
    </item>
    <item>
      <title>524.longest word in dictionary through deleting</title>
      <link>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting/</link>
      <pubDate>Tue, 28 Feb 2023 16:26:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting/</guid>
      <description>Description 524. Longest Word in Dictionary through Deleting (Medium)&#xA;Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.&#xA;Example 1:&#xA;Input: s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] Output: &amp;#34;apple&amp;#34; Example 2:</description>
    </item>
    <item>
      <title>524.通过删除字母匹配到字典里最长单词</title>
      <link>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting.zh/</link>
      <pubDate>Tue, 28 Feb 2023 16:26:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting.zh/</guid>
      <description>问题描述 524. 通过删除字母匹配到字典里最长单词 (Medium)&#xA;给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。&#xA;如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。&#xA;示例 1：&#xA;输入：s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] 输出：&amp;#34;apple&amp;#34; 示例 2：&#xA;输入：s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 输出：&amp;#34;a&amp;#34; 提示：&#xA;1 &amp;lt;= s.length &amp;lt;= 1000 1 &amp;lt;= dictionary.length &amp;lt;= 1000 1 &amp;lt;= dictionary[i].length &amp;lt;= 1000 s 和 dictionary[i] 仅由小写英文字母组成 解题思路 首先将dictionary按长度从大到小排序，相同长度的字符串，字典序小的在前面；&#xA;判断dictionary中的字符串是否能通过删除s中的某些字符得到可以利用双指针优化时间复杂度为$O(n)$，n为s的长度。&#xA;代码 class Solution { public: bool IsSub(string &amp;amp;s, string &amp;amp;word) { for (int i = 0, j = 0; j &amp;lt; word.</description>
    </item>
    <item>
      <title>179.largest number</title>
      <link>http://localhost:1313/posts/leet/179.largest-number/</link>
      <pubDate>Tue, 28 Feb 2023 10:14:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/179.largest-number/</guid>
      <description>Description 179. Largest Number (Medium)&#xA;Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.&#xA;Since the result may be very large, so you need to return a string instead of an integer.&#xA;Example 1:&#xA;Input: nums = [10,2] Output: &amp;#34;210&amp;#34; Example 2:&#xA;Input: nums = [3,30,34,5,9] Output: &amp;#34;9534330&amp;#34; Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ Solution First, we change the vector&amp;lt;int&amp;gt; to vector&amp;lt;string&amp;gt;.</description>
    </item>
    <item>
      <title>179.最大数</title>
      <link>http://localhost:1313/posts/leet/179.largest-number.zh/</link>
      <pubDate>Tue, 28 Feb 2023 10:13:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/179.largest-number.zh/</guid>
      <description>问题描述 179. 最大数 (Medium)&#xA;给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。&#xA;注意： 输出结果可能非常大，所以你需要返回一个字符串而不是整数。&#xA;示例 1：&#xA;输入：nums = [10,2] 输出：&amp;#34;210&amp;#34; 示例 2：&#xA;输入：nums = [3,30,34,5,9] 输出：&amp;#34;9534330&amp;#34; 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ 解题思路 贪心，将数组转化为字符串数组，然后如果s1 + s2 &amp;gt;= s2 + s1，那么就保证s1一定在s2的前面，利用该规则自定义排序，同时要注意对数组中元素全为0的特殊条件的判断。&#xA;代码 class Solution { public: string largestNumber(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { if (nums[i] != 0) { sum += nums[i]; break; } } // 对数组元素全为0的特殊情况的判断 if (sum == 0) { return &amp;#34;0&amp;#34;; } vector&amp;lt;string&amp;gt; tmp; for (int &amp;amp;num : nums) { tmp.</description>
    </item>
    <item>
      <title>765.couples holding hands</title>
      <link>http://localhost:1313/posts/leet/765.couples-holding-hands/</link>
      <pubDate>Mon, 27 Feb 2023 16:39:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/765.couples-holding-hands/</guid>
      <description>Description 765. Couples Holding Hands (Hard)&#xA;There are n couples sitting in 2n seats arranged in a row and want to hold hands.&#xA;The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).</description>
    </item>
    <item>
      <title>765.情侣牵手</title>
      <link>http://localhost:1313/posts/leet/765.couples-holding-hands.zh/</link>
      <pubDate>Mon, 27 Feb 2023 16:39:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/765.couples-holding-hands.zh/</guid>
      <description>问题描述 765. 情侣牵手 (Hard)&#xA;n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。&#xA;人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。&#xA;返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次 交换可选择任意两人，让他们站起来交换座位。&#xA;示例 1:&#xA;输入: row = [0,2,1,3] 输出: 1 解释: 只需要交换row[1]和row[2]的位置即可。 示例 2:&#xA;输入: row = [3,2,0,1] 输出: 0 解释: 无需交换座位，所有的情侣都已经可以手牵手了。 提示:&#xA;2n == row.length 2 &amp;lt;= n &amp;lt;= 30 n 是偶数 0 &amp;lt;= row[i] &amp;lt; 2n row 中所有元素均 无重复 解题思路 我们只需要遍历i = 0, 2, 4, 6, .</description>
    </item>
    <item>
      <title>2170.minimum operations to make the array alternating</title>
      <link>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating/</link>
      <pubDate>Mon, 27 Feb 2023 15:38:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating/</guid>
      <description>Description 2170. Minimum Operations to Make the Array Alternating (Medium)&#xA;You are given a 0-indexed array nums consisting of n positive integers.&#xA;The array nums is called alternating if:&#xA;nums[i - 2] == nums[i], where 2 &amp;lt;= i &amp;lt;= n - 1. nums[i - 1] != nums[i], where 1 &amp;lt;= i &amp;lt;= n - 1. In one operation, you can choose an index i and change nums[i] into any positive integer.</description>
    </item>
    <item>
      <title>2170.使数组变成交替数组的最少操作数</title>
      <link>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating.zh/</link>
      <pubDate>Mon, 27 Feb 2023 15:38:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating.zh/</guid>
      <description>问题描述 2170. 使数组变成交替数组的最少操作数 (Medium)&#xA;给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。&#xA;如果满足下述条件，则数组 nums 是一个 交替数组 ：&#xA;nums[i - 2] == nums[i] ，其中 2 &amp;lt;= i &amp;lt;= n - 1 。 nums[i - 1] != nums[i] ，其中 1 &amp;lt;= i &amp;lt;= n - 1 。 在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。&#xA;返回使数组变成交替数组的 最少操作数 。&#xA;示例 1：&#xA;输入：nums = [3,1,3,2,4,3] 输出：3 解释： 使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。 在这种情况下，操作数为 3 。 可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。 示例 2：</description>
    </item>
    <item>
      <title>1144.decrease elements to make array zigzag</title>
      <link>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag/</link>
      <pubDate>Mon, 27 Feb 2023 15:28:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag/</guid>
      <description>Description 1144. Decrease Elements To Make Array Zigzag (Medium)&#xA;Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.&#xA;An array A is a zigzag array if either:&#xA;Every even-indexed element is greater than adjacent elements, ie. A[0] &amp;gt; A[1] &amp;lt; A[2] &amp;gt; A[3] &amp;lt; A[4] &amp;gt; ... OR, every odd-indexed element is greater than adjacent elements, ie. A[0] &amp;lt; A[1] &amp;gt; A[2] &amp;lt; A[3] &amp;gt; A[4] &amp;lt; .</description>
    </item>
    <item>
      <title>1144.递减元素使数组呈锯齿状</title>
      <link>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag.zh/</link>
      <pubDate>Mon, 27 Feb 2023 15:28:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag.zh/</guid>
      <description>问题描述 1144. 递减元素使数组呈锯齿状 (Medium)&#xA;给你一个整数数组 nums，每次 操作 会从中选择一个元素并 将该元素的值减少 1。&#xA;如果符合下列情况之一，则数组 A 就是 锯齿数组：&#xA;每个偶数索引对应的元素都大于相邻的元素，即 A[0] &amp;gt; A[1] &amp;lt; A[2] &amp;gt; A[3] &amp;lt; A[4] &amp;gt; ... 或者，每个奇数索引对应的元素都大于相邻的元素，即 A[0] &amp;lt; A[1] &amp;gt; A[2] &amp;lt; A[3] &amp;gt; A[4] &amp;lt; ... 返回将数组 nums 转换为锯齿数组所需的最小操作次数。&#xA;示例 1：&#xA;输入：nums = [1,2,3] 输出：2 解释：我们可以把 2 递减到 0，或把 3 递减到 1。 示例 2：&#xA;输入：nums = [9,6,1,6,2] 输出：4 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 1000 1 &amp;lt;= nums[i] &amp;lt;= 1000 解题思路 首先要注意本题只允许递减数字，只需要考虑分别考虑偶数索引满足情况和奇数索引满足情况的情况，模拟即可。</description>
    </item>
    <item>
      <title>881.boats to save people</title>
      <link>http://localhost:1313/posts/leet/881.boats-to-save-people/</link>
      <pubDate>Sat, 25 Feb 2023 10:24:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/881.boats-to-save-people/</guid>
      <description>Description 881. Boats to Save People (Medium)&#xA;You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.&#xA;Return the minimum number of boats to carry every given person.</description>
    </item>
    <item>
      <title>881.救生艇</title>
      <link>http://localhost:1313/posts/leet/881.boats-to-save-people.zh/</link>
      <pubDate>Sat, 25 Feb 2023 10:23:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/881.boats-to-save-people.zh/</guid>
      <description>问题描述 881. 救生艇 (Medium)&#xA;给定数组 people 。 people[i] 表示第 i 个人的体重 ， 船的数量不限，每艘船可以承载的最大重量为 limit。&#xA;每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。&#xA;返回 承载所有人所需的最小船数 。&#xA;示例 1：&#xA;输入：people = [1,2], limit = 3 输出：1 解释：1 艘船载 (1, 2) 示例 2：&#xA;输入：people = [3,2,2,1], limit = 3 输出：3 解释：3 艘船分别载 (1, 2), (2) 和 (3) 示例 3：&#xA;输入：people = [3,5,3,4], limit = 5 输出：4 解释：4 艘船分别载 (3), (3), (4), (5) 提示：&#xA;1 &amp;lt;= people.length &amp;lt;= 5 * 10⁴ 1 &amp;lt;= people[i] &amp;lt;= limit &amp;lt;= 3 * 10⁴ 解题思路 每次必定选择最轻的的和二者重量和不超过limit的最重的人上船，因此可以将数组排序，然后一左一右双指针向中间遍历。</description>
    </item>
    <item>
      <title>1247.minimum swaps to make strings.equal</title>
      <link>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal/</link>
      <pubDate>Sat, 25 Feb 2023 10:11:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal/</guid>
      <description>Description 1247. Minimum Swaps to Make Strings Equal (Medium)&#xA;You are given two strings s1 and s2 of equal length consisting of letters &amp;quot;x&amp;quot; and &amp;quot;y&amp;quot; only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].&#xA;Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.</description>
    </item>
    <item>
      <title>1247.交换字符使得字符串相同</title>
      <link>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal.zh/</link>
      <pubDate>Sat, 25 Feb 2023 10:01:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal.zh/</guid>
      <description>问题描述 1247. 交换字符使得字符串相同 (Medium)&#xA;有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 &amp;quot;x&amp;quot; 和 &amp;quot;y&amp;quot;，你需要通过「交换字符」的方式使这两个字符串相同。&#xA;每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。&#xA;交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。&#xA;最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。&#xA;示例 1：&#xA;输入：s1 = &amp;#34;xx&amp;#34;, s2 = &amp;#34;yy&amp;#34; 输出：1 解释： 交换 s1[0] 和 s2[1]，得到 s1 = &amp;#34;yx&amp;#34;，s2 = &amp;#34;yx&amp;#34;。 示例 2：&#xA;输入：s1 = &amp;#34;xy&amp;#34;, s2 = &amp;#34;yx&amp;#34; 输出：2 解释： 交换 s1[0] 和 s2[0]，得到 s1 = &amp;#34;yy&amp;#34;，s2 = &amp;#34;xx&amp;#34; 。 交换 s1[0] 和 s2[1]，得到 s1 = &amp;#34;xy&amp;#34;，s2 = &amp;#34;xy&amp;#34; 。 注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 &amp;#34;yx&amp;#34;，因为我们只能交换属于两个不同字符串的字符。 示例 3：</description>
    </item>
    <item>
      <title>2357.make array zero by subtracting equal amounts</title>
      <link>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts/</link>
      <pubDate>Fri, 24 Feb 2023 09:18:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts/</guid>
      <description>Description 2357. Make Array Zero by Subtracting Equal Amounts (Easy)&#xA;You are given a non-negative integer array nums. In one operation, you must:&#xA;Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums. Subtract x from every positive element in nums. Return the minimum number of operations to make every element in nums equal to 0.&#xA;Example 1:&#xA;Input: nums = [1,5,0,3,5] Output: 3 Explanation: In the first operation, choose x = 1.</description>
    </item>
    <item>
      <title>2357.使数组中所有元素都等于零</title>
      <link>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts.zh/</link>
      <pubDate>Fri, 24 Feb 2023 09:17:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts.zh/</guid>
      <description>问题描述 2357. 使数组中所有元素都等于零 (Easy)&#xA;给你一个非负整数数组 nums 。在一步操作中，你必须：&#xA;选出一个正整数 x ， x 需要小于或等于 nums 中 最小 的 非零 元素。 nums 中的每个正整数都减去 x。 返回使 nums 中所有元素都等于 0 需要的 最少 操作数。&#xA;示例 1：&#xA;输入：nums = [1,5,0,3,5] 输出：3 解释： 第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。 第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。 第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。 示例 2：&#xA;输入：nums = [0] 输出：0 解释：nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。 提示：</description>
    </item>
    <item>
      <title>397.integer replacement</title>
      <link>http://localhost:1313/posts/leet/397.integer-replacement/</link>
      <pubDate>Thu, 23 Feb 2023 16:08:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/397.integer-replacement/</guid>
      <description>Description 397. Integer Replacement (Medium)&#xA;Given a positive integer n, you can apply one of the following operations:&#xA;If n is even, replace n with n / 2. If n is odd, replace n with either n + 1 or n - 1. Return the minimum number of operations needed for nto become 1.&#xA;Example 1:&#xA;Input: n = 8 Output: 3 Explanation: 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 Example 2:</description>
    </item>
    <item>
      <title>397.整数替换</title>
      <link>http://localhost:1313/posts/leet/397.integer-replacement.zh/</link>
      <pubDate>Thu, 23 Feb 2023 16:08:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/397.integer-replacement.zh/</guid>
      <description>问题描述 397. 整数替换 (Medium)&#xA;给定一个正整数 n ，你可以做如下操作：&#xA;如果 n 是偶数，则用 n / 2 替换 n。 如果 n 是奇数，则可以用 n + 1 或 n - 1 替换 n 。 返回 n 变为 1 所需的 最小替换次数 。&#xA;示例 1：&#xA;输入：n = 8 输出：3 解释：8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 示例 2：&#xA;输入：n = 7 输出：4 解释：7 -&amp;gt; 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 或 7 -&amp;gt; 6 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1 示例 3：</description>
    </item>
    <item>
      <title>1326.minimum number of taps to open to water a garden</title>
      <link>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden/</link>
      <pubDate>Tue, 21 Feb 2023 15:35:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden/</guid>
      <description>Description 1326. Minimum Number of Taps to Open to Water a Garden (Hard)&#xA;There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).&#xA;There are n + 1 taps located at points [0, 1, ..., n] in the garden.&#xA;Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.</description>
    </item>
    <item>
      <title>1326.浇灌花园的最少水龙头数目</title>
      <link>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/</link>
      <pubDate>Tue, 21 Feb 2023 15:35:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/</guid>
      <description>问题描述 1326. 灌溉花园的最少水龙头数目 (Hard)&#xA;在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。&#xA;花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。&#xA;给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i - ranges[i], i + ranges[i]] 。&#xA;请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。&#xA;示例 1：&#xA;输入：n = 5, ranges = [3,4,1,1,0,0] 输出：1 解释： 点 0 处的水龙头可以灌溉区间 [-3,3] 点 1 处的水龙头可以灌溉区间 [-3,5] 点 2 处的水龙头可以灌溉区间 [1,3] 点 3 处的水龙头可以灌溉区间 [2,4] 点 4 处的水龙头可以灌溉区间 [4,4] 点 5 处的水龙头可以灌溉区间 [5,5] 只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。 示例 2：</description>
    </item>
    <item>
      <title>1792.maximum average pass ratio</title>
      <link>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio/</link>
      <pubDate>Mon, 20 Feb 2023 14:14:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio/</guid>
      <description>Description 1792. Maximum Average Pass Ratio (Medium)&#xA;There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passᵢ, totalᵢ]. You know beforehand that in the ith class, there are totalᵢ total students, but only passᵢ number of students will pass the exam.&#xA;You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to.</description>
    </item>
    <item>
      <title>1792.最大平均通过率</title>
      <link>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio.zh/</link>
      <pubDate>Mon, 20 Feb 2023 14:14:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio.zh/</guid>
      <description>问题描述 1792. 最大平均通过率 (Medium)&#xA;一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passᵢ, totalᵢ] ，表示你提前知道了第 i 个班级总共有 totalᵢ 个学生，其中只有 passᵢ 个学生可以通过考试。&#xA;给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。&#xA;一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。 平均通过率 是所有班级的通过率之和除以班级数目。&#xA;请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-⁵ 以内的结果都会视为正确结果。&#xA;示例 1：&#xA;输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2 输出：0.78333 解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。 示例 2：&#xA;输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4 输出：0.</description>
    </item>
    <item>
      <title>1833.maximum Ice Cream Bars</title>
      <link>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars/</link>
      <pubDate>Mon, 20 Feb 2023 10:14:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars/</guid>
      <description>Description 1833. Maximum Ice Cream Bars (Medium)&#xA;It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.</description>
    </item>
    <item>
      <title>1833.雪糕的最大数量</title>
      <link>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars.zh/</link>
      <pubDate>Mon, 20 Feb 2023 10:14:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars.zh/</guid>
      <description>问题描述 1833. 雪糕的最大数量 (Medium)&#xA;夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。&#xA;商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。&#xA;注意： Tony 可以按任意顺序购买雪糕。&#xA;给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。&#xA;示例 1：&#xA;输入：costs = [1,3,2,4,1], coins = 7 输出：4 解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7 示例 2：&#xA;输入：costs = [10,6,8,7,7,8], coins = 5 输出：0 解释：Tony 没有足够的钱买任何一支雪糕。 示例 3：</description>
    </item>
    <item>
      <title>781.rabbits in forest</title>
      <link>http://localhost:1313/posts/leet/781.rabbits-in-forest/</link>
      <pubDate>Sat, 18 Feb 2023 18:14:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/781.rabbits-in-forest/</guid>
      <description>Solution 781. Rabbits in Forest (Medium)&#xA;There is a forest with an unknown number of rabbits. We asked n rabbits &amp;ldquo;How many rabbits have the same color as you?&amp;rdquo; and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit. Given the array answers, return the minimum number of rabbits that could be in the forest. Example 1:&#xA;Input: answers = [1,1,2] Output: 5 Explanation: The two rabbits that answered &amp;#34;1&amp;#34; could both be the same color, say red.</description>
    </item>
    <item>
      <title>781.森林中的兔子</title>
      <link>http://localhost:1313/posts/leet/781.rabbits-in-forest.zh/</link>
      <pubDate>Sat, 18 Feb 2023 18:14:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/781.rabbits-in-forest.zh/</guid>
      <description>问题描述 781. 森林中的兔子 (Medium)&#xA;森林中有未知数量的兔子。提问其中若干只兔子 &amp;ldquo;还有多少只兔子与你（指被提问的兔子）颜色相同?&amp;rdquo; ，将答案收集到一个整数数组 answers 中，其中 answers[i] 是第 i 只兔子的回答。 给你数组 answers ，返回森林中兔子的最少数量。 示例 1：&#xA;输入：answers = [1,1,2] 输出：5 解释： 两只回答了 &amp;#34;1&amp;#34; 的兔子可能有相同的颜色，设为红色。 之后回答了 &amp;#34;2&amp;#34; 的兔子不会是红色，否则他们的回答会相互矛盾。 设回答了 &amp;#34;2&amp;#34; 的兔子为蓝色。 此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。 因此森林中兔子的最少数量是 5 只：3 只回答的和 2 只没有回答的。 示例 2：&#xA;输入：answers = [10,10,10] 输出：11 提示：&#xA;1 &amp;lt;= answers.length &amp;lt;= 1000 0 &amp;lt;= answers[i] &amp;lt; 1000 解题思路 从题目中给出的例子我们可以发现，要想让兔子数量最小，那么要尽量让回答结果相同的兔子是同一个颜色的；&#xA;我们用一个哈希表unordered_map&amp;lt;int, int&amp;gt; ump来记录每种结果有多少只兔子回答了，key为回答结果，value是回答该结果的兔子的数量；&#xA;如果ump[i] &amp;gt; i + 1，说明这批兔子至少有不止一种颜色，颜色数为(ump[i] - 1) / (i + 1) + 1，每种颜色有i + 1个兔子。</description>
    </item>
    <item>
      <title>646.maximum length of pair chain</title>
      <link>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain/</link>
      <pubDate>Sat, 18 Feb 2023 15:00:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain/</guid>
      <description>Description 646. Maximum Length of Pair Chain (Medium)&#xA;You are given an array of n pairs pairs where pairs[i] = [leftᵢ, rightᵢ] and leftᵢ &amp;lt; rightᵢ. A pair p2 = [c, d] follows a pair p1 = [a, b] if b &amp;lt; c. A chain of pairs can be formed in this fashion. Return the length longest chain which can be formed. You do not need to use up all the given intervals.</description>
    </item>
    <item>
      <title>646.最长数对链</title>
      <link>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain.zh/</link>
      <pubDate>Sat, 18 Feb 2023 15:00:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain.zh/</guid>
      <description>问题描述 646. 最长数对链 (Medium)&#xA;给你一个由 n 个数对组成的数对数组 pairs ，其中 pairs[i] = [leftᵢ, rightᵢ] 且 leftᵢ &amp;lt; rightᵢ 现在，我们定义一种 跟随 关系，当且仅当 b &amp;lt; c 时，数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面。我们用这种形式来构造 数对链 。 找出并返回能够形成的 最长数对链的长度 。 你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例 1：&#xA;输入：pairs = [[1,2], [2,3], [3,4]] 输出：2 解释：最长的数对链是 [1,2] -&amp;gt; [3,4] 。 示例 2：&#xA;输入：pairs = [[1,2],[7,8],[4,5]] 输出：3 解释：最长的数对链是 [1,2] -&amp;gt; [4,5] -&amp;gt; [7,8] 。 提示：&#xA;n == pairs.length 1 &amp;lt;= n &amp;lt;= 1000 -1000 &amp;lt;= leftᵢ &amp;lt; rightᵢ &amp;lt;= 1000 解题思路 贪心 在选择第一个数对时，必定选择使pairs[i][1]最小的那个i，第二个数对则必定选择pairs[j][0] &amp;gt; pairs[i][1]且使pairs[j][0]最小的j，因此类推，因此我们将pairs按照其第二个元素升序排列。</description>
    </item>
    <item>
      <title>456.132 pattern</title>
      <link>http://localhost:1313/posts/leet/456.132-pattern/</link>
      <pubDate>Fri, 17 Feb 2023 14:46:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/456.132-pattern/</guid>
      <description>Description 456. 132 Pattern (Medium)&#xA;Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false. Example 1:&#xA;Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Example 2:</description>
    </item>
    <item>
      <title>456.132模式</title>
      <link>http://localhost:1313/posts/leet/456.132-pattern.zh/</link>
      <pubDate>Fri, 17 Feb 2023 14:46:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/456.132-pattern.zh/</guid>
      <description>问题描述 456. 132 模式 (Medium)&#xA;给你一个整数数组 nums ，数组中共有 n 个整数。 132 模式的子序列 由三个整数 nums[i]、 nums[j] 和 nums[k] 组成，并同时满足： i &amp;lt; j &amp;lt; k 和 nums[i] &amp;lt; nums[k] &amp;lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 示例 1：&#xA;输入：nums = [1,2,3,4] 输出：false 解释：序列中不存在 132 模式的子序列。 示例 2：&#xA;输入：nums = [3,1,4,2] 输出：true 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3：&#xA;输入：nums = [-1,3,2,0] 输出：true 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示：</description>
    </item>
    <item>
      <title>334.increasing triplet subsequence</title>
      <link>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence/</link>
      <pubDate>Fri, 17 Feb 2023 14:07:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence/</guid>
      <description>Description 334. Increasing Triplet Subsequence (Medium)&#xA;Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[j] &amp;lt; nums[k]. If no such indices exists, return false. Example 1:&#xA;Input: nums = [1,2,3,4,5] Output: true Explanation: Any triplet where i &amp;lt; j &amp;lt; k is valid. Example 2:&#xA;Input: nums = [5,4,3,2,1] Output: false Explanation: No triplet exists.</description>
    </item>
    <item>
      <title>334.递增的三元子序列</title>
      <link>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence.zh/</link>
      <pubDate>Fri, 17 Feb 2023 14:07:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence.zh/</guid>
      <description>问题描述 334. 递增的三元子序列 (Medium)&#xA;给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标 (i, j, k) 且满足 i &amp;lt; j &amp;lt; k ，使得 nums[i] &amp;lt; nums[j] &amp;lt; nums[k] ，返回 true ；否则，返回 false 。 示例 1：&#xA;输入：nums = [1,2,3,4,5] 输出：true 解释：任何 i &amp;lt; j &amp;lt; k 的三元组都满足题意 示例 2：&#xA;输入：nums = [5,4,3,2,1] 输出：false 解释：不存在满足题意的三元组 示例 3：&#xA;输入：nums = [2,1,5,0,4,6] 输出：true 解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &amp;lt; nums[4] == 4 &amp;lt; nums[5] == 6 提示：</description>
    </item>
    <item>
      <title>2335.minimum amount of time to fill cups</title>
      <link>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups/</link>
      <pubDate>Wed, 15 Feb 2023 16:51:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups/</guid>
      <description>Description [2335. Minimum Amount of Time to Fill Cups (Easy)]&#xA;You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water. You are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively.</description>
    </item>
    <item>
      <title>2335.装满杯子所需要的最短时长</title>
      <link>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups.zh/</link>
      <pubDate>Wed, 15 Feb 2023 16:51:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups.zh/</guid>
      <description>问题描述 2335. 装满杯子需要的最短总时长 (Easy)&#xA;现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。 给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、 amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。 示例 1：&#xA;输入：amount = [1,4,2] 输出：4 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯温水。 第 2 秒：装满一杯温水和一杯热水。 第 3 秒：装满一杯温水和一杯热水。 第 4 秒：装满一杯温水。 可以证明最少需要 4 秒才能装满所有杯子。 示例 2：&#xA;输入：amount = [5,4,4] 输出：7 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯热水。 第 2 秒：装满一杯冷水和一杯温水。 第 3 秒：装满一杯冷水和一杯温水。 第 4 秒：装满一杯温水和一杯热水。 第 5 秒：装满一杯冷水和一杯热水。 第 6 秒：装满一杯冷水和一杯温水。 第 7 秒：装满一杯热水。 示例 3：</description>
    </item>
    <item>
      <title>1705.maximum number of eaten apples</title>
      <link>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples/</link>
      <pubDate>Wed, 15 Feb 2023 15:59:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples/</guid>
      <description>Description 1705.maximum-number-of-eaten-apples&#xA;Solution The optimal strategy is to eat the apple that rots first, we can use the priority queue to simulate the process.&#xA;app_decay[i][0] indicates the expected decay time of the apples born on day i, and app_decay[i][1] indicates how many apples were born on day i.&#xA;The top() of the priority queue pq must be a vector with the minimum vec[0].&#xA;We traverse the array by time, if there are apples born on this day, we push app_decay[i] to pq, and pop the elements of the top() of pq until the heap is empty or pq.</description>
    </item>
    <item>
      <title>1705.吃苹果的最大数目</title>
      <link>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples.zh/</link>
      <pubDate>Wed, 15 Feb 2023 15:59:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples.zh/</guid>
      <description>问题描述 1705.吃苹果的最大数目 中等&#xA;There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0.</description>
    </item>
    <item>
      <title>871.minimum number of refueling stops</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</guid>
      <description>Description 871.minimum-number-of-refueling-stops&#xA;Solution Dynamic programming In this problem, the number is finite, and there is a recurrence relation, so we can use dynamic programming to solve this problem.&#xA;Let dp[i][j] means the furthest distance we can reach after passing throught i stations and adding fuel for j times. Obviously, i &amp;gt;= j.&#xA;So we can discuss dp[i][j] in two cases:&#xA;We don&amp;rsquo;t add fuel at the ith station: dp[i][j] = dp[i - 1][j] We add fuel in the ith station(We have to arrive at the ith station in the case we have just added fuel for j - 1 times before, that is: dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]): dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1].</description>
    </item>
    <item>
      <title>871.最低加油次数</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</guid>
      <description>问题描述 871.最低加油次数&#xA;解题思路 动态规划 对于这种有限次数，能看出来有递推关系的，可以考虑动态规划。&#xA;这里状态记为dp[i][j]，表示经过前i个加油站，加j次油之后，能够到达的最远距离，这里显然有i &amp;gt;= j。&#xA;那么考虑dp[i][j]的递推关系，可以分在第i个加油站加油和不加油两种情况来讨论：&#xA;在第i个加油站不加油：dp[i][j] = dp[i - 1][j] 在第i个加油站加油（要求第i个加油站可以在之前只加了j - 1次油的情况下到达），即dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]，此时dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1] dp[i][j]取两者中的最大值&#xA;贪心 首先，很容易想到，最佳策略每次加油，都是在油最多的加油站去加油，这里实际上可以认为能直接从经过的加油站中取油，即每次发现到达不了下一个加油站或者终点了，就从已经经过但是没加过油的加油站里加油，直到可以到达下一个加油站或者终点，可以利用优先队列来模拟这个过程，每次需要更新剩余的燃油cur_fuel。&#xA;代码 动态规划 class Solution { public: int minRefuelStops(int target, int startFuel, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;stations) { int n = stations.size(); if (n == 0) { if (startFuel &amp;gt;= target) return 0; return -1; } vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; dp(n + 1, vector&amp;lt;long long&amp;gt;(n + 1, 0)); dp[0][0] = startFuel; for (int i = 1; i &amp;lt;= n; i++) { dp[i][0] = stations[i - 1][0] &amp;lt;= startFuel ?</description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo/</guid>
      <description>Description 502.IPO&#xA;Solution Greedy algorithm: if we want to maximize the final capital, we choose the project whose profit is maximum and whose minimum captial required is less than or equal to our current capital.&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;Let key be the profits, value be a map, of which key is the minimum capital required while value is the amount of the corresponding project.&#xA;Code class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.</description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo.zh/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo.zh/</guid>
      <description>问题描述 502.IPO&#xA;解题思路 贪心：要最大化最终资本，因此必然选择满足当前资本需要的纯利润最大的项目。&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;key为纯利润，value也是map，该map的key为启动所需最小资本、value为项目数量。&#xA;代码 class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.size(); i++) { projs[profits[i]][capital[i]]++; } for (int i = 0; i &amp;lt; k; i++) { int find_flag = 0; for (auto &amp;amp;prj : projs) { if (w &amp;gt;= ((prj.second).begin())-&amp;gt;first) { w += prj.first; prj.</description>
    </item>
    <item>
      <title>575.分糖果</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies.zh/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies.zh/</guid>
      <description>问题描述 575.分糖果&#xA;解题思路 最优思路为一种糖果只吃一颗。&#xA;代码 class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>575.distribute candies</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies/</guid>
      <description>Description 575.distribute-candies&#xA;Solution The optimal way is to eat only one candy for each kind of candy.&#xA;Code class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>553.optimal division</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division/</guid>
      <description>Description 553.optimal division&#xA;Solution Greedy algorithm&#xA;The optimal method is actually to bracket the penultimate elements.&#xA;Code class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.</description>
    </item>
    <item>
      <title>553.最优除法</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division.zh/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division.zh/</guid>
      <description>问题描述 553.最优除法&#xA;解题思路 贪心，最优的除法实际上就是把第二个到最后一个元素括起来。&#xA;代码 class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.pop_back(); res.push_back(&amp;#39;)&amp;#39;); return res; } }; </description>
    </item>
    <item>
      <title>1710.maximum units on a truck</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</guid>
      <description>Description 1710.maximum-units-on-a-truck&#xA;Solution Sort boxTypes by the units that the box can load, then put the box of which the units are maximum on the truck one by one.&#xA;The time complexity can be decreased to $O(n)$ by using quick select.&#xA;Code class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.</description>
    </item>
    <item>
      <title>1710.卡车上的最大单元数</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</guid>
      <description>问题描述 1710.卡车上的最大单元数&#xA;解题思路 根据每个箱子可以装载的单元数量从大到小对boxTypes排序，然后每次将单元数量最大的箱子填入卡车。&#xA;使用快速选择算法可以将时间复杂度降低到$O(n)$。&#xA;代码 class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.size(); i++) { if (cnt + boxTypes[i][0] &amp;lt;= truckSize) { sum += boxTypes[i][0] * boxTypes[i][1]; cnt += boxTypes[i][0]; } else { sum += (truckSize - cnt) * boxTypes[i][1]; break; } } return sum; } }; </description>
    </item>
    <item>
      <title>1736.latest time by replacing hidden digits</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</guid>
      <description>Description 1736.latest-time-by-replacing-hidden-digits&#xA;Solution Analog + greedy algorithm&#xA;Code class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.</description>
    </item>
    <item>
      <title>1736.替换隐藏数字得到的最晚时间</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</guid>
      <description>问题描述 1736.替换隐藏数字得到的最晚时间&#xA;解题思路 模拟+贪心&#xA;代码 class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.push_back(time[0]); res.</description>
    </item>
    <item>
      <title>1798.maximum number of consecutive values you can make</title>
      <link>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make/</link>
      <pubDate>Sat, 04 Feb 2023 18:26:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make/</guid>
      <description>Description 1798.maximum-number-of-consecutive-values-you-can-make&#xA;Solution Greedy algorithm + dynamic programming&#xA;First, we sort the array in ascending orders. Let res[n] be the maximum value of consecutive integer that we can make by using the first n numbers.&#xA;if (coins[i - 1] &amp;gt; res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; Code class Solution { public: int getMaximumConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; coins) { std::sort(coins.begin(), coins.</description>
    </item>
    <item>
      <title>1798.你能构造出连续值的最大数目</title>
      <link>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make.zh/</link>
      <pubDate>Sat, 04 Feb 2023 18:26:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make.zh/</guid>
      <description>问题描述 1798.你能构造出连续值的最大数目&#xA;解题思路 贪心+动态规划&#xA;首先将数组按升序排序，令res[n]为前n个数所能构造出的连续整数的最大值:&#xA;if (coins[i - 1] &amp;gt; res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; 代码 class Solution { public: int getMaximumConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; coins) { std::sort(coins.begin(), coins.end()); vector&amp;lt;int&amp;gt; res(coins.size() + 1, 0); // 表示前n个数能表示出来的最大值 for (int i = 1; i &amp;lt;= coins.size(); i++) { if (coins[i - 1] &amp;gt; res[i - 1] + 1) res[i] = res[i - 1]; else res[i] = res[i - 1] + coins[i - 1]; } return res[coins.</description>
    </item>
    <item>
      <title>768.max chunks to make sorted ii</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</guid>
      <description>Description 768.max-chunks-to-make-sorted-ii&#xA;Solution A sufficient condition for an array to be divisible into blocks that satisfy the condition is that all elements in the block are less than or equal to any of the undivided elements in the right-hand array.&#xA;Code class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.</description>
    </item>
    <item>
      <title>768.最多能完成排序的块 II</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</guid>
      <description>问题描述 768.最多能完成排序的块II&#xA;解题思路 可以划分成满足条件的块的充分必要条件是，块内所有元素都小于等于右侧数组中未划分的任一元素。&#xA;本题中使用了map来进行处理，实际上使用单调栈就可以了。&#xA;代码 class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.size(); i++) r_map[arr[i]]++; while (idx &amp;lt; arr.size()) { for (int i = idx; i &amp;lt; arr.size(); i++) { l_map[arr[i]]++; r_map[arr[i]]--; if (r_map[arr[i]] == 0) r_map.erase(arr[i]); if (r_map.empty()) break; if (l_map.begin()-&amp;gt;first &amp;lt;= r_map.begin()-&amp;gt;first) { idx = i + 1; ans++; break; } } if (r_map.</description>
    </item>
    <item>
      <title>1145.binary tree coloring game</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</guid>
      <description>Description 1145.binary-tree-coloring-game&#xA;Solution Greedy algorithm: for second player, if he wants to win, there are three ways to color the node.&#xA;color the parent node of x, then we use dfs to get the number of red nodes, the number of blue nodes is $n$ minus the nubmer of red nodes; color the left child node of x, then we use dfs to get the number of blue nodes, the number of red nodes is $n$ minus the number of blue nodes; color the right child node of x Code class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root !</description>
    </item>
    <item>
      <title>1145.二叉树着色游戏</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</guid>
      <description>问题描述 1145.二叉树着色游戏&#xA;解题思路 贪心策略：对二号玩家来说，想要取胜，选择染色节点只有三种可能：&#xA;选择x的父节点，则通过深度优先搜索可以求得红色节点数，蓝色节点数为$n$减去红色节点数 选择x的左子节点，则通过dfs可以求得蓝色节点数，红色节点数为$n$减去蓝色节点数 选择x的右子节点 代码 class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root != nullptr) return get_num(root-&amp;gt;left) + get_num(root-&amp;gt;right) + 1; else return 0; } TreeNode *get_pos(int x, int n, TreeNode *root) { // 获取当前x对应的指针 if (root == nullptr) return nullptr; else { if (root-&amp;gt;val == x) return root; else { TreeNode *l = get_pos(x, n, root-&amp;gt;left); TreeNode *r = get_pos(x, n, root-&amp;gt;right); if (l !</description>
    </item>
    <item>
      <title>1877.minimize maximum pair sum in array</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</guid>
      <description>Description 1877.minimize-maximum-pair-sum-in-array&#xA;Solution Sort the array from smallest to largest, the smallest and largest pair, the next smallest and next largest pair, in that order. The result we need the maximum value of the sum of those pairs.&#xA;Code class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1877.数组中最大数对和的最小值</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</guid>
      <description>问题描述 1877.数组中最大数对和的最小值&#xA;解题思路 贪心&#xA;将数组从小到大排序，最小最大配对，次小次大配对，依次配对，结果就是这些配对和的最大值。&#xA;代码 class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1846.maximum element after decreasing and rearranging</title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</guid>
      <description>Description 1846.maximum-element-after-decreasing-and-rearranging&#xA;Solution Since we can reorder the element in the array as many times as we like, so we should sort the array first. If we want to find the possible maximum number of array whose the first element must be 1 and the absolute difference of any 2 adjacent differences must be less or equal to 1， so we can get arr[i] = min(i + 1, arr[i - 1] + 1).</description>
    </item>
    <item>
      <title>1846.减小和重新排列数组后的最大元素</title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</guid>
      <description>问题描述 1846.减小和重新排列数组后的最大元素&#xA;解题思路 由于题目允许我们重新排列数组中的元素任意次，因此首先将数组排序，根据arr中第一个元素必须为1，以及相邻两元素的差的绝对值小于等于1，可得arr[i] = min(i + 1, arr[i - 1] + 1)（因为我们要找arr可能的最大值），又因为不允许增大arr中的元素，所以arr[i] = min(arr[i], i + 1, arr[i - 1] + 1)。&#xA;代码 class Solution { public: int maximumElementAfterDecrementingAndRearranging(vector&amp;lt;int&amp;gt;&amp;amp; arr) { sort(arr.begin(), arr.end()); arr[0] = 1; for (int i = 1; i &amp;lt; arr.size(); i++) { arr[i] = min(arr[i - 1] + 1, min(arr[i], i + 1)); } return arr[arr.size() - 1]; } }; </description>
    </item>
    <item>
      <title>93.restore ip addresses</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses/</guid>
      <description>Description 93.restore-ip-addresses&#xA;Solution Backtracking is actually changing a problem to one like a tree, and doing DFS(depth first search).&#xA;Code class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.</description>
    </item>
    <item>
      <title>93.复原ip地址</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</guid>
      <description>问题描述 93.复原ip地址&#xA;解题思路 回溯实际上就是转化为树形问题，做深度优先遍历。&#xA;代码 class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.size()) { if (cnt == 4) { ip.</description>
    </item>
    <item>
      <title>1775.equal sum arrays with minimum number of operations</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</guid>
      <description>Description 1775.equal-sum-arrays-with-minmum-number-of-operations&#xA;Solution hash table + greedy algorithm The general idea of this problem is hash + greedy algorithm.&#xA;Assuming that the sum1 minus sum2 to be diff and diff &amp;gt; 0, to reduce the difference of the sum of two arrays, we should make diff be value minus the maximum value of changing a number in one of the two array, and make the count of number changed minus 1, until diff &amp;lt; 0.</description>
    </item>
    <item>
      <title>1775.通过最少操作次数使数组的和相等</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</guid>
      <description>问题描述 1775.通过最少操作次数使数组的和相等&#xA;解题思路 哈希+贪心 本题总体思路为哈希+贪心，用两个数组mp1，mp2记录nums1，nums2中每个数各出现了多少次;&#xA;假设nums1的和sum1减去nums2的和sum2的结果为diff，这里假设diff &amp;gt; 0，为了抹平两个数组的和的差距，应该每次减去两个数组中，变化数字引起的数值变化的最大值，并且将变化的数字的计数值减一;&#xA;nums1的和小于nums2的和的情况类似。&#xA;优化 首先假设sum1 &amp;lt; sum2，否则我们交换nums1和nums2并交换sum1和sum2即可，接下来，必定是nums1缩小，nums2增大，对应diff = sum2 - sum1缩小，diff可以减少1,2,3,4,5各若干次，取决于nums1和nums2中原先各个数的数量，用一个哈希表来记录，最后我们从大到小遍历i = 5, 4, 3, 2, 1.&#xA;代码 hash + greedy algorithm class Solution { public: int find_min(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = 1; i &amp;lt; v.size(); i++) { if (v[i] != 0) return i; } return 6; } int find_max(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = v.size() - 1; i &amp;gt;= 1; i--) { if (v[i] !</description>
    </item>
    <item>
      <title>738.monotone increasing digits</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</guid>
      <description>Description 738.monotone-increasing-digits&#xA;Solution First, we need change the number to a vector&amp;lt;int&amp;gt; dec, for example:1234 to {1, 2, 3, 4}. Then we can traverse the vector, until dec[i] &amp;gt; dec[i + 1], then set dec[i + n] = 9(n &amp;gt;= 1). If dec[i] == dec[i - 1] == ... == dec[j], then dec[j]--, set others as 9, else dec[i]--;&#xA;Code class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n !</description>
    </item>
    <item>
      <title>738.单调递增的数字</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</guid>
      <description>问题描述 738.单调递增的数字&#xA;解题思路 将该数字的每一位数字变成数组dec&amp;lt;int&amp;gt;的一部分，然后依次遍历，直到dec[i] &amp;gt; dec[i + 1]，然后将dec[i + 1]及以后的数字都变成9，如果dec[i] == dec[i - 1] == ··· == dec[j]，就将dec[j]--，其余全设置为9。&#xA;代码 class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n != 0) { res.push_back(n % 10); n = n / 10; } } int ten(int i) { int res = 1; while (i != 0) { i--; res *= 10; } return res; } public: int monotoneIncreasingDigits(int n) { vector&amp;lt;int&amp;gt; dec; vec_dec(n, dec); std::reverse(dec.</description>
    </item>
    <item>
      <title>56.merge intervals</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals/</guid>
      <description>Description 56.merge-intervals&#xA;Solution The solution is similar to 452.minimum-number-of-arrows-to-burst-balloons, if there is common space, change the res.back()[1] to intervals[i][1], while intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); if there is not common space, res.push_back().&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>56.合并区间</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals.zh/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals.zh/</guid>
      <description>问题描述 56.合并区间&#xA;解题思路 思路与452.用最少的箭引爆气球，只不过这里intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])，如果存在重叠，修改res最后一个元素的右端点值；如果不存在重叠，就往res里添加一个新的区间。&#xA;代码 class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i - 1][1] &amp;lt; intervals[i][0]) res.push_back(intervals[i]); else { intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); res[res.size() - 1][1] = intervals[i][1]; } } return res; } }; </description>
    </item>
    <item>
      <title>763.partition labels</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels/</guid>
      <description>Description 763.partition-label&#xA;Solution solution 1 First, we need traverse the string, record the maximum index of each letter in the string.&#xA;Then we need declare a variable right to record the maximum index of letter traversed. When the maximum index is the same as current index, we can partition the string.&#xA;solution 2 First, we need traverse the string, record the number of occurrence of each letter, and record whether the letter occur.</description>
    </item>
    <item>
      <title>763.划分字母区间</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels.zh/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels.zh/</guid>
      <description>问题描述 763.划分字母区间&#xA;解题思路 思路一 首先遍历一遍数组，记录每个字母在字符串中出现的最远位置。&#xA;声明一个变量right，用来记录已经遍历的字符中，最远的位置，当遍历到的位置与记录的最远位置重叠时，就说明可以划分数组了。&#xA;思路二 首先遍历一遍数组，记录每个字母出现的次数，并记录是否出现；&#xA;再遍历一次数组，当第一次碰到该字符时，该字符入栈，最后一次碰到该字符时，弹出栈顶的字符，栈空时，说明可以分割了。&#xA;代码 代码一 class Solution { public: vector&amp;lt;int&amp;gt; partitionLabels(string S) { int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置 for (int i = 0; i &amp;lt; S.size(); i++) { // 统计每一个字符最后出现的位置 hash[S[i] - &amp;#39;a&amp;#39;] = i; } vector&amp;lt;int&amp;gt; result; int left = 0; int right = 0; for (int i = 0; i &amp;lt; S.size(); i++) { right = max(right, hash[S[i] - &amp;#39;a&amp;#39;]); // 找到字符出现的最远边界 if (i == right) { result.</description>
    </item>
    <item>
      <title>435.non overlapping intervals</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</guid>
      <description>Description 435.non-overlapping-intervals&#xA;Solution This problem is almost the same with 452.minimum-number-of-arrows-to-burst-balloons, the number intervals minus the result of 452.minimum-number-of-arrows-to-burst-balloons is the result of this problem.&#xA;Attention, [1, 3], [3, 5] is not overlapping intervals in this problem.&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>435.无重叠区间</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</guid>
      <description>问题描述 435.无重叠区间&#xA;解题思路 本题和452.用最少数量的箭引爆气球可以说解题思路一模一样，区间数减去452.用最少数量的箭引爆气球就可以说是本题要求的答案，但是要注意的是，在本题中，区间端点相同是不认为重叠的。&#xA;代码 class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i][0] &amp;gt;= intervals[i - 1][1]) cnt++; else { intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); } } return intervals.size() - cnt; } }; </description>
    </item>
    <item>
      <title>452.用最少数量的箭引爆气球</title>
      <link>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</link>
      <pubDate>Thu, 03 Nov 2022 13:55:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</guid>
      <description>问题描述 452.用最少数量的箭引爆气球&#xA;解题思路 首先，按照$x_start$从小到大的顺序排序，然后开始分析需要的弓箭数。&#xA;if (points[i][0] &amp;gt; points[i - 1])，说明两个气球不存在重叠，需要两支箭，箭数result++; else，说明两个气球存在重叠，只需要一支箭，但此时，如何判断下一个气球是否需要新的箭呢: if (points[i + 1][0] &amp;gt; min(points[i - 1][1], points[i][1]))，那么就需要新的箭，反之就不需要，因此，令points[i][1] = min(points[i - 1][1], points[i][1])。 代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::sort; using std::vector; class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { return a[0] &amp;lt; b[0]; } public: int findMinArrowShots(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points) { int result = 1; sort(points.begin(), points.end(), cmp); for (int i = 1; i &amp;lt; points.size(); i++) { if (points[i - 1][1] &amp;lt; points[i][0]) result++; else { points[i][1] = min(points[i][1], points[i - 1][1]); } } return result; } }; </description>
    </item>
    <item>
      <title>406.queue reconstruction by height</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</guid>
      <description>Description 406.queue-reconstruction-by-height&#xA;Solution First, we need sort the vector by height, then do insertion according to ki.&#xA;When sorting, we need rewrite the comparing method, in reference to the use of sort() method in C++&#xA;Since there may be performance problem when doing insertion frequently in vector, we should use list based on linked list.&#xA;Code class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.</description>
    </item>
    <item>
      <title>406.根据身高重建队列</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</guid>
      <description>问题描述 406.根据身高重建队列&#xA;解题思路 首先根据身高对数组重新排序，再根据ki进行插入操作。&#xA;排序时，需要对排序的比较方法重写，参见C++ sort排序函数用法。&#xA;同时，考虑到基于使用vector来进行频繁的插入操作可能会存在性能问题，应该使用基于链表的list。&#xA;代码 class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.begin(), people.end(), cmp); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; queue; for (int i = 0; i &amp;lt; people.size(); i++) { int tmp = people[i][1]; queue.insert(tmp + queue.begin(), people[i]); } return queue; } }; class Solution { public: // 身高从大到小排（身高相同k小的站前面） static bool cmp(const vector&amp;lt;int&amp;gt;&amp;amp; a, const vector&amp;lt;int&amp;gt;&amp;amp; b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; people) { sort (people.</description>
    </item>
    <item>
      <title>860.lemonade change</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change/</guid>
      <description>Description 860.lemonade-change&#xA;Solution We can create an array to show the number of $5, $10, $20. When the number of $5 is less than 0, return false. When we receive $20, we should provide change with $10 preferentially.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>860.柠檬水找零</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change.zh/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change.zh/</guid>
      <description>问题描述 860.柠檬水找零&#xA;解题思路 创建一个数组，表示手中的5元纸币、10元纸币、20元纸币的数目，当其中5元纸币数目小于0，说明无法找零，遇到20元纸币时，优先使用10元纸币找零。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>135.candy</title>
      <link>http://localhost:1313/posts/leet/135.candy/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy/</guid>
      <description>Description 135.candy&#xA;Solution The key point of this problem is that we need traverse two times, one from front to back, the other from back to front.&#xA;Code class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // front to back for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // back to front for (int i = ratings.</description>
    </item>
    <item>
      <title>135.分发糖果</title>
      <link>http://localhost:1313/posts/leet/135.candy.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy.zh/</guid>
      <description>问题描述 135.分发糖果&#xA;解题思路 本题的关键在于，需要一次从前往后的遍历，第一次确定最少糖果数，同时还需要从后往前遍历，再一次确定最少糖果数。&#xA;代码 class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // 从前向后 for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // 从后向前 for (int i = ratings.size() - 2; i &amp;gt;= 0; i--) { if (ratings[i] &amp;gt; ratings[i + 1] ) { candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1); } } // 统计结果 int result = 0; for (int i = 0; i &amp;lt; candyVec.</description>
    </item>
    <item>
      <title>1005.maximize sum of array after k negations</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</guid>
      <description>Description 1005.maximize-sum-of-array-after-k-negations&#xA;Solution Greedy algorithm.&#xA;Code class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // first step for (int i = 0; i &amp;lt; A.size(); i++) { // second step if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // third step int result = 0; for (int a : A) result += a; // forth step return result; } }; </description>
    </item>
    <item>
      <title>1005.K次取反后的最大化的数组和</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</guid>
      <description>问题描述 1005.K次取反后最大化的数组和&#xA;解题思路 贪心算法&#xA;代码 class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // 第一步 for (int i = 0; i &amp;lt; A.size(); i++) { // 第二步 if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步 int result = 0; for (int a : A) result += a; // 第四步 return result; } }; </description>
    </item>
    <item>
      <title>45.jump game ii</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii/</guid>
      <description>Description 45.jump-game-ii&#xA;Solution In outer loop, we traverse from back to front, while in inner loop, we traverse from front to back, to find the station with minimum index that can arrive at destination. Make the station the new destination, and cnt++.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>45.跳跃游戏II</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</guid>
      <description>问题描述 45.跳跃游戏II&#xA;解题思路 外循环还是从末尾向前遍历，内循环从前往后遍历，每次找能到达终点的索引最小的位置，该位置作为新的终点，同时步数cnt++。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.size(); i++) { if (nums[i] + i &amp;gt;= cur_end) { cur_end = i; cnt++; break; } } } return cnt; } }; </description>
    </item>
    <item>
      <title>55.jump game</title>
      <link>http://localhost:1313/posts/leet/55.jump-game/</link>
      <pubDate>Sun, 30 Oct 2022 16:04:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game/</guid>
      <description>Description 55.jump-game&#xA;Solution Traversing from back to front, if nums[j] can be achieved from nums[j - 1] or nums in the front, then destination change from nums[j] to nums[j - 1] or num in the front.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r !</description>
    </item>
    <item>
      <title>55.跳跃游戏</title>
      <link>http://localhost:1313/posts/leet/55.jump-game.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:03:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game.zh/</guid>
      <description>问题描述 55.跳跃游戏&#xA;解题思路 从后向前遍历，只要nums[j]能由nums[j - 1]或者更前面的点跳到，那么终点就从nums[j]变成nums[j - 1]或更前面的点。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r != 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>53.maximum subarray</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray/</link>
      <pubDate>Sun, 30 Oct 2022 14:30:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray/</guid>
      <description>Description 53.maximum-subarray&#xA;Solution dp[i] denotes maximum sum of subarray ending with nums[i - 1], then: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;Code class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>53.最大子数组和</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</guid>
      <description>问题描述 53.最大子数组和&#xA;解题思路 动态规划 令dp[i]表示以nums[i - 1]结尾的连续子数组的最大和，则: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;贪心算法 以第一个正数为起点，开始记录和sum_temp，同时记录最大和sum，当sum_temp小于0时，起点变为新的正数。&#xA;代码 class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>134.gas station</title>
      <link>http://localhost:1313/posts/leet/134.gas-station/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station/</guid>
      <description>Description 134.gas-station&#xA;Solution We should consider total oil consumption total_oil, and remaining oil from new start station cur_oil(not replenish oil in new station):&#xA;total_oil &amp;lt; 0, can&amp;rsquo;t complete; cur_oil &amp;lt; 0, start at the new station; Code class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //total_oil need &amp;gt; 0, or can&amp;#39;t complete total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // start from i + 1 starting_station = i + 1; // restore to first state cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
    <item>
      <title>134.加油站</title>
      <link>http://localhost:1313/posts/leet/134.gas-station.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station.zh/</guid>
      <description>问题描述 134.加油站&#xA;解题思路 考虑两个变量，一个是总油耗total_oil，一个是从起点到下一个站点后汽车内部剩余的汽油cur_oil(没有在目标站点补充油耗)。 总油耗total_oil &amp;lt; 0，说明不可能到; cur_oil &amp;lt; 0，则以到达的站点作为新的起点再出发;&#xA;代码 class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //总和必须大于等于0，否则不能完成绕行 total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // 一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。 starting_station = i + 1; // 还原到初始状态 cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
  </channel>
</rss>
