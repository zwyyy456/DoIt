<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dsu on My New Hugo Site</title>
    <link>http://localhost:1313/tags/dsu/</link>
    <description>Recent content in Dsu on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 13 Apr 2023 10:17:27 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/dsu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1020.Number of Enclaves (Medium)</title>
      <link>http://localhost:1313/posts/leet/1020.number-of-enclaves/</link>
      <pubDate>Thu, 13 Apr 2023 10:17:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1020.number-of-enclaves/</guid>
      <description>Description 1020. Number of Enclaves (Medium)&#xA;You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.&#xA;A move consists of walking from one land cell to another adjacent ( 4-directionally) land cell or walking off the boundary of the grid.&#xA;Return the number of land cells in gridfor which we cannot walk off the boundary of the grid in any number of moves.</description>
    </item>
    <item>
      <title>1020.飞地的数量 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1020.number-of-enclaves.zh/</link>
      <pubDate>Thu, 13 Apr 2023 10:16:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1020.number-of-enclaves.zh/</guid>
      <description>问题描述 1020. 飞地的数量 (Medium)&#xA;给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、 1 表示一个陆地单元格。&#xA;一次 移动 是指从一个陆地单元格走到另一个相邻（ 上、下、左、右）的陆地单元格或跨过 grid 的边界。&#xA;返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。&#xA;示例 1：&#xA;输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] 输出：3 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。 示例 2：&#xA;输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] 输出：0 解释：所有 1 都在边界上或可以到达边界。 提示：&#xA;m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 500 grid[i][j] 的值为 0 或 1 解题思路 使用并查集，令cnt1为包含索引为m * n的节点树的节点数，cnt2为海水的节点数，res = m * n - (cnt1 - 1) - cnt2;。</description>
    </item>
    <item>
      <title>952.Largest Component Size by Common Factor (Hard)</title>
      <link>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor/</link>
      <pubDate>Wed, 22 Mar 2023 19:45:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor/</guid>
      <description>Description 952. Largest Component Size by Common Factor (Hard)&#xA;You are given an integer array of unique positive integers nums. Consider the following graph:&#xA;There are nums.length nodes, labeled nums[0] to nums[nums.length - 1], There is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph.&#xA;Example 1:&#xA;Input: nums = [4,6,15,35] Output: 4 Example 2:</description>
    </item>
    <item>
      <title>952.按公因数计算最大组件大小 (Hard)</title>
      <link>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor.zh/</link>
      <pubDate>Wed, 22 Mar 2023 19:29:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor.zh/</guid>
      <description>问题描述 952. 按公因数计算最大组件大小 (Hard)&#xA;给定一个由不同正整数的组成的非空数组 nums ，考虑下面的图：&#xA;有 nums.length 个节点，按从 nums[0] 到 nums[nums.length - 1] 标记； 只有当 nums[i] 和 nums[j] 共用一个大于 1 的公因数时， nums[i] 和 nums[j] 之间才有一条边。 返回 图中最大连通组件的大小 。&#xA;示例 1：&#xA;输入：nums = [4,6,15,35] 输出：4 示例 2：&#xA;输入：nums = [20,50,9,63] 输出：2 示例 3：&#xA;输入：nums = [2,3,6,7,4,12,21,39] 输出：8 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁴ 1 &amp;lt;= nums[i] &amp;lt;= 10⁵ nums 中所有值都 不同 解题思路 使用并查集，并注意质因数分解的求法。&#xA;由于nums[i] &amp;lt;= 100000，因此我们设置初始的并查集的节点为$100001$个，遍历数组中的每个元素，将每个元素和他的质因数连接起来，我们只将size_[nums[i]]初始化为1，其余均为0，这样不属于nums[i]的质因数的个数就不会被统计到树的数量中，遍历数组的元素时，更新ans即可。&#xA;注意，由于时间复杂度的要求，我们需要压缩路径并且使用启发式合并。</description>
    </item>
    <item>
      <title>并查集</title>
      <link>http://localhost:1313/posts/tech/dsu-oi-wiki.zh/</link>
      <pubDate>Wed, 22 Mar 2023 17:59:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dsu-oi-wiki.zh/</guid>
      <description>引入 并查集是一种用于管理元素所属的集合的数据结构，其实现或者说表现为一片森林，其中，每棵树表示了一个集合，树中的节点表示对应的集合中的元素：&#xA;顾名思义，并查集支持两种操作：&#xA;合并（Union）：合并两个元素所属的集合（合并对应的树）； 查询（Find）：查询某个元素所属的集合（即查询对应的树的根节点），这可以用于判断两个元素是否属于同一个集合； 并查集在经过修改后还可以支持单个元素的移动、删除；使用动态开点线段树还可以实现可持久化并查集；&#xA;初始化 初始时，我们设置每个元素都属于一个单独的集合，表示为一棵只有根节点的树，每个根节点的父亲都设置为自己。&#xA;class Dsu { vector&amp;lt;size_t&amp;gt; parent_; // 表示每个节点的父节点 vector&amp;lt;size_t&amp;gt; size_; // 表示每棵树有多少节点 Dsu(size_t size) : parent_(size), size_(size, 1) { iota(parent_.begin(), parent_.end()); } } 查询 我们只需要沿着树向上移动，直到找到根节点 size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x]; } 查询时进行路径压缩 查询过程中，经过的每个元素都属于该集合，因此我们可以直接将其连接到根节点，以加快后续查询。 size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x] = find(parent_[x]); } 合并 要合并两棵树，我们只需要将一棵树的根节点连接到另一棵树的根节点。 void Dsu::Unite(size_t x, size_t y) { parent_(find(x)) = find(y); } 启发式合并 即将节点较小或者深度较小的树连接到另一棵，这里以按节点数合并的实现作为参考:</description>
    </item>
  </channel>
</rss>
