<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>三叶 on My New Hugo Site</title>
    <link>http://localhost:1313/tags/%E4%B8%89%E5%8F%B6/</link>
    <description>Recent content in 三叶 on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 05 Dec 2022 20:20:35 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E4%B8%89%E5%8F%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3.longest substring without repeating characters</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</guid>
      <description>Description 3.longest-substring-withou-repeating-characters&#xA;Solution We use arr[96] to record the number of occurence of each character. If the number is larger than 1, than there is repeating character between l and r; else, update res, if current length of substr is larger than res.&#xA;Code class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.</description>
    </item>
    <item>
      <title>3.无重复字符的最长子串</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</guid>
      <description>问题描述 3.无重复字符的最长子串&#xA;解题思路 用arr[96]记录每个字符出现的次数，如果字符次数大于1，说明已经包含了重复字符，则要更新l，否则递增r，并记录最大的子串长度。&#xA;代码 class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.size(); r++) { arr[s[r] - &amp;#39; &amp;#39;]++; if (arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) { while (l &amp;lt; r &amp;amp;&amp;amp; arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) arr[s[l++] - &amp;#39; &amp;#39;]--; } else { res = max(r - l + 1, res); } } return res; } }; </description>
    </item>
    <item>
      <title>30.substring with concatenation of all words</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</guid>
      <description>Description 30.substring-with-concatenation-of-all-words&#xA;Solution For each word sequence {s.substr(i, word_len), s.substr(i + word_len, word_len)...} of i($[0, word_len - 1]$), we use sliding window to judge;&#xA;We should pay attention to the detail when judging. We can use mp to determine whether substr is in words, and mp_tmp to determine whether it is concatenated substring, if mp is empty, then it is;&#xA;For key-value in mp_tmp, if value becomes 0, then erase(key);</description>
    </item>
    <item>
      <title>30.串联所有单词串</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</guid>
      <description>问题描述 30.串联所有单词串&#xA;解题思路 首先，由于words中所有字符串长度相同，要比较words与s: - s从i = 0开始，可以划分为一系列的长为word_len = words[0].size()的单词; - s从i = 1开始，可以划分为一系列的长为word_len = words[0].size()的单词; - &amp;hellip;&amp;hellip; - s从i = word_len - 1开始&amp;hellip;&amp;hellip;&#xA;然后要注意利用unordered_map&amp;lt;string, int&amp;gt;判断是否满足条件的细节，mp用于判断word是否在words中;&#xA;mp_tmp的键值对中，如果值为0，就删掉该键;&#xA;还要注意l的处理，分为在mp_tmp为空，和mp_tmp不为空，但是word已经出现了超过words中的次数.&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findSubstring(string s, vector&amp;lt;string&amp;gt; &amp;amp;words) { unordered_map&amp;lt;string, int&amp;gt; mp; int word_len = words[0].size(); int cnt = 0; vector&amp;lt;int&amp;gt; res; for (int i = 0; i &amp;lt; words.size(); i++) { mp[words[i]]++; cnt++; } if (cnt * word_len &amp;gt; s.</description>
    </item>
    <item>
      <title>1610.maximum Number of Visible Points</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</guid>
      <description>Descripiton 1610.maximum-number-of-visible-points&#xA;Soluiton We can use function atan2 to change slope to angle in $-\pi ~ \pi$.&#xA;We need also expand arrays, let angle[n + i] = angle[i] + 360, and the length of array to be 2 * n, so we can avoid omission.&#xA;Code class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>1610.可见点的最大数目</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</guid>
      <description>问题描述 1610.可见点的最大数目&#xA;解题思路 利用atan2函数，即可将斜率转化为$-\pi ~ \pi$的角度;&#xA;扩充数组，令angle[n + i] = angle[i] + 360，使角度数组长度为2 * n，这样就能避免遗漏一四象限。&#xA;代码 class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>303.range sum query-immutable</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</guid>
      <description>Description 303.range-sum-query-immutable&#xA;Solution We can use prefix sum array, so we can get sum without traversing.&#xA;Code class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>303.区域和检索-数组不可变</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</guid>
      <description>问题描述 303.区域和检索-数组不可变&#xA;解题思路 利用前缀和数组，使得求区间和时无需再遍历数组求和。&#xA;代码 class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>1769.minimum number of operation to ove ll balls to each box</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</guid>
      <description>Description 1769.minimum-number-of-operations-to-move-all-balls-to-each-box&#xA;Solution Violent solution: $\Theta(n^2)$&#xA;We could use prefix sum to reduce the time complexity.&#xA;nums[i] denotes the number of ball in first i + 1 boxes, res[i] is the minimum number of operation to ove ll balls to the i + 1th box, sum is the total number of balls. Compared to moving all balls to i th box, if we want to move all ball to the i + 1th box, the balls in 0 =&amp;gt; i - 1 all need move an additional step, while the balls in i =&amp;gt; n - 1 will move one step less.</description>
    </item>
    <item>
      <title>1769.移动所有球到每个盒子所需的最小操作数</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</guid>
      <description>问题描述 1769.移动所有球到每个盒子所需的最小操作数&#xA;解题思路 暴力求解，时间复杂度为$\Theta(n^2)$;&#xA;可以考虑利用前缀和来降低时间复杂度: 设nums[i]是前i + 1个盒子里的球的总个数，res[i]为将所有球移到第i + 1个盒子里所需要的操作数，sum为球总个数，移到第i + 1个盒子相比移到第i个盒子，左边的球各要多移一步，右边的球各少移一步，因此有那么有:res[i] = res[i - 1] + nums[i - 1] - (sum - nums[i - 1])，&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; minOperations(string boxes) { vector&amp;lt;int&amp;gt; nums(boxes.size(), 0); int sum = boxes[0] - &amp;#39;0&amp;#39;; nums[0] = boxes[0] - &amp;#39;0&amp;#39;; for (int i = 1; i &amp;lt; boxes.size(); i++) { if (boxes[i] == &amp;#39;1&amp;#39;) { nums[i] = nums[i - 1] + 1; sum++; } else nums[i] = nums[i - 1]; } vector&amp;lt;int&amp;gt; res(boxes.</description>
    </item>
  </channel>
</rss>
