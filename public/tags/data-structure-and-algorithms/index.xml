<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structure and Algorithms on My New Hugo Site</title>
    <link>http://localhost:1313/tags/data-structure-and-algorithms/</link>
    <description>Recent content in Data Structure and Algorithms on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 Oct 2023 17:50:12 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/data-structure-and-algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>å·®åˆ†æ•°ç»„</title>
      <link>http://localhost:1313/posts/tech/difference_array.zh/</link>
      <pubDate>Fri, 06 Oct 2023 17:50:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/difference_array.zh/</guid>
      <description>ä»‹ç» è€ƒè™‘åŸæ•°ç»„ä¸º $[1, 3, 3, 5, 8]$ï¼Œæˆ‘ä»¬å¯¹ç›¸é‚»å…ƒç´ åšå·®ï¼Œç”¨ $a_i - a_{i - 1}$ï¼Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªå·®åˆ†æ•°ç»„ $[1, 2, 0, 2, 3]$ $diff$ï¼Œæˆ‘ä»¬è®¤ä¸º $a_{-1}$ ä¸º $0$ï¼Œå› æ­¤&#xA;$$diff[i] = \begin{cases} a[0] &amp;amp; i = 0 \newline a[i] - a[i - 1] &amp;amp; i &amp;gt; 0\end{cases}$$&#xA;æ€§è´¨ å·®åˆ†æ•°ç»„å¾€å¾€å’Œå‰ç¼€å’Œæ•°ç»„æ”¾åœ¨ä¸€å—è®¨è®ºï¼Œäº‹å®ä¸Šï¼Œå·®åˆ†æ•°ç»„çš„å‰ç¼€å’Œå³å¯è¿˜åŸå‡ºåŸæ•°ç»„ã€‚å³ï¼š&#xA;$$ a[k] = \sum\limits_{i = 0}^k diff[i]$$&#xA;å·®åˆ†æ•°ç»„è¿˜æœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„æ€§è´¨ï¼Œé‚£å°±æ˜¯å®ƒå¯ä»¥å°†åŒºé—´ä¿®æ”¹ï¼ˆå°†åŒºé—´ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½åŠ ä¸€ä¸ªå€¼æˆ–è€…å‡ä¸€ä¸ªå€¼ï¼‰å˜æˆå•ç‚¹ä¿®æ”¹ã€‚&#xA;ä¾‹å¦‚ï¼ŒåŠ å…¥æˆ‘ä»¬è¦å°†åŒºé—´ $[i, j]$ ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½åŠ  $c$ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦å°† $diff[i]$ åŠ  $c$ï¼Œå¹¶å°† $diff[j + 1]$ å‡å» $c$ å³å¯ï¼Œç”±è¿™ä¸ªå·®åˆ†æ•°ç»„å–å‰ç¼€å’Œè¿˜åŸå‡ºæ¥çš„åŸæ•°ç»„ï¼Œå°±æ˜¯æˆ‘ä»¬ä¿®æ”¹åçš„åŸæ•°ç»„ã€‚</description>
    </item>
    <item>
      <title>950. Reveal Cards In Increasing Order (Medium)</title>
      <link>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order/</link>
      <pubDate>Thu, 20 Jul 2023 10:25:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order/</guid>
      <description>Description 950. Reveal Cards In Increasing Order (Medium)&#xA;Solution This problem can be solved through direct simulation according to the given instructions. The use of recursion is not necessary. Since the problem involves popping the first element, a double-ended queue (deque) is a suitable data structure to use. The deque will store the indices of elements, and we can proceed with the simulation accordingly.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; deckRevealedIncreasing(vector&amp;lt;int&amp;gt;&amp;amp; deck) { sort(deck.</description>
    </item>
    <item>
      <title>950. æŒ‰é€’å¢é¡ºåºæ˜¾ç¤ºå¡ç‰Œ (Medium)</title>
      <link>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order.zh/</link>
      <pubDate>Thu, 20 Jul 2023 10:25:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order.zh/</guid>
      <description>é—®é¢˜æè¿° 950. æŒ‰é€’å¢é¡ºåºæ˜¾ç¤ºå¡ç‰Œ (Medium)&#xA;ç‰Œç»„ä¸­çš„æ¯å¼ å¡ç‰Œéƒ½å¯¹åº”æœ‰ä¸€ä¸ªå”¯ä¸€çš„æ•´æ•°ã€‚ä½ å¯ä»¥æŒ‰ä½ æƒ³è¦çš„é¡ºåºå¯¹è¿™å¥—å¡ç‰‡è¿›è¡Œæ’åºã€‚&#xA;æœ€åˆï¼Œè¿™äº›å¡ç‰Œåœ¨ç‰Œç»„é‡Œæ˜¯æ­£é¢æœä¸‹çš„ï¼ˆå³ï¼Œæœªæ˜¾ç¤ºçŠ¶æ€ï¼‰ã€‚&#xA;ç°åœ¨ï¼Œé‡å¤æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼Œç›´åˆ°æ˜¾ç¤ºæ‰€æœ‰å¡ç‰Œä¸ºæ­¢ï¼š&#xA;ä»ç‰Œç»„é¡¶éƒ¨æŠ½ä¸€å¼ ç‰Œï¼Œæ˜¾ç¤ºå®ƒï¼Œç„¶åå°†å…¶ä»ç‰Œç»„ä¸­ç§»å‡ºã€‚ å¦‚æœç‰Œç»„ä¸­ä»æœ‰ç‰Œï¼Œåˆ™å°†ä¸‹ä¸€å¼ å¤„äºç‰Œç»„é¡¶éƒ¨çš„ç‰Œæ”¾åœ¨ç‰Œç»„çš„åº•éƒ¨ã€‚ å¦‚æœä»æœ‰æœªæ˜¾ç¤ºçš„ç‰Œï¼Œé‚£ä¹ˆè¿”å›æ­¥éª¤ 1ã€‚å¦åˆ™ï¼Œåœæ­¢è¡ŒåŠ¨ã€‚ è¿”å›èƒ½ä»¥ é€’å¢é¡ºåº æ˜¾ç¤ºå¡ç‰Œçš„ç‰Œç»„é¡ºåºã€‚&#xA;ç­”æ¡ˆä¸­çš„ç¬¬ä¸€å¼ ç‰Œè¢«è®¤ä¸ºå¤„äºç‰Œå †é¡¶éƒ¨ã€‚&#xA;ç¤ºä¾‹ï¼š&#xA;è¾“å…¥ï¼š[17,13,11,2,3,5,7] è¾“å‡ºï¼š[2,13,3,11,5,17,7] è§£é‡Šï¼š æˆ‘ä»¬å¾—åˆ°çš„ç‰Œç»„é¡ºåºä¸º [17,13,11,2,3,5,7]ï¼ˆè¿™ä¸ªé¡ºåºä¸é‡è¦ï¼‰ï¼Œç„¶åå°†å…¶é‡æ–°æ’åºã€‚ é‡æ–°æ’åºåï¼Œç‰Œç»„ä»¥ [2,13,3,11,5,17,7] å¼€å§‹ï¼Œå…¶ä¸­ 2 ä½äºç‰Œç»„çš„é¡¶éƒ¨ã€‚ æˆ‘ä»¬æ˜¾ç¤º 2ï¼Œç„¶åå°† 13 ç§»åˆ°åº•éƒ¨ã€‚ç‰Œç»„ç°åœ¨æ˜¯ [3,11,5,17,7,13]ã€‚ æˆ‘ä»¬æ˜¾ç¤º 3ï¼Œå¹¶å°† 11 ç§»åˆ°åº•éƒ¨ã€‚ç‰Œç»„ç°åœ¨æ˜¯ [5,17,7,13,11]ã€‚ æˆ‘ä»¬æ˜¾ç¤º 5ï¼Œç„¶åå°† 17 ç§»åˆ°åº•éƒ¨ã€‚ç‰Œç»„ç°åœ¨æ˜¯ [7,13,11,17]ã€‚ æˆ‘ä»¬æ˜¾ç¤º 7ï¼Œå¹¶å°† 13 ç§»åˆ°åº•éƒ¨ã€‚ç‰Œç»„ç°åœ¨æ˜¯ [11,17,13]ã€‚ æˆ‘ä»¬æ˜¾ç¤º 11ï¼Œç„¶åå°† 17 ç§»åˆ°åº•éƒ¨ã€‚ç‰Œç»„ç°åœ¨æ˜¯ [13,17]ã€‚ æˆ‘ä»¬å±•ç¤º 13ï¼Œç„¶åå°† 17 ç§»åˆ°åº•éƒ¨ã€‚ç‰Œç»„ç°åœ¨æ˜¯ [17]ã€‚ æˆ‘ä»¬æ˜¾ç¤º 17ã€‚ ç”±äºæ‰€æœ‰å¡ç‰‡éƒ½æ˜¯æŒ‰é€’å¢é¡ºåºæ’åˆ—æ˜¾ç¤ºçš„ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯æ­£ç¡®çš„ã€‚ æç¤ºï¼š&#xA;1 &amp;lt;= A.length &amp;lt;= 1000 1 &amp;lt;= A[i] &amp;lt;= 10^6 å¯¹äºæ‰€æœ‰çš„ i !</description>
    </item>
    <item>
      <title>æ— å‘å›¾å½¢å¼ç»„ç»‡çš„æ ‘</title>
      <link>http://localhost:1313/posts/tech/undirected-graph-tree.zh/</link>
      <pubDate>Tue, 18 Jul 2023 09:30:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/undirected-graph-tree.zh/</guid>
      <description>å¼•å…¥ å¦‚ æ•°ç»„å½¢å¼ç»„ç»‡çš„æ ‘ ä¸­æ‰€è¯´ï¼Œæ ‘ä¸€èˆ¬ä»¥é“¾è¡¨ç»“ç‚¹çš„å½¢å¼ç»„ç»‡ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} }; ä¹Ÿå¯èƒ½ä»¥æ•°ç»„çš„å½¢å¼ç»„ç»‡ï¼Œå³ä½¿ç”¨ $parent$ æ•°ç»„ï¼Œ$y = parent[x]$ è¯´æ˜ $y$ æ˜¯ $x$ çš„çˆ¶ç»“ç‚¹ï¼Œæ ¹ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ä¸º $-1$ï¼Œè¡¨ç¤ºçˆ¶ç»“ç‚¹ä¸å­˜åœ¨ã€‚&#xA;è¿˜å¯ä»¥ä½¿ç”¨æ— å‘å›¾çš„å½¢å¼æ¥è¡¨ç¤ºï¼Œä¾‹å¦‚ leetcode çš„ 834. æ ‘ä¸­è·ç¦»ä¹‹å’Œã€‚&#xA;æ˜¨å¤©åšè¿™ä¸ªé¢˜çš„æ—¶å€™ï¼Œæ•´ä½“æ€è·¯æŒºå¥½æƒ³çš„ï¼Œä½†å°±æ˜¯æœ‰ä¸ªåœ°æ–¹è¢«å›°ä½äº†ï¼Œé‚£å°±æ˜¯ï¼Œåœ¨æ ‘çš„æ— å‘å›¾çš„è¡¨ç¤ºæƒ…å†µä¸‹ï¼Œå¦‚ä½•ç»Ÿè®¡ä»¥å½“å‰ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘çš„æ•°é‡ï¼Ÿï¼ˆæ²¡åŠæ³•è½¬åŒ–æˆæœ‰å‘å›¾ï¼ï¼‰&#xA;ç»Ÿè®¡ä»¥å½“å‰ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘çš„ç»“ç‚¹æ•° ç»Ÿè®¡æ–¹æ³•è¿˜æ˜¯æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆdfsï¼‰ï¼Œåªä¸è¿‡ï¼Œç›¸æ¯”ä¸€èˆ¬çš„æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œæˆ‘ä»¬éœ€è¦ä¼ å…¥ä¸€ä¸ªé¢å¤–çš„å‚æ•°ï¼Œå³ä¸Šä¸€æ¬¡æœç´¢çš„çˆ¶ç»“ç‚¹ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š&#xA;ç›¸åº”çš„ dfs ä»£ç ä¸º&#xA;for (int child : tree[pa]) { if (child == ancestor) { continue; } // å¯¹å­ç»“ç‚¹è¿›è¡Œ dfs ... } è¿™æ ·å°±ç¡®å®šå‡ºäº†ä¸€ä¸ªéå†æ–¹å‘ï¼Œå› æ­¤ï¼Œæ•´ä½“æ€è·¯å°±æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ä»»æ„é€‰æ‹©ä¸€ä¸ªç»“ç‚¹ä½œä¸º dfs çš„èµ·ç‚¹ï¼ˆè¿™é‡Œå°±é€‰æ‹© $0$ å·ç»“ç‚¹ï¼‰ï¼Œä¾æ¬¡è¿›è¡Œ dfsï¼Œåˆ©ç”¨é€’å½’çš„æ–¹æ³•ï¼Œç»Ÿè®¡ä»¥å½“å‰ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘çš„ç»“ç‚¹æ•°ã€‚&#xA;å› æ­¤ï¼Œ834. æ ‘ä¸­è·ç¦»ä¹‹å’Œ çš„å®Œæ•´è§£é¢˜ä»£ç å¦‚ä¸‹ï¼š&#xA;class Solution { public: int count(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;tree, vector&amp;lt;int&amp;gt; &amp;amp;dis, vector&amp;lt;int&amp;gt; &amp;amp;cnt, int pa, int grandpa) { int res = 1; for (int child : tree[pa]) { if (child == grandpa) { // é˜²æ­¢é‡å¤éå†ï¼Œä¿è¯ dfs éå†æ—¶çš„å•å‘æ€§ continue; } dis[child] = dis[pa] + 1; res += count(tree, dis, cnt, child, pa); } cnt[pa] = res; return res; } vector&amp;lt;int&amp;gt; sumOfDistancesInTree(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;edges) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; tree(n); for (auto &amp;amp;vec : edges) { tree[vec[0]].</description>
    </item>
    <item>
      <title>çº¢é»‘æ ‘</title>
      <link>http://localhost:1313/posts/tech/red-black-tree.zh/</link>
      <pubDate>Mon, 26 Jun 2023 19:44:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/red-black-tree.zh/</guid>
      <description>è‡ªé¡¶å‘ä¸‹çš„ 2-3-4 æ ‘ æ’å…¥ç»“ç‚¹ 2-3-4 æ ‘çš„æ’å…¥ç®—æ³•ï¼Œç®€è€Œè¨€ä¹‹ï¼Œå°±æ˜¯åœ¨å¾€ä¸‹æŸ¥æ‰¾åº”è¯¥å°†å¾…æ’å…¥çš„ new_key æ’å…¥åˆ°ä½•å¤„çš„æ—¶å€™ï¼Œä¸€æ—¦ç¢°åˆ° 4- ç»“ç‚¹ï¼Œå°±å°† 4- ç»“ç‚¹ä¸­é—´çš„ key ä¸Šæº¢ï¼Œå‰©ä¸‹çš„ä¸¤ä¸ª key ä½œä¸ºä¸¤ä¸ª 2- ç»“ç‚¹ï¼Œè¿™ä¸ªä¸Šæº¢çš„è¿‡ç¨‹ä¹Ÿæ˜¯é€’å½’çš„ï¼Œå¯ä»¥ç†è§£ä¸ºå‘åŸå…ˆ 4- ç»“ç‚¹çš„çˆ¶ç»“ç‚¹æ’å…¥ 4- ç»“ç‚¹ä¸­é—´çš„è¿™ä¸ª keyï¼Œ4- ç»“ç‚¹å‰©ä¸‹çš„éƒ¨åˆ†ä½œä¸ºä¸¤ä¸ª 2- ç»“ç‚¹ã€‚æˆ‘ä»¬çš„è¿™ä¸ªåˆ†è§£ç®—æ³•ï¼Œä¿è¯äº†4- ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ä¸ä¼šæ˜¯ 4- ç»“ç‚¹ã€‚ï¼ˆè¿™é‡Œå¯ä»¥ç”¨æ•°å­¦å½’çº³æ³•ç»™å‡ºè¯æ˜ï¼‰&#xA;è¿™æ ·å¤„ç†åˆ°æœ€åï¼Œæˆ‘ä»¬çš„ new_key è¦æ’å…¥çš„ç»“ç‚¹ä¸€å®šæ˜¯ 2- ç»“ç‚¹æˆ–è€… 3- ç»“ç‚¹ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æ’å…¥ã€‚&#xA;è¦å®ç°è¿™ä¸ªæ’å…¥ç®—æ³•ï¼Œæˆ‘ä»¬éœ€è¦ï¼š&#xA;å°† 4- ç»“ç‚¹è¡¨ç¤ºä¸ºç”±ä¸‰ä¸ª 2- ç»“ç‚¹ç»„æˆçš„ä¸€ä¸ªå¹³è¡¡çš„å­æ ‘ï¼Œæ ¹ç»“ç‚¹å’Œä¸¤ä¸ªå­ç»“ç‚¹éƒ½ç”¨ red link è¿æ¥ï¼› åœ¨å‘ä¸‹çš„è¿‡ç¨‹ä¸­åˆ†è§£æ‰€æœ‰ 4- ç»“ç‚¹å¹¶è¿›è¡Œé¢œè‰²è½¬æ¢ï¼› å’Œæ’å…¥æ“ä½œä¸€æ ·ï¼Œåœ¨å‘ä¸Šçš„è¿‡ç¨‹ä¸­ç”¨æ—‹è½¬å°† 4- ç»“ç‚¹é…å¹³ï¼› ä½†å®é™…ä¸Šï¼Œæˆ‘ä»¬åªè¦ç§»åŠ¨ put æ–¹æ³•ä¸­çš„ä¸‰è¡Œä»£ç å°±èƒ½ç”± 2-3 æ ‘å¯¹åº”çš„çº¢é»‘æ ‘æ“ä½œè½¬ç§»åˆ° 2-3-4 æ ‘å¯¹åº”çš„çº¢é»‘æ ‘æ“ä½œï¼›å³å°† FlipColors è¯­å¥ï¼ˆä»¥åŠ if åˆ¤æ–­ï¼‰ç§»åŠ¨åˆ° nullptr æµ‹è¯•ä¹‹åï¼Œé€’å½’è°ƒç”¨ä¹‹å‰ï¼Œå¦‚ä¸‹ï¼š&#xA;void Put(int key, int val) { root_ = Put(key, val, root_); root_-&amp;gt;color_ = kBlack; // æ ¹ç»“ç‚¹çš„é¢œè‰²ä¸€å®šæ˜¯é»‘è‰²ï¼ } auto Put(int key, int val, Node *h) -&amp;gt; Node * { // h è¡¨ç¤ºæˆ‘ä»¬å¾€ä»¥ h ä¸ºæ ¹ç»“ç‚¹çš„æ ‘ä¸­æ’å…¥ç»“ç‚¹ if (h == nullptr) { return new Node(key, val, 1, kRed); } if (isRed(h-&amp;gt;left_) &amp;amp;&amp;amp; isRed(h-&amp;gt;right_)) { // å·¦å³å­ç»“ç‚¹éƒ½æ˜¯çº¢è‰²ï¼Œç¿»è½¬é¢œè‰² // å³ç¢°åˆ° 4- ç»“ç‚¹å°±åˆ†è§£æˆä¸¤ä¸ª 2- ç»“ç‚¹ FlipColors(h); } if (key &amp;lt; h-&amp;gt;key_) { h-&amp;gt;left_ = Put(key, val, h-&amp;gt;left_); } else if (key &amp;gt; h-&amp;gt;key_) { h-&amp;gt;right_ = Put(key, val, h-&amp;gt;right_); } else { h-&amp;gt;val_ = val; } if (!</description>
    </item>
    <item>
      <title>å·¦å€¾çº¢é»‘æ ‘ ï¼ˆLLRBï¼‰</title>
      <link>http://localhost:1313/posts/tech/left-lean-red-black-tree.zh/</link>
      <pubDate>Sat, 24 Jun 2023 13:36:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/left-lean-red-black-tree.zh/</guid>
      <description>ç®€ä»‹ çº¢é»‘æ ‘æ˜¯å¹³è¡¡äºŒå‰æŸ¥æ‰¾æ ‘çš„ä¸€ç§ï¼Œå‰é¢æˆ‘ä»¬æåˆ°ï¼Œéå¹³è¡¡çš„ BSTï¼Œåœ¨åªæœ‰éšæœºæ’å…¥å’ŒæŸ¥è¯¢çš„æƒ…å†µä¸‹ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(\log n)$ çš„ï¼Œç„¶è€Œï¼Œå¦‚æœåŒæ—¶å­˜åœ¨éšæœºæ’å…¥å’Œéšæœºåˆ é™¤ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¼šé€€åŒ–åˆ° $O(\sqrt n)$ï¼Œè¿™æ˜¯æˆ‘ä»¬æ— æ³•æ¥å—çš„ã€‚&#xA;çº¢é»‘æ ‘åœ¨æ’å…¥å’Œåˆ é™¤æ—¶ï¼Œä¼šç»´æŒæ ‘çš„å¹³è¡¡ï¼Œå³ä¿è¯æ ‘çš„é«˜åº¦åœ¨ $[\log n, \log(n + 1)]$ï¼Œç†è®ºä¸Šæç«¯æƒ…å†µå¯èƒ½æ ‘é«˜æœ€å¤§ä¼šåˆ°è¾¾ $2 * \log n$ï¼Œå®é™…ä¸Šå¾ˆéš¾é‡åˆ°ï¼ˆå°½ç®¡è¿™æ ·ï¼Œè¿˜æ˜¯ä¿è¯äº† $O(\log n)$ çš„å¢åˆ æŸ¥æ”¹æ—¶é—´å¤æ‚åº¦ã€‚&#xA;çº¢é»‘æ ‘å…¶å®æ˜¯ 2-3 æŸ¥æ‰¾æ ‘æˆ–è€… 2-3-4 æŸ¥æ‰¾æ ‘çš„ä¸€ç§äºŒå‰æ ‘çš„å®ç°æ–¹å¼ã€‚å…¶ä¸­åŸºäº 2-3 æ ‘å®ç°çš„çº¢é»‘æ ‘è¢«ç§°ä¸ºå·¦å€¾çº¢é»‘æ ‘ï¼ˆLeft-Leaning Red-Black Trees, LLRBï¼‰ï¼ŒåŸºäº 2-3-4 æ ‘å®ç°çš„å°±æ˜¯æ™®é€šçš„çº¢é»‘æ ‘ï¼Œå·¦å€¾çº¢é»‘æ ‘å®ç°èµ·æ¥æ¯”çº¢é»‘æ ‘æ›´ç®€å•ä¸€äº›ï¼ˆã€Šç®—æ³• ç¬¬å››ç‰ˆã€‹é‡Œé¢ä¹Ÿä¸»è¦è®²çš„å·¦å€¾çº¢é»‘æ ‘ï¼‰ï¼Œå› æ­¤å…ˆè®²å·¦å€¾çº¢é»‘æ ‘ã€‚&#xA;2-3 æŸ¥æ‰¾æ ‘ åœ¨æ™®é€šçš„äºŒå‰æ ‘ä¸­ï¼Œéå¶å­ç»“ç‚¹å¯ä»¥æœ‰ä¸€ä¸ªæˆ–è€…ä¸¤ä¸ªå­ç»“ç‚¹ï¼Œå¦‚æœæ²¡æœ‰å­ç»“ç‚¹ï¼Œé‚£ä¹ˆå°±æ˜¯å¶å­ç»“ç‚¹ã€‚&#xA;è€Œ 2-3 æŸ¥æ‰¾æ ‘çš„é™åˆ¶è¦ä¸¥æ ¼å¾ˆå¤šã€‚æˆ‘ä»¬å°†æ‹¥æœ‰ä¸€ä¸ª key å’Œä¸¤ä¸ªé“¾æ¥ çš„ç»“ç‚¹ç§°ä¸º 2- ç»“ç‚¹ï¼Œæ‹¥æœ‰ä¸¤ä¸ª key å’Œä¸‰ä¸ªé“¾æ¥çš„ç»“ç‚¹ç§°ä¸º 3- ç»“ç‚¹ã€‚&#xA;2- ç»“ç‚¹å«æœ‰ä¸€ä¸ª keyï¼Œä¸¤ä¸ª linkï¼› 3- ç»“ç‚¹å«æœ‰ä¸¤ä¸ªä¸åŒçš„ keyï¼Œä¸‰ä¸ª linkã€‚ 3- ç»“ç‚¹å«æœ‰ä¸¤ä¸ª keyï¼ˆ$key_1 &amp;lt; key_2$ï¼‰ï¼Œä¸‰ä¸ªé“¾æ¥ï¼Œå·¦é“¾æ¥æŒ‡å‘ 2-3 æ ‘ä¸­çš„ key éƒ½å°äº $key_1$ï¼Œä¸­é—´é“¾æ¥æŒ‡å‘çš„ 2-3 æ ‘ä¸­çš„ key éƒ½æ»¡è¶³ $key_1 &amp;lt; key &amp;lt; key_2$ï¼Œå³é“¾æ¥æŒ‡å‘çš„ 2-3 æ ‘ä¸­çš„ key éƒ½å¤§äº $key_2$ã€‚</description>
    </item>
    <item>
      <title>æ ‘çŠ¶æ•°ç»„</title>
      <link>http://localhost:1313/posts/tech/binary_index_tree.zh/</link>
      <pubDate>Fri, 23 Jun 2023 23:55:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/binary_index_tree.zh/</guid>
      <description>å¼•å…¥ æ•°è£…æ•°ç»„æ˜¯ä¸€ç§æ”¯æŒå•ç‚¹ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢çš„æ•°æ®ç»“æ„ã€‚&#xA;è¿™é‡Œçš„åŒºé—´æŸ¥è¯¢ä¸€èˆ¬æŒ‡æ±‚å’Œã€‚&#xA;æ™®é€šæ ‘çŠ¶æ•°ç»„ç»´æŠ¤çš„ä¿¡æ¯ä»¥åŠè¿ç®—è¦æ»¡è¶³ç»“åˆå¾‹å¹¶ä¸”å¯ä»¥å·®åˆ†ã€‚&#xA;å®šä¹‰ è€ƒè™‘ä¸‹æ ‡ä» $1$ å¼€å§‹çš„æ•°ç»„ $a[1]\sim a[8]$ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š&#xA;æˆ‘ä»¬å¯ä»¥å‘ç°ï¼š&#xA;$c[2]$ ç®¡è¾– $\sum\limits_{i = 1}^2 a[i]$ï¼› $c[4]$ ç®¡è¾– $\sum\limits_{i = 1}^4 a[i]$ï¼› $c[6]$ ç®¡è¾– $\sum\limits_{i = 5}^6 a[i]$ï¼› $c[8]$ ç®¡è¾– $\sum\limits_{i = 1}^8 a[i]$ï¼› å³ $c[x]$ ç®¡è¾– $\sum\limits_{i = x - (x \text{AND} -x) + 1}^x a[i]$ã€‚ä¾‹å¦‚ $6\text{AND}(-6) + 1 = 5$ã€‚&#xA;åŒæ—¶æˆ‘ä»¬å®šä¹‰ $\text{lowbit}(x) = x \text{AND} -x$&#xA;ä½¿ç”¨ é‚£ä¹ˆå¦‚ä½•ä½¿ç”¨æ ‘çŠ¶æ•°ç»„å‘¢ï¼Œç¬¬ä¸€æ­¥æ˜¯åˆå§‹åŒ–ï¼Œæˆ‘ä»¬å…ˆå‡å®šåŸæ•°ç»„ä¹Ÿæ˜¯ä¸‹æ ‡ä» $1$ å¼€å§‹ï¼Œä» $0$ å¼€å§‹é‚£ä¹ˆåšç›¸åº”å˜æ¢å³å¯ã€‚&#xA;åˆå§‹åŒ– æˆ‘ä»¬å…ˆä»¤ $c[i] = 0$ï¼Œç„¶åéå† $a[j]$ï¼Œæ¯æ¬¡éå†ç›¸å½“äºæ˜¯ï¼ˆå‡è®¾åŸæ•°ç»„å…ƒç´ å‡ä¸º $0$ï¼Œç„¶åå°†å…¶å€¼åŠ ä¸Š $a[i]$ï¼‰ï¼Œå³åˆå§‹åŒ–æ ‘çŠ¶æ•°ç»„ç›¸å½“äºæ˜¯åšäº† $n$ æ¬¡å•ç‚¹ä¿®æ”¹ã€‚</description>
    </item>
    <item>
      <title>äºŒå‰æœç´¢æ ‘</title>
      <link>http://localhost:1313/posts/tech/bst.zh/</link>
      <pubDate>Fri, 23 Jun 2023 15:08:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/bst.zh/</guid>
      <description>äºŒå‰æœç´¢æ ‘ äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼ŒBSTï¼‰æ˜¯æŒ‡ä¸€é¢—ç©ºæ ‘æˆ–è€…æœ‰ä¸‹åˆ—æ€§è´¨çš„äºŒå‰æ ‘ï¼š&#xA;è‹¥ä»»æ„èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå·¦å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼› è‹¥ä»»æ„èŠ‚ç‚¹çš„å³å­æ ‘ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå³å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼› ä»»æ„èŠ‚ç‚¹çš„å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æœç´¢æ ‘ï¼› äºŒå‰æ ‘çš„å®šä¹‰æ˜¯ä»ä¸€ä¸ªé€’å½’çš„è§’åº¦æ¥å®šä¹‰çš„ï¼ŒéªŒè¯äºŒå‰æ ‘å…¶å®å¾ˆç®€å•ï¼Œå³ä¸­åºéå†äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹çš„å€¼ä»ä¸¥æ ¼é€’å¢ã€‚æ¢è¨€ä¹‹ï¼ŒäºŒå‰æœç´¢æ ‘ä¹Ÿå¯ä»¥å®šä¹‰æˆä¸­åºéå†æ—¶èŠ‚ç‚¹å€¼ä¸¥æ ¼é€’å¢çš„äºŒå‰æ ‘ã€‚&#xA;BST çš„åˆ é™¤ å¯¹æ ‘çš„å®šä¹‰ï¼Œæˆ‘ä»¬é‡‡å– Leetcode ä¸­çš„å®šä¹‰ï¼š&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) { } TreeNode(int x) : val(x), left(nullptr), right(nullptr) { } TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) { } }; é¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰ä¸¤ä¸ªè¾…åŠ©å‡½æ•° TreeNode *delMax(TreeNode *root, int key); å’Œ TreeNode *delMin(TreeNode *root, int key);ï¼Œåˆ†åˆ«è¡¨ç¤ºåˆ é™¤äºŒå‰æ ‘ä¸­çš„å€¼æœ€å¤§çš„èŠ‚ç‚¹å’Œå€¼æœ€å°çš„èŠ‚ç‚¹ã€‚è¿˜éœ€è¦è¾…åŠ©å‡½æ•° int getMin(TreeNode *root); å’Œ int getMax(TreeNode *root)ã€‚&#xA;getMin å’Œ getMax è‡ªä¸å¿…å¤šè¯´ï¼Œä»¥ delMax ä¸ºä¾‹ï¼Œéƒ½æ˜¯åˆ©ç”¨é€’å½’è¿›è¡Œå¤„ç†ï¼Œé€’å½’è¿”å›çš„æ˜¯å½“å‰ä»¥ root ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘ï¼Œåˆ é™¤äº†æœ€å¤§å€¼ä¹‹åçš„ rootã€‚é€’å½’ç»ˆæ­¢æ¡ä»¶å³ root-&amp;gt;right == nullptrï¼Œè¯´æ˜æ‰¾åˆ°äº†æ ‘çš„æœ€å¤§å€¼ï¼Œæ­¤æ—¶è¿”å› root-&amp;gt;leftã€‚ï¼ˆä»¥é¿å…å·¦å­æ ‘ä¸ä¸ºç©ºçš„æƒ…å†µï¼Œå·¦å­æ ‘ä¸ºç©ºåˆ™ç›¸å½“äºè¿”å›äº† nulltprï¼‰</description>
    </item>
    <item>
      <title>çº¿æ®µæ ‘</title>
      <link>http://localhost:1313/posts/tech/seg_tree.zh/</link>
      <pubDate>Tue, 13 Jun 2023 19:44:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/seg_tree.zh/</guid>
      <description>å¼•å…¥ çº¿æ®µæ ‘æ˜¯ç®—æ³•ç«èµ›ä¸­å¸¸ç”¨çš„ç”¨æ¥ç»´æŠ¤åŒºé—´ä¿¡æ¯çš„æ•°æ®ç»“æ„ã€‚&#xA;æ ‘çŠ¶æ•°ç»„å¯ä»¥åœ¨ $O(\log n)$ çš„æ—¶é—´å†…å®ç°å•ç‚¹ä¿®æ”¹ã€åŒºé—´æŸ¥è¯¢ï¼ˆæ±‚å’Œã€æ±‚æœ€å€¼ã€æ±‚å¼‚æˆ–ç­‰ï¼‰ï¼›è€Œçº¿æ®µæ ‘è¿˜å¯ä»¥åœ¨ $O(\log n)$ æ—¶é—´å†…å®ç°åŒºé—´ä¿®æ”¹æ“ä½œï¼Œä¾‹å¦‚å°† $[L, R]$ åŒºé—´èŒƒå›´å†…çš„å€¼éƒ½åŠ ä¸Šä¸€ä¸ªå¸¸æ•°ï¼Œä¹˜ä»¥ä¸€ä¸ªå¸¸æ•°ï¼Œæˆ–è€…éƒ½ç½®ä¸ºæŸä¸ªæ•°ã€‚&#xA;å¸¸è§„çº¿æ®µæ ‘ ç»“æ„ å°±æˆ‘çš„ç†è§£è€Œè¨€ï¼Œå¸¸è§„çš„çº¿æ®µæ ‘èƒ½å®ç°çš„åŠŸèƒ½å…¶å®ä¸æ ‘çŠ¶æ•°ç»„æ²¡ä»€ä¹ˆåŒºåˆ«ï¼Œéƒ½åªèƒ½åœ¨ $O(\log n)$ æ—¶é—´å†…å®ç°å•ç‚¹ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢ã€‚&#xA;çº¿æ®µæ ‘çš„æ„é€ ï¼šç»™å®šä¸€ä¸ªåŒºé—´ $[L, R]$ï¼Œå– $mid = L + (R - L) / 2$ï¼Œå°†å®ƒåˆ’åˆ†ä¸º $[L, mid]$ å’Œ $[mid + 1, R]$ ä¸¤ä¸ªåŒºé—´ï¼Œå¦‚æ­¤é€’å½’åœ°åˆ’åˆ†ï¼Œç›´åˆ°åŒºé—´é•¿åº¦ä¸º $1$ ä¸ºæ­¢ï¼Œè¿™äº›çˆ¶åŒºé—´å’Œåˆ’åˆ†ä¸ºå·¦å³ä¸¤è¾¹çš„å­åŒºé—´ï¼Œåœ¨ç»„ç»‡ç»“æ„ä¸Šå¾ˆåƒäºŒå‰æ ‘çš„çˆ¶ç»“ç‚¹å’Œå­ç»“ç‚¹ï¼Œè¿™ä¹Ÿå°±æ˜¯çº¿æ®µæ ‘çš„åå­—ç”±æ¥ã€‚&#xA;æˆ‘ä»¬è¿™é‡Œä»¥åŒºé—´æ±‚å’Œä¸ºä¾‹ï¼Œçº¿æ®µæ ‘çš„æ¯ä¸ªç»“ç‚¹å¯¹åº”ç€ç›¸åº”çš„çº¿æ®µä¸Šçš„ç‚¹çš„å’Œï¼Œä»¥æ•°ç»„ $a = {1,2,3,4,5,6,7,8,9,10}$ ä¸ºä¾‹ï¼Œçº¿æ®µæ ‘çš„ç»“æ„å¦‚å›¾æ‰€ç¤ºï¼š&#xA;å¯ä»¥çœ‹åˆ°ï¼Œçº¿æ®µæ ‘å­˜å‚¨çš„åŸºç¡€å½¢å¼æ˜¯æ•°ç»„ï¼Œä¸äºŒå‰å †çš„å­˜å‚¨æ–¹å¼ä¸€è‡´ï¼Œå‡è®¾å½“å‰çˆ¶ç»“ç‚¹çš„ç¼–å·ä¸º $p$ï¼Œé‚£ä¹ˆå·¦å„¿å­çš„ç¼–å·ä¸º $2 * p$ï¼Œå³å„¿å­çš„ç¼–å·ä¸º $2 * p + 1$ï¼Œç»“ç‚¹çš„å€¼ä¸ºå¯¹åº”åŒºé—´çš„å’Œã€‚&#xA;æ„å»ºçº¿æ®µæ ‘çš„æ–¹å¼å…¶å®ä¸â€œæ±‚ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘çš„å’Œâ€ç±»ä¼¼ï¼Œé€’å½’å¤„ç†æ˜¯å¾ˆå®¹æ˜“çš„ã€‚&#xA;ä»£ç å®ç°ï¼š&#xA;void Build(int idx, int l, int r, vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (l == r) { seg[idx] = nums[l]; return; } int mid = l + (r - l) / 2; Build(2 * idx, l, mid, nums); // é€’å½’æ„å»ºå·¦å­æ ‘ Build(2 * idx, mid + 1, r, nums); // é€’å½’æ„å»ºå³å­æ ‘ seg[idx] = seg[2 * idx] + seg[2 * idx + 1]; // æ›´æ–° seg[idx] } åŒºé—´æŸ¥è¯¢ çº¿æ®µæ ‘çš„åŒºé—´æŸ¥è¯¢ï¼Œå…¶å®åªè¦æŒæ¡äº†é€’å½’ï¼Œå°±å¾ˆå¥½ç†è§£äº†ã€‚</description>
    </item>
    <item>
      <title>æ•°ç»„å½¢å¼ç»„ç»‡çš„æ ‘</title>
      <link>http://localhost:1313/posts/tech/tree_in_array.zh/</link>
      <pubDate>Mon, 12 Jun 2023 13:47:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/tree_in_array.zh/</guid>
      <description>å¼•å…¥ åœ¨ LeetCode ä¸­ï¼ŒäºŒå‰æ ‘ä¸€èˆ¬æ˜¯ä»¥é“¾è¡¨ç»“ç‚¹çš„å½¢å¼ç»„ç»‡çš„ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} }; å…¶å®ä¹Ÿå¯ä»¥ç”¨æ•°ç»„çš„å½¢å¼ç»„ç»‡ï¼Œå³ä½¿ç”¨ $parent$ æ•°ç»„ï¼Œ$y = parent[x]$ è¯´æ˜ $y$ æ˜¯ $x$ çš„çˆ¶ç»“ç‚¹ï¼Œæ ¹ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ä¸º $-1$ï¼Œè¡¨ç¤ºçˆ¶ç»“ç‚¹ä¸å­˜åœ¨ã€‚&#xA;æœ€è¿‘å…¬å…±ç¥–å…ˆ é“¾è¡¨å½¢å¼ å¯¹é“¾è¡¨å½¢å¼æ ‘ï¼Œæ±‚æœ€è¿‘å…¬å…±ç¥–å…ˆå¯ä»¥ä½¿ç”¨é€’å½’å¾ˆæ–¹ä¾¿çš„è§£å†³ï¼š&#xA;/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr || root == p || root == q) { return root; } TreeNode *left = lowestCommonAncestor(root-&amp;gt;left, p, q); TreeNode *right = lowestCommonAncestor(root-&amp;gt;right, p, q); if (left !</description>
    </item>
    <item>
      <title>è·³è¡¨</title>
      <link>http://localhost:1313/posts/tech/skiplist.zh/</link>
      <pubDate>Tue, 06 Jun 2023 18:28:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/skiplist.zh/</guid>
      <description>è·³è¡¨ä»‹ç» è·³è¡¨æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œä½¿å¾—åŒ…å« $n$ ä¸ªå…ƒç´ çš„æœ‰åºåºåˆ—çš„æŸ¥æ‰¾å’Œæ’å…¥æ“ä½œçš„å¹³å‡æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(\log n)$ï¼Œä¸çº¢é»‘æ ‘ã€AVL æ€§èƒ½ç±»ä¼¼ã€‚&#xA;è·³è¡¨çš„å¿«é€ŸæŸ¥è¯¢æ•ˆæœæ˜¯é€šè¿‡ç»´æŠ¤ä¸€ä¸ªå¤šå±‚æ¬¡çš„é“¾è¡¨å®ç°çš„ï¼Œä¸”ä¸å‰ä¸€å±‚ï¼ˆä¸‹é¢ä¸€å±‚ï¼‰çš„é“¾è¡¨å…ƒç´ ç›¸æ¯”ï¼Œæ¯ä¸€å±‚é“¾è¡¨ä¸­çš„å…ƒç´ çš„æ•°é‡æ›´å°‘ï¼Œä¸€å¼€å§‹ï¼Œç®—æ³•åœ¨æœ€ä¸Šå±‚ï¼ˆä¹Ÿæ˜¯æœ€ç¨€ç–çš„ä¸€å±‚ï¼‰æŸ¥æ‰¾ï¼Œç›´åˆ°è¦æŸ¥è¯¢çš„å…ƒç´ åœ¨è¯¥å±‚ç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ ä¸­é—´ã€‚è¿™æ—¶ï¼Œç®—æ³•å°†è·³è½¬åˆ°ä¸‹ä¸€ä¸ªå±‚ï¼Œé‡å¤åˆšæ‰çš„æœç´¢ï¼Œç›´åˆ°æ‰¾åˆ°éœ€è¦æŸ¥æ‰¾çš„å…ƒç´ ä¸ºæ­¢å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š&#xA;å±‚æ•°ç´¢å¼•ä»ä½åˆ°é«˜é€æ¸é€’å¢ã€‚&#xA;æè¿° è·³è¡¨æ˜¯æŒ‰ç…§å±‚æ„å»ºçš„ï¼Œè·³è¡¨çš„æœ€åº•å±‚æ˜¯ä¸€ä¸ªæ™®é€šçš„æœ‰åºé“¾è¡¨ï¼Œæ¯ä¸ªæ›´é«˜å±‚éƒ½æ˜¯ä¸‹å±‚åˆ—è¡¨çš„å­åˆ—è¡¨ï¼Œç›¸å½“äºä¸‹å±‚åˆ—è¡¨çš„å¿«é€Ÿé€šé“ï¼Œè¿™é‡Œå¯ä»¥ç±»æ¯”ä¸€ä¸‹ Bæ ‘ æˆ–è€… B+æ ‘ã€‚&#xA;åœ¨è·³è¡¨ä¸­ï¼Œç¬¬ $i$ å±‚çš„å…ƒç´ ä¼šæœ‰æ¦‚ç‡ $p$ å‡ºç°åœ¨ç¬¬ $i + 1$ å±‚ä¸­ï¼ˆ$p$ é€šå¸¸å– $\frac{1}{2}$ æˆ–è€… $\frac{1}{4}$ï¼‰ï¼Œæ¯ä¸ªå…ƒç´ å¹³å‡å‡ºç°åœ¨ $\frac{1}{1 - p}$ ä¸ªåˆ—è¡¨ä¸­ã€‚&#xA;ä¸€èˆ¬è®¤ä¸ºï¼Œåˆ—è¡¨æœ‰ $log_{\frac{1}{p}}n$ å±‚ï¼Œåœ¨åé¢çš„å®ç°ä¸­ï¼Œæˆ‘ä»¬å›ºå®šäº†åˆ—è¡¨çš„å±‚æ•°ä¸º $klevel = 8$ï¼ŒåŠ¨æ€å±‚æ•°çš„åˆ—è¡¨å®ç°èµ·æ¥æ¯”è¾ƒå¤æ‚ã€‚&#xA;åœ¨æŸ¥æ‰¾ç›®æ ‡å…ƒç´ æ—¶ï¼Œä»é¡¶å±‚åˆ—è¡¨ã€å¤´å…ƒç´ èµ·æ­¥ã€‚ç®—æ³•æ²¿ç€æ¯å±‚é“¾è¡¨æœç´¢ï¼Œç›´è‡³æ‰¾åˆ°ä¸€ä¸ªå¤§äºæˆ–ç­‰äºç›®æ ‡çš„å…ƒç´ ï¼Œæˆ–è€…åˆ°è¾¾å½“å‰å±‚åˆ—è¡¨æœ«å°¾ï¼š&#xA;å¦‚æœè¯¥å…ƒç´ ç­‰äºç›®æ ‡å…ƒç´ ï¼Œåˆ™è¡¨æ˜è¯¥å…ƒç´ å·²è¢«æ‰¾åˆ°ï¼› å¦‚æœè¯¥å…ƒç´ å¤§äºç›®æ ‡å…ƒç´ æˆ–å·²åˆ°è¾¾é“¾è¡¨æœ«å°¾ï¼Œåˆ™é€€å›åˆ°å½“å‰å±‚çš„ä¸Šä¸€ä¸ªå…ƒç´ ï¼Œç„¶åè½¬å…¥ä¸‹ä¸€å±‚è¿›è¡Œæœç´¢ã€‚ æ¯å±‚é“¾è¡¨ä¸­é¢„æœŸçš„æŸ¥æ‰¾æ­¥æ•°æœ€å¤šä¸º $\frac{1}{p}$ï¼Œè€Œå±‚æ•°ä¸º $\log_{\frac{1}{p}}n$ï¼Œå› æ­¤æŸ¥æ‰¾çš„æ€»ä½“æ­¥æ•°ä¸º $\frac{\frac{1}{p}}{\log_{\frac{1}{p}}n}$ï¼Œ$p$ æ˜¯å¸¸æ•°ï¼Œå› æ­¤æ€»ä½“æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ çš„ã€‚&#xA;è·³è·ƒåˆ—è¡¨ä¸åƒå¹³è¡¡æ ‘ç­‰æ•°æ®ç»“æ„é‚£æ ·æä¾›å¯¹æœ€åæƒ…å†µçš„æ€§èƒ½ä¿è¯ï¼šç”±äºç”¨æ¥å»ºé€ è·³è·ƒåˆ—è¡¨é‡‡ç”¨éšæœºé€‰å–å…ƒç´ è¿›å…¥æ›´é«˜å±‚çš„æ–¹æ³•ï¼Œåœ¨å°æ¦‚ç‡æƒ…å†µä¸‹ä¼šç”Ÿæˆä¸€ä¸ªä¸å¹³è¡¡çš„è·³è·ƒåˆ—è¡¨ï¼ˆæœ€åæƒ…å†µä¾‹å¦‚æœ€åº•å±‚ä»…æœ‰ä¸€ä¸ªå…ƒç´ è¿›å…¥äº†æ›´é«˜å±‚ï¼Œæ­¤æ—¶è·³è·ƒåˆ—è¡¨çš„æŸ¥æ‰¾ä¸æ™®é€šåˆ—è¡¨ä¸€è‡´ï¼‰ã€‚&#xA;ä½†æ˜¯åœ¨å®é™…ä¸­å®ƒé€šå¸¸å·¥ä½œè‰¯å¥½ï¼ŒéšæœºåŒ–å¹³è¡¡æ–¹æ¡ˆä¹Ÿæ¯”å¹³è¡¡äºŒå‰æŸ¥æ‰¾æ ‘ç­‰æ•°æ®ç»“æ„ä¸­ä½¿ç”¨çš„ç¡®å®šæ€§å¹³è¡¡æ–¹æ¡ˆå®¹æ˜“å®ç°ã€‚&#xA;å®ç° ä»¥ 1206. Design Skiplist (Hard) ä¸ºä¾‹ï¼Œè¿›è¡Œè·³è¡¨çš„ç®€å•å®ç°ã€‚&#xA;ç”±ä¸Šè¿°å›¾ç‰‡ï¼Œæˆ‘ä»¬å¯ä»¥æ„æƒ³å‡ºç»“ç‚¹çš„æ•°æ®ç»“æ„ï¼š&#xA;ç»“ç‚¹å€¼ $val$ï¼› å­˜å‚¨å½“å‰ç»“ç‚¹æ¯ä¸€å±‚çš„ $next_$ æŒ‡é’ˆï¼ˆè¿™é‡Œä½¿ç”¨ vector å­˜å‚¨ï¼‰ã€‚ ä¸ºäº†æ–¹ä¾¿ç†è§£ï¼Œæˆ‘ä»¬å…¶å®å¯ä»¥æŠŠæ¯ä¸ªç»“ç‚¹éƒ½çœ‹æˆå›¾ä¸­ $klevel$ é«˜åº¦ï¼Œåªæ˜¯æˆ‘ä»¬åªç”»å‡ºæ¥ $next_[i]$ ä¸ä¸º $nullptr$ çš„å¯¹åº”å±‚ç½¢äº†ã€‚ const int klevel = 8; struct Node { int val_; vector&amp;lt;Node *&amp;gt; next_; // next[i] è¡¨ç¤ºå½“å‰ç»“ç‚¹åœ¨ç¬¬ i å±‚çš„ nextï¼Œi ä» 0 å¼€å§‹ Node(int val) : val_(val), next_{klevel, nullptr} { // åˆå§‹åŒ– } }; ä¹‹åï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªè¾…åŠ©å‡½æ•° void Find(int target, veoctor&amp;lt;Node *&amp;gt; pre); æ¥å­˜å‚¨æ¯ä¸€å±‚ä¸­ï¼šæ»¡è¶³å€¼å°äº $target$ å¹¶ä¸”å€¼æœ€å¤§çš„ç»“ç‚¹ã€‚</description>
    </item>
    <item>
      <title>æ•°ä½ DP</title>
      <link>http://localhost:1313/posts/tech/number_dp.zh/</link>
      <pubDate>Tue, 06 Jun 2023 10:37:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/number_dp.zh/</guid>
      <description>å¼•å…¥ æ•°ä½æ˜¯æŒ‡æŠŠä¸€ä¸ªæ•°å­—æŒ‰ç…§ä¸ªã€åã€ç™¾ã€åƒã€ä¸‡ç­‰ç­‰ä¸€ä½ä¸€ä½åœ°æ‹†å¼€ï¼Œå…³æ³¨å®ƒæ¯ä¸€ä½ä¸Šçš„æ•°å­—ã€‚å¦‚æœæ‹†çš„æ˜¯åè¿›åˆ¶æ•°ï¼Œé‚£ä¹ˆæ¯ä¸€ä½æ•°å­—éƒ½æ˜¯ $0\sim 9$ã€‚&#xA;æ•°ä½ DP ä¸€èˆ¬æ˜¯ç”¨æ¥è§£å†³ä¸€ç±»ç‰¹å®šé—®é¢˜ï¼Œä»¥ 1012. Numbers With Repeated Digits (Hard) ä¸ºä¾‹ï¼Œè¿™ä¸€ç±»é—®é¢˜çš„ç‰¹å¾éå¸¸æ˜æ˜¾&#xA;è¦æ±‚ç»Ÿè®¡æ»¡è¶³ä¸€å®šæ¡ä»¶çš„æ•°çš„æ•°é‡ï¼› è¿™äº›æ¡ä»¶ç»è¿‡è½¬åŒ–åå¯ä»¥ä½¿ç”¨â€œæ•°ä½â€çš„æ€æƒ³å»ç†è§£å’Œåˆ¤æ–­ï¼› è¾“å…¥ä¼šæä¾›ä¸€ä¸ªæ•°å­—åŒºé—´ï¼ˆæœ‰æ—¶å€™åªæä¾›ä¸Šç•Œï¼‰æ¥ä½œä¸ºç»Ÿè®¡çš„é™åˆ¶ï¼› ä¸Šç•Œå¾ˆå¤§ï¼ˆä¾‹å¦‚ $10^{22}$ï¼‰ï¼Œæš´åŠ›æšä¸¾ä¼šè¶…æ—¶ã€‚ æ€è·¯ å¯¹ 1012. Numbers With Repeated Digits (Hard)ï¼Œæ€è·¯å¦‚ä¸‹ï¼š&#xA;é¦–å…ˆï¼Œæ­£éš¾åˆ™åï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ $[1, n]$ èŒƒå›´å†…æ— é‡å¤æ•°å­—çš„æ­£æ•´æ•°çš„ä¸ªæ•°ï¼Œè®°ä¸º $res$ï¼Œç„¶åæœ€ç»ˆç»“æœå°±æ˜¯ $n - res + 1$ï¼ˆè‡³äºä¸ºä»€ä¹ˆè¿˜è¦å†åŠ ä¸Š $1$ï¼Œåé¢ä¼šè¯´æ˜ï¼‰ã€‚&#xA;å› æ­¤é—®é¢˜è½¬åŒ–ä¸ºæ±‚ $[1, n]$ èŒƒå›´å†…æ— é‡å¤æ•°å­—çš„æ­£æ•´æ•°çš„ä¸ªæ•°ï¼Œç¬¦åˆä¸Šè¿°çš„æ•°ä½ DP çš„ç‰¹å¾ï¼Œæˆ‘ä»¬å¯ä»¥ä»è®°å¿†åŒ–æœç´¢çš„è§’åº¦å»è€ƒè™‘ï¼Œé¦–å…ˆå°† $n$ è½¬åŒ–ä¸ºå¯¹åº”çš„å­—ç¬¦ä¸²ï¼Œå¯¹å­—ç¬¦ä¸²çš„æ¯ä¸€ä½ï¼Œæšä¸¾æ¯ä¸€ä½å¯èƒ½çš„æ•°ï¼Œå¦‚æœæœ€åç»„æˆçš„æ•°å­—æ»¡è¶³ $num &amp;lt; n$ï¼Œé‚£ä¹ˆ $res += 1$ï¼Œè¿™é‡Œå¾ˆå®¹æ˜“æƒ³åˆ° dfs(string &amp;amp;str, int idx, int mask)ï¼Œ$mask$ ä»¥äºŒè¿›åˆ¶çš„å½¢å¼è¡¨ç¤º $0\sim 9$ èŒƒå›´å†…çš„æ•°æ˜¯å¦è¢«é€‰æ‹©è¿‡ï¼›&#xA;ä½†æ˜¯ä»…ä»…æ˜¯è¿™æ ·ï¼Œæˆ‘ä»¬ä¸èƒ½æ–¹ä¾¿çš„åˆ¤æ–­å½“å‰ç»„æˆçš„æ•°å­—æ˜¯å¦æ»¡è¶³ $num &amp;lt; n$ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªé¢å¤–çš„å‚æ•° $is_limit$ã€‚ä¾‹å¦‚å¯¹æ•°å­— $n = 12345$ï¼Œå¦‚æœå‰é¢å·²ç»é€‰æ‹©çš„æ•°å­—ä¸º $123$ï¼Œé‚£ä¹ˆå¯¹æœ¬æ¬¡æšä¸¾ï¼Œ$is_limit$ ä¸º $true$ï¼Œå³æ•°å­—åªèƒ½é€‰æ‹© $0\sim4$ï¼Œåˆå› ä¸º $1,\ 2,\ 3$ å·²ç»é€‰æ‹©äº†ï¼Œ$mask = 14$ï¼Œå› æ­¤åªæœ‰ $0,\ 4$ å¯ä»¥é€‰ï¼Œäº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œåœ¨é€’å½’çš„è¿‡ç¨‹ä¸­ï¼Œå½“ä¸”ä»…å½“å½“å‰ $is_limit$ ä¸º $true$ï¼Œä¸”å½“å‰é€‰æ‹©çš„æ•°å­—ä¸å¯¹åº”æ•°ä½ä¸Šçš„æ•°å­—ç›¸ç­‰æ—¶ï¼Œæ›´æ·±ä¸€å±‚é€’å½’çš„ $is_limit$ ä»ä¸º $true$ï¼Œè‡³æ­¤ï¼Œé€’å½’å‡½æ•°ä¸º dfs(string &amp;amp;str, int idx, int mask, bool is_limit)ï¼›</description>
    </item>
    <item>
      <title>äºŒåˆ†ç­”æ¡ˆ</title>
      <link>http://localhost:1313/posts/tech/binary_search.zh/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/binary_search.zh/</guid>
      <description>æ¦‚è¿° äºŒåˆ†ç­”æ¡ˆå³åˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾æ¥å¾—åˆ°ç­”æ¡ˆï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå·¦è¾¹ç•Œ $left$ æ˜¯ $0$ æˆ–è€… $1$ï¼›å³è¾¹ç•Œ $right$ åˆ™è§†é¢˜ç›®æ¡ä»¶è€Œå®šï¼Œå–ä¸€ä¸ªå¾ˆå¤§çš„æ•°ï¼Œç„¶ååˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ€æƒ³ï¼Œæ¥æ‰¾åˆ°ç­”æ¡ˆã€‚&#xA;äºŒåˆ†ç­”æ¡ˆçš„è¦æ±‚ å¦‚æœé¢˜ç›®èƒ½å¤Ÿä½¿ç”¨äºŒåˆ†ç­”æ¡ˆçš„æ€æƒ³æ¥è§£å†³ï¼Œé‚£ä¹ˆ $[left, right]$ èŒƒå›´å†…ï¼Œè¦æ»¡è¶³äºŒæ®µæ€§ï¼Œå³å¯¹ $[left, res]$ æ»¡è¶³æ¡ä»¶ $A$ï¼Œè€Œ $(res, right]$ ä¸æ»¡è¶³æ¡ä»¶ $A$ï¼Œå¹¶ä¸” res çš„å–å€¼èŒƒå›´æ˜¯è¿ç»­çš„ã€‚&#xA;é€‚ç”¨æƒ…å†µ å¦‚æœé¢˜ç›®è¦æ±‚æ»¡è¶³ xxx æ¡ä»¶ä¸‹çš„æœ€å¤§å€¼æˆ–è€…æœ€å°å€¼ï¼Œå°±å¯ä»¥è€ƒè™‘äºŒåˆ†ç­”æ¡ˆï¼Œç‰¹åˆ«çš„ï¼Œå¦‚æœé¢˜ç›®è¦æ±‚æœ€å°åŒ–çš„æœ€å¤§å€¼æˆ–è€…æœ€å¤§åŒ–çš„æœ€å°å€¼ï¼Œé‚£ä¹ˆè¦é¦–å…ˆè€ƒè™‘ä½¿ç”¨äºŒåˆ†ç­”æ¡ˆã€‚&#xA;ä¾‹é¢˜ 2517. ç¤¼ç›’çš„æœ€å¤§ç”œèœœåº¦ (Medium)&#xA;class Solution { public: int Bsearch(int target, vector&amp;lt;int&amp;gt; &amp;amp;price, int left) { int right = price.size(); while (left &amp;lt; right) { int mid = left + (right - left) / 2; if (price[mid] &amp;lt; target) { left = mid + 1; } else { right = mid; } } return left; } bool Check(int mid, vector&amp;lt;int&amp;gt; &amp;amp;price, int k, int n) { int start = 0; for (int i = 0; i &amp;lt; k - 1; ++i) { start = Bsearch(price[start] + mid, price, start); // cout &amp;lt;&amp;lt; start &amp;lt;&amp;lt; &amp;#34; start\n&amp;#34;; if (start &amp;gt;= n) { return false; } } return true; } int maximumTastiness(vector&amp;lt;int&amp;gt; &amp;amp;price, int k) { // å…ˆæ’åºï¼Œç„¶åè€ƒè™‘æ˜¯äºŒåˆ†ç­”æ¡ˆè¿˜æ˜¯åŒæŒ‡é’ˆ sort(price.</description>
    </item>
    <item>
      <title>LRU ç®—æ³•ä¸ LFU ç®—æ³•</title>
      <link>http://localhost:1313/posts/tech/lru_lfu.zh/</link>
      <pubDate>Wed, 31 May 2023 16:36:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/lru_lfu.zh/</guid>
      <description>ç®—æ³•ä»‹ç» LRU LRU å…¨ç§°æ˜¯ Least Recently Usedï¼Œå³æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨ç®—æ³•ã€‚&#xA;LRU æ ¹æ®æ•°æ®çš„å†å²è®¿é—®è®°å½•æ¥è¿›è¡Œæ·˜æ±°æ•°æ®ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯â€œå¦‚æœæ•°æ®æœ€è¿‘è¢«è®¿é—®è¿‡ï¼Œé‚£ä¹ˆå°†æ¥è¢«è®¿é—®çš„å‡ ç‡ä¹Ÿæ›´é«˜ï¼Œå®ƒæ˜¯é¡µé¢ç½®æ¢ç®—æ³•çš„ä¸€ç§ï¼Œä¹Ÿå¸¸ç”¨äºç¼“å­˜è®¾è®¡ã€‚&#xA;LFU LFU å…¨ç§°æ˜¯ Least Frequently Usedï¼Œæ ¹æ®é¢‘ç‡æ¥é€‰æ‹©è¦æ·˜æ±°çš„å…ƒç´ ï¼Œå³åˆ é™¤è®¿é—®é¢‘ç‡æœ€ä½çš„å…ƒç´ ï¼Œå¦‚æœä¸¤ä¸ªå…ƒç´ çš„è®¿é—®é¢‘ç‡ç›¸åŒï¼Œåˆ™æ·˜æ±°è®¿é—®é¢‘ç‡æœ€ä½çš„å…ƒç´ ä¸­æœ€ä¹…æ²¡æœ‰è¢«è®¿é—®çš„å…ƒç´ ã€‚&#xA;æ•°æ®ç»“æ„ ä¸ç®¡æ˜¯ LRU è¿˜æ˜¯ LFU ç®—æ³•ï¼Œæˆ‘ä»¬éƒ½éœ€è¦ä½¿ç”¨åˆ°åŒå‘é“¾è¡¨ä½œä¸ºåŸºç¡€æ•°æ®ç»“æ„ï¼Œç”±äº LRU ä¸ LFU æ¶‰åŠçš„å¯¹åŒå‘é“¾è¡¨çš„å…ƒç´ çš„æ“ä½œæ¯”è¾ƒå¤æ‚ï¼Œè¿˜æ¶‰åŠå¯¹é“¾è¡¨ç»“ç‚¹çš„å…¶ä»–æ“ä½œï¼Œå› æ­¤é€‰æ‹©è‡ªå·±æ‰‹å†™ä¸€ä¸ªç®€å•çš„åŒå‘é“¾è¡¨ï¼ŒåŒæ—¶å¤ä¹ åŒå‘é“¾è¡¨çš„å®ç°ï¼ˆé˜¿é‡Œä¸€é¢å°±è¢«é—®åˆ°äº†ï¼ŒåŠå¤©æ²¡å†™å¯¹ğŸ˜…ï¼‰ã€‚&#xA;è¿™é‡Œæ ¹æ® LRU å’Œ LFU çš„éœ€è¦ï¼Œç®€å•å°è£…äº†åˆ é™¤ç»“ç‚¹ã€å°¾éƒ¨æ’å…¥ç»“ç‚¹ã€å’Œåˆ¤æ–­åŒå‘é“¾è¡¨æ˜¯å¦ä¸ºç©ºä¸‰ä¸ªå‡½æ•°ï¼Œå¾ˆå¤§ç¨‹åº¦ä¸Šç®€åŒ–äº† LRU å’Œ LFU çš„å®ç°ï¼Œé™ä½äº†å†™ç®—æ³•å®ç°ä»£ç çš„å‡ºé”™æ¦‚ç‡ã€‚&#xA;struct Node { Node() { } Node(int val, int key) : val_(val), key_(key), next_(nullptr), pre_(nullptr) { } int val_; int freq_; Node *next_; Node *pre_; int key_; }; struct List { Node *vhead_; // è™šæ‹Ÿå¤´ç»“ç‚¹ Node *vtail_; // è™šæ‹Ÿå°¾ç»“ç‚¹ int size_ = 0; // é“¾è¡¨ä¸­æœ‰æ•ˆç»“ç‚¹çš„æ•°é‡ List() : vhead_(new Node()), vtail_(new Node()) { vhead_-&amp;gt;next_ = vtail_; vtail_-&amp;gt;pre_ = vhead_; vhead_-&amp;gt;pre_ = nullptr; vtail_-&amp;gt;next_ = nullptr; } ~List() { delete vtail_; delete vhead_; vhead_ = nullptr; vtail_ = nullptr; } void Insert(Node *node) { // åŒå‘é“¾è¡¨çš„æ’å…¥, node è¡¨ç¤ºå¾…æ’å…¥ç»“ç‚¹ï¼Œæ’å…¥ä½œä¸ºåŒå‘é“¾è¡¨çš„å°¾ç»“ç‚¹ node-&amp;gt;pre_ = vtail_-&amp;gt;pre_; vtail_-&amp;gt;pre_-&amp;gt;next_ = node; vtail_-&amp;gt;pre_ = node; node-&amp;gt;next_ = vtail_; ++size_; } void Delete(Node *node) { // node æŒ‡å‘å¾…åˆ é™¤ç»“ç‚¹ node-&amp;gt;next_-&amp;gt;pre_ = node-&amp;gt;pre_; node-&amp;gt;pre_-&amp;gt;next_ = node-&amp;gt;next_; --size_; } bool Empty() { return size_ &amp;lt;= 0; } }; LRU å®ç° å¯¹äº LRU çš„å®ç°ï¼Œæˆ‘ä»¬éœ€è¦å€ŸåŠ©ä¸¤ä¸ªæ•°ç»„ç»“æ„å“ˆå¸Œè¡¨å’ŒåŒå‘é“¾è¡¨æ¥ç»„æˆä¸€ä¸ªæ–°çš„æ•°æ®ç»“æ„ã€‚æˆ‘ä»¬åˆ©ç”¨å“ˆå¸Œè¡¨å®ç° $O(1)$ æ—¶é—´å¤æ‚åº¦çš„æŸ¥æ‰¾ï¼Œè·å–å…ƒç´ çš„ val ä»¥åŠåœ¨åŒå‘é“¾è¡¨ä¸­çš„ä½ç½®ï¼›åˆ©ç”¨åŒå‘é“¾è¡¨å®ç° $O(1)$ æ—¶é—´å¤æ‚åº¦å†…çš„å…ƒç´ æ’å…¥å’Œåˆ é™¤ã€‚</description>
    </item>
    <item>
      <title>å­—å…¸æ ‘</title>
      <link>http://localhost:1313/posts/tech/trie.zh/</link>
      <pubDate>Mon, 29 May 2023 09:54:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/trie.zh/</guid>
      <description>å®šä¹‰ å­—å…¸æ ‘ï¼ˆTrieï¼‰ï¼Œæ˜¯ä¸€ä¸ªåƒå­—å…¸ä¸€æ ·çš„æ ‘ï¼Œåˆç§°å‰ç¼€æ ‘ã€‚&#xA;å¯ä»¥é«˜æ•ˆçš„æŸ¥è¯¢æŸä¸ªå­—ç¬¦ä¸²æ˜¯å¦åœ¨ä¸€ç»„ç»™å®šçš„å­—ç¬¦ä¸²ä¸­ï¼Œæˆ–è€…è¯´æŸ¥è¯¢æŸä¸ªå•è¯æ˜¯å¦åœ¨å­—å…¸ä¸­ã€‚&#xA;å­—å…¸æ ‘çš„æŸ¥è¯¢æ—¶é—´å¤æ‚åº¦å¯ä»¥è®¤ä¸ºæ˜¯ $O(l)$ï¼Œå…¶ä¸­ $l$ ä¸ºå¾…æŸ¥è¯¢å•è¯çš„é•¿åº¦ã€‚&#xA;å¼•å…¥ å­—å…¸æ ‘ç¤ºæ„å›¾ï¼š&#xA;å¯ä»¥å‘ç°ï¼Œè¿™æ£µå­—å…¸æ ‘ç”¨è¾¹æ¥ä»£è¡¨å­—æ¯ï¼Œè€Œæ ¹ç»“ç‚¹åˆ°æ ‘ä¸Šé¢æŸä¸€ä¸ªèŠ‚ç‚¹çš„è·¯å¾„å°±ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ $1\rightarrow 4\rightarrow 8\rightarrow 12$ è¡¨ç¤ºçš„å°±æ˜¯å­—ç¬¦ä¸² caaï¼Œå¦‚æœç»“ç‚¹ $12$ å¯¹åº”çš„ end_ å­—æ®µçš„å€¼ä¸º $true$ï¼Œè¯´æ˜ caa æ˜¯å­—å…¸æ ‘ä¸­ä¸€ä¸ªå®Œæ•´çš„å­—ç¬¦ä¸²ï¼Œå¦åˆ™åªæ˜¯ä¸€ä¸ªå‰ç¼€ã€‚&#xA;trie çš„ç»“æ„éå¸¸å¥½æ‡‚ï¼Œæˆ‘ä»¬ç”¨ $\delta(u,c)$ è¡¨ç¤ºç»“ç‚¹ $u$ çš„ $c$ å­—ç¬¦æŒ‡å‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œæˆ–ç€è¯´æ˜¯ç»“ç‚¹ $u$ ä»£è¡¨çš„å­—ç¬¦ä¸²åé¢æ·»åŠ ä¸€ä¸ªå­—ç¬¦ $c$ å½¢æˆçš„å­—ç¬¦ä¸²çš„ç»“ç‚¹ã€‚ï¼ˆ $c$ çš„å–å€¼èŒƒå›´å’Œå­—ç¬¦é›†å¤§å°æœ‰å…³ï¼Œä¸ä¸€å®šæ˜¯ $0\sim 26$ ã€‚ï¼‰&#xA;å­—å…¸æ ‘çš„å®ç° è¿™é‡Œæ”¾ä¸€ä¸ªç®€å•çš„å‰ç¼€æ ‘çš„ç±»çš„å®ç°ï¼Œ&#xA;struct Trie { int nex[10000][26], cnt; // nex çš„ç¬¬ä¸€ç»´åº¦è¡¨ç¤ºå‰ç¼€æ ‘çš„ç»“ç‚¹æ•°é‡ï¼Œä¸ä¸Šé¢çš„å›¾ç›¸å¯¹åº” bool end[10000]; // è¯¥ç»“ç‚¹ç»“å°¾çš„å­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨ void insert(char *s, int l) { // æ’å…¥å­—ç¬¦ä¸² int p = 0; for (int i = 0; i &amp;lt; l; i++) { int c = s[i] - &amp;#39;a&amp;#39;; if (!</description>
    </item>
    <item>
      <title>å¿«é€Ÿé€‰æ‹©ç®—æ³•</title>
      <link>http://localhost:1313/posts/tech/quick-select.zh/</link>
      <pubDate>Tue, 11 Apr 2023 19:55:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/quick-select.zh/</guid>
      <description>é—®é¢˜æè¿° ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º$n$çš„æ•°ç»„ï¼Œå¦‚ä½•åœ¨$O(n)$çš„æ—¶é—´å¤æ‚åº¦å†…æ‰¾åˆ°ç¬¬$k$å¤§çš„æ•°ã€‚&#xA;æ€è·¯ æœ´ç´ çš„æƒ³æ³•æ˜¯å…ˆæ’åºï¼Œç„¶åç›´æ¥æ‰¾åˆ°ç¬¬$k$ä¸ªå…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(n\log n)$ã€‚&#xA;æˆ‘ä»¬å¯ä»¥åˆ©ç”¨å¿«é€Ÿæ’åºçš„æ€æƒ³æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè€ƒè™‘å¿«é€Ÿæ’åºçš„åˆ’åˆ†è¿‡ç¨‹ï¼Œåœ¨å¿«é€Ÿæ’åºçš„â€œåˆ’åˆ†â€ç»“æŸåï¼Œæ•°ç»„$A_p \cdots A_r$è¢«åˆ†æˆäº†$A_p\cdots A_q$å’Œ$A_{q+1}\cdots A_r$ï¼Œæ­¤æ—¶å¯ä»¥æŒ‰ç…§å·¦è¾¹å…ƒç´ çš„ä¸ªæ•°ï¼ˆ$q-p+1$ï¼‰å’Œ$k$çš„å¤§å°å…³ç³»æ¥åˆ¤æ–­æ˜¯åªåœ¨å·¦è¾¹è¿˜æ˜¯å³è¾¹é€’å½’çš„æ±‚è§£ã€‚&#xA;ä»£ç  template &amp;lt;Typename T&amp;gt; // ç±»å‹Téœ€è¦å®šä¹‰ &amp;lt; è¿ç®— // arr ä¸ºæŸ¥æ‰¾èŒƒå›´æ•°ç»„ï¼Œrk ä¸ºéœ€è¦æŸ¥æ‰¾çš„æ’åï¼ˆä» 0 å¼€å§‹ï¼‰ï¼Œlen ä¸ºæ•°ç»„é•¿åº¦ T find_kth_element(T arr[], int rk, const int len) { if (len &amp;lt;= 1) { return arr[0]; } // éšæœºé€‰æ‹©åŸºå‡† const T pivot = arr[rand() % len]; // i å½“å‰æ“ä½œçš„å…ƒç´  // j ç¬¬ä¸€ä¸ªç­‰äºpivotçš„å…ƒç´  // k ç¬¬ä¸€ä¸ªå¤§äºpivotçš„å…ƒç´  // å®Œæˆä¸€è¶Ÿä¸‰è·¯å¿«æ’ï¼Œå°†åºåˆ—åˆ†ä¸ºï¼š // å°äº pivot çš„å…ƒç´  ï½œ ç­‰äº pivot çš„å…ƒç´  ï½œ å¤§äº pivot çš„å…ƒç´  int i = 0, j = 0, k = len; while (i &amp;lt; k) { if (arr[i] &amp;lt; pivot) { swap(arr[i++], arr[j++]); } else if (arr[i] &amp;gt; pivot) { swap(arr[i], arr[--k]); } else { ++i; } } // æ ¹æ®è¦æ‰¾çš„æ’åä¸ä¸¤æ¡åˆ†ç•Œçº¿çš„ä½ç½®ï¼Œå»ä¸åŒçš„åŒºé—´é€’å½’æŸ¥æ‰¾ç¬¬kå¤§çš„æ•° // å¦‚æœå°äºpivotçš„å…ƒç´ ä¸ªæ•°æ¯”kå¤šï¼Œåˆ™ç¬¬kå¤§çš„å…ƒç´ ä¸€å®šæ˜¯ä¸€ä¸ªå°äºpivotçš„æ•° if (rk &amp;lt; j) { return find_kth_element(arr, rk, j); } else if (rk &amp;gt;= k){ // å¦åˆ™ï¼Œå¦‚æœå°äºpivotå’Œç­‰äºpivotçš„å…ƒç´ åŠ èµ·æ¥ä¹Ÿæ²¡æœ‰kå¤š // åˆ™ç¬¬kå¤§çš„å…ƒç´ ä¸€å®šæ˜¯ä¸€ä¸ªå¤§äºpivotçš„å…ƒç´  return find_kth_element(arr + k, rk - k, len - k); } else { // å¦åˆ™ï¼Œpivotå°±æ˜¯ç¬¬kå¤§çš„å…ƒç´  return pivot; } } ä¼˜åŒ–ï¼šä¸­ä½æ•°çš„ä¸­ä½æ•° ä¸­ä½æ•°ä¸­çš„ä¸­ä½æ•°ï¼ˆè‹±æ–‡ï¼šMedian of mediansï¼‰ï¼Œæä¾›äº†ä¸€ç§ç¡®å®šæ€§çš„é€‰æ‹©åˆ’åˆ†è¿‡ç¨‹ä¸­åˆ†ç•Œå€¼çš„æ–¹æ³•ï¼Œä»è€Œèƒ½å¤Ÿè®©æ‰¾ç¬¬$k$å¤§çš„æ•°ç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹ä¹Ÿèƒ½å®ç°çº¿æ€§æ—¶é—´å¤æ‚åº¦ã€‚</description>
    </item>
    <item>
      <title>æ‹“æ‰‘æ’åº</title>
      <link>http://localhost:1313/posts/tech/topo-sort.zh/</link>
      <pubDate>Mon, 10 Apr 2023 14:13:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/topo-sort.zh/</guid>
      <description>å®šä¹‰ æ‹“æ‰‘æ’åºï¼ˆTopological sortingï¼‰è¦è§£å†³çš„é—®é¢˜æ˜¯ç»™ä¸€ä¸ªæœ‰å‘å›¾çš„æ‰€æœ‰èŠ‚ç‚¹æ’åºã€‚&#xA;è¿™é‡Œç›´æ¥ä½¿ç”¨OI-Wikiä¸­ä¸¾çš„ä¾‹å­æ¥è¯´æ˜ï¼š&#xA;æˆ‘ä»¬å¯ä»¥æ‹¿å¤§å­¦é€‰è¯¾çš„ä¾‹å­æ¥æè¿°è¿™ä¸ªè¿‡ç¨‹ï¼Œæ¯”å¦‚å­¦ä¹ å¤§å­¦è¯¾ç¨‹ä¸­æœ‰ï¼šå•å˜é‡å¾®ç§¯åˆ†ï¼Œçº¿æ€§ä»£æ•°ï¼Œç¦»æ•£æ•°å­¦æ¦‚è¿°ï¼Œæ¦‚ç‡è®ºä¸ç»Ÿè®¡å­¦æ¦‚è¿°ï¼Œè¯­è¨€åŸºç¡€ï¼Œç®—æ³•å¯¼è®ºï¼Œæœºå™¨å­¦ä¹ ã€‚å½“æˆ‘ä»¬æƒ³è¦å­¦ä¹  ç®—æ³•å¯¼è®º çš„æ—¶å€™ï¼Œå°±å¿…é¡»å…ˆå­¦ä¼š ç¦»æ•£æ•°å­¦æ¦‚è¿° å’Œ æ¦‚ç‡è®ºä¸ç»Ÿè®¡å­¦æ¦‚è¿°ï¼Œä¸ç„¶åœ¨è¯¾å ‚å°±ä¼šå¬çš„ä¸€è„¸æ‡µé€¼ã€‚å½“ç„¶è¿˜æœ‰ä¸€ä¸ªæ›´åŠ å‰çš„è¯¾ç¨‹ å•å˜é‡å¾®ç§¯åˆ†ã€‚&#xA;è¿™äº›è¯¾ç¨‹å°±ç›¸å½“äºå‡ ä¸ªé¡¶ç‚¹$u$, é¡¶ç‚¹ä¹‹é—´çš„æœ‰å‘è¾¹$(u,v)$å°±ç›¸å½“äºå­¦ä¹ è¯¾ç¨‹çš„é¡ºåºã€‚æ˜¾ç„¶æ‹“æ‰‘æ’åºä¸æ˜¯é‚£ä¹ˆçš„éº»çƒ¦ï¼Œä¸ç„¶ä½ æ˜¯å¦‚ä½•é€‰å‡ºåˆé€‚çš„å­¦ä¹ é¡ºåºã€‚ä¸‹é¢å°†ä»‹ç»å¦‚ä½•å°†è¿™ä¸ªè¿‡ç¨‹æŠ½è±¡å‡ºæ¥ï¼Œç”¨ç®—æ³•æ¥å®ç°ã€‚&#xA;ä½†æ˜¯å¦‚æœæŸä¸€å¤©æ’è¯¾çš„è€å¸ˆæ‰“çŒç¡äº†ï¼Œè¯´æƒ³è¦å­¦ä¹  ç®—æ³•å¯¼è®ºï¼Œè¿˜å¾—å…ˆå­¦ æœºå™¨å­¦ä¹ ï¼Œè€Œ æœºå™¨å­¦ä¹  çš„å‰ç½®è¯¾ç¨‹åˆæ˜¯ ç®—æ³•å¯¼è®ºï¼Œç„¶åä½ å°±ä¸€ä¸‡è„¸æ‡µé€¼äº†ï¼Œæˆ‘åˆ°åº•åº”è¯¥å…ˆå­¦å“ªä¸€ä¸ªï¼Ÿå½“ç„¶æˆ‘ä»¬åœ¨è¿™é‡Œä¸è€ƒè™‘ä»€ä¹ˆåŒæ—¶å­¦å‡ ä¸ªè¯¾ç¨‹çš„æƒ…å†µã€‚åœ¨è¿™é‡Œï¼Œç®—æ³•å¯¼è®º å’Œ æœºå™¨å­¦ä¹  é—´å°±å‡ºç°äº†ä¸€ä¸ªç¯ï¼Œæ˜¾ç„¶ä½ ç°åœ¨æ²¡åŠæ³•å¼„æ¸…æ¥šä½ éœ€è¦å­¦ä»€ä¹ˆäº†ï¼Œäºæ˜¯ä½ ä¹Ÿæ²¡åŠæ³•è¿›è¡Œæ‹“æ‰‘æ’åºäº†ã€‚å› è€Œå¦‚æœæœ‰å‘å›¾ä¸­å­˜åœ¨ç¯è·¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ²¡åŠæ³•è¿›è¡Œæ‹“æ‰‘æ’åºäº†ã€‚&#xA;å› æ­¤æˆ‘ä»¬å¯ä»¥è¯´åœ¨ä¸€ä¸ª[[DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰]]ä¸­ï¼Œæˆ‘ä»¬å°†å›¾ä¸­é¡¶ç‚¹ä»¥çº¿æ€§æ–¹å¼æ’åºï¼Œä½¿å¾—å¯¹äºä»»æ„é¡¶ç‚¹$u$åˆ°$v$çš„æœ‰å‘è¾¹$(u, v)$ï¼Œéƒ½æœ‰$u$åœ¨$v$çš„å‰é¢ã€‚&#xA;æˆ–è€…è¯´ç»™å®šä¸€ä¸ªDAGï¼Œå¦‚æœ$i$åˆ°$j$æœ‰è¾¹ï¼Œåˆ™è®¤ä¸º$j$ä¾èµ–äº$i$ï¼Œå¦‚æœ$i$åˆ°$j$æœ‰è·¯å¾„ï¼Œåˆ™ç§°$j$é—´æ¥ä¾èµ–äº$i$ï¼› æ‹“æ‰‘æ’åºçš„ç›®æ ‡æ˜¯å°†æ‰€æœ‰èŠ‚ç‚¹æ’åºï¼Œä½¿å¾—åœ¨å‰é¢çš„èŠ‚ç‚¹ä¸èƒ½ä¾èµ–äºæ’åœ¨åé¢çš„èŠ‚ç‚¹ã€‚&#xA;bfs æ‹“æ‰‘æ’åºæœ‰å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆbfsï¼‰å’Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆdfsï¼‰ä¸¤ç§å®ç°æ–¹å¼ï¼Œè¿™é‡Œæˆ‘ä»¬å…ˆè®¨è®ºbfsã€‚&#xA;åˆ©ç”¨bfså®ç°æ‹“æ‰‘æ’åºéœ€è¦æ ¹æ®èŠ‚ç‚¹çš„å…¥åº¦ï¼š&#xA;å…¥åº¦ï¼šæœ‰å¤šå°‘æ¡è¾¹ç›´æ¥æŒ‡å‘è¯¥èŠ‚ç‚¹&#xA;æ€è·¯ èµ·å§‹æ—¶ï¼Œå°†æ‰€æœ‰å…¥åº¦ä¸º$0$çš„ç‚¹æ”¾å…¥é˜Ÿåˆ—q_in0ï¼› å°†é˜Ÿé¦–å…ƒç´ å‡ºé˜Ÿï¼Œå‡ºé˜Ÿåºåˆ—å°±æ˜¯æˆ‘ä»¬è¦æ±‚çš„æ‹“æ‰‘åºï¼Œå¯¹å½“å‰å¼¹å‡ºçš„èŠ‚ç‚¹uï¼Œres.push_back(u)ï¼Œéå†uçš„æ‰€æœ‰å‡ºåº¦ï¼Œå³éå†æ‰€æœ‰ç”±uç›´æ¥æŒ‡å‘çš„èŠ‚ç‚¹vï¼Œé€’å‡èŠ‚ç‚¹vçš„å…¥åº¦ï¼› å¦‚æœèŠ‚ç‚¹vçš„å…¥åº¦å˜ä¸º0ï¼Œå°†èŠ‚ç‚¹vå…¥é˜Ÿï¼› å¾ªç¯2ã€3æµç¨‹ç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºï¼› å¦‚æœresæœ€åæ°å¥½æœ‰$n$ä¸ªèŠ‚ç‚¹ï¼Œè¯´æ˜åŸå›¾ä¸ºDAGï¼Œresä¸­çš„èŠ‚ç‚¹åºåˆ—å³è¦æ±‚çš„æ‹“æ‰‘åºï¼›å¦åˆ™è¯´æ˜å›¾ä¸­å­˜åœ¨ç¯ã€‚&#xA;ä»£ç å®ç° vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph; int n = graph.size(); int in[n]; // å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦ bool toposrot() { vector&amp;lt;int&amp;gt; res; queue&amp;lt;int&amp;gt; q_in0; for (int i = 0; i &amp;lt; n; ++i) { if (in[i] == 0) { q_in0.push(i); } } while (!</description>
    </item>
    <item>
      <title>kmp ç®—æ³•</title>
      <link>http://localhost:1313/posts/tech/kmp.zh/</link>
      <pubDate>Mon, 27 Mar 2023 16:45:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/kmp.zh/</guid>
      <description>é—®é¢˜æè¿° kmpç®—æ³•è§£å†³çš„æ˜¯å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜ï¼Œå³:å­—ç¬¦ä¸²Pæ˜¯å¦æ˜¯å­—ç¬¦ä¸²Sçš„å­ä¸²ï¼Ÿå¦‚æœæ˜¯ï¼Œå®ƒå‡ºç°åœ¨sçš„å“ªäº›ä½ç½®ï¼Ÿè¿™é‡Œæˆ‘ä»¬ç§° S ä¸ºä¸»ä¸²ï¼ŒP ä¸ºæ¨¡å¼ä¸²ã€‚&#xA;æ€è·¯ é¦–å…ˆæ˜¯æš´åŠ›åŒ¹é…ç®—æ³•ï¼ˆBrute-Forceç®—æ³•ï¼‰ï¼Œä»£ç å¦‚ä¸‹ï¼š&#xA;void BruteForce(string s, string p) { int len_s = s.size(), len_p = p.size(); for (int i = 0; i &amp;lt;= len_s - len_p; ++i) { int flag = true; for (int j = 0; j &amp;lt; len_p; ++j) { if (s[i + j] != p[j]) { flag = false; break; } } if (flag) { printf(&amp;#34;pos = %d\n&amp;#34;, i); } } } æ˜“å¾—æ—¶é—´å¤æ‚åº¦çš„æœ€åæƒ…å†µæ˜¯$O(mn)$çš„ï¼Œå…¶ä¸­$n$ä¸ºsçš„é•¿åº¦ï¼Œ$m$ä¸ºpçš„é•¿åº¦ã€‚</description>
    </item>
    <item>
      <title>å¹¶æŸ¥é›†</title>
      <link>http://localhost:1313/posts/tech/dsu-oi-wiki.zh/</link>
      <pubDate>Wed, 22 Mar 2023 17:59:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dsu-oi-wiki.zh/</guid>
      <description>å¼•å…¥ å¹¶æŸ¥é›†æ˜¯ä¸€ç§ç”¨äºç®¡ç†å…ƒç´ æ‰€å±çš„é›†åˆçš„æ•°æ®ç»“æ„ï¼Œå…¶å®ç°æˆ–è€…è¯´è¡¨ç°ä¸ºä¸€ç‰‡æ£®æ—ï¼Œå…¶ä¸­ï¼Œæ¯æ£µæ ‘è¡¨ç¤ºäº†ä¸€ä¸ªé›†åˆï¼Œæ ‘ä¸­çš„èŠ‚ç‚¹è¡¨ç¤ºå¯¹åº”çš„é›†åˆä¸­çš„å…ƒç´ ï¼š&#xA;é¡¾åæ€ä¹‰ï¼Œå¹¶æŸ¥é›†æ”¯æŒä¸¤ç§æ“ä½œï¼š&#xA;åˆå¹¶ï¼ˆUnionï¼‰ï¼šåˆå¹¶ä¸¤ä¸ªå…ƒç´ æ‰€å±çš„é›†åˆï¼ˆåˆå¹¶å¯¹åº”çš„æ ‘ï¼‰ï¼› æŸ¥è¯¢ï¼ˆFindï¼‰ï¼šæŸ¥è¯¢æŸä¸ªå…ƒç´ æ‰€å±çš„é›†åˆï¼ˆå³æŸ¥è¯¢å¯¹åº”çš„æ ‘çš„æ ¹èŠ‚ç‚¹ï¼‰ï¼Œè¿™å¯ä»¥ç”¨äºåˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦å±äºåŒä¸€ä¸ªé›†åˆï¼› å¹¶æŸ¥é›†åœ¨ç»è¿‡ä¿®æ”¹åè¿˜å¯ä»¥æ”¯æŒå•ä¸ªå…ƒç´ çš„ç§»åŠ¨ã€åˆ é™¤ï¼›ä½¿ç”¨åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘è¿˜å¯ä»¥å®ç°å¯æŒä¹…åŒ–å¹¶æŸ¥é›†ï¼›&#xA;åˆå§‹åŒ– åˆå§‹æ—¶ï¼Œæˆ‘ä»¬è®¾ç½®æ¯ä¸ªå…ƒç´ éƒ½å±äºä¸€ä¸ªå•ç‹¬çš„é›†åˆï¼Œè¡¨ç¤ºä¸ºä¸€æ£µåªæœ‰æ ¹èŠ‚ç‚¹çš„æ ‘ï¼Œæ¯ä¸ªæ ¹èŠ‚ç‚¹çš„çˆ¶äº²éƒ½è®¾ç½®ä¸ºè‡ªå·±ã€‚&#xA;class Dsu { vector&amp;lt;size_t&amp;gt; parent_; // è¡¨ç¤ºæ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ vector&amp;lt;size_t&amp;gt; size_; // è¡¨ç¤ºæ¯æ£µæ ‘æœ‰å¤šå°‘èŠ‚ç‚¹ Dsu(size_t size) : parent_(size), size_(size, 1) { iota(parent_.begin(), parent_.end()); } } æŸ¥è¯¢ æˆ‘ä»¬åªéœ€è¦æ²¿ç€æ ‘å‘ä¸Šç§»åŠ¨ï¼Œç›´åˆ°æ‰¾åˆ°æ ¹èŠ‚ç‚¹ size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x]; } æŸ¥è¯¢æ—¶è¿›è¡Œè·¯å¾„å‹ç¼© æŸ¥è¯¢è¿‡ç¨‹ä¸­ï¼Œç»è¿‡çš„æ¯ä¸ªå…ƒç´ éƒ½å±äºè¯¥é›†åˆï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥å°†å…¶è¿æ¥åˆ°æ ¹èŠ‚ç‚¹ï¼Œä»¥åŠ å¿«åç»­æŸ¥è¯¢ã€‚ size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x] = find(parent_[x]); } åˆå¹¶ è¦åˆå¹¶ä¸¤æ£µæ ‘ï¼Œæˆ‘ä»¬åªéœ€è¦å°†ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹è¿æ¥åˆ°å¦ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ void Dsu::Unite(size_t x, size_t y) { parent_(find(x)) = find(y); } å¯å‘å¼åˆå¹¶ å³å°†èŠ‚ç‚¹è¾ƒå°æˆ–è€…æ·±åº¦è¾ƒå°çš„æ ‘è¿æ¥åˆ°å¦ä¸€æ£µï¼Œè¿™é‡Œä»¥æŒ‰èŠ‚ç‚¹æ•°åˆå¹¶çš„å®ç°ä½œä¸ºå‚è€ƒ:</description>
    </item>
    <item>
      <title>Leetcode å¸¸è§æŠ¥é”™çš„åŸå› åˆ†æ</title>
      <link>http://localhost:1313/posts/tech/leetcode_error.zh/</link>
      <pubDate>Wed, 01 Mar 2023 19:02:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/leetcode_error.zh/</guid>
      <description>é—®é¢˜1 é—®é¢˜æè¿° Line 522: Char 69: runtime error: applying non-zero offset 18446744073709551615 to null pointer (basic_string.h)&#xA;æŠ¥é”™åŸå›  string res = 0&#xA;æŠ¥é”™åˆ†æ è¿™é‡ŒæŠ¥é”™çš„åŸå› æ˜¯å› ä¸ºä½¿ç”¨äº†intæ•´å‹å˜é‡æ¥åˆå§‹åŒ–stringã€‚&#xA;AddressSanitizer: stack-overflow æ ˆæº¢å‡ºï¼Œé€šå¸¸æ˜¯ç”±äºä½¿ç”¨äº†ç¼ºå°‘ç»ˆæ­¢æ¡ä»¶çš„é€’å½’è°ƒç”¨ã€‚</description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo/</guid>
      <description>Description 502.IPO&#xA;Solution Greedy algorithm: if we want to maximize the final capital, we choose the project whose profit is maximum and whose minimum captial required is less than or equal to our current capital.&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;Let key be the profits, value be a map, of which key is the minimum capital required while value is the amount of the corresponding project.&#xA;Code class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.</description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo.zh/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo.zh/</guid>
      <description>é—®é¢˜æè¿° 502.IPO&#xA;è§£é¢˜æ€è·¯ è´ªå¿ƒï¼šè¦æœ€å¤§åŒ–æœ€ç»ˆèµ„æœ¬ï¼Œå› æ­¤å¿…ç„¶é€‰æ‹©æ»¡è¶³å½“å‰èµ„æœ¬éœ€è¦çš„çº¯åˆ©æ¶¦æœ€å¤§çš„é¡¹ç›®ã€‚&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;keyä¸ºçº¯åˆ©æ¶¦ï¼Œvalueä¹Ÿæ˜¯mapï¼Œè¯¥mapçš„keyä¸ºå¯åŠ¨æ‰€éœ€æœ€å°èµ„æœ¬ã€valueä¸ºé¡¹ç›®æ•°é‡ã€‚&#xA;ä»£ç  class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.size(); i++) { projs[profits[i]][capital[i]]++; } for (int i = 0; i &amp;lt; k; i++) { int find_flag = 0; for (auto &amp;amp;prj : projs) { if (w &amp;gt;= ((prj.second).begin())-&amp;gt;first) { w += prj.first; prj.</description>
    </item>
    <item>
      <title>1138.alphabet board path</title>
      <link>http://localhost:1313/posts/leet/1138.alphabet-board-path/</link>
      <pubDate>Sun, 12 Feb 2023 19:14:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1138.alphabet-board-path/</guid>
      <description>Description 1138.alphabet-board-path&#xA;Solution Hash table.&#xA;Notice that we shouldn&amp;rsquo;t go left then go down or go right then go up.&#xA;Code class Solution { public: string alphabetBoardPath(string target) { string res; vector&amp;lt;int&amp;gt; cur_loc{0, 0}; vector&amp;lt;int&amp;gt; target_loc{0, 0}; // è¦æ³¨æ„è¾¹ç¼˜çš„å­˜åœ¨ for (auto &amp;amp;c : target) { target_loc[0] = (c - &amp;#39;a&amp;#39;) / 5; target_loc[1] = (c - &amp;#39;a&amp;#39;) % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col &amp;lt; 0) { res.</description>
    </item>
    <item>
      <title>1138.å­—æ¯æ¿ä¸Šçš„è·¯å¾„</title>
      <link>http://localhost:1313/posts/leet/1138.alphabet-board-path.zh/</link>
      <pubDate>Sun, 12 Feb 2023 19:14:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1138.alphabet-board-path.zh/</guid>
      <description>é—®é¢˜æè¿° 1138.å­—æ¯æ¿ä¸Šçš„è·¯å¾„&#xA;è§£é¢˜æ€è·¯ è€ƒè™‘åˆ°&amp;rsquo;z&amp;rsquo;å•ç‹¬åœ¨ä¸€ä¸ªåœ°æ–¹ï¼Œå› æ­¤ç§»åŠ¨é¡ºåºä¸­ï¼Œå·¦ä¸‹ã€å³ä¸Šä¸èƒ½åè¿‡æ¥ï¼Œå³ä¸èƒ½å…ˆå¾€ä¸‹å†å¾€å·¦æˆ–è€…å…ˆå¾€å³å†å¾€ä¸Šã€‚&#xA;ä»£ç  class Solution { public: string alphabetBoardPath(string target) { string res; vector&amp;lt;int&amp;gt; cur_loc{0, 0}; vector&amp;lt;int&amp;gt; target_loc{0, 0}; // è¦æ³¨æ„è¾¹ç¼˜çš„å­˜åœ¨ for (auto &amp;amp;c : target) { target_loc[0] = (c - &amp;#39;a&amp;#39;) / 5; target_loc[1] = (c - &amp;#39;a&amp;#39;) % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col &amp;lt; 0) { res.insert(res.end(), -move_col, &amp;#39;L&amp;#39;); if (move_row &amp;gt;= 0) res.</description>
    </item>
    <item>
      <title>1604.alert using same key card three or more times in a one hour period</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</guid>
      <description>Description 1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period&#xA;Solution Analog, hash table + sort.&#xA;Code class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>1604.è­¦å‘Šä¸€å°æ—¶å†…ä½¿ç”¨ç›¸åŒå‘˜å·¥å¡å¤§äºç­‰äºä¸‰æ¬¡çš„äºº</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</guid>
      <description>é—®é¢˜æè¿° 1604.è­¦å‘Šä¸€å°æ—¶å†…ä½¿ç”¨ç›¸åŒå‘˜å·¥å¡å¤§äºç­‰äºä¸‰æ¬¡çš„äºº&#xA;è§£é¢˜æ€è·¯ æ¨¡æ‹Ÿï¼Œå“ˆå¸Œè¡¨+æ’åº&#xA;ä»£ç  class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>575.åˆ†ç³–æœ</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies.zh/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies.zh/</guid>
      <description>é—®é¢˜æè¿° 575.åˆ†ç³–æœ&#xA;è§£é¢˜æ€è·¯ æœ€ä¼˜æ€è·¯ä¸ºä¸€ç§ç³–æœåªåƒä¸€é¢—ã€‚&#xA;ä»£ç  class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>575.distribute candies</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies/</guid>
      <description>Description 575.distribute-candies&#xA;Solution The optimal way is to eat only one candy for each kind of candy.&#xA;Code class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>2331.evaluate boolean binary tree</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</guid>
      <description>Description 2331.evaluate-boolean-binary-tree&#xA;Solution dfs(recursion)&#xA;Code class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
    <item>
      <title>2331.è®¡ç®—å¸ƒå°”äºŒå‰æ ‘çš„å€¼</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</guid>
      <description>é—®é¢˜æè¿° 2331.è®¡ç®—å¸ƒå°”äºŒå‰æ ‘çš„å€¼&#xA;è§£é¢˜æ€è·¯ é€’å½’&#xA;ä»£ç  class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
    <item>
      <title>553.optimal division</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division/</guid>
      <description>Description 553.optimal division&#xA;Solution Greedy algorithm&#xA;The optimal method is actually to bracket the penultimate elements.&#xA;Code class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.</description>
    </item>
    <item>
      <title>553.æœ€ä¼˜é™¤æ³•</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division.zh/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division.zh/</guid>
      <description>é—®é¢˜æè¿° 553.æœ€ä¼˜é™¤æ³•&#xA;è§£é¢˜æ€è·¯ è´ªå¿ƒï¼Œæœ€ä¼˜çš„é™¤æ³•å®é™…ä¸Šå°±æ˜¯æŠŠç¬¬äºŒä¸ªåˆ°æœ€åä¸€ä¸ªå…ƒç´ æ‹¬èµ·æ¥ã€‚&#xA;ä»£ç  class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.pop_back(); res.push_back(&amp;#39;)&amp;#39;); return res; } }; </description>
    </item>
    <item>
      <title>1710.maximum units on a truck</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</guid>
      <description>Description 1710.maximum-units-on-a-truck&#xA;Solution Sort boxTypes by the units that the box can load, then put the box of which the units are maximum on the truck one by one.&#xA;The time complexity can be decreased to $O(n)$ by using quick select.&#xA;Code class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.</description>
    </item>
    <item>
      <title>1710.å¡è½¦ä¸Šçš„æœ€å¤§å•å…ƒæ•°</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</guid>
      <description>é—®é¢˜æè¿° 1710.å¡è½¦ä¸Šçš„æœ€å¤§å•å…ƒæ•°&#xA;è§£é¢˜æ€è·¯ æ ¹æ®æ¯ä¸ªç®±å­å¯ä»¥è£…è½½çš„å•å…ƒæ•°é‡ä»å¤§åˆ°å°å¯¹boxTypesæ’åºï¼Œç„¶åæ¯æ¬¡å°†å•å…ƒæ•°é‡æœ€å¤§çš„ç®±å­å¡«å…¥å¡è½¦ã€‚&#xA;ä½¿ç”¨å¿«é€Ÿé€‰æ‹©ç®—æ³•å¯ä»¥å°†æ—¶é—´å¤æ‚åº¦é™ä½åˆ°$O(n)$ã€‚&#xA;ä»£ç  class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.size(); i++) { if (cnt + boxTypes[i][0] &amp;lt;= truckSize) { sum += boxTypes[i][0] * boxTypes[i][1]; cnt += boxTypes[i][0]; } else { sum += (truckSize - cnt) * boxTypes[i][1]; break; } } return sum; } }; </description>
    </item>
    <item>
      <title>1736.latest time by replacing hidden digits</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</guid>
      <description>Description 1736.latest-time-by-replacing-hidden-digits&#xA;Solution Analog + greedy algorithm&#xA;Code class Solution { public: string maximumTime(string time) { string res; // å…ˆè€ƒè™‘å°æ—¶ if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.</description>
    </item>
    <item>
      <title>1736.æ›¿æ¢éšè—æ•°å­—å¾—åˆ°çš„æœ€æ™šæ—¶é—´</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</guid>
      <description>é—®é¢˜æè¿° 1736.æ›¿æ¢éšè—æ•°å­—å¾—åˆ°çš„æœ€æ™šæ—¶é—´&#xA;è§£é¢˜æ€è·¯ æ¨¡æ‹Ÿ+è´ªå¿ƒ&#xA;ä»£ç  class Solution { public: string maximumTime(string time) { string res; // å…ˆè€ƒè™‘å°æ—¶ if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.push_back(time[0]); res.</description>
    </item>
    <item>
      <title>1210.minimum moves to reach target with rotations</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</guid>
      <description>Description 1210.minimum-moves-to-reach-target-with-rotations&#xA;Solution BFS.&#xA;We can use (x, y state) to denote the position of the snake, x as the abscissa of the tail of the snake, y as the ordinate of the tail of the snake. state indicates whether the snake is vertical or horizontal.&#xA;Code class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.</description>
    </item>
    <item>
      <title>1210.ç©¿è¿‡è¿·å®«çš„æœ€å°‘ç§»åŠ¨æ¬¡æ•°</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</guid>
      <description>é—®é¢˜æè¿° 1210.ç©¿è¿‡è¿·å®«çš„æœ€å°‘ç§»åŠ¨æ¬¡æ•°&#xA;è§£é¢˜æ€è·¯ å¹¿åº¦ä¼˜å…ˆæœç´¢&#xA;å¯ä»¥ç”¨(x, y, state)æ¥è¡¨ç¤ºè´ªåƒè›‡å½“å‰æ‰€å¤„çš„ä½ç½®ï¼Œxä¸ºè›‡å°¾çš„æ¨ªåæ ‡ï¼Œyä¸ºè›‡å°¾çš„çºµåæ ‡ï¼Œstateè¡¨ç¤ºè›‡å½“å‰å¤„äºæ°´å¹³è¿˜æ˜¯ç«–ç›´çŠ¶æ€ã€‚&#xA;ä»£ç  class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0) return true; else return false; } } else if (i == 1) { vec_tmp[0] += 1; vec_tmp[2] += 1; if (vec_tmp[2] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0 &amp;amp;&amp;amp; vec_tmp[2] &amp;lt; grid.</description>
    </item>
    <item>
      <title>768.max chunks to make sorted ii</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</guid>
      <description>Description 768.max-chunks-to-make-sorted-ii&#xA;Solution A sufficient condition for an array to be divisible into blocks that satisfy the condition is that all elements in the block are less than or equal to any of the undivided elements in the right-hand array.&#xA;Code class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // è¡¨ç¤ºåˆ’åˆ†arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.</description>
    </item>
    <item>
      <title>768.æœ€å¤šèƒ½å®Œæˆæ’åºçš„å— II</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 768.æœ€å¤šèƒ½å®Œæˆæ’åºçš„å—II&#xA;è§£é¢˜æ€è·¯ å¯ä»¥åˆ’åˆ†æˆæ»¡è¶³æ¡ä»¶çš„å—çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯ï¼Œå—å†…æ‰€æœ‰å…ƒç´ éƒ½å°äºç­‰äºå³ä¾§æ•°ç»„ä¸­æœªåˆ’åˆ†çš„ä»»ä¸€å…ƒç´ ã€‚&#xA;æœ¬é¢˜ä¸­ä½¿ç”¨äº†mapæ¥è¿›è¡Œå¤„ç†ï¼Œå®é™…ä¸Šä½¿ç”¨å•è°ƒæ ˆå°±å¯ä»¥äº†ã€‚&#xA;ä»£ç  class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // è¡¨ç¤ºåˆ’åˆ†arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.size(); i++) r_map[arr[i]]++; while (idx &amp;lt; arr.size()) { for (int i = idx; i &amp;lt; arr.size(); i++) { l_map[arr[i]]++; r_map[arr[i]]--; if (r_map[arr[i]] == 0) r_map.erase(arr[i]); if (r_map.empty()) break; if (l_map.begin()-&amp;gt;first &amp;lt;= r_map.begin()-&amp;gt;first) { idx = i + 1; ans++; break; } } if (r_map.</description>
    </item>
    <item>
      <title>1145.binary tree coloring game</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</guid>
      <description>Description 1145.binary-tree-coloring-game&#xA;Solution Greedy algorithm: for second player, if he wants to win, there are three ways to color the node.&#xA;color the parent node of x, then we use dfs to get the number of red nodes, the number of blue nodes is $n$ minus the nubmer of red nodes; color the left child node of x, then we use dfs to get the number of blue nodes, the number of red nodes is $n$ minus the number of blue nodes; color the right child node of x Code class Solution { public: int get_num(TreeNode *root) { // è·å–å½“å‰æ ‘çš„èŠ‚ç‚¹æ•° if (root !</description>
    </item>
    <item>
      <title>1145.äºŒå‰æ ‘ç€è‰²æ¸¸æˆ</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</guid>
      <description>é—®é¢˜æè¿° 1145.äºŒå‰æ ‘ç€è‰²æ¸¸æˆ&#xA;è§£é¢˜æ€è·¯ è´ªå¿ƒç­–ç•¥ï¼šå¯¹äºŒå·ç©å®¶æ¥è¯´ï¼Œæƒ³è¦å–èƒœï¼Œé€‰æ‹©æŸ“è‰²èŠ‚ç‚¹åªæœ‰ä¸‰ç§å¯èƒ½ï¼š&#xA;é€‰æ‹©xçš„çˆ¶èŠ‚ç‚¹ï¼Œåˆ™é€šè¿‡æ·±åº¦ä¼˜å…ˆæœç´¢å¯ä»¥æ±‚å¾—çº¢è‰²èŠ‚ç‚¹æ•°ï¼Œè“è‰²èŠ‚ç‚¹æ•°ä¸º$n$å‡å»çº¢è‰²èŠ‚ç‚¹æ•° é€‰æ‹©xçš„å·¦å­èŠ‚ç‚¹ï¼Œåˆ™é€šè¿‡dfså¯ä»¥æ±‚å¾—è“è‰²èŠ‚ç‚¹æ•°ï¼Œçº¢è‰²èŠ‚ç‚¹æ•°ä¸º$n$å‡å»è“è‰²èŠ‚ç‚¹æ•° é€‰æ‹©xçš„å³å­èŠ‚ç‚¹ ä»£ç  class Solution { public: int get_num(TreeNode *root) { // è·å–å½“å‰æ ‘çš„èŠ‚ç‚¹æ•° if (root != nullptr) return get_num(root-&amp;gt;left) + get_num(root-&amp;gt;right) + 1; else return 0; } TreeNode *get_pos(int x, int n, TreeNode *root) { // è·å–å½“å‰xå¯¹åº”çš„æŒ‡é’ˆ if (root == nullptr) return nullptr; else { if (root-&amp;gt;val == x) return root; else { TreeNode *l = get_pos(x, n, root-&amp;gt;left); TreeNode *r = get_pos(x, n, root-&amp;gt;right); if (l !</description>
    </item>
    <item>
      <title>1877.minimize maximum pair sum in array</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</guid>
      <description>Description 1877.minimize-maximum-pair-sum-in-array&#xA;Solution Sort the array from smallest to largest, the smallest and largest pair, the next smallest and next largest pair, in that order. The result we need the maximum value of the sum of those pairs.&#xA;Code class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1877.æ•°ç»„ä¸­æœ€å¤§æ•°å¯¹å’Œçš„æœ€å°å€¼</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</guid>
      <description>é—®é¢˜æè¿° 1877.æ•°ç»„ä¸­æœ€å¤§æ•°å¯¹å’Œçš„æœ€å°å€¼&#xA;è§£é¢˜æ€è·¯ è´ªå¿ƒ&#xA;å°†æ•°ç»„ä»å°åˆ°å¤§æ’åºï¼Œæœ€å°æœ€å¤§é…å¯¹ï¼Œæ¬¡å°æ¬¡å¤§é…å¯¹ï¼Œä¾æ¬¡é…å¯¹ï¼Œç»“æœå°±æ˜¯è¿™äº›é…å¯¹å’Œçš„æœ€å¤§å€¼ã€‚&#xA;ä»£ç  class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1129.shortest path with alternating colors</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</guid>
      <description>Description 1129.shortest-path-with-alternating-colors&#xA;Solution First, we need represent the graph as an edge matrix, and we use bfs to find the shortest path.&#xA;In this problem, since the edge color of the shortest path must change along the path, when we judge whether the current node is visited, we should distinguish the cases that the current node is visited by red edges and the cases that the current node is visited by blue edges.</description>
    </item>
    <item>
      <title>1129.é¢œè‰²äº¤æ›¿çš„æœ€çŸ­è·¯å¾„</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</guid>
      <description>é—®é¢˜æè¿° 1129.é¢œè‰²äº¤æ›¿çš„æœ€çŸ­è·¯å¾„&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆï¼Œå°†æœ¬é¢˜çš„å›¾ç»“æ„ä»¥è¾¹è¡¨çš„å½¢å¼è¡¨ç°å‡ºæ¥ï¼Œç„¶åé‡‡å–å¹¿åº¦ä¼˜å…ˆæœç´¢çš„æ–¹å¼å¯»æ‰¾æœ€çŸ­è·¯å¾„ï¼Œä¸€èˆ¬æ¥è¯´å¹¿åº¦ä¼˜å…ˆæœç´¢èƒ½å¤Ÿä¿è¯æ‰¾åˆ°çš„æ˜¯æœ€çŸ­è·¯å¾„ã€‚&#xA;åœ¨æœ¬é¢˜ä¸­ï¼Œç”±äºè¦æ±‚æœ€çŸ­è·¯å¾„æ˜¯äº¤æ›¿å‡ºç°çš„ï¼Œé‚£ä¹ˆåœ¨åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦å·²ç»è®¿é—®è¿‡æ—¶ï¼Œè¦åˆ†çº¢è‰²è·¯å¾„è®¿é—®èŠ‚ç‚¹å’Œè“è‰²è·¯å¾„è®¿é—®èŠ‚ç‚¹ä¸¤ç§æƒ…å†µè®¨è®ºã€‚&#xA;é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ºä¸‰å…ƒç»„tie(point, len, c_flag)ï¼Œåˆ†åˆ«è¡¨ç¤ºå½“å‰èŠ‚ç‚¹çš„ç´¢å¼•ã€åˆ°è¾¾å½“å‰èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ï¼ˆä¸ä¸€å®šæ˜¯æœ€çŸ­çš„ï¼Œæœ¬é¢˜ä¸­å­˜åœ¨ç¯ï¼‰ã€åˆ°è¾¾å½“å‰èŠ‚ç‚¹çš„è·¯å¾„é¢œè‰²ï¼ˆ0è¡¨ç¤ºè“è‰²ï¼Œ1è¡¨ç¤ºçº¢è‰²ï¼‰&#xA;æç¤ºbfs(q, red_connect, blue_connect, answer, n)ï¼ˆå…¶ä¸­qåŒ…å«tie(0, 0, 0)å’Œtie(0, 0, 1)ï¼‰ä¸bfs(q, red_connect, blue_connect, answer, n)æ‰§è¡Œä¸¤æ¬¡ï¼ˆqåˆ†åˆ«ä¸ºtie(0, 0, 0)å’Œtie(0, 0, 1)ï¼‰çš„ç»“æœæ˜¯ä¸€æ ·çš„ã€‚&#xA;ä»£ç  class Solution { public: void bfs(queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;red_connect, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;blue_connect, vector&amp;lt;int&amp;gt; &amp;amp;answer, int n, int i) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; visited(n, vector&amp;lt;int&amp;gt;(2, 0)); // visited[k][1]è¡¨ç¤ºç”±çº¢åˆ°pointï¼Œvisited[k][0]ä¸º1è¡¨ç¤ºç”±è“åˆ°point int tmp_point = 0; while (!q.empty()) { auto [point, len, c_flag] = q.front(); visited[point][c_flag] = 1; q.pop(); if (answer[point] == -1) answer[point] = len; else answer[point] = min(answer[point], len); if (c_flag == 0) { for (int k = 0; k &amp;lt; red_connect[point].</description>
    </item>
    <item>
      <title>2325.decode the message</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message/</guid>
      <description>Description 2325.decode-the-message&#xA;Solution We use arrya as a hash table, to keep track of the order in which the letter appear.&#xA;Code class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // -1 means the letter never appears, other value means the order in which the letter appears for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c !</description>
    </item>
    <item>
      <title>2325.è§£å¯†æ¶ˆæ¯</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</guid>
      <description>é—®é¢˜æè¿° 2325.è§£å¯†æ¶ˆæ¯&#xA;è§£é¢˜æ€è·¯ åˆ©ç”¨æ•°ç»„ä½œä¸ºå“ˆå¸Œè¡¨ï¼Œè®°å½•æ¯ä¸ªå­—æ¯æ˜¯ç¬¬å‡ ä¸ªå‡ºç°çš„&#xA;ä»£ç  class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // ä¸º-1è¡¨ç¤ºè¿™ä¸ªå­—æ¯ä»æœªå‡ºç°è¿‡ï¼Œ0ï¼Œ1ï¼Œ2ç­‰è¡¨ç¤ºè¿™ä¸ªå­—æ¯å¯¹åº”çš„è§£å¯†å­—æ¯ for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c != &amp;#39; &amp;#39;) res.push_back(&amp;#39;a&amp;#39; + arr[c - &amp;#39;a&amp;#39;]); else res.</description>
    </item>
    <item>
      <title>1846.maximum element after decreasing and rearranging</title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</guid>
      <description>Description 1846.maximum-element-after-decreasing-and-rearranging&#xA;Solution Since we can reorder the element in the array as many times as we like, so we should sort the array first. If we want to find the possible maximum number of array whose the first element must be 1 and the absolute difference of any 2 adjacent differences must be less or equal to 1ï¼Œ so we can get arr[i] = min(i + 1, arr[i - 1] + 1).</description>
    </item>
    <item>
      <title>1846.å‡å°å’Œé‡æ–°æ’åˆ—æ•°ç»„åçš„æœ€å¤§å…ƒç´ </title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</guid>
      <description>é—®é¢˜æè¿° 1846.å‡å°å’Œé‡æ–°æ’åˆ—æ•°ç»„åçš„æœ€å¤§å…ƒç´ &#xA;è§£é¢˜æ€è·¯ ç”±äºé¢˜ç›®å…è®¸æˆ‘ä»¬é‡æ–°æ’åˆ—æ•°ç»„ä¸­çš„å…ƒç´ ä»»æ„æ¬¡ï¼Œå› æ­¤é¦–å…ˆå°†æ•°ç»„æ’åºï¼Œæ ¹æ®arrä¸­ç¬¬ä¸€ä¸ªå…ƒç´ å¿…é¡»ä¸º1ï¼Œä»¥åŠç›¸é‚»ä¸¤å…ƒç´ çš„å·®çš„ç»å¯¹å€¼å°äºç­‰äº1ï¼Œå¯å¾—arr[i] = min(i + 1, arr[i - 1] + 1)ï¼ˆå› ä¸ºæˆ‘ä»¬è¦æ‰¾arrå¯èƒ½çš„æœ€å¤§å€¼ï¼‰ï¼Œåˆå› ä¸ºä¸å…è®¸å¢å¤§arrä¸­çš„å…ƒç´ ï¼Œæ‰€ä»¥arr[i] = min(arr[i], i + 1, arr[i - 1] + 1)ã€‚&#xA;ä»£ç  class Solution { public: int maximumElementAfterDecrementingAndRearranging(vector&amp;lt;int&amp;gt;&amp;amp; arr) { sort(arr.begin(), arr.end()); arr[0] = 1; for (int i = 1; i &amp;lt; arr.size(); i++) { arr[i] = min(arr[i - 1] + 1, min(arr[i], i + 1)); } return arr[arr.size() - 1]; } }; </description>
    </item>
    <item>
      <title>2319.check if matrix is X matrix</title>
      <link>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix/</link>
      <pubDate>Tue, 31 Jan 2023 09:50:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix/</guid>
      <description>Description 2319.check-if-matrix-is-X-matrix&#xA;Solution Analog&#xA;Code class Solution { public: bool checkXMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { bool res = true; for (int i = 0; i &amp;lt; grid.size(); i++) { for (int j = 0; j &amp;lt; grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>2319.åˆ¤æ–­çŸ©é˜µæ˜¯å¦æ˜¯ä¸€ä¸ªXçŸ©é˜µ</title>
      <link>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix.zh/</link>
      <pubDate>Tue, 31 Jan 2023 09:50:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix.zh/</guid>
      <description>é—®é¢˜æè¿° 2319.åˆ¤æ–­çŸ©é˜µæ˜¯å¦æ˜¯ä¸€ä¸ªXçŸ©é˜µ&#xA;è§£é¢˜æ€è·¯ æ¨¡æ‹Ÿ&#xA;ä»£ç  class Solution { public: bool checkXMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { bool res = true; for (int i = 0; i &amp;lt; grid.size(); i++) { for (int j = 0; j &amp;lt; grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>1669.merge in between linked list</title>
      <link>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list/</link>
      <pubDate>Mon, 30 Jan 2023 12:22:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list/</guid>
      <description>Description 1669.merge-in-between-linked-list&#xA;Solution Analog&#xA;Code class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i &amp;lt; a - 1; i++) { head = head-&amp;gt;next; } for (int i = 0; i &amp;lt; b; i++) { head2 = head2-&amp;gt;next; } while (tail2-&amp;gt;next != nullptr) tail2 = tail2-&amp;gt;next; tail2-&amp;gt;next = head2-&amp;gt;next; head2-&amp;gt;next = nullptr; head-&amp;gt;next = list2; return list1; } }; </description>
    </item>
    <item>
      <title>1669.åˆå¹¶ä¸¤ä¸ªé“¾è¡¨</title>
      <link>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list.zh/</link>
      <pubDate>Mon, 30 Jan 2023 12:22:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list.zh/</guid>
      <description>é—®é¢˜æè¿° 1669.åˆå¹¶ä¸¤ä¸ªé“¾è¡¨&#xA;è§£é¢˜æ€è·¯ æ¨¡æ‹Ÿ&#xA;ä»£ç  class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i &amp;lt; a - 1; i++) { head = head-&amp;gt;next; } for (int i = 0; i &amp;lt; b; i++) { head2 = head2-&amp;gt;next; } while (tail2-&amp;gt;next != nullptr) tail2 = tail2-&amp;gt;next; tail2-&amp;gt;next = head2-&amp;gt;next; head2-&amp;gt;next = nullptr; head-&amp;gt;next = list2; return list1; } }; </description>
    </item>
    <item>
      <title>1814.count nice pairs in an array</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</link>
      <pubDate>Tue, 17 Jan 2023 17:19:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</guid>
      <description>Description 1814.count-nice-pairs-in-an-array&#xA;Solution We can change the requirements to nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]).&#xA;Then we use hash tables to record the times of occurrence of the value.&#xA;Code class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>1814.ç»Ÿè®¡ä¸€ä¸ªæ•°ç»„ä¸­å¥½å¯¹å­çš„æ•°ç›®</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</link>
      <pubDate>Tue, 17 Jan 2023 17:12:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</guid>
      <description>é—®é¢˜æè¿° 1814.ç»Ÿè®¡ä¸€ä¸ªæ•°ç»„ä¸­å¥½å¯¹å­çš„æ•°ç›®&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆï¼Œå˜æ¢ä¸€ä¸‹é¢˜ç›®çš„éœ€æ±‚ï¼Œnums[i] - rev(nums[i]) == nums[j] - rev(nums[j])ï¼Œç„¶ååˆ©ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªå€¼å‡ºç°äº†å¤šå°‘æ¬¡å°±å¯ä»¥äº†ã€‚&#xA;ä»£ç  class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>ä½è¿ç®—ä¸é›†åˆ</title>
      <link>http://localhost:1313/posts/tech/bit_operation.zh/</link>
      <pubDate>Thu, 05 Jan 2023 14:50:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/bit_operation.zh/</guid>
      <description>å‰è¨€ åœ¨åˆ· LeetCode çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¸¸å¸¸ç¢°åˆ°éœ€è¦æšä¸¾åŒæ—¶é€‰æ‹©å‡ ä¸ªå…ƒç´ ï¼Œæˆ–è€…è¯´æšä¸¾é€‰æ‹©ä¸€ä¸ªé›†åˆçš„æƒ…å†µï¼Œå³åŒæ—¶é€‰æ‹© $\lbrace0, 1, 2\rbrace$ æˆ–è€… $\lbrace0, 1,3\rbrace$ ç­‰ï¼Œè¿™é‡Œé›†åˆä¸­çš„æ•°å­—è¡¨ç¤ºè¦é€‰æ‹©çš„å…ƒç´ çš„ç´¢å¼•ã€‚&#xA;é€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¾€å¾€ä¼šä½¿ç”¨å“ˆå¸Œè¡¨æ¥è¡¨ç¤ºé›†åˆï¼Œå¥½å¤„åœ¨äºå¯ä»¥æ–¹ä¾¿çš„åœ¨ $O(1)$ æ—¶é—´å†…ç¡®å®šå…ƒç´ æ˜¯å¦å¤„äºé›†åˆä¸­ï¼Œåå¤„åˆ™æ˜¯å½“æˆ‘ä»¬éœ€è¦åšé›†åˆä¹‹é—´çš„è¿ç®—ï¼Œä¾‹å¦‚æ±‚äº¤é›†æˆ–è€…å¹¶é›†ï¼Œé‚£ä¹ˆå°±éœ€è¦ $O(n)$ æ—¶é—´æ‰èƒ½å®ç°ï¼›å¦ä¸€ä¸ªç¼ºé™·å°±æ˜¯ï¼Œå½“é€’å½’å‡½æ•°çš„å¯å˜å®å‚ä¸­å­˜åœ¨å“ˆå¸Œè¡¨ï¼ˆæˆ–è€…å¯¹å“ˆå¸Œè¡¨çš„å¼•ç”¨ï¼‰æ—¶ï¼Œæ— æ³•é€šè¿‡æ·»åŠ  $cach$ æ•°ç»„å®ç°è®°å¿†åŒ–æœç´¢ã€‚&#xA;äºæ˜¯ï¼Œæˆ‘ä»¬éœ€è¦æƒ³ä¸€ä¸ªæ–°çš„åŠæ³•æ¥è¡¨ç¤ºé›†åˆï¼Œç”±äºé›†åˆå¯ä»¥ç”±å…¨é›†ï¼ˆåŒ…å«æ‰€æœ‰å…ƒç´ çš„é›†åˆï¼‰ä¸­æ¯ä¸ªå…ƒç´ çš„é€‰æˆ–è€…ä¸é€‰æ¥è¡¨ç¤ºï¼Œå› æ­¤ï¼Œå¾ˆå®¹æ˜“è”æƒ³åˆ°äºŒè¿›åˆ¶ä¸Šæ¯ä¸€ä½çš„ $0$ å’Œ $1$ï¼Œä¾‹å¦‚ $101 = 5$ è¡¨ç¤ºé›†åˆä¸­åªæœ‰ç¬¬ $0$ ä¸ªå…ƒç´ å’Œç¬¬ $2$ ä¸ªå…ƒç´ ã€‚&#xA;ä½¿ç”¨æ•°å­¦åŒ–ä¸€ç‚¹çš„è¯­è¨€ï¼Œå³é›†åˆå¯ä»¥ä»¥å¦‚ä¸‹æ–¹å¼å‹ç¼©æˆäºŒè¿›åˆ¶ä¸‹çš„ä¸€ä¸ªæ•°å­—ï¼š&#xA;$$f(S)=\sum\limits_{i\in S}2^i$$&#xA;å…¶ä¸­ $i$ è¡¨ç¤ºé›†åˆä¸­çš„å…ƒç´ åœ¨åŸæ•°ç»„ä¸­çš„ç´¢å¼•ã€‚$\lbrace a[0], a[1], a[3]\rbrace$ å³å¯ç”± $2^0+2^1+2^3 = 13$ å³äºŒè¿›åˆ¶æ•° $1101$ è¡¨ç¤ºã€‚&#xA;é›†åˆä¸å…ƒç´  æ ¹æ®ä¸Šé¢æåˆ°çš„äºŒè¿›åˆ¶è¡¨ç¤ºé›†åˆçš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ $O(1)$ çš„æ—¶é—´å†…å®ç°é›†åˆä¸å…ƒç´ ä¹‹é—´çš„è¿ç®—ã€‚&#xA;å…·ä½“è¿ç®—è¡¨æ ¼å‚è§çµç¥çš„ ä»é›†åˆè®ºåˆ°ä½è¿ç®—ï¼Œå¸¸è§ä½è¿ç®—æŠ€å·§åˆ†ç±»æ€»ç»“ï¼ã€‚ æ— éœ€è®°å¿†ï¼Œè‡ªå·±åšé¢˜çš„æ—¶å€™å¾ˆå®¹æ˜“å°±èƒ½æ¨å¯¼å‡ºæ¥ã€‚&#xA;é›†åˆä¸é›†åˆ é›†åˆä¸é›†åˆä¹‹é—´çš„è¿ç®—ä¹Ÿå¯ä»¥åœ¨ç”¨äºŒè¿›åˆ¶æ•°è¡¨ç¤ºé›†åˆçš„æƒ…å†µä¸‹ï¼Œåœ¨ $O(1)$ æ—¶é—´å†…å®Œæˆè®¡ç®—ã€‚&#xA;å…·ä½“è¿ç®—è¡¨æ ¼åŒæ ·å‚è§çµç¥çš„ ä»é›†åˆè®ºåˆ°ä½è¿ç®—ï¼Œå¸¸è§ä½è¿ç®—æŠ€å·§åˆ†ç±»æ€»ç»“ï¼ã€‚&#xA;åŒæ ·æ— éœ€è®°å¿†ï¼Œè‡ªå·±åšé¢˜çš„æ—¶å€™å¾ˆå®¹æ˜“å°±èƒ½æ¨å¯¼å‡ºæ¥ã€‚&#xA;éå†é›†åˆ åœ¨é›†åˆç”¨äºŒè¿›åˆ¶æ•° $mask$ è¡¨ç¤ºçš„æƒ…å†µä¸‹ï¼Œé›†åˆä¸­çš„å…ƒç´ ä¸ªæ•°å¯ä»¥ç”± C++ åº“å‡½æ•° __builtin_popcount(mask) è®¡ç®—å‡ºæ¥ã€‚&#xA;è®¾å…ƒç´ èŒƒå›´ä» $0$ åˆ° $n - 1$ï¼ŒæŒ¨ä¸ªåˆ¤æ–­å…ƒç´ æ˜¯å¦åœ¨é›†åˆ $s$ ä¸­ï¼š</description>
    </item>
    <item>
      <title>2042.check if numbers are ascending in a sentence</title>
      <link>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence/</link>
      <pubDate>Tue, 03 Jan 2023 16:34:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence/</guid>
      <description>Description 2042.check-if-numbers-are-ascending-in-a-sentence&#xA;Solution analog1 I change string s to &amp;quot; &amp;quot; + s + &amp;quot; &amp;quot;, then traverse the new string, check whether substr between two blanks is numbers;&#xA;analog2 We just check whether current char is a number, if that, num = num * 10 + s[i] - &#39;0&#39;, loop until current char is not a number.&#xA;Code code1 class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string &amp;amp;s) { int ans = 0; for (int i = l + 1; i &amp;lt; r; i++) { if (s[i] - &amp;#39;0&amp;#39; &amp;lt;= 9 &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt;= 0) { ans += mpow(s[i] - &amp;#39;0&amp;#39;, r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector&amp;lt;int&amp;gt; numbers; s = &amp;#34; &amp;#34; + s + &amp;#34; &amp;#34;; for (int i = 0; i &amp;lt; s.</description>
    </item>
    <item>
      <title>2042.æ£€æŸ¥å¥å­ä¸­çš„æ•°å­—æ˜¯å¦é€’å¢</title>
      <link>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence.zh/</link>
      <pubDate>Tue, 03 Jan 2023 16:34:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence.zh/</guid>
      <description>é—®é¢˜æè¿° 2042.æ£€æŸ¥å¥å­ä¸­çš„æ•°å­—æ˜¯å¦é€’å¢&#xA;è§£é¢˜æ€è·¯ æ¨¡æ‹Ÿä¸€ é¦–å…ˆå°†å­—ç¬¦ä¸²çš„é¦–å°¾éƒ½åŠ ä¸Šç©ºæ ¼ï¼Œç„¶åéå†å³å¯ï¼Œæ£€æŸ¥ä¸¤æ¬¡ç©ºæ ¼ä¹‹é—´çš„å­—ç¬¦ä¸²æ˜¯å¦æ˜¯æ•°å­—ï¼Œå¦‚æœæ˜¯å°±è½¬åŒ–ä¸ºæ•°å­—;&#xA;æ¨¡æ‹ŸäºŒ ç›´æ¥åˆ¤æ–­å­—ç¬¦æ˜¯å¦æ˜¯æ•°å­—ï¼Œå¦‚æœæ˜¯æ•°å­—ï¼Œnum = num * 10 + s[i] - &#39;0&#39;ï¼Œå¾ªç¯ç›´åˆ°ç¢°åˆ°ç©ºæ ¼&#xA;ä»£ç  ä»£ç ä¸€ class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string &amp;amp;s) { int ans = 0; for (int i = l + 1; i &amp;lt; r; i++) { if (s[i] - &amp;#39;0&amp;#39; &amp;lt;= 9 &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt;= 0) { ans += mpow(s[i] - &amp;#39;0&amp;#39;, r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector&amp;lt;int&amp;gt; numbers; s = &amp;#34; &amp;#34; + s + &amp;#34; &amp;#34;; for (int i = 0; i &amp;lt; s.</description>
    </item>
    <item>
      <title>1751.æœ€å¤šå¯ä»¥å‚åŠ çš„ä¼šè®®æ•°ç›®II</title>
      <link>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:09:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 1751.æœ€å¤šå¯ä»¥å‚åŠ çš„ä¼šè®®æ•°ç›®II&#xA;è§£é¢˜æ€è·¯ åŠ¨æ€è§„åˆ’+äºŒåˆ†æ³• ä»¤dp[i][j]è¡¨ç¤ºåœ¨å‰iä¸ªä¼šè®®ï¼Œæœ€å¤šå‚åŠ jä¸ªä¼šè®®ï¼Œæ”¶è·çš„æœ€å¤§ä»·å€¼:&#xA;è€ƒè™‘é€‰æ‹©ä¸å‚åŠ events[i - 1]ï¼Œdp[i][j] = dp[i - 1][j]; é€‰æ‹©å‚åŠ events[i - 1]ï¼Œdp[i][j] = dp[idx][j - 1] + events[i - 1][2]; å…¶ä¸­idxè¡¨ç¤ºç»“æŸæ—¥æœŸå°äºevents[i - 1][0]ä¸”æœ€æ¥è¿‘events[i - 1][0]çš„ä¼šè®®çš„ç´¢å¼•å·ï¼Œå› æ­¤è¿™é‡Œéœ€è¦æŒ‰ç…§ç»“æŸæ—¥æœŸä»å°åˆ°å¤§å¯¹eventsæ’åº; å¯»æ‰¾idxå¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾; äºŒåˆ†æŸ¥æ‰¾è¦æ³¨æ„å…¶ä¸­çš„ä¸å˜é‡ï¼Œå³lå·¦ä¾§çš„å€¼éƒ½å°äºtargetï¼Œrå³ä¾§çš„å€¼éƒ½å¤§äºæˆ–ç­‰äºtarget(è¿™é‡Œæ˜¯å¦ç­‰äºå–å†³äºå…·ä½“å®ç°&amp;gt;=æˆ–è€…&amp;gt;)&#xA;ä»£ç  class Solution { public: int maxValue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;events, int k) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(events.size() + 1, vector&amp;lt;int&amp;gt;(k + 1, 0)); // æŒ‰ç…§ä¼šè®®ç»“æŸé¡ºåºæ’åº std::sort(events.begin(), events.end(), [](auto &amp;amp;a, auto &amp;amp;b) { return a[1] &amp;lt; b[1]; }); // for (int i = 1; i &amp;lt;= events.</description>
    </item>
    <item>
      <title>1945.sum of digits of string after convert</title>
      <link>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert/</link>
      <pubDate>Thu, 15 Dec 2022 18:06:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert/</guid>
      <description>Solution 1945.sum-of-digits-of-string-after-convert&#xA;Solution Code class Solution { public: int getLucky(string s, int k) { vector&amp;lt;int&amp;gt; num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - &amp;#39;a&amp;#39; + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i &amp;lt; k; i++) { while (sum !</description>
    </item>
    <item>
      <title>1945.å­—ç¬¦ä¸²è½¬åŒ–ä¹‹åçš„å„ä½æ•°å­—ä¹‹å’Œ</title>
      <link>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:06:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert.zh/</guid>
      <description>é—®é¢˜æè¿° 1945.å­—ç¬¦ä¸²è½¬åŒ–åçš„å„ä½æ•°å­—ä¹‹å’Œ&#xA;è§£é¢˜æ€è·¯ æ­£å¸¸æ€è·¯å°±å¥½ã€‚&#xA;ä»£ç  class Solution { public: int getLucky(string s, int k) { vector&amp;lt;int&amp;gt; num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - &amp;#39;a&amp;#39; + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i &amp;lt; k; i++) { while (sum !</description>
    </item>
    <item>
      <title>443.å‹ç¼©å­—ç¬¦ä¸²</title>
      <link>http://localhost:1313/posts/leet/443.string-compression.zh/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression.zh/</guid>
      <description>é—®é¢˜æè¿° 443.å‹ç¼©å­—ç¬¦ä¸²&#xA;è§£é¢˜æ€è·¯ åŒæŒ‡é’ˆã€æ»‘åŠ¨çª—å£ï¼Œæ³¨æ„forå¾ªç¯ä¸­ä¸éœ€è¦fast++ã€‚&#xA;ä»£ç  class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.push_back(chars[slow]); res.push_back(cnt + &amp;#39;0&amp;#39;); } else if (cnt &amp;gt;= 10 &amp;amp;&amp;amp; cnt &amp;lt;= 99) { res.</description>
    </item>
    <item>
      <title>443.string compression</title>
      <link>http://localhost:1313/posts/leet/443.string-compression/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression/</guid>
      <description>Description 443.string-compression&#xA;Solution Sliding window, please pay attention to that fast++ is not needed in for loop.&#xA;Code class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.</description>
    </item>
    <item>
      <title>1812.determine color of a chessboard square</title>
      <link>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square/</link>
      <pubDate>Thu, 08 Dec 2022 16:00:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square/</guid>
      <description>Description 1812.determine color of a chessboard square&#xA;Solution Easy&#xA;Code class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - &amp;#39;a&amp;#39; + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>1812.åˆ¤æ–­å›½é™…è±¡æ£‹æ£‹ç›˜ä¸­ä¸€ä¸ªæ ¼å­çš„é¢œè‰²</title>
      <link>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square.zh/</link>
      <pubDate>Thu, 08 Dec 2022 16:00:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square.zh/</guid>
      <description>é—®é¢˜æè¿° 1812.åˆ¤æ–­å›½é™…è±¡æ£‹æ£‹ç›˜ä¸­ä¸€ä¸ªæ ¼å­çš„é¢œè‰²&#xA;è§£é¢˜æ€è·¯ å¤ªç®€å•äº†ï¼Œä¸å†™&#xA;ä»£ç  class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - &amp;#39;a&amp;#39; + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>698.partition to k equal sum subsets</title>
      <link>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets/</link>
      <pubDate>Thu, 08 Dec 2022 15:47:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets/</guid>
      <description>Description 698.partition-to-k-equal-sum-subsets&#xA;Solution Sort array from large to small, so that we can avoid making mistake of judging arrays like [1, 1, 2, 2].&#xA;We use used[i] to avoid using the same element more than once, if sum == target, sum = 0, if cnt == k, than it can be devided.&#xA;Code class Solution { public: bool dfs(vector&amp;lt;int&amp;gt; &amp;amp;nums, int index, int sum, int target, int cnt, int k, vector&amp;lt;int&amp;gt; &amp;amp;used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); // pay attention to the `idx - 1` rather than `index - 1` } for (int i = index; i &amp;gt;= 0; i--) { if (used[i] || sum + nums[i] &amp;gt; target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k !</description>
    </item>
    <item>
      <title>698.åˆ’ä¸ºkä¸ªç›¸ç­‰çš„å­é›†</title>
      <link>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets.zh/</link>
      <pubDate>Thu, 08 Dec 2022 15:47:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets.zh/</guid>
      <description>é—®é¢˜æè¿° 698.åˆ’ä¸ºkä¸ªç›¸ç­‰çš„å­é›†&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆï¼Œå¯¹æ•°ç»„æŒ‰ç…§ä»å¤§åˆ°å°æ’åºï¼Œç›¸æ¯”ä»å°åˆ°å¤§æ’åºï¼Œèƒ½é¿å…[1, 1, 2, 2]è¿™æ ·çš„æ•°ç»„çš„è¯¯åˆ¤;&#xA;åˆ©ç”¨used[i]æ•°ç»„é¿å…é‡å¤ä½¿ç”¨åŒä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœsum == targetï¼Œå°±å°†sumç½®é›¶ï¼Œå¦‚æœcnt == kï¼Œè¯´æ˜æ»¡è¶³æ¡ä»¶ã€‚&#xA;ä»£ç  class Solution { public: bool dfs(vector&amp;lt;int&amp;gt; &amp;amp;nums, int index, int sum, int target, int cnt, int k, vector&amp;lt;int&amp;gt; &amp;amp;used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); //æ³¨æ„è¿™é‡Œæ˜¯idex - 1è€Œä¸æ˜¯index - 1 } for (int i = index; i &amp;gt;= 0; i--) { if (used[i] || sum + nums[i] &amp;gt; target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k !</description>
    </item>
    <item>
      <title>438.find all anagrams in a string</title>
      <link>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string/</link>
      <pubDate>Wed, 07 Dec 2022 19:23:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string/</guid>
      <description>Description 438.find-all-anagrams-in-a-string&#xA;Solution Similar to 30.substring-with-concatenation-of-all-words, easier.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { unordered_map&amp;lt;char, int&amp;gt; mp; for (char &amp;amp;c : p) mp[c]++; vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;char, int&amp;gt; tmp = mp; for (int l = 0, r = 0; r &amp;lt; s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.</description>
    </item>
    <item>
      <title>438.æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯</title>
      <link>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string.zh/</link>
      <pubDate>Wed, 07 Dec 2022 19:23:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string.zh/</guid>
      <description>é—®é¢˜æè¿° 438.æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯&#xA;è§£é¢˜æ€è·¯ å‚ç…§30.ä¸²è”æ‰€æœ‰å•è¯ä¸²ï¼Œæ€è·¯å®Œå…¨ä¸€è‡´ã€‚&#xA;ä»£ç  class Solution { public: vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { unordered_map&amp;lt;char, int&amp;gt; mp; for (char &amp;amp;c : p) mp[c]++; vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;char, int&amp;gt; tmp = mp; for (int l = 0, r = 0; r &amp;lt; s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.find(s[r]) != mp.end()) { while (s[l] !</description>
    </item>
    <item>
      <title>93.restore ip addresses</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses/</guid>
      <description>Description 93.restore-ip-addresses&#xA;Solution Backtracking is actually changing a problem to one like a tree, and doing DFS(depth first search).&#xA;Code class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.</description>
    </item>
    <item>
      <title>93.å¤åŸipåœ°å€</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</guid>
      <description>é—®é¢˜æè¿° 93.å¤åŸipåœ°å€&#xA;è§£é¢˜æ€è·¯ å›æº¯å®é™…ä¸Šå°±æ˜¯è½¬åŒ–ä¸ºæ ‘å½¢é—®é¢˜ï¼Œåšæ·±åº¦ä¼˜å…ˆéå†ã€‚&#xA;ä»£ç  class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.size()) { if (cnt == 4) { ip.</description>
    </item>
    <item>
      <title>1775.equal sum arrays with minimum number of operations</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</guid>
      <description>Description 1775.equal-sum-arrays-with-minmum-number-of-operations&#xA;Solution hash table + greedy algorithm The general idea of this problem is hash + greedy algorithm.&#xA;Assuming that the sum1 minus sum2 to be diff and diff &amp;gt; 0, to reduce the difference of the sum of two arrays, we should make diff be value minus the maximum value of changing a number in one of the two array, and make the count of number changed minus 1, until diff &amp;lt; 0.</description>
    </item>
    <item>
      <title>1775.é€šè¿‡æœ€å°‘æ“ä½œæ¬¡æ•°ä½¿æ•°ç»„çš„å’Œç›¸ç­‰</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</guid>
      <description>é—®é¢˜æè¿° 1775.é€šè¿‡æœ€å°‘æ“ä½œæ¬¡æ•°ä½¿æ•°ç»„çš„å’Œç›¸ç­‰&#xA;è§£é¢˜æ€è·¯ å“ˆå¸Œ+è´ªå¿ƒ æœ¬é¢˜æ€»ä½“æ€è·¯ä¸ºå“ˆå¸Œ+è´ªå¿ƒï¼Œç”¨ä¸¤ä¸ªæ•°ç»„mp1ï¼Œmp2è®°å½•nums1ï¼Œnums2ä¸­æ¯ä¸ªæ•°å„å‡ºç°äº†å¤šå°‘æ¬¡;&#xA;å‡è®¾nums1çš„å’Œsum1å‡å»nums2çš„å’Œsum2çš„ç»“æœä¸ºdiffï¼Œè¿™é‡Œå‡è®¾diff &amp;gt; 0ï¼Œä¸ºäº†æŠ¹å¹³ä¸¤ä¸ªæ•°ç»„çš„å’Œçš„å·®è·ï¼Œåº”è¯¥æ¯æ¬¡å‡å»ä¸¤ä¸ªæ•°ç»„ä¸­ï¼Œå˜åŒ–æ•°å­—å¼•èµ·çš„æ•°å€¼å˜åŒ–çš„æœ€å¤§å€¼ï¼Œå¹¶ä¸”å°†å˜åŒ–çš„æ•°å­—çš„è®¡æ•°å€¼å‡ä¸€;&#xA;nums1çš„å’Œå°äºnums2çš„å’Œçš„æƒ…å†µç±»ä¼¼ã€‚&#xA;ä¼˜åŒ– é¦–å…ˆå‡è®¾sum1 &amp;lt; sum2ï¼Œå¦åˆ™æˆ‘ä»¬äº¤æ¢nums1å’Œnums2å¹¶äº¤æ¢sum1å’Œsum2å³å¯ï¼Œæ¥ä¸‹æ¥ï¼Œå¿…å®šæ˜¯nums1ç¼©å°ï¼Œnums2å¢å¤§ï¼Œå¯¹åº”diff = sum2 - sum1ç¼©å°ï¼Œdiffå¯ä»¥å‡å°‘1,2,3,4,5å„è‹¥å¹²æ¬¡ï¼Œå–å†³äºnums1å’Œnums2ä¸­åŸå…ˆå„ä¸ªæ•°çš„æ•°é‡ï¼Œç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨æ¥è®°å½•ï¼Œæœ€åæˆ‘ä»¬ä»å¤§åˆ°å°éå†i = 5, 4, 3, 2, 1.&#xA;ä»£ç  hash + greedy algorithm class Solution { public: int find_min(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = 1; i &amp;lt; v.size(); i++) { if (v[i] != 0) return i; } return 6; } int find_max(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = v.size() - 1; i &amp;gt;= 1; i--) { if (v[i] !</description>
    </item>
    <item>
      <title>219.contains duplicate ii</title>
      <link>http://localhost:1313/posts/leet/219.contains-duplicate-ii/</link>
      <pubDate>Tue, 06 Dec 2022 20:00:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/219.contains-duplicate-ii/</guid>
      <description>Description 219.contains-duplicate-ii&#xA;Solution We can use unordered_map to record the number of ocurrence of each integer and slide window accrording the unordered_map.&#xA;Code class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] &amp;lt;= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; </description>
    </item>
    <item>
      <title>219.å­˜åœ¨é‡å¤å…ƒç´ II</title>
      <link>http://localhost:1313/posts/leet/219.contains-duplicate-ii.zh/</link>
      <pubDate>Tue, 06 Dec 2022 20:00:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/219.contains-duplicate-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 219.å­˜åœ¨é‡å¤å…ƒç´ II&#xA;è§£é¢˜æ€è·¯ åˆ©ç”¨unordered_mapè®°å½•å…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œä½¿ç”¨æ»‘åŠ¨çª—å£æ³•ã€‚&#xA;ä»£ç  class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] &amp;lt;= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; </description>
    </item>
    <item>
      <title>396.rotate function</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function/</guid>
      <description>Description 396. rotate-function&#xA;Solution The key is to find the mathematical laws&#xA;Code class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>396.æ—‹è½¬å‡½æ•°</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function.zh/</guid>
      <description>é—®é¢˜æè¿° 396.æ—‹è½¬å‡½æ•°&#xA;è§£é¢˜æ€è·¯ å…³é”®åœ¨äºæ‰¾åˆ°æ•°å­¦è§„å¾‹&#xA;ä»£ç  class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.size(); i++) { res[i] = res[i - 1] + sum - (nums.</description>
    </item>
    <item>
      <title>1796.second largest digit in a string</title>
      <link>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string/</link>
      <pubDate>Tue, 06 Dec 2022 19:47:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string/</guid>
      <description>Description 1796.second-largest-digit-in-a-string&#xA;Solution Just traversing.&#xA;Code class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] &amp;lt;= &amp;#39;9&amp;#39;) { if (s[i] - &amp;#39;0&amp;#39; &amp;gt; first) { second = first; first = s[i] - &amp;#39;0&amp;#39;; } else if (s[i] - &amp;#39;0&amp;#39; &amp;lt; first &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt; second) second = s[i] - &amp;#39;0&amp;#39;; } } return second; } }; </description>
    </item>
    <item>
      <title>1796.å­—ç¬¦ä¸²ä¸­ç¬¬äºŒå¤§çš„æ•°å­—</title>
      <link>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:47:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string.zh/</guid>
      <description>é—®é¢˜æè¿° 1796.å­—ç¬¦ä¸²ä¸­ç¬¬äºŒå¤§çš„æ•°å­—&#xA;è§£é¢˜æ€è·¯ éå†å°±å¥½äº†&#xA;ä»£ç  class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] &amp;lt;= &amp;#39;9&amp;#39;) { if (s[i] - &amp;#39;0&amp;#39; &amp;gt; first) { second = first; first = s[i] - &amp;#39;0&amp;#39;; } else if (s[i] - &amp;#39;0&amp;#39; &amp;lt; first &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt; second) second = s[i] - &amp;#39;0&amp;#39;; } } return second; } }; </description>
    </item>
    <item>
      <title>1805.number of different integers in a string</title>
      <link>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string/</link>
      <pubDate>Tue, 06 Dec 2022 19:14:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string/</guid>
      <description>Descripiton 1805.number-of-different-integers-in-a-string&#xA;Solution Treating numbers as strings, save them in unordered_set, we need pay attention to pilot zero and the condition which last character is a number.&#xA;Code class Solution { public: int numDifferentIntegers(string word) { unordered_set&amp;lt;string&amp;gt; words; string str; for (int i = 0; i &amp;lt; word.size(); i++) { if (str.empty()) { if (word[i] - &amp;#39;0&amp;#39; &amp;lt;= 9) str.push_back(word[i]); } else { if (word[i] - &amp;#39;0&amp;#39; &amp;gt; 9) { if (words.</description>
    </item>
    <item>
      <title>1805.å­—ç¬¦ä¸²ä¸­ä¸åŒæ•´æ•°çš„æ•°ç›®</title>
      <link>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:14:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string.zh/</guid>
      <description>é—®é¢˜æè¿° 1805.å­—ç¬¦ä¸²ä¸­ä¸åŒæ•´æ•°çš„æ•°ç›®&#xA;è§£é¢˜æ€è·¯ æŠŠæ•°å­—å½“ä½œå­—ç¬¦ä¸²å¤„ç†ï¼Œå­˜å…¥unordered_set(å“ˆå¸Œè¡¨)ä¸­ï¼Œæ³¨æ„æœ€åä¸€ä¸ªå­—ç¬¦æ˜¯æ•°å­—çš„æƒ…å†µã€‚&#xA;ä»£ç  class Solution { public: int numDifferentIntegers(string word) { unordered_set&amp;lt;string&amp;gt; words; string str; for (int i = 0; i &amp;lt; word.size(); i++) { if (str.empty()) { if (word[i] - &amp;#39;0&amp;#39; &amp;lt;= 9) str.push_back(word[i]); } else { if (word[i] - &amp;#39;0&amp;#39; &amp;gt; 9) { if (words.find(str) == words.end()) words.insert(str); str.clear(); } else { if (str.size() == 1 &amp;amp;&amp;amp; str[0] == &amp;#39;0&amp;#39;) { // å»é™¤å…ˆå¯¼0 str.clear(); } str.push_back(word[i]); } } } if (!</description>
    </item>
    <item>
      <title>131.palindrome patitioning</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning/</guid>
      <description>Description 131.palindrome-partitioning&#xA;Solution We can whether it is palindrome by dynamic programming: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;When traversing, pay attention to the order of traversing i;&#xA;Last, we use backtracking to update res.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.</description>
    </item>
    <item>
      <title>131.åˆ†å‰²å›æ–‡ä¸²</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</guid>
      <description>é—®é¢˜æè¿° 131.åˆ†å‰²å›æ–‡ä¸²&#xA;è§£é¢˜æ€è·¯ åˆ©ç”¨åŠ¨æ€è§„åˆ’æ¥åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;è¿™é‡Œéå†çš„æ—¶å€™è¦æ³¨æ„içš„éå†é¡ºåº;&#xA;æœ€åè€ƒè™‘åˆ©ç”¨å›æº¯æ³•ï¼Œæ›´æ–°ç­”æ¡ˆã€‚&#xA;ä»£ç  class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.size(); i++) { if (dp[index][i]) { res_tmp.push_back(s.substr(index, i - index + 1)); track_back(s, i + 1, dp); res_tmp.pop_back(); } } return; } vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) { vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>3.longest substring without repeating characters</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</guid>
      <description>Description 3.longest-substring-withou-repeating-characters&#xA;Solution We use arr[96] to record the number of occurence of each character. If the number is larger than 1, than there is repeating character between l and r; else, update res, if current length of substr is larger than res.&#xA;Code class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.</description>
    </item>
    <item>
      <title>3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</guid>
      <description>é—®é¢˜æè¿° 3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²&#xA;è§£é¢˜æ€è·¯ ç”¨arr[96]è®°å½•æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°ï¼Œå¦‚æœå­—ç¬¦æ¬¡æ•°å¤§äº1ï¼Œè¯´æ˜å·²ç»åŒ…å«äº†é‡å¤å­—ç¬¦ï¼Œåˆ™è¦æ›´æ–°lï¼Œå¦åˆ™é€’å¢rï¼Œå¹¶è®°å½•æœ€å¤§çš„å­ä¸²é•¿åº¦ã€‚&#xA;ä»£ç  class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.size(); r++) { arr[s[r] - &amp;#39; &amp;#39;]++; if (arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) { while (l &amp;lt; r &amp;amp;&amp;amp; arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) arr[s[l++] - &amp;#39; &amp;#39;]--; } else { res = max(r - l + 1, res); } } return res; } }; </description>
    </item>
    <item>
      <title>30.substring with concatenation of all words</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</guid>
      <description>Description 30.substring-with-concatenation-of-all-words&#xA;Solution For each word sequence {s.substr(i, word_len), s.substr(i + word_len, word_len)...} of i($[0, word_len - 1]$), we use sliding window to judge;&#xA;We should pay attention to the detail when judging. We can use mp to determine whether substr is in words, and mp_tmp to determine whether it is concatenated substring, if mp is empty, then it is;&#xA;For key-value in mp_tmp, if value becomes 0, then erase(key);</description>
    </item>
    <item>
      <title>30.ä¸²è”æ‰€æœ‰å•è¯ä¸²</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</guid>
      <description>é—®é¢˜æè¿° 30.ä¸²è”æ‰€æœ‰å•è¯ä¸²&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆï¼Œç”±äºwordsä¸­æ‰€æœ‰å­—ç¬¦ä¸²é•¿åº¦ç›¸åŒï¼Œè¦æ¯”è¾ƒwordsä¸s: - sä»i = 0å¼€å§‹ï¼Œå¯ä»¥åˆ’åˆ†ä¸ºä¸€ç³»åˆ—çš„é•¿ä¸ºword_len = words[0].size()çš„å•è¯; - sä»i = 1å¼€å§‹ï¼Œå¯ä»¥åˆ’åˆ†ä¸ºä¸€ç³»åˆ—çš„é•¿ä¸ºword_len = words[0].size()çš„å•è¯; - &amp;hellip;&amp;hellip; - sä»i = word_len - 1å¼€å§‹&amp;hellip;&amp;hellip;&#xA;ç„¶åè¦æ³¨æ„åˆ©ç”¨unordered_map&amp;lt;string, int&amp;gt;åˆ¤æ–­æ˜¯å¦æ»¡è¶³æ¡ä»¶çš„ç»†èŠ‚ï¼Œmpç”¨äºåˆ¤æ–­wordæ˜¯å¦åœ¨wordsä¸­;&#xA;mp_tmpçš„é”®å€¼å¯¹ä¸­ï¼Œå¦‚æœå€¼ä¸º0ï¼Œå°±åˆ æ‰è¯¥é”®;&#xA;è¿˜è¦æ³¨æ„lçš„å¤„ç†ï¼Œåˆ†ä¸ºåœ¨mp_tmpä¸ºç©ºï¼Œå’Œmp_tmpä¸ä¸ºç©ºï¼Œä½†æ˜¯wordå·²ç»å‡ºç°äº†è¶…è¿‡wordsä¸­çš„æ¬¡æ•°.&#xA;ä»£ç  class Solution { public: vector&amp;lt;int&amp;gt; findSubstring(string s, vector&amp;lt;string&amp;gt; &amp;amp;words) { unordered_map&amp;lt;string, int&amp;gt; mp; int word_len = words[0].size(); int cnt = 0; vector&amp;lt;int&amp;gt; res; for (int i = 0; i &amp;lt; words.size(); i++) { mp[words[i]]++; cnt++; } if (cnt * word_len &amp;gt; s.</description>
    </item>
    <item>
      <title>1610.maximum Number of Visible Points</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</guid>
      <description>Descripiton 1610.maximum-number-of-visible-points&#xA;Soluiton We can use function atan2 to change slope to angle in $-\pi ~ \pi$.&#xA;We need also expand arrays, let angle[n + i] = angle[i] + 360, and the length of array to be 2 * n, so we can avoid omission.&#xA;Code class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // ç”¨æ¥æ ‡è®°è¿™æ˜¯ä¸€ä¸ªé‡å çš„ç‚¹ else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>1610.å¯è§ç‚¹çš„æœ€å¤§æ•°ç›®</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</guid>
      <description>é—®é¢˜æè¿° 1610.å¯è§ç‚¹çš„æœ€å¤§æ•°ç›®&#xA;è§£é¢˜æ€è·¯ åˆ©ç”¨atan2å‡½æ•°ï¼Œå³å¯å°†æ–œç‡è½¬åŒ–ä¸º$-\pi ~ \pi$çš„è§’åº¦;&#xA;æ‰©å……æ•°ç»„ï¼Œä»¤angle[n + i] = angle[i] + 360ï¼Œä½¿è§’åº¦æ•°ç»„é•¿åº¦ä¸º2 * nï¼Œè¿™æ ·å°±èƒ½é¿å…é—æ¼ä¸€å››è±¡é™ã€‚&#xA;ä»£ç  class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // ç”¨æ¥æ ‡è®°è¿™æ˜¯ä¸€ä¸ªé‡å çš„ç‚¹ else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>303.range sum query-immutable</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</guid>
      <description>Description 303.range-sum-query-immutable&#xA;Solution We can use prefix sum array, so we can get sum without traversing.&#xA;Code class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>303.åŒºåŸŸå’Œæ£€ç´¢-æ•°ç»„ä¸å¯å˜</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</guid>
      <description>é—®é¢˜æè¿° 303.åŒºåŸŸå’Œæ£€ç´¢-æ•°ç»„ä¸å¯å˜&#xA;è§£é¢˜æ€è·¯ åˆ©ç”¨å‰ç¼€å’Œæ•°ç»„ï¼Œä½¿å¾—æ±‚åŒºé—´å’Œæ—¶æ— éœ€å†éå†æ•°ç»„æ±‚å’Œã€‚&#xA;ä»£ç  class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>1769.minimum number of operation to ove ll balls to each box</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</guid>
      <description>Description 1769.minimum-number-of-operations-to-move-all-balls-to-each-box&#xA;Solution Violent solution: $\Theta(n^2)$&#xA;We could use prefix sum to reduce the time complexity.&#xA;nums[i] denotes the number of ball in first i + 1 boxes, res[i] is the minimum number of operation to ove ll balls to the i + 1th box, sum is the total number of balls. Compared to moving all balls to i th box, if we want to move all ball to the i + 1th box, the balls in 0 =&amp;gt; i - 1 all need move an additional step, while the balls in i =&amp;gt; n - 1 will move one step less.</description>
    </item>
    <item>
      <title>1769.ç§»åŠ¨æ‰€æœ‰çƒåˆ°æ¯ä¸ªç›’å­æ‰€éœ€çš„æœ€å°æ“ä½œæ•°</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</guid>
      <description>é—®é¢˜æè¿° 1769.ç§»åŠ¨æ‰€æœ‰çƒåˆ°æ¯ä¸ªç›’å­æ‰€éœ€çš„æœ€å°æ“ä½œæ•°&#xA;è§£é¢˜æ€è·¯ æš´åŠ›æ±‚è§£ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$\Theta(n^2)$;&#xA;å¯ä»¥è€ƒè™‘åˆ©ç”¨å‰ç¼€å’Œæ¥é™ä½æ—¶é—´å¤æ‚åº¦: è®¾nums[i]æ˜¯å‰i + 1ä¸ªç›’å­é‡Œçš„çƒçš„æ€»ä¸ªæ•°ï¼Œres[i]ä¸ºå°†æ‰€æœ‰çƒç§»åˆ°ç¬¬i + 1ä¸ªç›’å­é‡Œæ‰€éœ€è¦çš„æ“ä½œæ•°ï¼Œsumä¸ºçƒæ€»ä¸ªæ•°ï¼Œç§»åˆ°ç¬¬i + 1ä¸ªç›’å­ç›¸æ¯”ç§»åˆ°ç¬¬iä¸ªç›’å­ï¼Œå·¦è¾¹çš„çƒå„è¦å¤šç§»ä¸€æ­¥ï¼Œå³è¾¹çš„çƒå„å°‘ç§»ä¸€æ­¥ï¼Œå› æ­¤æœ‰é‚£ä¹ˆæœ‰:res[i] = res[i - 1] + nums[i - 1] - (sum - nums[i - 1])ï¼Œ&#xA;ä»£ç  class Solution { public: vector&amp;lt;int&amp;gt; minOperations(string boxes) { vector&amp;lt;int&amp;gt; nums(boxes.size(), 0); int sum = boxes[0] - &amp;#39;0&amp;#39;; nums[0] = boxes[0] - &amp;#39;0&amp;#39;; for (int i = 1; i &amp;lt; boxes.size(); i++) { if (boxes[i] == &amp;#39;1&amp;#39;) { nums[i] = nums[i - 1] + 1; sum++; } else nums[i] = nums[i - 1]; } vector&amp;lt;int&amp;gt; res(boxes.</description>
    </item>
    <item>
      <title>424.æ›¿æ¢åçš„æœ€é•¿é‡å¤å­—ç¬¦</title>
      <link>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:47:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</guid>
      <description>é—®é¢˜æè¿° 424.æ›¿æ¢åçš„æœ€é•¿é‡å¤å­—ç¬¦&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆï¼Œæ³¨æ„ä¸€ç‚¹ï¼Œå­ä¸²å¦‚æœèƒ½é€šè¿‡kæ¬¡æ›¿æ¢å˜æˆåªåŒ…å«ç›¸åŒå­—æ¯çš„å­ä¸²ï¼Œé‚£ä¹ˆä¸€å®šæœ‰max_cnt + k &amp;gt;= subarray.size();é‚£ä¹ˆä¸æ»¡è¶³æ¡ä»¶çš„å­ä¸²ä¸€å®šæœ‰max_cnt + k &amp;lt; subarray.size()ï¼Œæ ¹æ®è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨æ»‘åŠ¨çª—å£æ³•;&#xA;å¦‚æœæ»¡è¶³æ¡ä»¶ï¼Œé‚£ä¹ˆåªå¢åŠ rightï¼Œå¦‚æœä¸æ»¡è¶³æ¡ä»¶ï¼Œright++ã€left++ï¼Œè¿™æ ·right - leftä¸€å®šæ˜¯é€’å¢çš„ï¼Œå¹¶ä¸”ä¼šéå†æœå¯»åˆ°æ‰€æœ‰çš„ä¸åŒå­—ç¬¦ã€‚&#xA;ä»£ç  class Solution { public: int characterReplacement(string s, int k) { vector&amp;lt;int&amp;gt; num(26); int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right &amp;lt; n) { num[s[right] - &amp;#39;A&amp;#39;]++; maxn = max(maxn, num[s[right] - &amp;#39;A&amp;#39;]); if (right - left + 1 - maxn &amp;gt; k) { num[s[left] - &amp;#39;A&amp;#39;]--; left++; } right++; } return right - left; } }; </description>
    </item>
    <item>
      <title>413.arithmetic slices</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices/</guid>
      <description>Descritpion 413.arithmetic slices&#xA;Solution We should notice that the number of subarray $cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$(len) is the length of arithmetic array.&#xA;Code class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>413.ç­‰å·®æ•°åˆ—åˆ’åˆ†</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</guid>
      <description>é—®é¢˜æè¿° 413.ç­‰å·®æ•°åˆ—åˆ’åˆ†&#xA;è§£é¢˜æ€è·¯ æ³¨æ„åˆ°å­æ•°ç»„ä¸ªæ•°$cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$ï¼Œå…¶ä¸­lenæ˜¯ç­‰å·®æ•°ç»„çš„é•¿åº¦ï¼Œåˆ™cnt = (n - 1) * (n - 2) / 2ï¼Œæ¯æ¬¡éå†æ‰¾å‡ºè¿ç»­çš„ç­‰å·®æ•°ç»„çš„é•¿åº¦å³å¯ã€‚ æµ‹è¯•test&#xA;ä»£ç  class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.size(); i++) { if (nums[i] - nums[i - 1] == dif) len++; else { if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; len = 2; dif = nums[i] - nums[i - 1]; } } if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; return cnt; } }; </description>
    </item>
    <item>
      <title>88.merge sorted array</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array/</guid>
      <description>Description 88.merge-sorted-array&#xA;Solution We use pointers, assign values of nums1 from end to front, so we use only $\Theta(1)$ extra space.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>88.åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</guid>
      <description>é—®é¢˜æè¿° 88.åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„&#xA;è§£é¢˜æ€è·¯ åŒæŒ‡é’ˆï¼Œç”±äºnum1çš„é•¿åº¦æ˜¯m + nï¼Œå› æ­¤éå†æ—¶ï¼Œå¯ä»¥è€ƒè™‘é’ˆå¯¹nums1ï¼Œä»åå¾€å‰èµ‹å€¼ï¼Œä»è€Œåªéœ€è¦$\Theta(1)$çš„é¢å¤–ç©ºé—´ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>142.linked list cycle ii</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</guid>
      <description>Description 142.linked-list-cycle-ii&#xA;Solution Like 141.linked-list-cycle, when fast and slow meet each other, we make a pointer p start from virtual head node, traverse one by one, the same as slow. slow and p will meet at the entrance of the cycle.&#xA;Code class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead !</description>
    </item>
    <item>
      <title>142.ç¯å½¢é“¾è¡¨II</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 142.ç¯å½¢é“¾è¡¨II&#xA;è§£é¢˜æ€è·¯ åˆ¤æ–­æ˜¯å¦é“¾è¡¨æ˜¯å¦å­˜åœ¨ç¯çš„æ–¹å¼ä¸141.ç¯å½¢é“¾è¡¨ä¸€è‡´ï¼Œå½“ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡æ—¶ï¼Œå†è®©ä¸€ä¸ªæŒ‡é’ˆä»è™šæ‹Ÿå¤´èŠ‚ç‚¹å¼€å§‹ä¸€ä¸ªèŠ‚ç‚¹ä¸€ä¸ªèŠ‚ç‚¹çš„éå†ï¼ŒslowæŒ‡é’ˆä¹Ÿæ˜¯ï¼Œä¸¤ä¸ªæŒ‡é’ˆä¼šåœ¨ç¯çš„å…¥å£å¤„ç›¸é‡ã€‚&#xA;ä»£ç  class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead != slow) { vhead = vhead-&amp;gt;next; slow = slow-&amp;gt;next; } delete vhead; return slow; } } return nullptr; } }; </description>
    </item>
    <item>
      <title>141.linked list cycle</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle/</guid>
      <description>Description 141.linked-list-cycle&#xA;Solution We can use two pointers, one fast, one slow. For each time, fast move to next next node, slow move to next node. If there is cycle, fast will be equal to slow, or fast will be nullptr.&#xA;Code class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>141.ç¯å½¢é“¾è¡¨</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</guid>
      <description>é—®é¢˜æè¿° 141.ç¯å½¢é“¾è¡¨&#xA;è§£é¢˜æ€è·¯ ä½¿ç”¨å¿«æ…¢ä¸¤ä¸ªæŒ‡é’ˆï¼Œfastä¸€æ¬¡ç§»åŠ¨ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œslowä¸€æ¬¡ç§»åŠ¨ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœé“¾è¡¨å­˜åœ¨ç¯ï¼Œé‚£ä¹ˆfastå’Œslowä¸€å®šä¼šæœ‰ç›¸ç­‰çš„æ—¶å€™ï¼Œå¦åˆ™fastä¼šè¿åŠ¨åˆ°é“¾è¡¨æœ«å°¾ã€‚&#xA;ä»£ç  class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>345.reverse vowels of a string</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</guid>
      <description>Description 345.reverse-vowels-of-a-string&#xA;Solution We use unordered_set to determine whether it is vowel, two pointers.&#xA;Code class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.</description>
    </item>
    <item>
      <title>345.åè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</guid>
      <description>é—®é¢˜æè¿° 345.åè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯&#xA;è§£é¢˜æ€è·¯ åŒæŒ‡é’ˆæ³•ï¼Œä½¿ç”¨unordered_set(åº•å±‚å®ç°ä¸ºå“ˆå¸Œè¡¨)æ¥åˆ¤æ–­æ˜¯å¦æ˜¯å…ƒéŸ³å­—æ¯ã€‚&#xA;ä»£ç  class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) == mset.end()) r--; else if (mset.</description>
    </item>
    <item>
      <title>75.sort colors</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors/</link>
      <pubDate>Fri, 25 Nov 2022 15:27:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors/</guid>
      <description>Description 75.sort-colors&#xA;Solution Here, we need three pointers l, r, idx, l for 0, r for 2, idx for traversing.&#xA;When traversing:&#xA;if nums[idx] == 0,swap(nums[idx], nums[l]);, and idx++; l++ if nums[idx] == 1, idx++; if nums[idx] == 2, swap(nums[idx], nums[r]);, and only r--, because new nums[idx] may be 0 or 1 or 2, so we need determine the value of nums[idx] again. if swap(nums[idx], nums[l]);, new nums[idx] will be 0 only when idx == l, or nums[idx] == 1, so we can increase idx.</description>
    </item>
    <item>
      <title>75.é¢œè‰²åˆ†ç±»</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors.zh/</link>
      <pubDate>Fri, 25 Nov 2022 15:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors.zh/</guid>
      <description>é—®é¢˜æè¿° 75.é¢œè‰²åˆ†ç±»&#xA;è§£é¢˜æ€è·¯ è¿™é‡Œï¼Œæˆ‘ä»¬éœ€è¦ä¸‰ä¸ªæŒ‡é’ˆl, r, idx, lç”¨æ¥å­˜æ”¾0,rç”¨æ¥å­˜æ”¾2ï¼Œidxç”¨æ¥è¿›è¡Œéå†æ•°ç»„ã€‚&#xA;è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨éå†æ•°ç»„æ—¶:&#xA;if nums[idx] == 0ï¼Œéœ€è¦äº¤æ¢nums[idx]å’Œnums[l]çš„å€¼ï¼ŒåŒæ—¶idx++; l++; if nums[idx] == 1ï¼Œidx++å³å¯ if nums[idx] == 2ï¼Œéœ€è¦äº¤æ¢nums[idx]å’Œnums[l]çš„å€¼ï¼Œä½†æ­¤æ—¶åªæ˜¯r--ï¼Œä¸ä¼šidx++ï¼Œè¿™æ˜¯å› ä¸ºæ–°çš„äº¤æ¢åçš„nums[idx]çš„å€¼å¯èƒ½æ˜¯0ã€1ã€2ä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œå› æ­¤è¿˜éœ€è¦é‡æ–°åˆ¤æ–­nums[idx] å¦‚æœidx == lï¼Œé‚£ä¹ˆ[0, idx]åŒºé—´èŒƒå›´å†…çš„æ•°éƒ½æ˜¯0ï¼Œå¦‚æœidx != lï¼Œé‚£ä¹ˆ[0, l - 1]åŒºé—´èŒƒå›´å†…éƒ½æ˜¯0ï¼Œ[l, idx)åŒºé—´èŒƒå›´å†…éƒ½æ˜¯1ï¼Œå› æ­¤å¯ä»¥è¿›è¡Œidx++; ä»£ç  class Solution { public: void sortColors(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int tmp = 0, index = 0; int l = 0, r = nums.size() - 1; while (index &amp;lt;= r) { if (nums[index] == 0) { tmp = nums[l]; nums[l++] = 0; nums[index++] = tmp; } else if (nums[index] == 2) { tmp = nums[r]; nums[r--] = 2; nums[index] = tmp; } else index++; } } }; </description>
    </item>
    <item>
      <title>26.remove duplicates from sorted array</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</guid>
      <description>Description 26.remove-duplicates-from-sorted-array&#xA;Solution We use two pointers fast and slow, fast used to check if duplicated, slow use for assignment.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>26.åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</guid>
      <description>é—®é¢˜æè¿° 26.åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹&#xA;è§£é¢˜æ€è·¯ é‡‡ç”¨åŒæŒ‡é’ˆæ³•ï¼Œä¸€å¿«ä¸€æ…¢ï¼Œfastç”¨äºæ£€æµ‹æ˜¯å¦é‡å¤ï¼Œslowç”¨æ¥è¢«èµ‹å€¼ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>18.4sum</title>
      <link>http://localhost:1313/posts/leet/18.4sum/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum/</guid>
      <description>Description 18.4sum&#xA;Solution Two pointers, i, j = i + 1, l = j + 1, r = nums.size() - 1;&#xA;Pay attention to overflow exception and deduplication.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    <item>
      <title>18.4å››æ•°ä¹‹å’Œ</title>
      <link>http://localhost:1313/posts/leet/18.4sum.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum.zh/</guid>
      <description>é—®é¢˜æè¿° 18.å››æ•°ä¹‹å’Œ&#xA;è§£é¢˜æ€è·¯ åŒæŒ‡é’ˆæ³•ï¼Œi, j = i + 1, l, r;&#xA;æ³¨æ„å»é‡å’Œæº¢å‡ºã€‚&#xA;ä»£ç  class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.size() - 2; j++) { if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) continue; int l = j + 1, r = nums.</description>
    </item>
    <item>
      <title>19.remove nth node from end of list</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</guid>
      <description>Description 19.remove-nth-node-from-end-of-list&#xA;Solution For convenience, we create a virtual head node pre, pre-&amp;gt;next = head.&#xA;We will use two pointers fast and slow. First, fast go head for n times, then fast and slow go ahead together. When fast arrives at last node, slow points to the last node of the node we need delete.&#xA;Code class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next !</description>
    </item>
    <item>
      <title>19.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</guid>
      <description>é—®é¢˜æè¿° 19.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆè®¾ç½®ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹preï¼Œpre-&amp;gt;next = head;&#xA;åŒæŒ‡é’ˆæ³•ï¼Œè€ƒè™‘ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆfastï¼Œslowï¼Œä¸€å¿«ä¸€æ…¢ï¼ŒfastæŒ‡é’ˆå…ˆå‰è¿›nä¸ªä½ç½®ï¼Œç„¶åfastå’Œslowä¸€èµ·éå†ï¼Œå½“faståˆ°è¾¾æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼Œslowåˆšå¥½ä½äºè¦åˆ é™¤çš„èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚&#xA;ä»£ç  class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next; slow = slow-&amp;gt;next; } slow-&amp;gt;next = slow-&amp;gt;next-&amp;gt;next; return pre-&amp;gt;next; } }; </description>
    </item>
    <item>
      <title>16.3sum closest</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest/</guid>
      <description>Description 16.3sum-closest&#xA;Solution The violent solution: triple cycle, $\Theta(n^3)$&#xA;We should notice that we don&amp;rsquo;t care the original index of array, so we can use two pointers to reduce the time complexity.&#xA;First, we need sort the array, in outer loop, i iterates from 0 to nums.size() - 3, in inner loop, l and r come together from end to the middle.&#xA;Code class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.</description>
    </item>
    <item>
      <title>16.æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest.zh/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest.zh/</guid>
      <description>é—®é¢˜æè¿° 16.æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ&#xA;è§£é¢˜æ€è·¯ æš´åŠ›è§£æ³•ï¼Œä¸‰é‡å¾ªç¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$\Theta(n^3)$;&#xA;æ³¨æ„åˆ°æœ¬é¢˜ä¸å…³æ³¨æ•°ç»„ä¸­å…ƒç´ çš„åˆå§‹ç´¢å¼•ï¼Œå› æ­¤å¯ä»¥è€ƒè™‘åˆ©ç”¨åŒæŒ‡é’ˆæ¥é™ä½æ—¶é—´å¤æ‚åº¦: é¦–å…ˆå°†æ•°ç»„æ’åºï¼Œæœ€å¤–å±‚iä»0éå†åˆ°nums.size() - 3ï¼Œå†…å±‚å¾ªç¯é‡‡ç”¨ç›¸å‘åŒæŒ‡é’ˆlï¼Œrä»ä¸¤ç«¯å‘ä¸­é—´é æ‹¢ï¼Œå¹¶ä¸”è¦æ³¨æ„å¦‚ä½•å»é‡ï¼Œ(å½“ç„¶ï¼Œæ­¤é¢˜å¯ä»¥ä¸å…³æ³¨)ã€‚&#xA;ä»£ç  class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.begin(), nums.end()); int sum = nums[0] + nums[1] + nums[2]; // è®°å½•ä¸‰æ•°ä¹‹å’Œ for (int i = 0; i &amp;lt; nums.size() - 2; i++) { // è·³è¿‡é‡å¤çš„ if (i !</description>
    </item>
    <item>
      <title>å¿«é€Ÿå¹‚ä¸å¿«é€Ÿä¹˜</title>
      <link>http://localhost:1313/posts/tech/exponentiating-by-squaring.zh/</link>
      <pubDate>Sat, 19 Nov 2022 11:51:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/exponentiating-by-squaring.zh/</guid>
      <description>å®šä¹‰ å¿«é€Ÿå¹‚ï¼ŒäºŒè¿›åˆ¶å–å¹‚ï¼ˆBinary Exponentiationï¼Œä¹Ÿç§°å¹³æ–¹æ³•ï¼‰ï¼Œæ˜¯ä¸€ä¸ªåœ¨ $\Theta(\log n)$ çš„æ—¶é—´å†…è®¡ç®— $a^n$ çš„å°æŠ€å·§ï¼Œè€Œæš´åŠ›çš„è®¡ç®—éœ€è¦ $\Theta(n)$ çš„æ—¶é—´ã€‚&#xA;è¿™ä¸ªæŠ€å·§ä¹Ÿå¸¸å¸¸ç”¨åœ¨éè®¡ç®—çš„åœºæ™¯ï¼Œå› ä¸ºå®ƒå¯ä»¥åº”ç”¨åœ¨ä»»ä½•å…·æœ‰ç»“åˆå¾‹çš„è¿ç®—ä¸­ã€‚å…¶ä¸­æ˜¾ç„¶çš„æ˜¯å®ƒå¯ä»¥åº”ç”¨äºæ¨¡æ„ä¹‰ä¸‹å–å¹‚ã€çŸ©é˜µå¹‚ç­‰è¿ç®—ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥ä¼šè®¨è®ºã€‚&#xA;è§£é‡Š è®¡ç®— $a$ çš„ $n$ æ¬¡æ–¹è¡¨ç¤ºå°† $n$ ä¸ª $a$ ä¹˜åœ¨ä¸€èµ·ï¼š$a^{n} = \underbrace{a \times a \cdots \times a}_{n\text{ ä¸ª a}}$ã€‚ç„¶è€Œå½“ $a,n$ å¤ªå¤§çš„æ—¶ä¾¯ï¼Œè¿™ç§æ–¹æ³•å°±ä¸å¤ªé€‚ç”¨äº†ã€‚ä¸è¿‡æˆ‘ä»¬çŸ¥é“ï¼š$a^{b+c} = a^b \cdot a^c,,,a^{2b} = a^b \cdot a^b = (a^b)^2$ã€‚äºŒè¿›åˆ¶å–å¹‚çš„æƒ³æ³•æ˜¯ï¼Œæˆ‘ä»¬å°†å–å¹‚çš„ä»»åŠ¡æŒ‰ç…§æŒ‡æ•°çš„ äºŒè¿›åˆ¶è¡¨ç¤º æ¥åˆ†å‰²æˆæ›´å°çš„ä»»åŠ¡ã€‚&#xA;è¿‡ç¨‹ é¦–å…ˆæˆ‘ä»¬å°† $n$ è¡¨ç¤ºä¸º 2 è¿›åˆ¶ï¼Œä¸¾ä¸€ä¸ªä¾‹å­å§ï¼š&#xA;$$ 3^{13} = 3^{(1101)_2} = 3^8 \cdot 3^4 \cdot 3^1 $$&#xA;å› ä¸º $n$ æœ‰ $\lfloor \log_2 n \rfloor + 1$ ä¸ªäºŒè¿›åˆ¶ä½ï¼Œå› æ­¤å½“æˆ‘ä»¬çŸ¥é“äº† $a^1, a^2, a^4, a^8, \dots, a^{2^{\lfloor \log_2 n \rfloor}}$ åï¼Œæˆ‘ä»¬åªç”¨è®¡ç®— $\Theta(\log n)$ æ¬¡ä¹˜æ³•å°±å¯ä»¥è®¡ç®—å‡º $a^n$ã€‚</description>
    </item>
    <item>
      <title>11.container with most water</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water/</link>
      <pubDate>Sat, 19 Nov 2022 09:46:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water/</guid>
      <description>Description 11.container-with-most-water&#xA;Solution The violent solution of this problem has a time complexity of $O(n^2)$, to reduce the time complexity, we consider two-pointers.&#xA;So, we need determine how left pointer l and right pointer r will meet each other:&#xA;if (height[l] &amp;gt;= height[r]), the capacity depends on height[r]. If l++, the capacity will become smaller, so we should r--. if (height[l] &amp;lt; height[r]), the capacity depends on height[l]. If r--, the capacity will become smaller, so we should l++.</description>
    </item>
    <item>
      <title>11.ç››æœ€å¤šæ°´çš„å®¹å™¨</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</link>
      <pubDate>Sat, 19 Nov 2022 09:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</guid>
      <description>é—®é¢˜æè¿° 11.ç››æœ€å¤šæ°´çš„å®¹å™¨&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜æš´åŠ›è§£æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$(ä¼šè¶…æ—¶ï¼Œæ²¡è¯•è¿‡)ï¼Œä¸ºäº†é™ä½æ—¶é—´å¤æ‚åº¦ï¼Œè€ƒè™‘ä½¿ç”¨åŒæŒ‡é’ˆã€‚&#xA;é‚£ä¹ˆï¼Œæœ¬é¢˜éœ€è¦è€ƒè™‘çš„å°±æ˜¯å·¦æŒ‡é’ˆlå’Œå³æŒ‡é’ˆrå¦‚ä½•å‘ä¸­é—´é æ‹¢ï¼š&#xA;if (height[l] &amp;gt;= height[r])ï¼Œè¯´æ˜å®¹å™¨å®¹ç§¯æ˜¯ç”±height[r]æ¥å†³å®šçš„ï¼Œè¿™æ—¶å€™ï¼Œlå‘ä¸­é—´è€ƒè™‘ï¼Œåªå¯èƒ½ä¼šç¼©å°å®¹ç§¯ï¼Œå› æ­¤åº”è¯¥r--; if (height[l] &amp;lt; height[r])ï¼Œè¯´æ˜å®¹å™¨å®¹ç§¯ç”±height[l]æ¥å†³å®šï¼Œè¿™æ—¶å€™ï¼Œrå‘ä¸­é—´é æ‹¢ï¼Œåªä¼šç¼©å°å®¹ç§¯ï¼Œå› æ­¤åº”è¯¥l++; ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int l = 0, r = height.size() - 1; int res = 0; while (l &amp;lt; r) { if (height[l] &amp;gt;= height[r]) { res = max(res, (r - l) * height[r]); r--; // å› ä¸ºæ­¤æ—¶ï¼Œå¢åŠ låªå¯èƒ½ç¼©å°resï¼Œæ‰€ä»¥å‡å°‘r } else { res = max(res, (r - l) * height[l]); l++; // height[l] &amp;lt; height[r], æ­¤æ—¶å‡å°‘rä¹Ÿåªä¼šç¼©å°resï¼Œæ‰€ä»¥å¢åŠ l } } return res; } }; </description>
    </item>
    <item>
      <title>42.trapping rain water</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water/</guid>
      <description>Description 42.trapping-rain-water&#xA;Solution We can use monotone stack&#xA;The capacity of unit cosist of height[stk.top()] is (min(height[r], height[l]) - height[stk.top()]) * (l - r - 1), l is next element below the top of the stack, since height[l] &amp;gt;= height[stk.top()] r is the index of first column which height[r] &amp;gt;= height[stk.top()].&#xA;The result is the sum.&#xA;Code ```cpp #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.</description>
    </item>
    <item>
      <title>42.æ¥é›¨æ°´</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</guid>
      <description>é—®é¢˜æè¿° 42.æ¥é›¨æ°´&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜è€ƒè™‘ä½¿ç”¨å•è°ƒæ ˆ(monotone stack)ï¼Œæ ˆé¡¶åˆ°æ ˆåº•ä¾æ¬¡é€’å¢ã€‚&#xA;ç”±height[stk.top()]å­˜æ”¾é›¨æ°´çš„å•å…ƒï¼Œå…¶è®¡ç®—æ–¹å¼ä¸º(min(height[r], height[l]) - height[stk.top()]) * (l - r - 1)ï¼Œå…¶ä¸­lå³æ ˆé¡¶çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œråˆ™æ˜¯ç¬¬ä¸€ä¸ªé«˜åº¦å¤§äºheight[stk.top()]çš„æŸ±å­çš„ç´¢å¼•ã€‚&#xA;ç»“æœä¸ºæ‰€æœ‰æŸ±å­èƒ½å­˜æ”¾çš„é›¨æ°´çš„ç´¯åŠ ã€‚&#xA;ä»£ç  #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.push(0); int res = 0; for (int i = 1; i &amp;lt; height.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; height[i] &amp;gt; height[stk.top()]) { int mid = stk.top(); stk.pop(); if (!stk.empty()) { int h = min(height[i], height[stk.top()]) - height[mid]; int w = i - stk.</description>
    </item>
    <item>
      <title>503.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ II</title>
      <link>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:59:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 503.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ II&#xA;è§£é¢˜æ€è·¯ ç›¸æ¯”496.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ Iï¼Œåœ¨éå†æ•°ç»„ä¸Šæœ‰æ‰€åŒºåˆ«ï¼Œå¦‚æœi &amp;gt;= nums.size()ï¼Œç”¨j = i - nums.size();æ¥ä»£æ›¿iï¼Œå› æ­¤içš„å–å€¼èŒƒå›´æ˜¯[0, 2 * nums.size())ã€‚&#xA;ä»£ç  class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElements(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; res(nums.size(), -1); stack&amp;lt;int&amp;gt; stk; stk.push(0); int j = 0; for (int i = 1; i &amp;lt; 2 * nums.size(); i++) { if (i &amp;gt;= nums.size()) { j = i - nums.size(); while (!stk.empty() &amp;amp;&amp;amp; nums[j] &amp;gt; nums[stk.top()]) { res[stk.top()] = nums[j]; stk.pop(); } stk.push(j); } else { while (!</description>
    </item>
    <item>
      <title>496.next greater element i</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i/</guid>
      <description>Description 496.next-greater-element-i&#xA;Solution We can use monotone stack to traverse nums2, and use unordered_map to store the element in nums1 and corresponding result.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.</description>
    </item>
    <item>
      <title>496.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ I</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</guid>
      <description>é—®é¢˜æè¿° 496.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ I&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜åˆ©ç”¨å•è°ƒæ ˆ(monotone stack)æ¥éå†nums2ï¼Œå¹¶ä¸”åˆ©ç”¨unordered_mapæ¥å­˜å‚¨nums1ä¸­å…ƒç´ å’Œå¯¹åº”çš„ç»“æœã€‚&#xA;ä»£ç  class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.find(nums2[stk.top()]) != umap.end()) { umap[nums2[stk.top()]] = nums2[i]; } stk.pop(); } stk.push(i); } vector&amp;lt;int&amp;gt; res(nums1.size(), -1); for (int i = 0; i &amp;lt; nums1.</description>
    </item>
    <item>
      <title>monotone stack</title>
      <link>http://localhost:1313/posts/tech/monotone-stack/</link>
      <pubDate>Fri, 11 Nov 2022 15:55:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/monotone-stack/</guid>
      <description>Description brief Monotone stack is a stack whose elements(from top to bottom) are (strictly) monotonically increasing or decreasing.&#xA;Monotone increasing stack: the element which is smaller than the element in the top can be pushed into stack, else we will pop the element in the top, until the stack is empty or the element is smaller than the element in the top, then we push the element into the stack. This data structure is usually used for problems to find first element that is larger than certain element.</description>
    </item>
    <item>
      <title>å•è°ƒæ ˆ</title>
      <link>http://localhost:1313/posts/tech/monotone-stack.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:54:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/monotone-stack.zh/</guid>
      <description>é—®é¢˜æè¿° ç®€è¿° å•è°ƒæ ˆ(monotone stack)æ˜¯æŒ‡æ ˆå†…å…ƒç´ (æ ˆé¡¶åˆ°æ ˆåº•)éƒ½æ˜¯(ä¸¥æ ¼)å•è°ƒé€’å¢æˆ–è€…é€’å‡çš„æ ˆã€‚&#xA;å•è°ƒé€’å¢æ ˆ(ä»æ ˆé¡¶åˆ°æ ˆåº•)ï¼šåªæœ‰æ¯”æ ˆé¡¶å°çš„æ‰èƒ½å…¥æ ˆï¼Œå¦æŠŠæ ˆé¡¶å…ƒç´ å¼¹å‡ºï¼Œç›´åˆ°æ ˆä¸ºç©ºæˆ–è€…æˆ–è€…å¾…å¤„ç†çš„å…ƒç´ å°äºæ ˆé¡¶å…ƒç´ ï¼Œå°†å…ƒç´ å…¥æ ˆï¼Œé€‚ç”¨äºæ±‚è§£ç¬¬ä¸€ä¸ªå¤§äºæŸå…ƒç´ çš„æ•°çš„æƒ…å†µï¼›&#xA;å•è°ƒé€’å‡æ ˆï¼Œä¸é€’å¢æ ˆç›¸åï¼Œé€‚ç”¨äºæ±‚è§£ç¬¬ä¸€ä¸ªå°äºæŸä½ç½®å…ƒç´ çš„æ•°ï¼›&#xA;åˆ¤æ–­æ–¹æ³• å•è°ƒé€’å¢/é€’å‡æ ˆä¸€èˆ¬æ ¹æ®å‡ºæ ˆåé¡ºåºæ¥å†³å®šï¼Œä¾‹å¦‚æ ˆå†…é¡ºåº[1, 2, 6]ï¼Œå‡ºæ ˆåé¡ºåº[6, 2, 1]ï¼Œè¿™å°±æ˜¯å•è°ƒé€’å‡æ ˆã€‚&#xA;å“¨å…µæŠ€å·§ å¯¹äºæœ‰äº›æ—¶å€™ï¼Œå¦‚æœä¼šç”¨åˆ°æ•°ç»„çš„å…¨éƒ¨å…ƒç´ ï¼Œå³æ ˆä¸­çš„å…ƒç´ æœ€åéƒ½è¦å‡ºæ ˆï¼Œé‚£ä¹ˆå¾ˆå¯èƒ½å› ä¸ºæ²¡æœ‰è€ƒè™‘è¾¹ç•Œè€Œæ— æ³•é€šè¿‡ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å“¨å…µæ³•ã€‚&#xA;ä¾‹å¦‚åœ¨{1, 3, 4, 5, 2, 9, 6}æœ«å°¾æ·»åŠ ä¸€ä¸ª-1ä½œä¸ºå“¨å…µï¼Œå˜æˆäº† {1, 3, 4, 5, 2, 9, 6, -1}ï¼Œè¿™ç§æŠ€å·§å¯ä»¥ç®€åŒ–ä»£ç é€»è¾‘ã€‚&#xA;ä¾‹é¢˜ </description>
    </item>
    <item>
      <title>739.daily temperatures</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures/</guid>
      <description>Description 739.dail-temperatures&#xA;Solution We can consider monotone stack. If the stack is empty or the element to deal with is smaller than the element in the top of the stack, we can push the element to the stack, else we should pop the element in the top of the stack until the stack is empty or the element is smaller than the element in the top of the stack.&#xA;It&amp;rsquo;s convenient to push the index i into the stack.</description>
    </item>
    <item>
      <title>739.æ¯æ—¥æ¸©åº¦</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</guid>
      <description>é—®é¢˜æè¿° 739.æ¯æ—¥æ¸©åº¦&#xA;è§£é¢˜æ€è·¯ è€ƒè™‘åˆ©ç”¨å•è°ƒæ ˆ(monotone stack)æ¥è¿›è¡Œå¤„ç†ï¼Œå¦‚æœæ ˆä¸ºç©ºæˆ–è€…è¦å…¥æ ˆçš„å…ƒç´ å°äºæ ˆé¡¶å…ƒç´ ï¼Œé‚£ä¹ˆè¯¥å…ƒç´ å…¥æ ˆï¼Œå¦åˆ™å¼¹å‡ºæ ˆé¡¶å…ƒç´ ç›´åˆ°æ ˆä¸ºç©ºï¼Œæˆ–è€…è¦å…¥æ ˆçš„å…ƒç´ å°äºæ ˆé¡¶å…ƒç´ ï¼Œå†å°†è¯¥å…ƒç´ å…¥æ ˆã€‚&#xA;è¿™é‡Œåº”è¯¥å°†æ•°ç»„ç´¢å¼•iå…¥æ ˆä¼šæ¯”è¾ƒæ–¹ä¾¿ã€‚&#xA;ä»£ç  class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt; &amp;amp;temperatures) { vector&amp;lt;int&amp;gt; res(temperatures.size(), 0); stack&amp;lt;int&amp;gt; st; st.push(0); for (int i = 1; i &amp;lt; temperatures.size(); i++) { int j = i; // if (!st.empty()) { while (!st.empty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[st.top()]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); // } } return res; } }; </description>
    </item>
    <item>
      <title>738.monotone increasing digits</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</guid>
      <description>Description 738.monotone-increasing-digits&#xA;Solution First, we need change the number to a vector&amp;lt;int&amp;gt; dec, for example:1234 to {1, 2, 3, 4}. Then we can traverse the vector, until dec[i] &amp;gt; dec[i + 1], then set dec[i + n] = 9(n &amp;gt;= 1). If dec[i] == dec[i - 1] == ... == dec[j], then dec[j]--, set others as 9, else dec[i]--;&#xA;Code class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n !</description>
    </item>
    <item>
      <title>738.å•è°ƒé€’å¢çš„æ•°å­—</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</guid>
      <description>é—®é¢˜æè¿° 738.å•è°ƒé€’å¢çš„æ•°å­—&#xA;è§£é¢˜æ€è·¯ å°†è¯¥æ•°å­—çš„æ¯ä¸€ä½æ•°å­—å˜æˆæ•°ç»„dec&amp;lt;int&amp;gt;çš„ä¸€éƒ¨åˆ†ï¼Œç„¶åä¾æ¬¡éå†ï¼Œç›´åˆ°dec[i] &amp;gt; dec[i + 1]ï¼Œç„¶åå°†dec[i + 1]åŠä»¥åçš„æ•°å­—éƒ½å˜æˆ9ï¼Œå¦‚æœdec[i] == dec[i - 1] == Â·Â·Â· == dec[j]ï¼Œå°±å°†dec[j]--ï¼Œå…¶ä½™å…¨è®¾ç½®ä¸º9ã€‚&#xA;ä»£ç  class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n != 0) { res.push_back(n % 10); n = n / 10; } } int ten(int i) { int res = 1; while (i != 0) { i--; res *= 10; } return res; } public: int monotoneIncreasingDigits(int n) { vector&amp;lt;int&amp;gt; dec; vec_dec(n, dec); std::reverse(dec.</description>
    </item>
    <item>
      <title>56.merge intervals</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals/</guid>
      <description>Description 56.merge-intervals&#xA;Solution The solution is similar to 452.minimum-number-of-arrows-to-burst-balloons, if there is common space, change the res.back()[1] to intervals[i][1], while intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); if there is not common space, res.push_back().&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>56.åˆå¹¶åŒºé—´</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals.zh/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals.zh/</guid>
      <description>é—®é¢˜æè¿° 56.åˆå¹¶åŒºé—´&#xA;è§£é¢˜æ€è·¯ æ€è·¯ä¸452.ç”¨æœ€å°‘çš„ç®­å¼•çˆ†æ°”çƒï¼Œåªä¸è¿‡è¿™é‡Œintervals[i][1] = max(intervals[i][1], intervals[i - 1][1])ï¼Œå¦‚æœå­˜åœ¨é‡å ï¼Œä¿®æ”¹resæœ€åä¸€ä¸ªå…ƒç´ çš„å³ç«¯ç‚¹å€¼ï¼›å¦‚æœä¸å­˜åœ¨é‡å ï¼Œå°±å¾€resé‡Œæ·»åŠ ä¸€ä¸ªæ–°çš„åŒºé—´ã€‚&#xA;ä»£ç  class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i - 1][1] &amp;lt; intervals[i][0]) res.push_back(intervals[i]); else { intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); res[res.size() - 1][1] = intervals[i][1]; } } return res; } }; </description>
    </item>
    <item>
      <title>763.partition labels</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels/</guid>
      <description>Description 763.partition-label&#xA;Solution solution 1 First, we need traverse the string, record the maximum index of each letter in the string.&#xA;Then we need declare a variable right to record the maximum index of letter traversed. When the maximum index is the same as current index, we can partition the string.&#xA;solution 2 First, we need traverse the string, record the number of occurrence of each letter, and record whether the letter occur.</description>
    </item>
    <item>
      <title>763.åˆ’åˆ†å­—æ¯åŒºé—´</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels.zh/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels.zh/</guid>
      <description>é—®é¢˜æè¿° 763.åˆ’åˆ†å­—æ¯åŒºé—´&#xA;è§£é¢˜æ€è·¯ æ€è·¯ä¸€ é¦–å…ˆéå†ä¸€éæ•°ç»„ï¼Œè®°å½•æ¯ä¸ªå­—æ¯åœ¨å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æœ€è¿œä½ç½®ã€‚&#xA;å£°æ˜ä¸€ä¸ªå˜é‡rightï¼Œç”¨æ¥è®°å½•å·²ç»éå†çš„å­—ç¬¦ä¸­ï¼Œæœ€è¿œçš„ä½ç½®ï¼Œå½“éå†åˆ°çš„ä½ç½®ä¸è®°å½•çš„æœ€è¿œä½ç½®é‡å æ—¶ï¼Œå°±è¯´æ˜å¯ä»¥åˆ’åˆ†æ•°ç»„äº†ã€‚&#xA;æ€è·¯äºŒ é¦–å…ˆéå†ä¸€éæ•°ç»„ï¼Œè®°å½•æ¯ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ï¼Œå¹¶è®°å½•æ˜¯å¦å‡ºç°ï¼›&#xA;å†éå†ä¸€æ¬¡æ•°ç»„ï¼Œå½“ç¬¬ä¸€æ¬¡ç¢°åˆ°è¯¥å­—ç¬¦æ—¶ï¼Œè¯¥å­—ç¬¦å…¥æ ˆï¼Œæœ€åä¸€æ¬¡ç¢°åˆ°è¯¥å­—ç¬¦æ—¶ï¼Œå¼¹å‡ºæ ˆé¡¶çš„å­—ç¬¦ï¼Œæ ˆç©ºæ—¶ï¼Œè¯´æ˜å¯ä»¥åˆ†å‰²äº†ã€‚&#xA;ä»£ç  ä»£ç ä¸€ class Solution { public: vector&amp;lt;int&amp;gt; partitionLabels(string S) { int hash[27] = {0}; // iä¸ºå­—ç¬¦ï¼Œhash[i]ä¸ºå­—ç¬¦å‡ºç°çš„æœ€åä½ç½® for (int i = 0; i &amp;lt; S.size(); i++) { // ç»Ÿè®¡æ¯ä¸€ä¸ªå­—ç¬¦æœ€åå‡ºç°çš„ä½ç½® hash[S[i] - &amp;#39;a&amp;#39;] = i; } vector&amp;lt;int&amp;gt; result; int left = 0; int right = 0; for (int i = 0; i &amp;lt; S.size(); i++) { right = max(right, hash[S[i] - &amp;#39;a&amp;#39;]); // æ‰¾åˆ°å­—ç¬¦å‡ºç°çš„æœ€è¿œè¾¹ç•Œ if (i == right) { result.</description>
    </item>
    <item>
      <title>435.non overlapping intervals</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</guid>
      <description>Description 435.non-overlapping-intervals&#xA;Solution This problem is almost the same with 452.minimum-number-of-arrows-to-burst-balloons, the number intervals minus the result of 452.minimum-number-of-arrows-to-burst-balloons is the result of this problem.&#xA;Attention, [1, 3], [3, 5] is not overlapping intervals in this problem.&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>435.æ— é‡å åŒºé—´</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</guid>
      <description>é—®é¢˜æè¿° 435.æ— é‡å åŒºé—´&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜å’Œ452.ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒå¯ä»¥è¯´è§£é¢˜æ€è·¯ä¸€æ¨¡ä¸€æ ·ï¼ŒåŒºé—´æ•°å‡å»452.ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒå°±å¯ä»¥è¯´æ˜¯æœ¬é¢˜è¦æ±‚çš„ç­”æ¡ˆï¼Œä½†æ˜¯è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨æœ¬é¢˜ä¸­ï¼ŒåŒºé—´ç«¯ç‚¹ç›¸åŒæ˜¯ä¸è®¤ä¸ºé‡å çš„ã€‚&#xA;ä»£ç  class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i][0] &amp;gt;= intervals[i - 1][1]) cnt++; else { intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); } } return intervals.size() - cnt; } }; </description>
    </item>
    <item>
      <title>452.ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ</title>
      <link>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</link>
      <pubDate>Thu, 03 Nov 2022 13:55:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</guid>
      <description>é—®é¢˜æè¿° 452.ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆï¼ŒæŒ‰ç…§$x_start$ä»å°åˆ°å¤§çš„é¡ºåºæ’åºï¼Œç„¶åå¼€å§‹åˆ†æéœ€è¦çš„å¼“ç®­æ•°ã€‚&#xA;if (points[i][0] &amp;gt; points[i - 1])ï¼Œè¯´æ˜ä¸¤ä¸ªæ°”çƒä¸å­˜åœ¨é‡å ï¼Œéœ€è¦ä¸¤æ”¯ç®­ï¼Œç®­æ•°result++; elseï¼Œè¯´æ˜ä¸¤ä¸ªæ°”çƒå­˜åœ¨é‡å ï¼Œåªéœ€è¦ä¸€æ”¯ç®­ï¼Œä½†æ­¤æ—¶ï¼Œå¦‚ä½•åˆ¤æ–­ä¸‹ä¸€ä¸ªæ°”çƒæ˜¯å¦éœ€è¦æ–°çš„ç®­å‘¢: if (points[i + 1][0] &amp;gt; min(points[i - 1][1], points[i][1]))ï¼Œé‚£ä¹ˆå°±éœ€è¦æ–°çš„ç®­ï¼Œåä¹‹å°±ä¸éœ€è¦ï¼Œå› æ­¤ï¼Œä»¤points[i][1] = min(points[i - 1][1], points[i][1])ã€‚ ä»£ç  #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::sort; using std::vector; class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { return a[0] &amp;lt; b[0]; } public: int findMinArrowShots(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points) { int result = 1; sort(points.begin(), points.end(), cmp); for (int i = 1; i &amp;lt; points.size(); i++) { if (points[i - 1][1] &amp;lt; points[i][0]) result++; else { points[i][1] = min(points[i][1], points[i - 1][1]); } } return result; } }; </description>
    </item>
    <item>
      <title>406.queue reconstruction by height</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</guid>
      <description>Description 406.queue-reconstruction-by-height&#xA;Solution First, we need sort the vector by height, then do insertion according to ki.&#xA;When sorting, we need rewrite the comparing method, in reference to the use of sort() method in C++&#xA;Since there may be performance problem when doing insertion frequently in vector, we should use list based on linked list.&#xA;Code class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.</description>
    </item>
    <item>
      <title>406.æ ¹æ®èº«é«˜é‡å»ºé˜Ÿåˆ—</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</guid>
      <description>é—®é¢˜æè¿° 406.æ ¹æ®èº«é«˜é‡å»ºé˜Ÿåˆ—&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆæ ¹æ®èº«é«˜å¯¹æ•°ç»„é‡æ–°æ’åºï¼Œå†æ ¹æ®kiè¿›è¡Œæ’å…¥æ“ä½œã€‚&#xA;æ’åºæ—¶ï¼Œéœ€è¦å¯¹æ’åºçš„æ¯”è¾ƒæ–¹æ³•é‡å†™ï¼Œå‚è§C++ sortæ’åºå‡½æ•°ç”¨æ³•ã€‚&#xA;åŒæ—¶ï¼Œè€ƒè™‘åˆ°åŸºäºä½¿ç”¨vectoræ¥è¿›è¡Œé¢‘ç¹çš„æ’å…¥æ“ä½œå¯èƒ½ä¼šå­˜åœ¨æ€§èƒ½é—®é¢˜ï¼Œåº”è¯¥ä½¿ç”¨åŸºäºé“¾è¡¨çš„listã€‚&#xA;ä»£ç  class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.begin(), people.end(), cmp); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; queue; for (int i = 0; i &amp;lt; people.size(); i++) { int tmp = people[i][1]; queue.insert(tmp + queue.begin(), people[i]); } return queue; } }; class Solution { public: // èº«é«˜ä»å¤§åˆ°å°æ’ï¼ˆèº«é«˜ç›¸åŒkå°çš„ç«™å‰é¢ï¼‰ static bool cmp(const vector&amp;lt;int&amp;gt;&amp;amp; a, const vector&amp;lt;int&amp;gt;&amp;amp; b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; people) { sort (people.</description>
    </item>
    <item>
      <title>860.lemonade change</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change/</guid>
      <description>Description 860.lemonade-change&#xA;Solution We can create an array to show the number of $5, $10, $20. When the number of $5 is less than 0, return false. When we receive $20, we should provide change with $10 preferentially.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>860.æŸ æª¬æ°´æ‰¾é›¶</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change.zh/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change.zh/</guid>
      <description>é—®é¢˜æè¿° 860.æŸ æª¬æ°´æ‰¾é›¶&#xA;è§£é¢˜æ€è·¯ åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œè¡¨ç¤ºæ‰‹ä¸­çš„5å…ƒçº¸å¸ã€10å…ƒçº¸å¸ã€20å…ƒçº¸å¸çš„æ•°ç›®ï¼Œå½“å…¶ä¸­5å…ƒçº¸å¸æ•°ç›®å°äº0ï¼Œè¯´æ˜æ— æ³•æ‰¾é›¶ï¼Œé‡åˆ°20å…ƒçº¸å¸æ—¶ï¼Œä¼˜å…ˆä½¿ç”¨10å…ƒçº¸å¸æ‰¾é›¶ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>135.candy</title>
      <link>http://localhost:1313/posts/leet/135.candy/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy/</guid>
      <description>Description 135.candy&#xA;Solution The key point of this problem is that we need traverse two times, one from front to back, the other from back to front.&#xA;Code class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // front to back for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // back to front for (int i = ratings.</description>
    </item>
    <item>
      <title>135.åˆ†å‘ç³–æœ</title>
      <link>http://localhost:1313/posts/leet/135.candy.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy.zh/</guid>
      <description>é—®é¢˜æè¿° 135.åˆ†å‘ç³–æœ&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜çš„å…³é”®åœ¨äºï¼Œéœ€è¦ä¸€æ¬¡ä»å‰å¾€åçš„éå†ï¼Œç¬¬ä¸€æ¬¡ç¡®å®šæœ€å°‘ç³–æœæ•°ï¼ŒåŒæ—¶è¿˜éœ€è¦ä»åå¾€å‰éå†ï¼Œå†ä¸€æ¬¡ç¡®å®šæœ€å°‘ç³–æœæ•°ã€‚&#xA;ä»£ç  class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // ä»å‰å‘å for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // ä»åå‘å‰ for (int i = ratings.size() - 2; i &amp;gt;= 0; i--) { if (ratings[i] &amp;gt; ratings[i + 1] ) { candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1); } } // ç»Ÿè®¡ç»“æœ int result = 0; for (int i = 0; i &amp;lt; candyVec.</description>
    </item>
    <item>
      <title>1005.maximize sum of array after k negations</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</guid>
      <description>Description 1005.maximize-sum-of-array-after-k-negations&#xA;Solution Greedy algorithm.&#xA;Code class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // first step for (int i = 0; i &amp;lt; A.size(); i++) { // second step if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // third step int result = 0; for (int a : A) result += a; // forth step return result; } }; </description>
    </item>
    <item>
      <title>1005.Kæ¬¡å–ååçš„æœ€å¤§åŒ–çš„æ•°ç»„å’Œ</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</guid>
      <description>é—®é¢˜æè¿° 1005.Kæ¬¡å–ååæœ€å¤§åŒ–çš„æ•°ç»„å’Œ&#xA;è§£é¢˜æ€è·¯ è´ªå¿ƒç®—æ³•&#xA;ä»£ç  class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // ç¬¬ä¸€æ­¥ for (int i = 0; i &amp;lt; A.size(); i++) { // ç¬¬äºŒæ­¥ if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // ç¬¬ä¸‰æ­¥ int result = 0; for (int a : A) result += a; // ç¬¬å››æ­¥ return result; } }; </description>
    </item>
    <item>
      <title>45.jump game ii</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii/</guid>
      <description>Description 45.jump-game-ii&#xA;Solution In outer loop, we traverse from back to front, while in inner loop, we traverse from front to back, to find the station with minimum index that can arrive at destination. Make the station the new destination, and cnt++.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>45.è·³è·ƒæ¸¸æˆII</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 45.è·³è·ƒæ¸¸æˆII&#xA;è§£é¢˜æ€è·¯ å¤–å¾ªç¯è¿˜æ˜¯ä»æœ«å°¾å‘å‰éå†ï¼Œå†…å¾ªç¯ä»å‰å¾€åéå†ï¼Œæ¯æ¬¡æ‰¾èƒ½åˆ°è¾¾ç»ˆç‚¹çš„ç´¢å¼•æœ€å°çš„ä½ç½®ï¼Œè¯¥ä½ç½®ä½œä¸ºæ–°çš„ç»ˆç‚¹ï¼ŒåŒæ—¶æ­¥æ•°cnt++ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.size(); i++) { if (nums[i] + i &amp;gt;= cur_end) { cur_end = i; cnt++; break; } } } return cnt; } }; </description>
    </item>
    <item>
      <title>55.jump game</title>
      <link>http://localhost:1313/posts/leet/55.jump-game/</link>
      <pubDate>Sun, 30 Oct 2022 16:04:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game/</guid>
      <description>Description 55.jump-game&#xA;Solution Traversing from back to front, if nums[j] can be achieved from nums[j - 1] or nums in the front, then destination change from nums[j] to nums[j - 1] or num in the front.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r !</description>
    </item>
    <item>
      <title>55.è·³è·ƒæ¸¸æˆ</title>
      <link>http://localhost:1313/posts/leet/55.jump-game.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:03:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game.zh/</guid>
      <description>é—®é¢˜æè¿° 55.è·³è·ƒæ¸¸æˆ&#xA;è§£é¢˜æ€è·¯ ä»åå‘å‰éå†ï¼Œåªè¦nums[j]èƒ½ç”±nums[j - 1]æˆ–è€…æ›´å‰é¢çš„ç‚¹è·³åˆ°ï¼Œé‚£ä¹ˆç»ˆç‚¹å°±ä»nums[j]å˜æˆnums[j - 1]æˆ–æ›´å‰é¢çš„ç‚¹ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r != 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>72.edit distance</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance/</guid>
      <description>Description 72.edit-distance&#xA;Solution It&amp;rsquo;s easy to consider what dp[i][j] should denotes.&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else, we can consider in three cases: replace the word1[i - 1]: dp[i][j] = dp[i - 1][j - 1] + 1; remove word1[i - 1]: dp[i][j] = dp[i - 1][j] + 1; insert word2[j - 1] between word[i - 1] and word[i], it&amp;rsquo;s the same as remove word2[j - 1]: dp[i][j] = dp[i][j - 1] + 1; We should also pay attention to the initialzation of dp[i][j].</description>
    </item>
    <item>
      <title>72.ç¼–è¾‘è·ç¦»</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance.zh/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance.zh/</guid>
      <description>é—®é¢˜æè¿° 72.ç¼–è¾‘è·ç¦»&#xA;è§£é¢˜æ€è·¯ dp[i][j]çš„å«ä¹‰ä¸å†èµ˜è¿°:&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else,åˆ†ä¸ºä¸‰ç§æ“ä½œæƒ…å†µ: æ›¿æ¢æœ«å°¾å­—ç¬¦: dp[i][j] = dp[i - 1][j - 1] + 1; åˆ é™¤word1çš„ç¬¬iä¸ªå­—ç¬¦: dp[i][j] = dp[i - 1][j] + 1; åˆ é™¤word2çš„ç¬¬jä¸ªå­—ç¬¦ï¼Œå³ç›¸å½“äºåœ¨ç¬¬iä¸ªå­—ç¬¦åæ’å…¥word2[j - 1]: dp[i][j] = dp[i][j - 1] ä»£ç  class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 1; i &amp;lt;= word1.</description>
    </item>
    <item>
      <title>583.delete operations for two strings</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</guid>
      <description>Description 583.delete-operation-for-two-strings&#xA;Solution dp[i][j] denotes minimum number of options to make strings the same when considering the first i characters of word1 and the first j characters of word2.&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; Code class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.</description>
    </item>
    <item>
      <title>583.ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</guid>
      <description>é—®é¢˜æè¿° 583.ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ&#xA;è§£é¢˜æ€è·¯ dp[i][j]è¡¨ç¤ºå¯¹word1çš„å‰iä¸ªå­—ç¬¦ï¼Œword2çš„å‰jä¸ªå­—ç¬¦ï¼Œä½¿å¾—å®ƒä»¬ç›¸åŒçš„æœ€å°æ­¥æ•°:&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; ä»£ç  class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 0; i &amp;lt;= word1.size(); i++) { dp[i][0] = i; } for (int j = 0; j &amp;lt;= word2.</description>
    </item>
    <item>
      <title>115.distinct subsequences</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences/</guid>
      <description>Description 115.distinct-subsequence&#xA;Solution dp[i][j] denotes the occurrences of the first j characters of t in the first i characters of s:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(uses[i - 1] and not use s[i - 1]åŒ¹é…) else dp[i][j] = dp[i - 1][j]; Code class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>115.ä¸åŒçš„å­åºåˆ—</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</guid>
      <description>é—®é¢˜æè¿° 115.ä¸åŒçš„å­åºåˆ—&#xA;è§£é¢˜æ€è·¯ dp[i][j]è¡¨ç¤ºè€ƒè™‘è€ƒè™‘tçš„å‰jä¸ªå­—ç¬¦åœ¨sçš„å‰iä¸ªå­—ç¬¦ä¸­çš„å‡ºç°ä¸ªæ•°:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(è¡¨ç¤ºä½¿ç”¨s[i - 1]åŒ¹é…å’Œä¸ä½¿ç”¨s[i - 1]åŒ¹é…) else dp[i][j] = dp[i - 1][j]; ä»£ç  class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;uint32_t&amp;gt;(t.size() + 1, 0)); // dp[0][0] = 1; for (int i = 0; i &amp;lt;= s.size(); i++) { dp[i][0] = 1; } for (int i = 1; i &amp;lt;= s.</description>
    </item>
    <item>
      <title>392.is subsequence</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence/</guid>
      <description>Description 392.is-subsequence&#xA;Solution It&amp;rsquo;s similar to 1143.longest-common-subsequence. We just need to judge whether the result is equal to s.size().&#xA;Code class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>392.åˆ¤æ–­å­åºåˆ—</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence.zh/</guid>
      <description>é—®é¢˜æè¿° 392.åˆ¤æ–­å­åºåˆ—&#xA;è§£é¢˜æ€è·¯ ä¸1143.æœ€é•¿å…¬å…±å­åºåˆ—åŸºæœ¬ä¸€æ ·ï¼Œåªéœ€è¦å†åˆ¤æ–­ç»“æœæ˜¯å¦å’Œs.size()ç›¸ç­‰å°±å¥½äº†ã€‚&#xA;ä»£ç  class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>53.maximum subarray</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray/</link>
      <pubDate>Sun, 30 Oct 2022 14:30:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray/</guid>
      <description>Description 53.maximum-subarray&#xA;Solution dp[i] denotes maximum sum of subarray ending with nums[i - 1], then: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;Code class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>53.æœ€å¤§å­æ•°ç»„å’Œ</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</guid>
      <description>é—®é¢˜æè¿° 53.æœ€å¤§å­æ•°ç»„å’Œ&#xA;è§£é¢˜æ€è·¯ åŠ¨æ€è§„åˆ’ ä»¤dp[i]è¡¨ç¤ºä»¥nums[i - 1]ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œï¼Œåˆ™: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;è´ªå¿ƒç®—æ³• ä»¥ç¬¬ä¸€ä¸ªæ­£æ•°ä¸ºèµ·ç‚¹ï¼Œå¼€å§‹è®°å½•å’Œsum_tempï¼ŒåŒæ—¶è®°å½•æœ€å¤§å’Œsumï¼Œå½“sum_tempå°äº0æ—¶ï¼Œèµ·ç‚¹å˜ä¸ºæ–°çš„æ­£æ•°ã€‚&#xA;ä»£ç  class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>1035.uncrossed lines</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines/</link>
      <pubDate>Sat, 29 Oct 2022 20:45:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines/</guid>
      <description>Description 1035.uncrossed-lines&#xA;Solution The same as 1143.longest-common-subsequence&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1035.ä¸ç›¸äº¤çš„çº¿</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:44:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</guid>
      <description>é—®é¢˜æè¿° 1035.ä¸ç›¸äº¤çš„çº¿&#xA;è§£é¢˜æ€è·¯ åªæ˜¯1143.æœ€é•¿å…¬å…±å­åºåˆ—çš„å¦ä¸€ç§æè¿°&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1143.longest common subsequence</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</guid>
      <description>Description 1143.longest-common-subsequence&#xA;Solution dp[i][j] denotes the length of longest common subsequence of first i characters of text1 and first j characters of text2:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.</description>
    </item>
    <item>
      <title>1143.æœ€é•¿å…¬å…±å­åºåˆ—</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</guid>
      <description>é—®é¢˜æè¿° 1143.æœ€é•¿å…¬å…±å­åºåˆ—&#xA;è§£é¢˜æ€è·¯ dp[i][j]è¡¨ç¤ºtext1çš„å‰iä¸ªå­—ç¬¦å’Œtext2çš„å‰jä¸ªå­—ç¬¦é‡Œæœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); ä»£ç  #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.size() + 1, vector&amp;lt;int&amp;gt;(text2.size() + 1, 0)); int m = 0; int res = 0; for (int i = 1; i &amp;lt;= text1.</description>
    </item>
    <item>
      <title>134.gas station</title>
      <link>http://localhost:1313/posts/leet/134.gas-station/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station/</guid>
      <description>Description 134.gas-station&#xA;Solution We should consider total oil consumption total_oil, and remaining oil from new start station cur_oil(not replenish oil in new station):&#xA;total_oil &amp;lt; 0, can&amp;rsquo;t complete; cur_oil &amp;lt; 0, start at the new station; Code class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //total_oil need &amp;gt; 0, or can&amp;#39;t complete total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // start from i + 1 starting_station = i + 1; // restore to first state cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
    <item>
      <title>134.åŠ æ²¹ç«™</title>
      <link>http://localhost:1313/posts/leet/134.gas-station.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station.zh/</guid>
      <description>é—®é¢˜æè¿° 134.åŠ æ²¹ç«™&#xA;è§£é¢˜æ€è·¯ è€ƒè™‘ä¸¤ä¸ªå˜é‡ï¼Œä¸€ä¸ªæ˜¯æ€»æ²¹è€—total_oilï¼Œä¸€ä¸ªæ˜¯ä»èµ·ç‚¹åˆ°ä¸‹ä¸€ä¸ªç«™ç‚¹åæ±½è½¦å†…éƒ¨å‰©ä½™çš„æ±½æ²¹cur_oil(æ²¡æœ‰åœ¨ç›®æ ‡ç«™ç‚¹è¡¥å……æ²¹è€—)ã€‚ æ€»æ²¹è€—total_oil &amp;lt; 0ï¼Œè¯´æ˜ä¸å¯èƒ½åˆ°; cur_oil &amp;lt; 0ï¼Œåˆ™ä»¥åˆ°è¾¾çš„ç«™ç‚¹ä½œä¸ºæ–°çš„èµ·ç‚¹å†å‡ºå‘;&#xA;ä»£ç  class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //æ€»å’Œå¿…é¡»å¤§äºç­‰äº0ï¼Œå¦åˆ™ä¸èƒ½å®Œæˆç»•è¡Œ total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // ä¸€ä¸ªç«™çš„æ”¶ç›Šå¦‚æœå°äº0ï¼Œè‚¯å®šä¸èƒ½ä½œä¸ºèµ·ç‚¹ï¼›è€Œè¿ç»­çš„å¤šä¸ªç«™ä¹Ÿå¯ä»¥ç­‰æ•ˆåœ°çœ‹åšä¸€ä¸ªç«™ï¼Œå¦‚æœå…¶ç´¯ç§¯æ”¶ç›Šå°äº0ï¼Œå°±è·³è¿‡ï¼Œå¯»æ‰¾ä¸‹ä¸€ä¸ªã€‚ starting_station = i + 1; // è¿˜åŸåˆ°åˆå§‹çŠ¶æ€ cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
    <item>
      <title>718.maximum length of repeated subarray</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</guid>
      <description>Description 718.maximum-length-of-repeated-subarray&#xA;Solution dp[i][j] denotes the length of longest public subarray of two subarray ending with nums1[i - 1], nums2[j - 1];&#xA;Recurrence formula&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; Code class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.</description>
    </item>
    <item>
      <title>718.æœ€é•¿é‡å¤å­æ•°ç»„</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</guid>
      <description>é—®é¢˜æè¿° 718.æœ€é•¿é‡å¤å­æ•°ç»„&#xA;è§£é¢˜æ€è·¯ dp[i][j]è¡¨ç¤ºåˆ†åˆ«ä»¥nums1[i - 1], nums2[j - 1]ç»“å°¾çš„ä¸¤ä¸ªå­æ•°ç»„çš„æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦ï¼›&#xA;é€’æ¨å…³ç³»:&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; ä»£ç  class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) // dp[i][j] = max(dp[i - 1][j - 1] + 1, dp[i][j]); dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] &amp;gt; m) m = dp[i][j]; } } return m; } }; </description>
    </item>
    <item>
      <title>674.longest continuous increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</guid>
      <description>Description 674.longest-continuous-increasing-subsequence&#xA;Solution dp[i] denotes the length of longest continuous increasing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; Code class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>674.æœ€é•¿è¿ç»­é€’å¢åºåˆ—</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</guid>
      <description>é—®é¢˜æè¿° 674.æœ€é•¿è¿ç»­é€’å¢åºåˆ—&#xA;è§£é¢˜æ€è·¯ dp[i]è¡¨ç¤ºä»¥nums[i - 1]ç»“å°¾çš„æœ€é•¿è¿ç»­é€’å¢å­åºåˆ—é•¿åº¦;&#xA;é€’æ¨å…³ç³»ä¸º:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; ä»£ç  class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>300.longest increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</guid>
      <description>Description 300.longest-increasing-subsequence&#xA;Solution The key point is: what dp[i] means is conducive to solving this problem. Since subsequence may be not continuous, dp[i] should denotes maximum length increaing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; i dp[i] = max(dp[j] + 1, dp[i]) Code class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // initialize dp[i] as 1 since there is one element at least // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>300.æœ€é•¿é€’å¢å­åºåˆ—</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</guid>
      <description>é—®é¢˜æè¿° 300.æœ€é•¿é€’å¢å­åºåˆ— æœ¬é¢˜ç®€å†™ä¸ºLISé—®é¢˜ï¼Œä¸LCSé—®é¢˜ï¼ˆæœ€é•¿å…¬å…±å­åºåˆ—ï¼‰ç›¸å¯¹ã€‚&#xA;è§£é¢˜æ€è·¯ åŠ¨æ€è§„åˆ’ å…³é”®åœ¨äºï¼Œdp[i]è¡¨ç¤ºä»€ä¹ˆå«ä¹‰ä¾¿äºè§£è¿™é“é¢˜ï¼Œå­åºåˆ—ä¸ä¸€å®šè¿ç»­ï¼Œæ‰€ä»¥ä¸ºäº†ä¾¿äºæ±‚è§£ï¼Œdp[i]åº”è¯¥è¡¨ç¤ºä¸ºä»¥nums[i - 1]ç»“å°¾çš„æœ€é•¿ä¸¥æ ¼é€’å¢å­åºåˆ—çš„é•¿åº¦ï¼›&#xA;é€’æ¨å…³ç³»ä¸º:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; iï¼Œè¡¨ç¤ºnums[i - 1]å‰çš„ä»»æ„ä¸€ä¸ªå…ƒç´  dp[i] = max(dp[j] + 1, dp[i]) è´ªå¿ƒ åŠ¨æ€è§„åˆ’çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$ï¼Œè¿™é‡Œå­˜åœ¨ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦æ›´ä½çš„è´ªå¿ƒè§£æ³•ï¼š&#xA;åŠ¨æ€è§„åˆ’çš„æ—¶é—´$O(n^2)$çš„æ—¶é—´å¤æ‚åº¦ä¸­ï¼Œ$O(n)$çš„æ—¶é—´å¤æ‚åº¦åœ¨ä¸éå†æ•´ä¸ªæ•°ç»„ï¼Œè¿™æ˜¯æ— æ³•é¿å…çš„ï¼›å‰©ä¸‹çš„$O(n)$çš„æ—¶é—´å¤æ‚åº¦ï¼Œå®é™…ä¸Šåœ¨æ‰¾ä¸€ä¸ªæ»¡è¶³j &amp;lt; iä»¥åŠnums[j] &amp;lt; nums[i]çš„å¹¶ä¸”ä½¿dp[j]æœ€å¤§çš„jï¼›&#xA;é‚£ä¹ˆï¼Œå¯ä»¥è½¬åŒ–ä¸ºæ‰¾dp[j]å›ºå®šçš„æƒ…å†µä¸‹ï¼Œæœ€å°çš„ä¸€ä¸ªnums[j]ï¼Œè¿™æ ·å¿…ç„¶èƒ½å¤Ÿä¼˜å…ˆæ»¡è¶³ï¼Œnums[i] &amp;gt; nums[j]ï¼›å› æ­¤æˆ‘ä»¬æ„é€ ä¸€ä¸ªè´ªå¿ƒæ•°ç»„ï¼šmin_lenï¼Œmin_len[i] = xè¡¨ç¤ºé•¿åº¦ä¸ºiçš„ä¸Šå‡å­åºåˆ—çš„æœ€å°ç»“å°¾å…ƒç´ ä¸ºxã€‚è€ƒè™‘åˆ°min_lenä¸€å®šæ˜¯ä¸ªå•è°ƒé€’å¢çš„æ•°ç»„ï¼ˆæ˜“è¯ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åŸºäºè¿™ä¸ªå•è°ƒé€’å¢çš„ç‰¹æ€§ï¼Œåˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œæ‰¾åˆ°æ»¡è¶³min_len[j] &amp;lt; nums[i]çš„æœ€å¤§çš„jï¼Œå³åˆ©ç”¨$O(\log n)$æ‰¾åˆ°æœ€ä½³è½¬ç§»ä½ç½®ã€‚&#xA;ä»£ç  åŠ¨æ€è§„åˆ’ class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // dp[0]ä¸è€ƒè™‘ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥åˆå§‹åŒ–ä¸º1 // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>714.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</guid>
      <description>é—®é¢˜æè¿° 714.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹&#xA;è§£é¢˜æ€è·¯ åˆ†ä¸ºæ‰‹ä¸­æœ‰è‚¡ç¥¨å’Œæ— è‚¡ç¥¨ä¸¤ç§æƒ…å†µè®¨è®ºï¼Œè®¾å®šåœ¨å–å‡ºè‚¡ç¥¨æ—¶æ”¯å‡ºæ‰‹ç»­è´¹:&#xA;æ‰‹ä¸­æœ‰è‚¡ç¥¨:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); æ‰‹ä¸­æ— è‚¡ç¥¨:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); åˆå§‹åŒ–:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; ä»£ç  class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); dp[0][0] = -prices[0]; dp[0][1] = -fee; for (int i = 1; i &amp;lt;= prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); } return dp[prices.</description>
    </item>
    <item>
      <title>714.best time to buy and sell stock with transaction fee</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</guid>
      <description>Description 714.best-time-to-buy-and-sell-stock-with-transaction-fee&#xA;è§£é¢˜æ€è·¯ We can consider this problem in two cases: owning stock and not owning stock, assuming that you need to pay transaction fee when selling stock.&#xA;owning stock:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); not owning stock:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); Initializing dp:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; Code class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>309.best time to buy and sell stock with cooldown</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>Description 309.best-time-to-buy-and-sell-stock-with-cooldown&#xA;Solution The key point is find what dp should denote and its recurrence formula.&#xA;dp[i] indicates only considering first i days, and is devided into five cases: no operation, bought but not sold (stock in hand), exactly sold, cooling off period, and idle, which are noted as dp[i][0], dp[i][1], dp[i][2], dp[i][3], and dp[i][4] correspondingly.&#xA;Recurrence formula:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // last day can be on operation, bought but not sold, cooling off period, idle dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // last day can be cooling off period adn idle.</description>
    </item>
    <item>
      <title>309.æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</guid>
      <description>é—®é¢˜æè¿° 309.æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜çš„å…³é”®åœ¨äºæ‰¾åˆ°dpçš„å®é™…å«ä¹‰ï¼Œä»¥åŠå®ƒçš„é€’æ¨å…³ç³»; dp[i]è¡¨ç¤ºåªè€ƒè™‘å‰iå¤©çš„æƒ…å†µï¼Œåˆ†ä¸ºæ— æ“ä½œã€ä¹°å…¥æœªå–å‡º(æ‰‹ä¸­æœ‰è‚¡ç¥¨)ã€æ­£å¥½å–å‡ºã€å†·é™æœŸã€ç©ºé—²äº”ç§æƒ…å†µï¼Œåˆ†åˆ«è®°ä¸ºdp[i][0], dp[i][1], dp[i][2], dp[i][3], dp[i][4].&#xA;é€’æ¨å…³ç³»å¦‚ä¸‹:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // ä¸Šä¸€å¤©çš„å¯èƒ½æƒ…å†µæœ‰æ— æ“ä½œã€ä¹°å…¥æœªå–å‡ºã€å†·é™æœŸã€ç©ºé—²å››ç§æƒ…å†µ dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // ä¸Šä¸€å¤©å¯èƒ½æœ‰å†·é™æœŸå’Œç©ºé—²ä¸¤ç§æƒ…å†µ ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max3(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ?</description>
    </item>
    <item>
      <title>123.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIII</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</link>
      <pubDate>Wed, 12 Oct 2022 20:04:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</guid>
      <description>é—®é¢˜æè¿° 123.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIII&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜çš„å…³é”®åœ¨äºæ‰¾åˆ°dpçš„å®é™…å«ä¹‰ï¼Œä»¥åŠå®ƒçš„é€’æ¨å…³ç³»;&#xA;dp[i]è¡¨ç¤ºåªè€ƒè™‘å‰iå¤©çš„æƒ…å†µï¼Œé‚£ä¹ˆåˆ°äº†ç¬¬iå¤©ï¼Œæœ‰äº”ç§å¯èƒ½çš„æƒ…å†µ:&#xA;æ²¡æœ‰åšä»»ä½•æ“ä½œï¼Œè®°ä¸ºdp[i][0]; å‰iå¤©å‘ç”Ÿäº†ä¸€æ¬¡ä¹°å…¥ï¼Œè®°ä¸ºdp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) å‰iå¤©å‘ç”Ÿäº†ä¸€æ¬¡å–å‡ºï¼Œè®°ä¸ºdp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) å‰iå¤©å‘ç”Ÿäº†ä¸¤æ¬¡ä¹°å…¥ï¼Œè®°ä¸ºdp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) å‰iå¤©å‘ç”Ÿäº†ä¸¤æ¬¡å–å‡ºï¼Œè®°ä¸ºdp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) åˆå§‹åŒ–:&#xA;dp[0][0] = 0; dp[0][1] = -prices[0]; // å‘ç”Ÿäº†ä¸€æ¬¡ä¹°å…¥ dp[0][2] = 0; // ä¹°å…¥åˆå–å‡º dp[0][3] = -prices[0]; // ä¹°å…¥-&amp;gt;å–å‡º-&amp;gt;ä¹°å…¥ dp[0][4] = 0; // ä¹°å…¥-&amp;gt;å–å‡º-&amp;gt;ä¹°å…¥-&amp;gt;å–å‡º ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>122.best time to buy and sell stock ii</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sat, 08 Oct 2022 08:14:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Description 122.best-time-to-buy-and-sell-stock-ii&#xA;Solution The key point of this problem is to find the recurrence formula of dp[i]. Let&amp;rsquo;s discuss this problem in two cases.&#xA;if prices[i - 1] is not selected, then dp[i] = dp[i - 1]. It shows that: prices[i - 1] &amp;lt; prices[i - 2]; if prices[i - 1] is selected, then prices[i - 1] &amp;gt;= prices[i - 2], dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2].</description>
    </item>
    <item>
      <title>122.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºII</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 122.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºII&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜çš„å…³é”®æ˜¯è¦æ‰¾dpçš„é€’æ¨å…³ç³»ï¼Œåˆ†ä¸¤ç§æƒ…å†µè®¨è®º:&#xA;prices[i - 1]ä¸ä¼šè¢«é€‰æ‹©ï¼Œé‚£ä¹ˆdp[i] = dp[i - 1]ï¼Œå…¶å®ä¹Ÿè¯´æ˜ï¼Œprices[i - 1] &amp;lt; prices[i - 2]ï¼› prices[i - 1]è¢«é€‰æ‹©ï¼Œé‚£ä¹ˆprices[i - 1] &amp;gt;= prices[i - 2]ï¼Œdp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]ã€‚ ä»£ç  class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.size() == 1) return 0; vector&amp;lt;int&amp;gt; dp(prices.size() + 1, 0); for (int i = 2; i &amp;lt;= prices.size(); i++) { if (prices[i - 1] &amp;gt;= prices[i - 2]) dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]; else dp[i] = dp[i - 1]; } return dp[prices.</description>
    </item>
    <item>
      <title>123.best time to buy and sell stock iii</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</guid>
      <description>Description 123.best-time-to-buy-and-sell-stock-iii&#xA;Solution The key point is to find what dp should denotes and the recursion formula:&#xA;dp[i] denotes only considering first i days, then by day i, there are five possible cases:&#xA;no operation, written as dp[i][0]; buy stock once in first i days, written as dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) sell stock once in first i days, written as dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) by stock twice in first i days, written as dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) sell stock twice in first i days, written as dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) Initializaiton:</description>
    </item>
    <item>
      <title>121.best time to buy and sell stock</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 07 Oct 2022 16:34:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</guid>
      <description>Description 121.best-time-to-buy-and-sell-stock&#xA;Solution dynamic programming dp[i] denotes maximum profit in first i days, so the recurrence relation of dp[i] is: dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0).&#xA;greedy algorithm Let&amp;rsquo;s use cur to record the minimum element and replace the value of cur if the element is smaller, if the element is larger than cur, calculate the profit, save the maximum profit.&#xA;Code class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>121.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</link>
      <pubDate>Fri, 07 Oct 2022 16:33:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</guid>
      <description>é—®é¢˜æè¿° 121.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº&#xA;è§£é¢˜æ€è·¯ åŠ¨æ€è§„åˆ’ dp[i]è¡¨ç¤ºå‰iå¤©çš„æœ€å¤§æ”¶ç›Šï¼Œé‚£ä¹ˆdp[i]çš„é€’æ¨å…¬å¼ä¸º:dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0)ã€‚&#xA;è´ªå¿ƒç®—æ³• åˆ©ç”¨curè®°å½•æœ€å°å…ƒç´ ï¼Œç¢°åˆ°æ›´å°çš„å°±æ›¿æ¢curçš„å€¼ï¼Œé‡åˆ°æ¯”å®ƒå¤§çš„å°±è¿›è¡Œä¸€æ¬¡åˆ©æ¶¦è®¡ç®—ï¼Œä¿å­˜æœ€å¤§çš„åˆ©æ¶¦ã€‚&#xA;ä»£ç  class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } int max(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ? a : c; else return b &amp;gt; c ? b : c; } public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.</description>
    </item>
    <item>
      <title>337.æ‰“å®¶åŠ«èˆIII</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</guid>
      <description>é—®é¢˜æè¿° 337.æ‰“å®¶åŠ«èˆIII&#xA;è§£é¢˜æ€è·¯ ä¸¥æ ¼æ¥è¯´ï¼Œè¿™ä¸€é¢˜å’Œ198.æ‰“å®¶åŠ«èˆï¼Œ213.æ‰“å®¶åŠ«èˆIIçš„æ€è·¯å¹¶ä¸ä¸€è‡´ã€‚&#xA;é¦–å…ˆï¼Œè¿™ä¸€é“é¢˜éå†çš„æ˜¯æ ‘ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚è¦æ¯”è¾ƒçš„æ˜¯é€‰æ‹©ç›®å‰èŠ‚ç‚¹å’Œç›®å‰èŠ‚ç‚¹å·¦å­èŠ‚ç‚¹+å³å­èŠ‚ç‚¹ï¼Œå› æ­¤åœ¨éå†æ–¹å¼ä¸Šéœ€è¦é‡‡å–ååºéå†ã€‚&#xA;åŒæ—¶ï¼Œä½œä¸ºäºŒå‰æ ‘çš„é—®é¢˜ï¼Œä¸€èˆ¬æ˜¯è€ƒè™‘é€’å½’è¿›è¡Œå¤„ç†ï¼š&#xA;é€’å½’çš„ç»ˆæ­¢æ¡ä»¶ï¼š å½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼› é€’å½’å‡½æ•°çš„è¿”å›å€¼ï¼š è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º2çš„æ•°ç»„dpï¼Œdp[0]è¡¨ç¤ºä¸å·å½“å‰èŠ‚ç‚¹çš„æœ€å¤§é‡‘é’±ï¼Œdp[1]è¡¨ç¤ºå·å½“å‰èŠ‚ç‚¹çš„æœ€å¤§é‡‘é’±ï¼› æœ¬çº§é€’å½’åšä»€ä¹ˆï¼š è®¡ç®—å·å½“å‰èŠ‚ç‚¹çš„æ”¶ç›Šval1ï¼Œä¸å·å½“å‰èŠ‚ç‚¹çš„æ”¶ç›Šval2ï¼Œè¿”å›{val2, val1}ã€‚ ä»£ç  class Solution { public: int rob(TreeNode* root) { vector&amp;lt;int&amp;gt; result = robTree(root); return max(result[0], result[1]); } // é•¿åº¦ä¸º2çš„æ•°ç»„ï¼Œ0ï¼šä¸å·ï¼Œ1ï¼šå· vector&amp;lt;int&amp;gt; robTree(TreeNode* cur) { if (cur == NULL) return vector&amp;lt;int&amp;gt;{0, 0}; vector&amp;lt;int&amp;gt; left = robTree(cur-&amp;gt;left); vector&amp;lt;int&amp;gt; right = robTree(cur-&amp;gt;right); // å·curï¼Œé‚£ä¹ˆå°±ä¸èƒ½å·å·¦å³èŠ‚ç‚¹ã€‚ int val1 = cur-&amp;gt;val + left[0] + right[0]; // ä¸å·curï¼Œé‚£ä¹ˆå¯ä»¥å·ä¹Ÿå¯ä»¥ä¸å·å·¦å³èŠ‚ç‚¹ï¼Œåˆ™å–è¾ƒå¤§çš„æƒ…å†µ int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; } }; </description>
    </item>
    <item>
      <title>337.house robber iii</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii/</guid>
      <description>Description 337.house-robber-iii&#xA;Solution Strictly speaking, the idea of this problem is different from 198.house-robberï¼Œ213.house-robber-ii.&#xA;At first, what this problem need to traverse is tree, rather than an array. We need to compare selecting curent node with selecting left-child node and right-child node rather than current node. So, we should select postorder traversal.&#xA;And as a problem of binary tree, we consider recursion.&#xA;termination conditions of recursion current node is null; return value of recursion function return an array dp of length 2, dp[0] denotes maximum amount when not stealing current node, dp[1] denotes maximum amount when stealing current node; what this level of recursion does calculate the amount val1 when stealing current node, val2 for not stealing current node, return {val2, val1}.</description>
    </item>
    <item>
      <title>213.house robber ii</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii/</guid>
      <description>Description 213.house-robber-ii&#xA;Solution Referring to 198.house-robber, there be another constraint that first and last can&amp;rsquo;t be selected at the same time. So we can split the array into two part: one for [0, n - 1), another for [1, n), corresponding to dp0 and dp1 respectively, just return max(dp0, dp1).&#xA;Code class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.</description>
    </item>
    <item>
      <title>213.æ‰“å®¶åŠ«èˆII</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 213.æ‰“å®¶åŠ«èˆII&#xA;è§£é¢˜æ€è·¯ å‚ç…§198.æ‰“å®¶åŠ«èˆï¼Œä½†æ˜¯è¿™é‡Œå¤šäº†ä¸€ä¸ªé¦–å°¾ä¸èƒ½åŒæ—¶é€‰æ‹©çš„é€‰é¡¹ï¼Œå› æ­¤å¯ä»¥è€ƒè™‘å°†æ•°ç»„åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œä¸€ä¸ªåŒ…å«[0, n - 1)ï¼Œä¸€ä¸ªåŒ…å«[1, n)ï¼Œåˆ†åˆ«å¯¹åº”dp0å’Œdp1ï¼Œå–æœ€åä¸¤è€…çš„æœ€å¤§å€¼å³å¯ã€‚&#xA;ä»£ç  class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.size() - 2); int result2 = robRange(nums, 1, nums.size() - 1); return max(result1, result2); } int robRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int end) { if (end == start) return nums[start]; vector&amp;lt;int&amp;gt; dp(nums.size()); dp[start] = nums[start]; dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i &amp;lt;= end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; } }; </description>
    </item>
    <item>
      <title>198.house robber</title>
      <link>http://localhost:1313/posts/leet/198.house-robber/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber/</guid>
      <description>Description 198.house-robber&#xA;Solution dp[i] denotes the maximum amount when the first i houses are considered.&#xA;Let&amp;rsquo;s consider the recursive relationship:&#xA;If the i-th house was stolen, it means that the i - 1th house was not stolen, so dp[i] = dp[i - 2] + a[i - 1]. If the i-th house was not stolen, then dp[i] = dp[i - 1]. So, dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]).</description>
    </item>
    <item>
      <title>198.æ‰“å®¶åŠ«èˆ</title>
      <link>http://localhost:1313/posts/leet/198.house-robber.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber.zh/</guid>
      <description>é—®é¢˜æè¿° 198.æ‰“å®¶åŠ«èˆ&#xA;è§£é¢˜æ€è·¯ dp[i]è¡¨ç¤ºè€ƒè™‘å‰iä¸ªæˆ¿é—´ï¼Œèƒ½çªƒå–åˆ°çš„æœ€å¤§é‡‘é¢ã€‚&#xA;è€ƒè™‘é€’æ¨å…³ç³»:&#xA;å‡è®¾ç¬¬è¦çªƒå–ç¬¬iä¸ªæˆ¿é—´ï¼Œé‚£ä¹ˆè¯´æ˜ç¬¬i - 1ä¸ªæˆ¿é—´ï¼Œè‚¯å®šæ²¡æœ‰è¢«çªƒå–ï¼Œdp[i] = dp[i - 2] + nums[i - 1]ã€‚ å‡è®¾ä¸çªƒå–ç¬¬iä¸ªæˆ¿é—´ï¼Œåˆ™dp[i] = dp[i - 1]ã€‚ ç»¼ä¸Šï¼Œdp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1])ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int rob(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); if (nums.size() == 1) return nums[0]; if (nums.</description>
    </item>
    <item>
      <title>139.word Break</title>
      <link>http://localhost:1313/posts/leet/139.word-break/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break/</guid>
      <description>Description 139.word-break&#xA;Solution First, we should determine what dp array means. In this problem, dp[i] = 1 denotes that a string of length i can be split into words that appear in the dictionary.&#xA;So, we can get the recursive relationship:dp[j] = dp[i] &amp;amp;&amp;amp; substr in [i, j) can be split.&#xA;To initialize dp array: dp[0] = 1.&#xA;Attention: we should traverse volume first, then traverse items; if in the reverse order, it&amp;rsquo;s not convenient to judge whether string can be split.</description>
    </item>
    <item>
      <title>139.å•è¯æ‹†åˆ†</title>
      <link>http://localhost:1313/posts/leet/139.word-break.zh/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break.zh/</guid>
      <description>é—®é¢˜æè¿° 139.å•è¯æ‹†åˆ†&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆç¡®å®šdpæ•°ç»„çš„å«ä¹‰ï¼Œdp[i] = 1åº”è¯¥è¡¨ç¤ºé•¿åº¦ä¸ºiçš„å­—ç¬¦ä¸²ï¼Œå¯ä»¥æ‹†åˆ†æˆå­—å…¸ä¸­å‡ºç°çš„å•è¯;&#xA;åˆ™ï¼Œdpçš„é€’æ¨å…¬å¼ä¸º:dp[j] = dp[i] &amp;amp;&amp;amp; [i, j]åŒºé—´çš„å­—ä¸²å¯ä»¥æ‹†åˆ†æˆå­—å…¸ä¸­çš„å•è¯&#xA;åˆå§‹åŒ–dpæ•°ç»„:dp[0] = 1ã€‚&#xA;è¿™é‡Œè¦æ³¨æ„ï¼Œå…ˆéå†ä½“ç§¯ï¼Œå†éå†ç‰©å“ï¼›å¦‚æœå€’è¿‡æ¥ï¼Œæ˜¯ä¸æ–¹ä¾¿åˆ¤æ–­å­—ä¸²æ˜¯å¦å¯ä»¥æ‹†åˆ†çš„ã€‚&#xA;ä»£ç  #include &amp;lt;string&amp;gt; #include &amp;lt;unordered_set&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::unordered_set; using std::vector; class Solution { public: bool wordBreak(string s, vector&amp;lt;string&amp;gt; &amp;amp;wordDict) { unordered_set&amp;lt;string&amp;gt; wordSet(wordDict.begin(), wordDict.end()); vector&amp;lt;int&amp;gt; dp(s.length() + 1, 0); // 0 ä¸ºfalse dp[0] = 1; // å…ˆéå†ä½“ç§¯ï¼Œå†éå†ç‰©å“ for (int j = 0; j &amp;lt;= s.length(); j++) { for (int i = 0; i &amp;lt;= j; i++) { string word = s.</description>
    </item>
    <item>
      <title>279.å®Œå…¨å¹³æ–¹æ•°</title>
      <link>http://localhost:1313/posts/leet/279.perfect-squares.zh/</link>
      <pubDate>Wed, 05 Oct 2022 17:07:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/279.perfect-squares.zh/</guid>
      <description>é—®é¢˜æè¿° 279.å®Œå…¨å¹³æ–¹æ•°&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜å¯ä»¥è½¬åŒ–æˆä¸€ä¸ªå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œâ€œç‰©å“â€å³{1, 4, 9, 16,...}ç­‰å®Œå…¨å¹³æ–¹æ•°ï¼Œä½“ç§¯é™åˆ¶å³æ‰€ç»™çš„æ•´æ•°$n$ã€‚&#xA;ä»£ç  class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } public: int numSquares(int n) { int num = 1; for (int i = 1; i * i &amp;lt;= n; i++) num = i; vector&amp;lt;int&amp;gt; nums(num, 0); for (int i = 0; i &amp;lt; num; i++) // nums[i] &amp;lt;= n nums[i] = (i + 1) * (i + 1); vector&amp;lt;int&amp;gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; num; i++) { for (int j = nums[i]; j &amp;lt;= n; j++) { if (dp[j - nums[i]] &amp;lt; INT_MAX) dp[j] = min(dp[j], dp[j - nums[i]] + 1); } } return dp[n]; } }; </description>
    </item>
    <item>
      <title>322.coin change</title>
      <link>http://localhost:1313/posts/leet/322.coin-change/</link>
      <pubDate>Wed, 05 Oct 2022 03:53:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change/</guid>
      <description>Description 322.coin-change&#xA;Solution The recursive relationship change from max to min: dp[j] = min(dp[j], dp[j - coins[i]] + 1).&#xA;We need pay attention to issue about initializing dp array. To ensure that if j - coins[i] can&amp;rsquo;t be come up with, dp[j] is still dp[j] in last loop, we should initialize dp as INT_MAX, and dp[0] = 0.&#xA;Attention: INT_MAX + 1 &amp;lt; INT_MAX(in C++)&#xA;Code #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>322.é›¶é’±å…‘æ¢</title>
      <link>http://localhost:1313/posts/leet/322.coin-change.zh/</link>
      <pubDate>Wed, 05 Oct 2022 03:52:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change.zh/</guid>
      <description>é—®é¢˜æè¿° 322.é›¶é’±å…‘æ¢&#xA;è§£é¢˜æ€è·¯ é¦–å…ˆï¼Œé€’æ¨å…³ç³»ä»æœ€å¤§å˜æˆäº†æœ€å°ï¼Œå³dp[j] = min(dp[j], dp[j - coins[i]] + 1)ã€‚&#xA;åŒæ—¶ï¼Œè¦æ³¨æ„å¯¹dpæ•°ç»„çš„åˆå§‹åŒ–é—®é¢˜ï¼Œä¸ºäº†ä¿è¯j - coins[i]æ— æ³•ç»„æˆæ—¶ï¼Œdp[j]é€‰æ‹©çš„ä»æ˜¯ä¸Šä¸€æ¬¡iå¾ªç¯çš„dp[j]ï¼Œå› æ­¤è¦å°†dpæ•°ç»„åˆå§‹åŒ–ä¸ºINT_MAXï¼ŒåŒæ—¶dp[0] = 0ã€‚&#xA;è¦æ³¨æ„INT_MAX + 1 &amp;lt; INT_MAX(åœ¨C++ä¸­)&#xA;ä»£ç  #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } public: int coinChange(vector&amp;lt;int&amp;gt; &amp;amp;coins, int amount) { if (amount == 0) return 0; vector&amp;lt;int&amp;gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; coins.</description>
    </item>
    <item>
      <title>377.combination sum iv</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv/</guid>
      <description>Description 377.combination-sum-iv&#xA;Solution This problem is still a unbounded-knapsack-problem, however, what this problem want to get is permutations rather than combinations.&#xA;With reference to 518.coin-change-ii, traverse volume first, than traverse items.&#xA;ä»£ç  class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // prevent overflow, not dp[j] + dp[j - nums[i]] &amp;lt; INT_MAX if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>377.ç»„åˆæ€»å’ŒIV</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</guid>
      <description>é—®é¢˜æè¿° 377.ç»„åˆæ€»å’ŒIV&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜ä¾æ—§æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œä½†æ˜¯æœ¬é¢˜æ±‚çš„æ˜¯æ’åˆ—è€Œéç»„åˆã€‚&#xA;å‚è€ƒ518.é›¶é’±å…‘æ¢IIï¼Œå…ˆéå†ä½“ç§¯ï¼Œå†éå†ç‰©å“ã€‚&#xA;ä»£ç  class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // é˜²æ­¢æº¢å‡º if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>518.coin change ii</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii/</guid>
      <description>Description 518.coin-change-ii&#xA;Solution This problem is still a unbounded-knapsack-problem. What this problem need to solve is combination rather than combination.&#xA;If we want to get the number of combination, we should traverse items first, than traverse volume. But if you want to get the number of permutation, you should traverse volume first, than traverse items.&#xA;For example, assume that nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2, combnations: {1, 1, 1}, {1, 2}.</description>
    </item>
    <item>
      <title>518.é›¶é’±å…‘æ¢II</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 518.é›¶é’±å…‘æ¢II&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜ä¾æ—§æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œä½†æ˜¯æœ¬é¢˜æ±‚çš„æ˜¯ç»„åˆè€Œéæ’åˆ—ã€‚&#xA;æ±‚ç»„åˆæ—¶ï¼Œå…ˆéå†ç‰©å“ï¼Œå†éå†ä½“ç§¯ï¼›æ±‚æ’åˆ—æ—¶ï¼Œåˆ™æ˜¯å…ˆéå†ä½“ç§¯ï¼Œå†éå†ç‰©å“ã€‚&#xA;ä¾‹å¦‚ï¼šå‡è®¾nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2ï¼Œé€‰æ‹©ç»„åˆæ–¹å¼ä¸º{1, 1, 1}, {1, 2}ã€‚&#xA;dp[0] = 1; for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; 2; i++) { if (j &amp;gt;= nums[i]) dp[j] = dp[j] + dp[j - nums[i]]; } } dp[3] = 3ï¼Œé€‰æ‹©çš„æ’åˆ—æ–¹å¼ä¸º{1, 1, 1}, {1, 2}, {2, 1}ã€‚</description>
    </item>
    <item>
      <title>474.ones and zeroes</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes/</link>
      <pubDate>Wed, 05 Oct 2022 00:34:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes/</guid>
      <description>Description 474.ones-and-zeroes&#xA;Solution This problem can be viewed as a two-dimensional 01-knapsack-problem. There are two-dimensional limits about &amp;ldquo;volume&amp;rdquo;: numbers of $0$ can not exceed $m$ and numbers of $1$ can not exceed $n$.&#xA;Recursive relation: dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ?</description>
    </item>
    <item>
      <title>474.ä¸€å’Œé›¶</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:37:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</guid>
      <description>é—®é¢˜æè¿° 474.ä¸€å’Œé›¶&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜å¯ä»¥çœ‹æˆä¸€ä¸ªäºŒç»´çš„01èƒŒåŒ…é—®é¢˜ï¼Œä½“ç§¯å­˜åœ¨ä¸¤ä¸ªç»´åº¦çš„é™åˆ¶ï¼Œå³$0$çš„ä¸ªæ•°ä¸èƒ½è¶…è¿‡$m$ï¼Œ$1$çš„ä¸ªæ•°ä¸è¶…è¿‡$n$ã€‚&#xA;é€’æ¨å…³ç³»:dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;ä»£ç  #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: int findMaxForm(vector&amp;lt;string&amp;gt; &amp;amp;strs, int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; str_num(strs.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); for (int i = 0; i &amp;lt; strs.size(); i++) { for (int j = 0; j &amp;lt; strs[i].</description>
    </item>
    <item>
      <title>494.target sum</title>
      <link>http://localhost:1313/posts/leet/494.target-sum/</link>
      <pubDate>Tue, 04 Oct 2022 04:22:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum/</guid>
      <description>Description 494.target-sum&#xA;Solution Actually, what we need to do is choose some numbers whose sum is $\max((sum + target) / 2, (sum - target) / 2)$ in this array. So we can change this problem to a 01-knapsack-problem, and dynamic programming can be used to solve this problem. Also, backtracking can be used to solve this problem.&#xA;In this problem, dp[i][j] should denotes the number of methods to make the sum of number selected to be j when considering the first i numbers.</description>
    </item>
    <item>
      <title>494.ç›®æ ‡å’Œ</title>
      <link>http://localhost:1313/posts/leet/494.target-sum.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:09:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum.zh/</guid>
      <description>é—®é¢˜æè¿° 494.ç›®æ ‡å’Œ&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜è¡¨é¢ä¸Šè¯´æ·»åŠ &amp;rsquo;+&amp;lsquo;æˆ–è€…&amp;rsquo;-&amp;rsquo;ï¼Œå®é™…ä¸Šå°±æ˜¯åœ¨è¿™ä¸ªæ•°ç»„ä¸­é€‰æ‹©ä¸€äº›æ•°ï¼Œä½¿è¿™äº›æ•°çš„æ€»å’Œä¸º$\max((sum + target) / 2, (sum - target) / 2)$ã€‚ä»è€Œè½¬æ¢æˆ01èƒŒåŒ…é—®é¢˜ï¼Œåˆ©ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åˆ©ç”¨å›æº¯æ³•æ±‚è§£ã€‚&#xA;åœ¨æœ¬é¢˜ä¸­ï¼Œdp[i][j]åº”è¯¥è¡¨ç¤ºä¸ºè€ƒè™‘å‰iä¸ªæ•°æ—¶ï¼Œä½¿é€‰æ‹©çš„æ•°æ€»å’Œä¸ºjçš„æ–¹æ³•æ•°ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int findTargetSumWays(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int sum = 0; vector&amp;lt;int&amp;gt; my_num(nums.size() + 1, 0); for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; my_num[i + 1] = nums[i]; } if ((sum + target) % 2 == 1) return 0; vector&amp;lt;int&amp;gt; res(1001, 0); res[0] = 1; target = max((sum + target) / 2, (sum - target) / 2); // int cnt = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>unbounded knapsack problem</title>
      <link>http://localhost:1313/posts/tech/unbounded-knapsack-problem/</link>
      <pubDate>Tue, 04 Oct 2022 01:33:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/unbounded-knapsack-problem/</guid>
      <description>Description Unbounded Knapsack Problem&#xA;There are $N$ kinds of items and a knapsack with the capacity of $V$, each item has unlimited pieces available.&#xA;The volume of the $i$-th item is $v_i$, and value is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen&amp;rsquo;t exceed the capacity of the pack.&#xA;Solution It&amp;rsquo;s a classic problem of dynamic programming and knapsack problem.</description>
    </item>
    <item>
      <title>å®Œå…¨èƒŒåŒ…é—®é¢˜</title>
      <link>http://localhost:1313/posts/tech/unbounded-knapsack-problem.zh/</link>
      <pubDate>Mon, 03 Oct 2022 13:50:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/unbounded-knapsack-problem.zh/</guid>
      <description>é—®é¢˜æè¿° å®Œå…¨èƒŒåŒ…é—®é¢˜&#xA;æœ‰$N$ä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡æ˜¯$V$çš„èƒŒåŒ…ï¼Œæ¯ä»¶ç‰©å“éƒ½æœ‰æ— é™ä»¶å¯ç”¨ã€‚&#xA;ç¬¬$i$ç§ç‰©å“çš„ä½“ç§¯æ˜¯$v_i$ï¼Œä»·å€¼æ˜¯$w_i$ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼Œå¯ä½¿è¿™äº›ç‰©å“æ€»ä½“ç§¯ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”æ€»ä»·å€¼æœ€å¤§ã€‚&#xA;è§£é¢˜æ€è·¯ å†…å±‚åµŒå¥—å¾ªç¯ 01èƒŒåŒ…é—®é¢˜ æ¯æ ·ç‰©å“åªèƒ½ä½¿ç”¨ä¸€ä»¶ï¼Œè€Œé’ˆå¯¹å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨å†…å±‚æœ‰å…³ä½“ç§¯çš„å¾ªç¯ä¸­ï¼Œå†æ·»åŠ ä¸€å±‚å¾ªç¯ï¼Œæšä¸¾ä¸€å…±ä½¿ç”¨äº†å¤šå°‘ä»¶ç‰©å“$i$å³å¯ã€‚&#xA;for (int i = 1; i &amp;lt;= n; i++) { for (int j = m; j &amp;gt;= v[i]; j--) { for (k = 1; k * v[i] &amp;lt;= j; k++) { dp[j] = max(dp[j], dp[j - k * v[i] + k * w[i]); } } } æ›´æ”¹éå†æ–¹å‘ åœ¨01èƒŒåŒ…é—®é¢˜ä¸­ï¼Œæˆ‘ä»¬å†…å±‚å…³äºä½“ç§¯çš„å¾ªç¯ï¼Œæ˜¯ä»å¤§åˆ°å°çš„ï¼Œè¿™æ˜¯ä¸ºäº†ä¿è¯åœ¨æ¯”è¾ƒmax(dp[j], dp[j - v[i]] + w[i])æ—¶ï¼Œä½¿ç”¨çš„æ˜¯ä¸Šä¸€æ¬¡iå¾ªç¯çš„æ•°å€¼ï¼›&#xA;è€Œåœ¨å®Œå…¨èƒŒåŒ…é—®é¢˜ä¸­ï¼Œå†…å±‚å…³äºä½“ç§¯çš„å¾ªç¯ï¼Œä¿®æ”¹æˆä»å°åˆ°å¤§å³å¯ï¼Œæ­¤æ—¶dp = max(dp[j], dp[j - v[i]] + w[i])ä¸­ï¼Œdp[j - v[i]] + w[i]ä½¿ç”¨çš„å°±æ˜¯æœ¬æ¬¡iå¾ªç¯ä¸­çš„æ•°å€¼ï¼Œè€Œiå¾ªç¯ä¸­,dp[j - v[i]] = max(dp[j - v[i]], dp[(j - v[i]) - v[i]] + w[i]),ä¾æ¬¡å¾€å‰é€’æ¨ï¼Œæ€»èƒ½æ‰¾åˆ°é‚£ä¸ªæœ€å¤§å€¼dp[j - k * v[i]] + k * w[i]ã€‚</description>
    </item>
    <item>
      <title>1049.last stone weight ii</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</link>
      <pubDate>Sat, 01 Oct 2022 19:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</guid>
      <description>Description 1049.last-stone-weight-ii&#xA;Solution In reality, it&amp;rsquo;s still a 01-pack-problem.&#xA;What it want to get is when you divide the array into two part with least difference of their sum, what the difference is. If you are aware of this, just write code similar to 416.partition-equal-subset-sum.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.</description>
    </item>
    <item>
      <title>1049.æœ€åä¸€å—çŸ³å¤´çš„é‡é‡II</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:22:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 1049.æœ€åä¸€å—çŸ³å¤´çš„é‡é‡II&#xA;è§£é¢˜æ€è·¯ å®é™…ä¸Šè¿˜æ˜¯ä¸€ä¸ª01èƒŒåŒ…é—®é¢˜ã€‚æœ¬è´¨ä¸Šæ˜¯åœ¨æ±‚å°†æ•°ç»„åˆ†æˆå·®å€¼æœ€å°çš„ä¸¤éƒ¨åˆ†ä¹‹åï¼Œè¿™ä¸¤éƒ¨åˆ†çš„å·®å€¼ï¼Œç†è§£äº†è¿™ä¸€ç‚¹ä¹‹åï¼Œå‚ç…§416.åˆ†å‰²ç­‰å’Œå­é›†å†™ä»£ç å°±å¥½äº†ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.size(); i++) { sum += stones[i]; } vector&amp;lt;int&amp;gt; dp(sum / 2 + 1, 0); for (int i = 0; i &amp;lt; stones.size(); i++) { for (int j = sum / 2; j &amp;gt;= stones[i]; j--) dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); } return sum - 2 * dp[sum / 2]; } }; </description>
    </item>
    <item>
      <title>416.åˆ†å‰²ç­‰å’Œå­é›†</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</guid>
      <description>é—®é¢˜æè¿° 416.åˆ†å‰²ç­‰å’Œå­é›†&#xA;è§£é¢˜æ€è·¯ æœ¬é¢˜å®é™…ä¸Šæ˜¯ä¸€ä¸ª01èƒŒåŒ…é—®é¢˜ï¼Œåœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼ŒèƒŒåŒ…çš„ä½“ç§¯$V$æ˜¯æ•°ç»„ä¸­æ‰€æœ‰æ•°çš„çš„å’Œçš„ä¸€åŠ(å‘ä¸‹å–æ•´)ï¼Œç‰©å“çš„ä»·å€¼å°±æ˜¯æ•°ç»„ä¸­æ•°çš„å–å€¼ï¼š&#xA;ä»£ç  #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; } if (sum % 2 == 1) return false; sum_half = sum / 2; vector&amp;lt;int&amp;gt; dp(sum_half + 1, 0); for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>416.partition equal subset sum</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</guid>
      <description>Description 416.partition-equal-subset-sum&#xA;Solution This problem can be viewed as one case of 01-pack-problem&#xA;In this problem, the volume of pack $V$ is half of sum of all integers in the array(rounded down), the value of item is just value of integer in the array.&#xA;Code #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>01èƒŒåŒ…é—®é¢˜</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem.zh/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem.zh/</guid>
      <description>é—®é¢˜æè¿° 01èƒŒåŒ…é—®é¢˜ æœ‰$N$ä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡æ˜¯$V$çš„èƒŒåŒ…ï¼Œæ¯ä»¶ç‰©å“åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚&#xA;ç¬¬$i$ä»¶ç‰©å“çš„ä½“ç§¯æ˜¯$v_i$ï¼Œä»·å€¼æ˜¯$w_i$ï¼Œæ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼Œå¯ä½¿è¿™äº›ç‰©å“æ€»ä½“ç§¯ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œå¹¶ä¸”æ€»ä»·å€¼æœ€å¤§ã€‚&#xA;è§£é¢˜æ€è·¯ åŠ¨æ€è§„åˆ’çš„ç»å…¸ä¾‹é¢˜ï¼Œé¦–å…ˆè€ƒè™‘dp[i][j]çš„å«ä¹‰ï¼Œè¿™é‡Œiè¡¨ç¤ºåªè€ƒè™‘å‰iä¸ªç‰©å“(iä»$1\sim N$)ï¼Œdp[i][j]è¡¨ç¤ºæ€»ä½“ç§¯ä¸ºjçš„æƒ…å†µä¸‹ï¼Œè€ƒè™‘å‰iä¸ªç‰©å“æ—¶ï¼ŒèƒŒåŒ…é‡Œçš„ç‰©å“çš„æœ€å¤§ä»·å€¼ã€‚&#xA;å¯ä»¥åˆ†æˆä¸¤ç§æƒ…å†µè€ƒè™‘dp[i][j]çš„é€’æ¨å…³ç³»ï¼š&#xA;ç¬¬iä¸ªç‰©å“ä¸åœ¨èƒŒåŒ…ä¸­æ—¶ï¼Œdp[i][j] = dp[i - 1][j] æ­¤æ—¶åªæœ‰å‰i - 1ä¸ªç‰©å“ï¼ŒèƒŒåŒ…ä¸­ç‰©å“ä½“ç§¯ä»ä¸ºjã€‚ ç¬¬iä¸ªç‰©å“åœ¨èƒŒåŒ…ä¸­æ—¶ï¼Œdp[i][j] = dp[i - 1][j - v[i]] + w[i] å‰i - 1ä¸ªç‰©å“çš„ä½“ç§¯ä¸ºj - v[i]ã€‚ åˆå§‹åŒ–ï¼Œæ˜¾ç„¶dp[0][0] = 0ã€‚&#xA;æ ¹æ®é€’æ¨å…³ç³»å’Œåˆå§‹åŒ–æ¡ä»¶å†™forå¾ªç¯éå†å³å¯ã€‚&#xA;ä»£ç  #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; const int N = 1010; // ä½“ç§¯ä¸è¶…è¿‡1000ï¼Œ ç‰©å“ä»¶æ•°ä¹Ÿä¸è¶…è¿‡1000 int main() { int n, m; // nä¸ºç‰©å“æ•°é‡ï¼Œmä¸ºèƒŒåŒ…ä½“ç§¯ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int dp[N][N] = {0}; int v[N] = {0}; // ä½“ç§¯ int w[N] = {0}; // ä»·å€¼ for (int i = 1; i &amp;lt;=n; i++) cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i]; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { dp[i][j] = dp[i - 1][j]; if (j &amp;gt;= v[i]) // å½“å‰æ€»ä½“ç§¯è‚¯å®šä¸èƒ½å°äºv[i]ï¼Œå¦‚æœå°äºçš„è¯ï¼Œç¬¬iä¸ªç‰©å“ä¸èƒ½æ”¾ dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } // int res = 0; // for (int j = 1; j &amp;lt;=m; j++) { // res = max(res, dp[n][j]); // ä¸éœ€è¦éå†ï¼Œç›´æ¥è¾“å‡ºdp[n][m]å³å¯ // } cout &amp;lt;&amp;lt; dp[n][m] &amp;lt;&amp;lt; endl; return 0; } ä¼˜åŒ– åˆ†æä¸Šé¢çš„ä»£ç ï¼Œå®é™…ä¸Šdp[i][j]é€’æ¨æ—¶åªä¼šç”¨åˆ°dp[i - 1][j]ï¼Œè€Œä¸ä¼šç”¨åˆ°dp[i - 2][j], dp[i - 3][j]ç­‰ï¼Œå› æ­¤dpæ•°ç»„å®é™…ä¸Šåªéœ€è¦ä¸€ç»´å³å¯ï¼Œç´¢å¼•ä¸ºå½“å‰æ€»ä½“ç§¯ã€‚</description>
    </item>
    <item>
      <title>01 kanpsack problem</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem/</guid>
      <description>Description 01-pack-problem&#xA;There are $N$ items and a pack with capacity of $V$, and each item can only be used once.&#xA;The volume of the $i$-th item is $v_i$, and vaule is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen&amp;rsquo;t exceed the capacity of the pack.&#xA;Solution It&amp;rsquo;s a classic problem of dynamic programming.</description>
    </item>
    <item>
      <title>Dynamic Programming</title>
      <link>http://localhost:1313/posts/tech/dynamic-programming/</link>
      <pubDate>Thu, 29 Sep 2022 16:25:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dynamic-programming/</guid>
      <description>Description Usually, One-dimensional dynamic planning problem, the parameter is always $n$, the result is similar to number sequence $a_n$, or $f(n)$($f$ can be viewed as function or corresponding relationship). At the same time, there will be certain corresponding relationship between $a_n$ and $a_{n - 1}, a_{n - 2}&amp;hellip;a_{1}$, such as $a_n = a_{n-1} + a_{n-2}$(fibonacci sequence).&#xA;Solution Number sequence can be corresponded with array in programming language such as C++. If you find the recursive relationship among number sequence, you can write traversal code using for loop to get the answer.</description>
    </item>
    <item>
      <title>746.min cost climbing stairs</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 16:13:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</guid>
      <description>Description 746.min-cost-climbing-stairs&#xA;Solution It&amp;rsquo;s like 70.climbing-stairs plus, the recursive relationship becomes more complicated, but the essence is the same.&#xA;$$dp_n = \min[dp_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2]]$$&#xA;After get the recursive relationship, we can write traversal code to get the answer using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ?</description>
    </item>
    <item>
      <title>509.fibonacci number</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number/</link>
      <pubDate>Thu, 29 Sep 2022 16:10:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number/</guid>
      <description>Description 509.fibonacci number&#xA;Solution $a_n = a_{n - 1} + a_{n - 2}$.&#xA;Based on the recursive relationship, we can easily write traversal code using for loop.&#xA;Code class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>343.integer break</title>
      <link>http://localhost:1313/posts/leet/343.integer-break/</link>
      <pubDate>Thu, 29 Sep 2022 16:05:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break/</guid>
      <description>Description 343.integer-break&#xA;Solution The key point is still find the recursive relationship.&#xA;Notice that when $n &amp;gt; 4$, $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$.&#xA;So we can easily write traversal code using for loop.&#xA;Code class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>70.climbing stairs</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 15:55:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs/</guid>
      <description>Description 70.climbing-stairs&#xA;Solution Actually, it&amp;rsquo;s the same with 509.fibonacci-number. Let $dp_n$ be the number of ways to get to the top, then we have: $$dp_n = dp_{n - 1} + dp_{n - 2}$$ So we can write the traversal code of for loop.&#xA;Code class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>63.unique paths ii</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii/</link>
      <pubDate>Thu, 29 Sep 2022 15:39:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii/</guid>
      <description>Description 63.unique-paths-ii&#xA;Solution Compared with 62.unique-paths, the main difference is that you need to change $dp_{mn}$ when hitting an obstacle(obstacleGrid[i][j] = 0). Just set dp[i][j] = 0.&#xA;And you need pay attention to judging the conditionality in for loop.&#xA;When i = 0 or j = 0, dp[i][j] = dp[i][j - 1] or dp[i][j] = dp[i - 1][j]. dp[0][0] = 0.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.</description>
    </item>
    <item>
      <title>62.unique paths</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths/</link>
      <pubDate>Thu, 29 Sep 2022 15:28:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths/</guid>
      <description>Description 62.unique-paths&#xA;Solution $dp_{mn}$ means the number of paths from (1, 1) to (m, n). Just find the connection among $dp_{mn}, dp_{(m-1)n}, dp_{m(n-1)}$.&#xA;We have: $$dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$$ Based on the relationship, we can write the traversal code using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>343.æ•´æ•°æ‹†åˆ†</title>
      <link>http://localhost:1313/posts/leet/343.integer-break.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:59:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break.zh/</guid>
      <description>é¢˜ç›®æè¿° 343.æ•´æ•°æ‹†åˆ†&#xA;è§£é¢˜æ€è·¯ è¿˜æ˜¯å¯»æ‰¾é€’æ¨å…³ç³»,è®¾$dp_n$ä¸ºæ­£æ•´æ•°$n$æ‰€æ±‚çš„æœ€å¤§ä¹˜ç§¯ã€‚ è¿™é‡Œå¯ä»¥æ³¨æ„åˆ°:$n &amp;gt; 4$æ—¶ï¼Œ $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$ã€‚ æ ¹æ®é€’æ¨å…³ç³»å†™å‡ºforå¾ªç¯é€’æ¨æ±‚è§£ã€‚&#xA;ä»£ç  class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>63.ä¸åŒè·¯å¾„II</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:55:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</guid>
      <description>é¢˜ç›®æè¿° 63.ä¸åŒè·¯å¾„II&#xA;è§£é¢˜æ€è·¯ ç›¸æ¯”62.ä¸åŒè·¯å¾„IIï¼Œ ä¸»è¦æ˜¯å¤šäº†éšœç¢ç‰©åœ°åˆ¤æ–­ï¼Œè®¾$obstacleGrid[i][j] = 0$ï¼Œåˆ™$dp_{{i}{j}} = 0$ï¼Œå…¶ä½™é€’æ¨å…³ç³»ç›¸åŒã€‚ æ³¨æ„forå¾ªç¯éå†åœ°è¿‡ç¨‹ä¸­çš„æ¡ä»¶åˆ¤æ–­ã€‚å½“i = 0æˆ–j = 0ï¼Œdp[i][j] = dp[i][j - 1]æˆ–dp[i][j] = dp[i - 1][j]ã€‚ dp[0][0] = 0ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m, vector&amp;lt;int&amp;gt;(n, 0)); dp[0][0] = 1; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (i == 0 &amp;amp;&amp;amp; j == 0) { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = 1; } else { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else { if (i == 0) dp[i][j] = dp[i][j - 1]; else if (j == 0) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } } return dp[m - 1][n - 1]; } }; </description>
    </item>
    <item>
      <title>62.ä¸åŒè·¯å¾„</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:51:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths.zh/</guid>
      <description>é—®é¢˜æè¿° 62.ä¸åŒè·¯å¾„&#xA;è§£é¢˜æ€è·¯ è¿˜æ˜¯æ‰¾é€’æ¨å…³ç³»ï¼š $dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>746.ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:36:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</guid>
      <description>é¢˜ç›®æè¿° 746.ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯&#xA;è§£é¢˜æ€è·¯ ç›¸å½“äºçˆ¬æ¥¼æ¢¯çš„è¿›é˜¶ç‰ˆï¼Œé€’æ¨å…³ç³»å˜å¤æ‚äº†ä¸€äº›ï¼Œä½†æœ¬è´¨æ²¡æœ‰å˜ã€‚ $a_n = min(a_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2])$ å†™å‡ºé€’æ¨å…³ç³»åå°±èƒ½å¾ˆæ–¹ä¾¿åœ°å†™å‡ºforå¾ªç¯æ¥éå†æ±‚è§£ã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ? cost[0] : cost[1]; for (int i = 2; i &amp;lt;= sz; i++) { // åŸå§‹ç‰ˆæœ¬ // dp[i] = (dp[i - 2] + cost[i - 2]) &amp;lt; (dp[i - 1] + cost[i - 1]) ?</description>
    </item>
    <item>
      <title>70.çˆ¬æ¥¼æ¢¯</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:56:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</guid>
      <description>é¢˜ç›®æè¿° 70.çˆ¬æ¥¼æ¢¯&#xA;è§£é¢˜æ€è·¯ æœ¬è´¨ä¸Šä¸æ–æ³¢é‚£å¥‘æ•°æ˜¯ä¸€æ ·çš„ï¼š$a_n = a_{n - 1} + a_{n - 2}$ æ„å»ºforå¾ªç¯æ¥éå†ã€‚&#xA;ä»£ç  class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>509.æ–æ³¢é‚£å¥‘æ•°</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:52:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</guid>
      <description>é¢˜ç›®æè¿° 509.æ–æ³¢é‚£å¥‘æ•°&#xA;è§£é¢˜æ€è·¯ $a_n = a_{n-1} + a_{n-2}$ï¼Œåˆ©ç”¨è¿™ä¸€é€’æ¨å…³ç³»æ„å»ºforå¾ªç¯å³å¯ï¼Œå®é™…ä¸Šåªéœ€è¦å®¹é‡ä¸º2çš„æ•°ç»„ã€‚&#xA;ä»£ç  class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>ä¸€ç»´åŠ¨æ€è§„åˆ’-åŸºç¡€ç‰ˆ</title>
      <link>http://localhost:1313/posts/tech/dynamic-programming.zh/</link>
      <pubDate>Wed, 28 Sep 2022 19:23:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dynamic-programming.zh/</guid>
      <description>é—®é¢˜æè¿° ä¸€èˆ¬æ¥è¯´ï¼Œä¸€ç»´åŠ¨æ€è§„åˆ’çš„é—®é¢˜ï¼Œå…¶è¾“å…¥çš„å‚æ•°ä¸€èˆ¬æ˜¯$n$ï¼Œè€Œæ‰€æ±‚ç»“æœæœ‰ç‚¹åƒæ•°åˆ—$a_n$ï¼Œæˆ–è€…è¯´$f(n)$($f$å¯ä»¥è®¤ä¸ºæ˜¯å‡½æ•°æˆ–è€…è¯´å¯¹åº”å…³ç³»)ï¼ŒåŒæ—¶$a_n$ä¸ä¹‹å‰çš„$a_{n-1},a_{n-2},&amp;hellip;a_{1}$æœ‰ä¸€ä¸ªç¡®å®šçš„å¯¹åº”çš„å…³ç³»ï¼Œä¾‹å¦‚$a_n = a_{n-1} + a_{n-2}$(æ–æ³¢é‚£å¥‘æ•°åˆ—)&#xA;è§£é¢˜æ­¥éª¤ æ•°åˆ—å³å¯ä¸ç¼–ç¨‹è¯­è¨€ä¸­çš„æ•°ç»„å¯¹åº”èµ·æ¥ï¼Œåœ¨æ‰¾åˆ°æ•°åˆ—ä¹‹é—´çš„è¿­ä»£å…³ç³»æ—¶ï¼Œå³å¯ç¼–å†™forå¾ªç¯æ¥æ±‚è§£ã€‚&#xA;ä¾‹é¢˜ 509.æ–æ³¢é‚£å¥‘æ•° 509.æ–æ³¢é‚£å¥‘æ•°-é¢˜è§£ 70.çˆ¬æ¥¼æ¢¯ 70.çˆ¬æ¥¼æ¢¯-é¢˜è§£ 746.ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ 746.ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯-é¢˜è§£ 343.æ•´æ•°æ‹†åˆ† 343.æ•´æ•°æ‹†åˆ†-é¢˜è§£ 62.ä¸åŒè·¯å¾„ 62.ä¸åŒè·¯å¾„-é¢˜è§£ 63.ä¸åŒè·¯å¾„II 63.ä¸åŒè·¯å¾„II-é¢˜è§£ </description>
    </item>
    <item>
      <title>37.sudoku Solver è§£æ•°ç‹¬</title>
      <link>http://localhost:1313/posts/leet/37.sudoku-solver.zh/</link>
      <pubDate>Mon, 26 Sep 2022 15:03:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/37.sudoku-solver.zh/</guid>
      <description>é¢˜ç›®æè¿° é“¾æ¥ï¼š37.Sodoku Solver&#xA;è§£é¢˜æ€è·¯ ç›¸æ¯”ä¸€èˆ¬çš„å›æº¯ï¼Œéœ€è¦ä¸¤å±‚forå¾ªç¯ï¼Œä¸€ä¸ªå¤„ç†è¡Œï¼Œä¸€ä¸ªå¤„ç†åˆ—ï¼Œé€’å½’çš„è¿‡ç¨‹æ¥å†³å®šï¼Œç©ºæ ¼å¤„åˆ°åº•å¡«å“ªä¸ªæ•°å­—ï¼› æœ¬é€’å½’å‡½æ•°ç”¨boolä½œä¸ºè¿”å›å€¼ç±»å‹ï¼Œè¦æ³¨æ„è¿”å›å€¼åœ¨é€’å½’ä¸­çš„ä½œç”¨ï¼› å¦å¤–è¿˜æœ‰ä¸€ä¸ªåˆ¤æ–­boardæ˜¯å¦åˆè§„çš„å‡½æ•°ã€‚&#xA;ä»£ç  class Solution { private: bool isValid(int row, int col, char val, vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // åˆ¤æ–­è¡Œé‡Œæ˜¯å¦é‡å¤ if (board[row][i] == val) { return false; } } for (int j = 0; j &amp;lt; 9; j++) { // åˆ¤æ–­åˆ—é‡Œæ˜¯å¦é‡å¤ if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i &amp;lt; startRow + 3; i++) { // åˆ¤æ–­9æ–¹æ ¼é‡Œæ˜¯å¦é‡å¤ for (int j = startCol; j &amp;lt; startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // é€è¡Œ for (int j = 0; j &amp;lt; 9; j++) { // é€åˆ— if (board[i][j] !</description>
    </item>
    <item>
      <title>37.è§£æ•°ç‹¬</title>
      <link>http://localhost:1313/posts/leet/37.sudoku-solver/</link>
      <pubDate>Mon, 26 Sep 2022 15:03:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/37.sudoku-solver/</guid>
      <description>Description é“¾æ¥ï¼š37.Sodoku Solver&#xA;Solution Compared with usual backtracking, we need for loop of two layers, one for row and another for column. A recursive process is used to determine exactly which number to fill in the space.&#xA;This return type of this function is bool, please pay attention to the role of return value in recursion.&#xA;Also a function to determine whether board is legal is required.&#xA;Code class Solution { private: bool isValid(int row, int col, char val, vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // judge whether there are duplicates in a row if (board[row][i] == val) { return false; } } for (int j = 0; j &amp;lt; 9; j++) { // judge whether there are duplicates in a column if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; // judge whether there are duplicates in ninepin for (int i = startRow; i &amp;lt; startRow + 3; i++) { for (int j = startCol; j &amp;lt; startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // traverse in row for (int j = 0; j &amp;lt; 9; j++) { // traverse in column if (board[i][j] !</description>
    </item>
    <item>
      <title>47.permutations-ii</title>
      <link>http://localhost:1313/posts/leet/47.permutations-ii/</link>
      <pubDate>Sun, 25 Sep 2022 22:05:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/47.permutations-ii/</guid>
      <description>Description 47.permutations-ii&#xA;Solution Compared with 47.permutations, there is interference from duplicate numbers. So we should de-duplicate such as combination-sum-ii&#xA;Judge whether nums[i] is in path by if (used[i] == 1), de-duplicate by if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0).&#xA;Attention: we should sort the array first.&#xA;Code #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; using std::vector; class Solution { private: vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int used[8] = {0}; void track_back(vector&amp;lt;int&amp;gt; nums, int index) { if (path.</description>
    </item>
    <item>
      <title>47.permutations-ii å…¨æ’åˆ—II</title>
      <link>http://localhost:1313/posts/leet/47.permutations-ii.zh/</link>
      <pubDate>Sun, 25 Sep 2022 22:05:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/47.permutations-ii.zh/</guid>
      <description>é—®é¢˜æè¿° 47.å…¨æ’åˆ—II&#xA;è§£é¢˜æ€è·¯ ç›¸æ¯”å…¨æ’åˆ—ï¼Œå¤šäº†é‡å¤æ•°å­—çš„å¹²æ‰°ï¼Œå¯ä»¥å‚ç…§å¸¦é‡å¤æ•°å­—çš„ç»„åˆé—®é¢˜æ¥è¿›è¡Œå»é‡:&#xA;if (used[i] == 1)åˆ¤æ–­nums[i]æ˜¯å¦å·²ç»åœ¨pathä¸­ï¼Œif (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0)æ¥è¿›è¡Œå»é‡ã€‚&#xA;æ³¨æ„ï¼Œè¦å…ˆå¯¹ç›®æ ‡æ•°ç»„æ’åºã€‚&#xA;ä»£ç  #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; using std::vector; class Solution { private: vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int used[8] = {0}; void track_back(vector&amp;lt;int&amp;gt; nums, int index) { if (path.size() &amp;gt;= nums.size()) { res.push_back(path); return; } for (int i = 0; i &amp;lt; nums.size(); i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0) continue; if (used[i] == 1) continue; path.</description>
    </item>
    <item>
      <title>51.n Queens</title>
      <link>http://localhost:1313/posts/leet/51.n-queens/</link>
      <pubDate>Sun, 25 Sep 2022 21:42:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/51.n-queens/</guid>
      <description>Description 51.n-queens&#xA;Solution Backtracking, please pay attention to how to judge whether chess is in the same diagonal.&#xA;Code class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = &amp;#34;.........&amp;#34;; vector&amp;lt;string&amp;gt; row_str; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; void track_back(int n, int index) { if (index &amp;gt;= n) { res.</description>
    </item>
    <item>
      <title>51.nçš‡å</title>
      <link>http://localhost:1313/posts/leet/51.n-queens.zh/</link>
      <pubDate>Sun, 25 Sep 2022 21:42:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/51.n-queens.zh/</guid>
      <description>é—®é¢˜æè¿° 51.nçš‡å&#xA;è§£é¢˜æ€è·¯ å…¸å‹çš„å›æº¯ï¼Œæ³¨æ„å¦‚ä½•åˆ¤æ–­æ£‹å­åœ¨åŒä¸€æ–œçº¿ä¸Šã€‚&#xA;ä»£ç  class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = &amp;#34;.........&amp;#34;; vector&amp;lt;string&amp;gt; row_str; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; void track_back(int n, int index) { if (index &amp;gt;= n) { res.push_back(row_str); return; } for (int i = 0; i &amp;lt; n; i++) { // iè¡¨ç¤ºåœ¨ç¬¬å‡ åˆ—ï¼Œindexè¡¨ç¤ºåœ¨ç¬¬å‡ è¡Œ if (col_arr[i] !</description>
    </item>
  </channel>
</rss>
