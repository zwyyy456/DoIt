<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structure and Algorithms on My New Hugo Site</title>
    <link>http://localhost:1313/tags/data-structure-and-algorithms/</link>
    <description>Recent content in Data Structure and Algorithms on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 Oct 2023 17:50:12 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/data-structure-and-algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>差分数组</title>
      <link>http://localhost:1313/posts/tech/difference_array.zh/</link>
      <pubDate>Fri, 06 Oct 2023 17:50:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/difference_array.zh/</guid>
      <description>介绍 考虑原数组为 $[1, 3, 3, 5, 8]$，我们对相邻元素做差，用 $a_i - a_{i - 1}$，可以得到一个差分数组 $[1, 2, 0, 2, 3]$ $diff$，我们认为 $a_{-1}$ 为 $0$，因此&#xA;$$diff[i] = \begin{cases} a[0] &amp;amp; i = 0 \newline a[i] - a[i - 1] &amp;amp; i &amp;gt; 0\end{cases}$$&#xA;性质 差分数组往往和前缀和数组放在一块讨论，事实上，差分数组的前缀和即可还原出原数组。即：&#xA;$$ a[k] = \sum\limits_{i = 0}^k diff[i]$$&#xA;差分数组还有一个非常重要的性质，那就是它可以将区间修改（将区间中的每个元素都加一个值或者减一个值）变成单点修改。&#xA;例如，加入我们要将区间 $[i, j]$ 中的每个元素都加 $c$，那么我们只需要将 $diff[i]$ 加 $c$，并将 $diff[j + 1]$ 减去 $c$ 即可，由这个差分数组取前缀和还原出来的原数组，就是我们修改后的原数组。</description>
    </item>
    <item>
      <title>950. Reveal Cards In Increasing Order (Medium)</title>
      <link>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order/</link>
      <pubDate>Thu, 20 Jul 2023 10:25:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order/</guid>
      <description>Description 950. Reveal Cards In Increasing Order (Medium)&#xA;Solution This problem can be solved through direct simulation according to the given instructions. The use of recursion is not necessary. Since the problem involves popping the first element, a double-ended queue (deque) is a suitable data structure to use. The deque will store the indices of elements, and we can proceed with the simulation accordingly.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; deckRevealedIncreasing(vector&amp;lt;int&amp;gt;&amp;amp; deck) { sort(deck.</description>
    </item>
    <item>
      <title>950. 按递增顺序显示卡牌 (Medium)</title>
      <link>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order.zh/</link>
      <pubDate>Thu, 20 Jul 2023 10:25:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order.zh/</guid>
      <description>问题描述 950. 按递增顺序显示卡牌 (Medium)&#xA;牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。&#xA;最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。&#xA;现在，重复执行以下步骤，直到显示所有卡牌为止：&#xA;从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。 如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。 如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。 返回能以 递增顺序 显示卡牌的牌组顺序。&#xA;答案中的第一张牌被认为处于牌堆顶部。&#xA;示例：&#xA;输入：[17,13,11,2,3,5,7] 输出：[2,13,3,11,5,17,7] 解释： 我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。 重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。 我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。 我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。 我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。 我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。 我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。 我们展示 13，然后将 17 移到底部。牌组现在是 [17]。 我们显示 17。 由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。 提示：&#xA;1 &amp;lt;= A.length &amp;lt;= 1000 1 &amp;lt;= A[i] &amp;lt;= 10^6 对于所有的 i !</description>
    </item>
    <item>
      <title>无向图形式组织的树</title>
      <link>http://localhost:1313/posts/tech/undirected-graph-tree.zh/</link>
      <pubDate>Tue, 18 Jul 2023 09:30:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/undirected-graph-tree.zh/</guid>
      <description>引入 如 数组形式组织的树 中所说，树一般以链表结点的形式组织，定义如下：&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} }; 也可能以数组的形式组织，即使用 $parent$ 数组，$y = parent[x]$ 说明 $y$ 是 $x$ 的父结点，根结点的父结点为 $-1$，表示父结点不存在。&#xA;还可以使用无向图的形式来表示，例如 leetcode 的 834. 树中距离之和。&#xA;昨天做这个题的时候，整体思路挺好想的，但就是有个地方被困住了，那就是，在树的无向图的表示情况下，如何统计以当前结点为根结点的子树的数量？（没办法转化成有向图！）&#xA;统计以当前结点为根结点的子树的结点数 统计方法还是深度优先搜索（dfs），只不过，相比一般的深度优先搜索，我们需要传入一个额外的参数，即上一次搜索的父结点，如下图所示：&#xA;相应的 dfs 代码为&#xA;for (int child : tree[pa]) { if (child == ancestor) { continue; } // 对子结点进行 dfs ... } 这样就确定出了一个遍历方向，因此，整体思路就是，我们可以任意选择一个结点作为 dfs 的起点（这里就选择 $0$ 号结点），依次进行 dfs，利用递归的方法，统计以当前结点为根结点的子树的结点数。&#xA;因此，834. 树中距离之和 的完整解题代码如下：&#xA;class Solution { public: int count(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;tree, vector&amp;lt;int&amp;gt; &amp;amp;dis, vector&amp;lt;int&amp;gt; &amp;amp;cnt, int pa, int grandpa) { int res = 1; for (int child : tree[pa]) { if (child == grandpa) { // 防止重复遍历，保证 dfs 遍历时的单向性 continue; } dis[child] = dis[pa] + 1; res += count(tree, dis, cnt, child, pa); } cnt[pa] = res; return res; } vector&amp;lt;int&amp;gt; sumOfDistancesInTree(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;edges) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; tree(n); for (auto &amp;amp;vec : edges) { tree[vec[0]].</description>
    </item>
    <item>
      <title>红黑树</title>
      <link>http://localhost:1313/posts/tech/red-black-tree.zh/</link>
      <pubDate>Mon, 26 Jun 2023 19:44:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/red-black-tree.zh/</guid>
      <description>自顶向下的 2-3-4 树 插入结点 2-3-4 树的插入算法，简而言之，就是在往下查找应该将待插入的 new_key 插入到何处的时候，一旦碰到 4- 结点，就将 4- 结点中间的 key 上溢，剩下的两个 key 作为两个 2- 结点，这个上溢的过程也是递归的，可以理解为向原先 4- 结点的父结点插入 4- 结点中间的这个 key，4- 结点剩下的部分作为两个 2- 结点。我们的这个分解算法，保证了4- 结点的父结点不会是 4- 结点。（这里可以用数学归纳法给出证明）&#xA;这样处理到最后，我们的 new_key 要插入的结点一定是 2- 结点或者 3- 结点，因此，我们可以直接插入。&#xA;要实现这个插入算法，我们需要：&#xA;将 4- 结点表示为由三个 2- 结点组成的一个平衡的子树，根结点和两个子结点都用 red link 连接； 在向下的过程中分解所有 4- 结点并进行颜色转换； 和插入操作一样，在向上的过程中用旋转将 4- 结点配平； 但实际上，我们只要移动 put 方法中的三行代码就能由 2-3 树对应的红黑树操作转移到 2-3-4 树对应的红黑树操作；即将 FlipColors 语句（以及 if 判断）移动到 nullptr 测试之后，递归调用之前，如下：&#xA;void Put(int key, int val) { root_ = Put(key, val, root_); root_-&amp;gt;color_ = kBlack; // 根结点的颜色一定是黑色！ } auto Put(int key, int val, Node *h) -&amp;gt; Node * { // h 表示我们往以 h 为根结点的树中插入结点 if (h == nullptr) { return new Node(key, val, 1, kRed); } if (isRed(h-&amp;gt;left_) &amp;amp;&amp;amp; isRed(h-&amp;gt;right_)) { // 左右子结点都是红色，翻转颜色 // 即碰到 4- 结点就分解成两个 2- 结点 FlipColors(h); } if (key &amp;lt; h-&amp;gt;key_) { h-&amp;gt;left_ = Put(key, val, h-&amp;gt;left_); } else if (key &amp;gt; h-&amp;gt;key_) { h-&amp;gt;right_ = Put(key, val, h-&amp;gt;right_); } else { h-&amp;gt;val_ = val; } if (!</description>
    </item>
    <item>
      <title>左倾红黑树 （LLRB）</title>
      <link>http://localhost:1313/posts/tech/left-lean-red-black-tree.zh/</link>
      <pubDate>Sat, 24 Jun 2023 13:36:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/left-lean-red-black-tree.zh/</guid>
      <description>简介 红黑树是平衡二叉查找树的一种，前面我们提到，非平衡的 BST，在只有随机插入和查询的情况下，时间复杂度是 $O(\log n)$ 的，然而，如果同时存在随机插入和随机删除，那么时间复杂度会退化到 $O(\sqrt n)$，这是我们无法接受的。&#xA;红黑树在插入和删除时，会维持树的平衡，即保证树的高度在 $[\log n, \log(n + 1)]$，理论上极端情况可能树高最大会到达 $2 * \log n$，实际上很难遇到（尽管这样，还是保证了 $O(\log n)$ 的增删查改时间复杂度。&#xA;红黑树其实是 2-3 查找树或者 2-3-4 查找树的一种二叉树的实现方式。其中基于 2-3 树实现的红黑树被称为左倾红黑树（Left-Leaning Red-Black Trees, LLRB），基于 2-3-4 树实现的就是普通的红黑树，左倾红黑树实现起来比红黑树更简单一些（《算法 第四版》里面也主要讲的左倾红黑树），因此先讲左倾红黑树。&#xA;2-3 查找树 在普通的二叉树中，非叶子结点可以有一个或者两个子结点，如果没有子结点，那么就是叶子结点。&#xA;而 2-3 查找树的限制要严格很多。我们将拥有一个 key 和两个链接 的结点称为 2- 结点，拥有两个 key 和三个链接的结点称为 3- 结点。&#xA;2- 结点含有一个 key，两个 link； 3- 结点含有两个不同的 key，三个 link。 3- 结点含有两个 key（$key_1 &amp;lt; key_2$），三个链接，左链接指向 2-3 树中的 key 都小于 $key_1$，中间链接指向的 2-3 树中的 key 都满足 $key_1 &amp;lt; key &amp;lt; key_2$，右链接指向的 2-3 树中的 key 都大于 $key_2$。</description>
    </item>
    <item>
      <title>树状数组</title>
      <link>http://localhost:1313/posts/tech/binary_index_tree.zh/</link>
      <pubDate>Fri, 23 Jun 2023 23:55:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/binary_index_tree.zh/</guid>
      <description>引入 数装数组是一种支持单点修改和区间查询的数据结构。&#xA;这里的区间查询一般指求和。&#xA;普通树状数组维护的信息以及运算要满足结合律并且可以差分。&#xA;定义 考虑下标从 $1$ 开始的数组 $a[1]\sim a[8]$，如下图所示：&#xA;我们可以发现：&#xA;$c[2]$ 管辖 $\sum\limits_{i = 1}^2 a[i]$； $c[4]$ 管辖 $\sum\limits_{i = 1}^4 a[i]$； $c[6]$ 管辖 $\sum\limits_{i = 5}^6 a[i]$； $c[8]$ 管辖 $\sum\limits_{i = 1}^8 a[i]$； 即 $c[x]$ 管辖 $\sum\limits_{i = x - (x \text{AND} -x) + 1}^x a[i]$。例如 $6\text{AND}(-6) + 1 = 5$。&#xA;同时我们定义 $\text{lowbit}(x) = x \text{AND} -x$&#xA;使用 那么如何使用树状数组呢，第一步是初始化，我们先假定原数组也是下标从 $1$ 开始，从 $0$ 开始那么做相应变换即可。&#xA;初始化 我们先令 $c[i] = 0$，然后遍历 $a[j]$，每次遍历相当于是（假设原数组元素均为 $0$，然后将其值加上 $a[i]$），即初始化树状数组相当于是做了 $n$ 次单点修改。</description>
    </item>
    <item>
      <title>二叉搜索树</title>
      <link>http://localhost:1313/posts/tech/bst.zh/</link>
      <pubDate>Fri, 23 Jun 2023 15:08:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/bst.zh/</guid>
      <description>二叉搜索树 二叉搜索树（Binary Search Tree，BST）是指一颗空树或者有下列性质的二叉树：&#xA;若任意节点的左子树不为空，那么左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不为空，那么右子树上所有节点的值均小于它的根节点的值； 任意节点的左、右子树也分别为二叉搜索树； 二叉树的定义是从一个递归的角度来定义的，验证二叉树其实很简单，即中序遍历二叉树，节点的值从严格递增。换言之，二叉搜索树也可以定义成中序遍历时节点值严格递增的二叉树。&#xA;BST 的删除 对树的定义，我们采取 Leetcode 中的定义：&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) { } TreeNode(int x) : val(x), left(nullptr), right(nullptr) { } TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) { } }; 首先，我们定义两个辅助函数 TreeNode *delMax(TreeNode *root, int key); 和 TreeNode *delMin(TreeNode *root, int key);，分别表示删除二叉树中的值最大的节点和值最小的节点。还需要辅助函数 int getMin(TreeNode *root); 和 int getMax(TreeNode *root)。&#xA;getMin 和 getMax 自不必多说，以 delMax 为例，都是利用递归进行处理，递归返回的是当前以 root 为根节点的树，删除了最大值之后的 root。递归终止条件即 root-&amp;gt;right == nullptr，说明找到了树的最大值，此时返回 root-&amp;gt;left。（以避免左子树不为空的情况，左子树为空则相当于返回了 nulltpr）</description>
    </item>
    <item>
      <title>线段树</title>
      <link>http://localhost:1313/posts/tech/seg_tree.zh/</link>
      <pubDate>Tue, 13 Jun 2023 19:44:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/seg_tree.zh/</guid>
      <description>引入 线段树是算法竞赛中常用的用来维护区间信息的数据结构。&#xA;树状数组可以在 $O(\log n)$ 的时间内实现单点修改、区间查询（求和、求最值、求异或等）；而线段树还可以在 $O(\log n)$ 时间内实现区间修改操作，例如将 $[L, R]$ 区间范围内的值都加上一个常数，乘以一个常数，或者都置为某个数。&#xA;常规线段树 结构 就我的理解而言，常规的线段树能实现的功能其实与树状数组没什么区别，都只能在 $O(\log n)$ 时间内实现单点修改和区间查询。&#xA;线段树的构造：给定一个区间 $[L, R]$，取 $mid = L + (R - L) / 2$，将它划分为 $[L, mid]$ 和 $[mid + 1, R]$ 两个区间，如此递归地划分，直到区间长度为 $1$ 为止，这些父区间和划分为左右两边的子区间，在组织结构上很像二叉树的父结点和子结点，这也就是线段树的名字由来。&#xA;我们这里以区间求和为例，线段树的每个结点对应着相应的线段上的点的和，以数组 $a = {1,2,3,4,5,6,7,8,9,10}$ 为例，线段树的结构如图所示：&#xA;可以看到，线段树存储的基础形式是数组，与二叉堆的存储方式一致，假设当前父结点的编号为 $p$，那么左儿子的编号为 $2 * p$，右儿子的编号为 $2 * p + 1$，结点的值为对应区间的和。&#xA;构建线段树的方式其实与“求以该节点为根节点的子树的和”类似，递归处理是很容易的。&#xA;代码实现：&#xA;void Build(int idx, int l, int r, vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (l == r) { seg[idx] = nums[l]; return; } int mid = l + (r - l) / 2; Build(2 * idx, l, mid, nums); // 递归构建左子树 Build(2 * idx, mid + 1, r, nums); // 递归构建右子树 seg[idx] = seg[2 * idx] + seg[2 * idx + 1]; // 更新 seg[idx] } 区间查询 线段树的区间查询，其实只要掌握了递归，就很好理解了。</description>
    </item>
    <item>
      <title>数组形式组织的树</title>
      <link>http://localhost:1313/posts/tech/tree_in_array.zh/</link>
      <pubDate>Mon, 12 Jun 2023 13:47:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/tree_in_array.zh/</guid>
      <description>引入 在 LeetCode 中，二叉树一般是以链表结点的形式组织的，定义如下：&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} }; 其实也可以用数组的形式组织，即使用 $parent$ 数组，$y = parent[x]$ 说明 $y$ 是 $x$ 的父结点，根结点的父结点为 $-1$，表示父结点不存在。&#xA;最近公共祖先 链表形式 对链表形式树，求最近公共祖先可以使用递归很方便的解决：&#xA;/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr || root == p || root == q) { return root; } TreeNode *left = lowestCommonAncestor(root-&amp;gt;left, p, q); TreeNode *right = lowestCommonAncestor(root-&amp;gt;right, p, q); if (left !</description>
    </item>
    <item>
      <title>跳表</title>
      <link>http://localhost:1313/posts/tech/skiplist.zh/</link>
      <pubDate>Tue, 06 Jun 2023 18:28:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/skiplist.zh/</guid>
      <description>跳表介绍 跳表是一种数据结构，使得包含 $n$ 个元素的有序序列的查找和插入操作的平均时间复杂度都是 $O(\log n)$，与红黑树、AVL 性能类似。&#xA;跳表的快速查询效果是通过维护一个多层次的链表实现的，且与前一层（下面一层）的链表元素相比，每一层链表中的元素的数量更少，一开始，算法在最上层（也是最稀疏的一层）查找，直到要查询的元素在该层相邻的两个元素中间。这时，算法将跳转到下一个层，重复刚才的搜索，直到找到需要查找的元素为止如下图所示：&#xA;层数索引从低到高逐渐递增。&#xA;描述 跳表是按照层构建的，跳表的最底层是一个普通的有序链表，每个更高层都是下层列表的子列表，相当于下层列表的快速通道，这里可以类比一下 B树 或者 B+树。&#xA;在跳表中，第 $i$ 层的元素会有概率 $p$ 出现在第 $i + 1$ 层中（$p$ 通常取 $\frac{1}{2}$ 或者 $\frac{1}{4}$），每个元素平均出现在 $\frac{1}{1 - p}$ 个列表中。&#xA;一般认为，列表有 $log_{\frac{1}{p}}n$ 层，在后面的实现中，我们固定了列表的层数为 $klevel = 8$，动态层数的列表实现起来比较复杂。&#xA;在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾：&#xA;如果该元素等于目标元素，则表明该元素已被找到； 如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。 每层链表中预期的查找步数最多为 $\frac{1}{p}$，而层数为 $\log_{\frac{1}{p}}n$，因此查找的总体步数为 $\frac{\frac{1}{p}}{\log_{\frac{1}{p}}n}$，$p$ 是常数，因此总体查找的时间复杂度为 $O(\log n)$ 的。&#xA;跳跃列表不像平衡树等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。&#xA;但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。&#xA;实现 以 1206. Design Skiplist (Hard) 为例，进行跳表的简单实现。&#xA;由上述图片，我们可以构想出结点的数据结构：&#xA;结点值 $val$； 存储当前结点每一层的 $next_$ 指针（这里使用 vector 存储）。 为了方便理解，我们其实可以把每个结点都看成图中 $klevel$ 高度，只是我们只画出来 $next_[i]$ 不为 $nullptr$ 的对应层罢了。 const int klevel = 8; struct Node { int val_; vector&amp;lt;Node *&amp;gt; next_; // next[i] 表示当前结点在第 i 层的 next，i 从 0 开始 Node(int val) : val_(val), next_{klevel, nullptr} { // 初始化 } }; 之后，我们使用一个辅助函数 void Find(int target, veoctor&amp;lt;Node *&amp;gt; pre); 来存储每一层中：满足值小于 $target$ 并且值最大的结点。</description>
    </item>
    <item>
      <title>数位 DP</title>
      <link>http://localhost:1313/posts/tech/number_dp.zh/</link>
      <pubDate>Tue, 06 Jun 2023 10:37:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/number_dp.zh/</guid>
      <description>引入 数位是指把一个数字按照个、十、百、千、万等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 $0\sim 9$。&#xA;数位 DP 一般是用来解决一类特定问题，以 1012. Numbers With Repeated Digits (Hard) 为例，这一类问题的特征非常明显&#xA;要求统计满足一定条件的数的数量； 这些条件经过转化后可以使用“数位”的思想去理解和判断； 输入会提供一个数字区间（有时候只提供上界）来作为统计的限制； 上界很大（例如 $10^{22}$），暴力枚举会超时。 思路 对 1012. Numbers With Repeated Digits (Hard)，思路如下：&#xA;首先，正难则反，我们可以考虑 $[1, n]$ 范围内无重复数字的正整数的个数，记为 $res$，然后最终结果就是 $n - res + 1$（至于为什么还要再加上 $1$，后面会说明）。&#xA;因此问题转化为求 $[1, n]$ 范围内无重复数字的正整数的个数，符合上述的数位 DP 的特征，我们可以从记忆化搜索的角度去考虑，首先将 $n$ 转化为对应的字符串，对字符串的每一位，枚举每一位可能的数，如果最后组成的数字满足 $num &amp;lt; n$，那么 $res += 1$，这里很容易想到 dfs(string &amp;amp;str, int idx, int mask)，$mask$ 以二进制的形式表示 $0\sim 9$ 范围内的数是否被选择过；&#xA;但是仅仅是这样，我们不能方便的判断当前组成的数字是否满足 $num &amp;lt; n$，因此，我们需要一个额外的参数 $is_limit$。例如对数字 $n = 12345$，如果前面已经选择的数字为 $123$，那么对本次枚举，$is_limit$ 为 $true$，即数字只能选择 $0\sim4$，又因为 $1,\ 2,\ 3$ 已经选择了，$mask = 14$，因此只有 $0,\ 4$ 可以选，事实上，我们可以发现，在递归的过程中，当且仅当当前 $is_limit$ 为 $true$，且当前选择的数字与对应数位上的数字相等时，更深一层递归的 $is_limit$ 仍为 $true$，至此，递归函数为 dfs(string &amp;amp;str, int idx, int mask, bool is_limit)；</description>
    </item>
    <item>
      <title>二分答案</title>
      <link>http://localhost:1313/posts/tech/binary_search.zh/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/binary_search.zh/</guid>
      <description>概述 二分答案即利用二分查找来得到答案，一般情况下，左边界 $left$ 是 $0$ 或者 $1$；右边界 $right$ 则视题目条件而定，取一个很大的数，然后利用二分查找的思想，来找到答案。&#xA;二分答案的要求 如果题目能够使用二分答案的思想来解决，那么 $[left, right]$ 范围内，要满足二段性，即对 $[left, res]$ 满足条件 $A$，而 $(res, right]$ 不满足条件 $A$，并且 res 的取值范围是连续的。&#xA;适用情况 如果题目要求满足 xxx 条件下的最大值或者最小值，就可以考虑二分答案，特别的，如果题目要求最小化的最大值或者最大化的最小值，那么要首先考虑使用二分答案。&#xA;例题 2517. 礼盒的最大甜蜜度 (Medium)&#xA;class Solution { public: int Bsearch(int target, vector&amp;lt;int&amp;gt; &amp;amp;price, int left) { int right = price.size(); while (left &amp;lt; right) { int mid = left + (right - left) / 2; if (price[mid] &amp;lt; target) { left = mid + 1; } else { right = mid; } } return left; } bool Check(int mid, vector&amp;lt;int&amp;gt; &amp;amp;price, int k, int n) { int start = 0; for (int i = 0; i &amp;lt; k - 1; ++i) { start = Bsearch(price[start] + mid, price, start); // cout &amp;lt;&amp;lt; start &amp;lt;&amp;lt; &amp;#34; start\n&amp;#34;; if (start &amp;gt;= n) { return false; } } return true; } int maximumTastiness(vector&amp;lt;int&amp;gt; &amp;amp;price, int k) { // 先排序，然后考虑是二分答案还是双指针 sort(price.</description>
    </item>
    <item>
      <title>LRU 算法与 LFU 算法</title>
      <link>http://localhost:1313/posts/tech/lru_lfu.zh/</link>
      <pubDate>Wed, 31 May 2023 16:36:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/lru_lfu.zh/</guid>
      <description>算法介绍 LRU LRU 全称是 Least Recently Used，即最近最久未使用算法。&#xA;LRU 根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高，它是页面置换算法的一种，也常用于缓存设计。&#xA;LFU LFU 全称是 Least Frequently Used，根据频率来选择要淘汰的元素，即删除访问频率最低的元素，如果两个元素的访问频率相同，则淘汰访问频率最低的元素中最久没有被访问的元素。&#xA;数据结构 不管是 LRU 还是 LFU 算法，我们都需要使用到双向链表作为基础数据结构，由于 LRU 与 LFU 涉及的对双向链表的元素的操作比较复杂，还涉及对链表结点的其他操作，因此选择自己手写一个简单的双向链表，同时复习双向链表的实现（阿里一面就被问到了，半天没写对😅）。&#xA;这里根据 LRU 和 LFU 的需要，简单封装了删除结点、尾部插入结点、和判断双向链表是否为空三个函数，很大程度上简化了 LRU 和 LFU 的实现，降低了写算法实现代码的出错概率。&#xA;struct Node { Node() { } Node(int val, int key) : val_(val), key_(key), next_(nullptr), pre_(nullptr) { } int val_; int freq_; Node *next_; Node *pre_; int key_; }; struct List { Node *vhead_; // 虚拟头结点 Node *vtail_; // 虚拟尾结点 int size_ = 0; // 链表中有效结点的数量 List() : vhead_(new Node()), vtail_(new Node()) { vhead_-&amp;gt;next_ = vtail_; vtail_-&amp;gt;pre_ = vhead_; vhead_-&amp;gt;pre_ = nullptr; vtail_-&amp;gt;next_ = nullptr; } ~List() { delete vtail_; delete vhead_; vhead_ = nullptr; vtail_ = nullptr; } void Insert(Node *node) { // 双向链表的插入, node 表示待插入结点，插入作为双向链表的尾结点 node-&amp;gt;pre_ = vtail_-&amp;gt;pre_; vtail_-&amp;gt;pre_-&amp;gt;next_ = node; vtail_-&amp;gt;pre_ = node; node-&amp;gt;next_ = vtail_; ++size_; } void Delete(Node *node) { // node 指向待删除结点 node-&amp;gt;next_-&amp;gt;pre_ = node-&amp;gt;pre_; node-&amp;gt;pre_-&amp;gt;next_ = node-&amp;gt;next_; --size_; } bool Empty() { return size_ &amp;lt;= 0; } }; LRU 实现 对于 LRU 的实现，我们需要借助两个数组结构哈希表和双向链表来组成一个新的数据结构。我们利用哈希表实现 $O(1)$ 时间复杂度的查找，获取元素的 val 以及在双向链表中的位置；利用双向链表实现 $O(1)$ 时间复杂度内的元素插入和删除。</description>
    </item>
    <item>
      <title>字典树</title>
      <link>http://localhost:1313/posts/tech/trie.zh/</link>
      <pubDate>Mon, 29 May 2023 09:54:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/trie.zh/</guid>
      <description>定义 字典树（Trie），是一个像字典一样的树，又称前缀树。&#xA;可以高效的查询某个字符串是否在一组给定的字符串中，或者说查询某个单词是否在字典中。&#xA;字典树的查询时间复杂度可以认为是 $O(l)$，其中 $l$ 为待查询单词的长度。&#xA;引入 字典树示意图：&#xA;可以发现，这棵字典树用边来代表字母，而根结点到树上面某一个节点的路径就代表一个字符串，例如 $1\rightarrow 4\rightarrow 8\rightarrow 12$ 表示的就是字符串 caa，如果结点 $12$ 对应的 end_ 字段的值为 $true$，说明 caa 是字典树中一个完整的字符串，否则只是一个前缀。&#xA;trie 的结构非常好懂，我们用 $\delta(u,c)$ 表示结点 $u$ 的 $c$ 字符指向的下一个结点，或着说是结点 $u$ 代表的字符串后面添加一个字符 $c$ 形成的字符串的结点。（ $c$ 的取值范围和字符集大小有关，不一定是 $0\sim 26$ 。）&#xA;字典树的实现 这里放一个简单的前缀树的类的实现，&#xA;struct Trie { int nex[10000][26], cnt; // nex 的第一维度表示前缀树的结点数量，与上面的图相对应 bool end[10000]; // 该结点结尾的字符串是否存在 void insert(char *s, int l) { // 插入字符串 int p = 0; for (int i = 0; i &amp;lt; l; i++) { int c = s[i] - &amp;#39;a&amp;#39;; if (!</description>
    </item>
    <item>
      <title>快速选择算法</title>
      <link>http://localhost:1313/posts/tech/quick-select.zh/</link>
      <pubDate>Tue, 11 Apr 2023 19:55:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/quick-select.zh/</guid>
      <description>问题描述 给定一个长度为$n$的数组，如何在$O(n)$的时间复杂度内找到第$k$大的数。&#xA;思路 朴素的想法是先排序，然后直接找到第$k$个元素，时间复杂度为$O(n\log n)$。&#xA;我们可以利用快速排序的思想来解决这个问题，考虑快速排序的划分过程，在快速排序的“划分”结束后，数组$A_p \cdots A_r$被分成了$A_p\cdots A_q$和$A_{q+1}\cdots A_r$，此时可以按照左边元素的个数（$q-p+1$）和$k$的大小关系来判断是只在左边还是右边递归的求解。&#xA;代码 template &amp;lt;Typename T&amp;gt; // 类型T需要定义 &amp;lt; 运算 // arr 为查找范围数组，rk 为需要查找的排名（从 0 开始），len 为数组长度 T find_kth_element(T arr[], int rk, const int len) { if (len &amp;lt;= 1) { return arr[0]; } // 随机选择基准 const T pivot = arr[rand() % len]; // i 当前操作的元素 // j 第一个等于pivot的元素 // k 第一个大于pivot的元素 // 完成一趟三路快排，将序列分为： // 小于 pivot 的元素 ｜ 等于 pivot 的元素 ｜ 大于 pivot 的元素 int i = 0, j = 0, k = len; while (i &amp;lt; k) { if (arr[i] &amp;lt; pivot) { swap(arr[i++], arr[j++]); } else if (arr[i] &amp;gt; pivot) { swap(arr[i], arr[--k]); } else { ++i; } } // 根据要找的排名与两条分界线的位置，去不同的区间递归查找第k大的数 // 如果小于pivot的元素个数比k多，则第k大的元素一定是一个小于pivot的数 if (rk &amp;lt; j) { return find_kth_element(arr, rk, j); } else if (rk &amp;gt;= k){ // 否则，如果小于pivot和等于pivot的元素加起来也没有k多 // 则第k大的元素一定是一个大于pivot的元素 return find_kth_element(arr + k, rk - k, len - k); } else { // 否则，pivot就是第k大的元素 return pivot; } } 优化：中位数的中位数 中位数中的中位数（英文：Median of medians），提供了一种确定性的选择划分过程中分界值的方法，从而能够让找第$k$大的数算法在最坏情况下也能实现线性时间复杂度。</description>
    </item>
    <item>
      <title>拓扑排序</title>
      <link>http://localhost:1313/posts/tech/topo-sort.zh/</link>
      <pubDate>Mon, 10 Apr 2023 14:13:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/topo-sort.zh/</guid>
      <description>定义 拓扑排序（Topological sorting）要解决的问题是给一个有向图的所有节点排序。&#xA;这里直接使用OI-Wiki中举的例子来说明：&#xA;我们可以拿大学选课的例子来描述这个过程，比如学习大学课程中有：单变量微积分，线性代数，离散数学概述，概率论与统计学概述，语言基础，算法导论，机器学习。当我们想要学习 算法导论 的时候，就必须先学会 离散数学概述 和 概率论与统计学概述，不然在课堂就会听的一脸懵逼。当然还有一个更加前的课程 单变量微积分。&#xA;这些课程就相当于几个顶点$u$, 顶点之间的有向边$(u,v)$就相当于学习课程的顺序。显然拓扑排序不是那么的麻烦，不然你是如何选出合适的学习顺序。下面将介绍如何将这个过程抽象出来，用算法来实现。&#xA;但是如果某一天排课的老师打瞌睡了，说想要学习 算法导论，还得先学 机器学习，而 机器学习 的前置课程又是 算法导论，然后你就一万脸懵逼了，我到底应该先学哪一个？当然我们在这里不考虑什么同时学几个课程的情况。在这里，算法导论 和 机器学习 间就出现了一个环，显然你现在没办法弄清楚你需要学什么了，于是你也没办法进行拓扑排序了。因而如果有向图中存在环路，那么我们就没办法进行拓扑排序了。&#xA;因此我们可以说在一个[[DAG（有向无环图）]]中，我们将图中顶点以线性方式排序，使得对于任意顶点$u$到$v$的有向边$(u, v)$，都有$u$在$v$的前面。&#xA;或者说给定一个DAG，如果$i$到$j$有边，则认为$j$依赖于$i$，如果$i$到$j$有路径，则称$j$间接依赖于$i$； 拓扑排序的目标是将所有节点排序，使得在前面的节点不能依赖于排在后面的节点。&#xA;bfs 拓扑排序有广度优先搜索（bfs）和深度优先搜索（dfs）两种实现方式，这里我们先讨论bfs。&#xA;利用bfs实现拓扑排序需要根据节点的入度：&#xA;入度：有多少条边直接指向该节点&#xA;思路 起始时，将所有入度为$0$的点放入队列q_in0； 将队首元素出队，出队序列就是我们要求的拓扑序，对当前弹出的节点u，res.push_back(u)，遍历u的所有出度，即遍历所有由u直接指向的节点v，递减节点v的入度； 如果节点v的入度变为0，将节点v入队； 循环2、3流程直到队列为空； 如果res最后恰好有$n$个节点，说明原图为DAG，res中的节点序列即要求的拓扑序；否则说明图中存在环。&#xA;代码实现 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph; int n = graph.size(); int in[n]; // 存储每个节点的入度 bool toposrot() { vector&amp;lt;int&amp;gt; res; queue&amp;lt;int&amp;gt; q_in0; for (int i = 0; i &amp;lt; n; ++i) { if (in[i] == 0) { q_in0.push(i); } } while (!</description>
    </item>
    <item>
      <title>kmp 算法</title>
      <link>http://localhost:1313/posts/tech/kmp.zh/</link>
      <pubDate>Mon, 27 Mar 2023 16:45:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/kmp.zh/</guid>
      <description>问题描述 kmp算法解决的是字符串匹配问题，即:字符串P是否是字符串S的子串？如果是，它出现在s的哪些位置？这里我们称 S 为主串，P 为模式串。&#xA;思路 首先是暴力匹配算法（Brute-Force算法），代码如下：&#xA;void BruteForce(string s, string p) { int len_s = s.size(), len_p = p.size(); for (int i = 0; i &amp;lt;= len_s - len_p; ++i) { int flag = true; for (int j = 0; j &amp;lt; len_p; ++j) { if (s[i + j] != p[j]) { flag = false; break; } } if (flag) { printf(&amp;#34;pos = %d\n&amp;#34;, i); } } } 易得时间复杂度的最坏情况是$O(mn)$的，其中$n$为s的长度，$m$为p的长度。</description>
    </item>
    <item>
      <title>并查集</title>
      <link>http://localhost:1313/posts/tech/dsu-oi-wiki.zh/</link>
      <pubDate>Wed, 22 Mar 2023 17:59:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dsu-oi-wiki.zh/</guid>
      <description>引入 并查集是一种用于管理元素所属的集合的数据结构，其实现或者说表现为一片森林，其中，每棵树表示了一个集合，树中的节点表示对应的集合中的元素：&#xA;顾名思义，并查集支持两种操作：&#xA;合并（Union）：合并两个元素所属的集合（合并对应的树）； 查询（Find）：查询某个元素所属的集合（即查询对应的树的根节点），这可以用于判断两个元素是否属于同一个集合； 并查集在经过修改后还可以支持单个元素的移动、删除；使用动态开点线段树还可以实现可持久化并查集；&#xA;初始化 初始时，我们设置每个元素都属于一个单独的集合，表示为一棵只有根节点的树，每个根节点的父亲都设置为自己。&#xA;class Dsu { vector&amp;lt;size_t&amp;gt; parent_; // 表示每个节点的父节点 vector&amp;lt;size_t&amp;gt; size_; // 表示每棵树有多少节点 Dsu(size_t size) : parent_(size), size_(size, 1) { iota(parent_.begin(), parent_.end()); } } 查询 我们只需要沿着树向上移动，直到找到根节点 size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x]; } 查询时进行路径压缩 查询过程中，经过的每个元素都属于该集合，因此我们可以直接将其连接到根节点，以加快后续查询。 size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x] = find(parent_[x]); } 合并 要合并两棵树，我们只需要将一棵树的根节点连接到另一棵树的根节点。 void Dsu::Unite(size_t x, size_t y) { parent_(find(x)) = find(y); } 启发式合并 即将节点较小或者深度较小的树连接到另一棵，这里以按节点数合并的实现作为参考:</description>
    </item>
    <item>
      <title>Leetcode 常见报错的原因分析</title>
      <link>http://localhost:1313/posts/tech/leetcode_error.zh/</link>
      <pubDate>Wed, 01 Mar 2023 19:02:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/leetcode_error.zh/</guid>
      <description>问题1 问题描述 Line 522: Char 69: runtime error: applying non-zero offset 18446744073709551615 to null pointer (basic_string.h)&#xA;报错原因 string res = 0&#xA;报错分析 这里报错的原因是因为使用了int整型变量来初始化string。&#xA;AddressSanitizer: stack-overflow 栈溢出，通常是由于使用了缺少终止条件的递归调用。</description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo/</guid>
      <description>Description 502.IPO&#xA;Solution Greedy algorithm: if we want to maximize the final capital, we choose the project whose profit is maximum and whose minimum captial required is less than or equal to our current capital.&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;Let key be the profits, value be a map, of which key is the minimum capital required while value is the amount of the corresponding project.&#xA;Code class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.</description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo.zh/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo.zh/</guid>
      <description>问题描述 502.IPO&#xA;解题思路 贪心：要最大化最终资本，因此必然选择满足当前资本需要的纯利润最大的项目。&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;key为纯利润，value也是map，该map的key为启动所需最小资本、value为项目数量。&#xA;代码 class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.size(); i++) { projs[profits[i]][capital[i]]++; } for (int i = 0; i &amp;lt; k; i++) { int find_flag = 0; for (auto &amp;amp;prj : projs) { if (w &amp;gt;= ((prj.second).begin())-&amp;gt;first) { w += prj.first; prj.</description>
    </item>
    <item>
      <title>1138.alphabet board path</title>
      <link>http://localhost:1313/posts/leet/1138.alphabet-board-path/</link>
      <pubDate>Sun, 12 Feb 2023 19:14:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1138.alphabet-board-path/</guid>
      <description>Description 1138.alphabet-board-path&#xA;Solution Hash table.&#xA;Notice that we shouldn&amp;rsquo;t go left then go down or go right then go up.&#xA;Code class Solution { public: string alphabetBoardPath(string target) { string res; vector&amp;lt;int&amp;gt; cur_loc{0, 0}; vector&amp;lt;int&amp;gt; target_loc{0, 0}; // 要注意边缘的存在 for (auto &amp;amp;c : target) { target_loc[0] = (c - &amp;#39;a&amp;#39;) / 5; target_loc[1] = (c - &amp;#39;a&amp;#39;) % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col &amp;lt; 0) { res.</description>
    </item>
    <item>
      <title>1138.字母板上的路径</title>
      <link>http://localhost:1313/posts/leet/1138.alphabet-board-path.zh/</link>
      <pubDate>Sun, 12 Feb 2023 19:14:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1138.alphabet-board-path.zh/</guid>
      <description>问题描述 1138.字母板上的路径&#xA;解题思路 考虑到&amp;rsquo;z&amp;rsquo;单独在一个地方，因此移动顺序中，左下、右上不能反过来，即不能先往下再往左或者先往右再往上。&#xA;代码 class Solution { public: string alphabetBoardPath(string target) { string res; vector&amp;lt;int&amp;gt; cur_loc{0, 0}; vector&amp;lt;int&amp;gt; target_loc{0, 0}; // 要注意边缘的存在 for (auto &amp;amp;c : target) { target_loc[0] = (c - &amp;#39;a&amp;#39;) / 5; target_loc[1] = (c - &amp;#39;a&amp;#39;) % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col &amp;lt; 0) { res.insert(res.end(), -move_col, &amp;#39;L&amp;#39;); if (move_row &amp;gt;= 0) res.</description>
    </item>
    <item>
      <title>1604.alert using same key card three or more times in a one hour period</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</guid>
      <description>Description 1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period&#xA;Solution Analog, hash table + sort.&#xA;Code class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>1604.警告一小时内使用相同员工卡大于等于三次的人</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</guid>
      <description>问题描述 1604.警告一小时内使用相同员工卡大于等于三次的人&#xA;解题思路 模拟，哈希表+排序&#xA;代码 class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>575.分糖果</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies.zh/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies.zh/</guid>
      <description>问题描述 575.分糖果&#xA;解题思路 最优思路为一种糖果只吃一颗。&#xA;代码 class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>575.distribute candies</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies/</guid>
      <description>Description 575.distribute-candies&#xA;Solution The optimal way is to eat only one candy for each kind of candy.&#xA;Code class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>2331.evaluate boolean binary tree</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</guid>
      <description>Description 2331.evaluate-boolean-binary-tree&#xA;Solution dfs(recursion)&#xA;Code class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
    <item>
      <title>2331.计算布尔二叉树的值</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</guid>
      <description>问题描述 2331.计算布尔二叉树的值&#xA;解题思路 递归&#xA;代码 class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
    <item>
      <title>553.optimal division</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division/</guid>
      <description>Description 553.optimal division&#xA;Solution Greedy algorithm&#xA;The optimal method is actually to bracket the penultimate elements.&#xA;Code class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.</description>
    </item>
    <item>
      <title>553.最优除法</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division.zh/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division.zh/</guid>
      <description>问题描述 553.最优除法&#xA;解题思路 贪心，最优的除法实际上就是把第二个到最后一个元素括起来。&#xA;代码 class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.pop_back(); res.push_back(&amp;#39;)&amp;#39;); return res; } }; </description>
    </item>
    <item>
      <title>1710.maximum units on a truck</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</guid>
      <description>Description 1710.maximum-units-on-a-truck&#xA;Solution Sort boxTypes by the units that the box can load, then put the box of which the units are maximum on the truck one by one.&#xA;The time complexity can be decreased to $O(n)$ by using quick select.&#xA;Code class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.</description>
    </item>
    <item>
      <title>1710.卡车上的最大单元数</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</guid>
      <description>问题描述 1710.卡车上的最大单元数&#xA;解题思路 根据每个箱子可以装载的单元数量从大到小对boxTypes排序，然后每次将单元数量最大的箱子填入卡车。&#xA;使用快速选择算法可以将时间复杂度降低到$O(n)$。&#xA;代码 class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.size(); i++) { if (cnt + boxTypes[i][0] &amp;lt;= truckSize) { sum += boxTypes[i][0] * boxTypes[i][1]; cnt += boxTypes[i][0]; } else { sum += (truckSize - cnt) * boxTypes[i][1]; break; } } return sum; } }; </description>
    </item>
    <item>
      <title>1736.latest time by replacing hidden digits</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</guid>
      <description>Description 1736.latest-time-by-replacing-hidden-digits&#xA;Solution Analog + greedy algorithm&#xA;Code class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.</description>
    </item>
    <item>
      <title>1736.替换隐藏数字得到的最晚时间</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</guid>
      <description>问题描述 1736.替换隐藏数字得到的最晚时间&#xA;解题思路 模拟+贪心&#xA;代码 class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.push_back(time[0]); res.</description>
    </item>
    <item>
      <title>1210.minimum moves to reach target with rotations</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</guid>
      <description>Description 1210.minimum-moves-to-reach-target-with-rotations&#xA;Solution BFS.&#xA;We can use (x, y state) to denote the position of the snake, x as the abscissa of the tail of the snake, y as the ordinate of the tail of the snake. state indicates whether the snake is vertical or horizontal.&#xA;Code class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.</description>
    </item>
    <item>
      <title>1210.穿过迷宫的最少移动次数</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</guid>
      <description>问题描述 1210.穿过迷宫的最少移动次数&#xA;解题思路 广度优先搜索&#xA;可以用(x, y, state)来表示贪吃蛇当前所处的位置，x为蛇尾的横坐标，y为蛇尾的纵坐标，state表示蛇当前处于水平还是竖直状态。&#xA;代码 class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0) return true; else return false; } } else if (i == 1) { vec_tmp[0] += 1; vec_tmp[2] += 1; if (vec_tmp[2] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0 &amp;amp;&amp;amp; vec_tmp[2] &amp;lt; grid.</description>
    </item>
    <item>
      <title>768.max chunks to make sorted ii</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</guid>
      <description>Description 768.max-chunks-to-make-sorted-ii&#xA;Solution A sufficient condition for an array to be divisible into blocks that satisfy the condition is that all elements in the block are less than or equal to any of the undivided elements in the right-hand array.&#xA;Code class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.</description>
    </item>
    <item>
      <title>768.最多能完成排序的块 II</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</guid>
      <description>问题描述 768.最多能完成排序的块II&#xA;解题思路 可以划分成满足条件的块的充分必要条件是，块内所有元素都小于等于右侧数组中未划分的任一元素。&#xA;本题中使用了map来进行处理，实际上使用单调栈就可以了。&#xA;代码 class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.size(); i++) r_map[arr[i]]++; while (idx &amp;lt; arr.size()) { for (int i = idx; i &amp;lt; arr.size(); i++) { l_map[arr[i]]++; r_map[arr[i]]--; if (r_map[arr[i]] == 0) r_map.erase(arr[i]); if (r_map.empty()) break; if (l_map.begin()-&amp;gt;first &amp;lt;= r_map.begin()-&amp;gt;first) { idx = i + 1; ans++; break; } } if (r_map.</description>
    </item>
    <item>
      <title>1145.binary tree coloring game</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</guid>
      <description>Description 1145.binary-tree-coloring-game&#xA;Solution Greedy algorithm: for second player, if he wants to win, there are three ways to color the node.&#xA;color the parent node of x, then we use dfs to get the number of red nodes, the number of blue nodes is $n$ minus the nubmer of red nodes; color the left child node of x, then we use dfs to get the number of blue nodes, the number of red nodes is $n$ minus the number of blue nodes; color the right child node of x Code class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root !</description>
    </item>
    <item>
      <title>1145.二叉树着色游戏</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</guid>
      <description>问题描述 1145.二叉树着色游戏&#xA;解题思路 贪心策略：对二号玩家来说，想要取胜，选择染色节点只有三种可能：&#xA;选择x的父节点，则通过深度优先搜索可以求得红色节点数，蓝色节点数为$n$减去红色节点数 选择x的左子节点，则通过dfs可以求得蓝色节点数，红色节点数为$n$减去蓝色节点数 选择x的右子节点 代码 class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root != nullptr) return get_num(root-&amp;gt;left) + get_num(root-&amp;gt;right) + 1; else return 0; } TreeNode *get_pos(int x, int n, TreeNode *root) { // 获取当前x对应的指针 if (root == nullptr) return nullptr; else { if (root-&amp;gt;val == x) return root; else { TreeNode *l = get_pos(x, n, root-&amp;gt;left); TreeNode *r = get_pos(x, n, root-&amp;gt;right); if (l !</description>
    </item>
    <item>
      <title>1877.minimize maximum pair sum in array</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</guid>
      <description>Description 1877.minimize-maximum-pair-sum-in-array&#xA;Solution Sort the array from smallest to largest, the smallest and largest pair, the next smallest and next largest pair, in that order. The result we need the maximum value of the sum of those pairs.&#xA;Code class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1877.数组中最大数对和的最小值</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</guid>
      <description>问题描述 1877.数组中最大数对和的最小值&#xA;解题思路 贪心&#xA;将数组从小到大排序，最小最大配对，次小次大配对，依次配对，结果就是这些配对和的最大值。&#xA;代码 class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1129.shortest path with alternating colors</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</guid>
      <description>Description 1129.shortest-path-with-alternating-colors&#xA;Solution First, we need represent the graph as an edge matrix, and we use bfs to find the shortest path.&#xA;In this problem, since the edge color of the shortest path must change along the path, when we judge whether the current node is visited, we should distinguish the cases that the current node is visited by red edges and the cases that the current node is visited by blue edges.</description>
    </item>
    <item>
      <title>1129.颜色交替的最短路径</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</guid>
      <description>问题描述 1129.颜色交替的最短路径&#xA;解题思路 首先，将本题的图结构以边表的形式表现出来，然后采取广度优先搜索的方式寻找最短路径，一般来说广度优先搜索能够保证找到的是最短路径。&#xA;在本题中，由于要求最短路径是交替出现的，那么在判断节点是否已经访问过时，要分红色路径访问节点和蓝色路径访问节点两种情况讨论。&#xA;队列中的元素为三元组tie(point, len, c_flag)，分别表示当前节点的索引、到达当前节点的路径长度（不一定是最短的，本题中存在环）、到达当前节点的路径颜色（0表示蓝色，1表示红色）&#xA;提示bfs(q, red_connect, blue_connect, answer, n)（其中q包含tie(0, 0, 0)和tie(0, 0, 1)）与bfs(q, red_connect, blue_connect, answer, n)执行两次（q分别为tie(0, 0, 0)和tie(0, 0, 1)）的结果是一样的。&#xA;代码 class Solution { public: void bfs(queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;red_connect, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;blue_connect, vector&amp;lt;int&amp;gt; &amp;amp;answer, int n, int i) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; visited(n, vector&amp;lt;int&amp;gt;(2, 0)); // visited[k][1]表示由红到point，visited[k][0]为1表示由蓝到point int tmp_point = 0; while (!q.empty()) { auto [point, len, c_flag] = q.front(); visited[point][c_flag] = 1; q.pop(); if (answer[point] == -1) answer[point] = len; else answer[point] = min(answer[point], len); if (c_flag == 0) { for (int k = 0; k &amp;lt; red_connect[point].</description>
    </item>
    <item>
      <title>2325.decode the message</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message/</guid>
      <description>Description 2325.decode-the-message&#xA;Solution We use arrya as a hash table, to keep track of the order in which the letter appear.&#xA;Code class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // -1 means the letter never appears, other value means the order in which the letter appears for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c !</description>
    </item>
    <item>
      <title>2325.解密消息</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</guid>
      <description>问题描述 2325.解密消息&#xA;解题思路 利用数组作为哈希表，记录每个字母是第几个出现的&#xA;代码 class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // 为-1表示这个字母从未出现过，0，1，2等表示这个字母对应的解密字母 for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c != &amp;#39; &amp;#39;) res.push_back(&amp;#39;a&amp;#39; + arr[c - &amp;#39;a&amp;#39;]); else res.</description>
    </item>
    <item>
      <title>1846.maximum element after decreasing and rearranging</title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</guid>
      <description>Description 1846.maximum-element-after-decreasing-and-rearranging&#xA;Solution Since we can reorder the element in the array as many times as we like, so we should sort the array first. If we want to find the possible maximum number of array whose the first element must be 1 and the absolute difference of any 2 adjacent differences must be less or equal to 1， so we can get arr[i] = min(i + 1, arr[i - 1] + 1).</description>
    </item>
    <item>
      <title>1846.减小和重新排列数组后的最大元素</title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</guid>
      <description>问题描述 1846.减小和重新排列数组后的最大元素&#xA;解题思路 由于题目允许我们重新排列数组中的元素任意次，因此首先将数组排序，根据arr中第一个元素必须为1，以及相邻两元素的差的绝对值小于等于1，可得arr[i] = min(i + 1, arr[i - 1] + 1)（因为我们要找arr可能的最大值），又因为不允许增大arr中的元素，所以arr[i] = min(arr[i], i + 1, arr[i - 1] + 1)。&#xA;代码 class Solution { public: int maximumElementAfterDecrementingAndRearranging(vector&amp;lt;int&amp;gt;&amp;amp; arr) { sort(arr.begin(), arr.end()); arr[0] = 1; for (int i = 1; i &amp;lt; arr.size(); i++) { arr[i] = min(arr[i - 1] + 1, min(arr[i], i + 1)); } return arr[arr.size() - 1]; } }; </description>
    </item>
    <item>
      <title>2319.check if matrix is X matrix</title>
      <link>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix/</link>
      <pubDate>Tue, 31 Jan 2023 09:50:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix/</guid>
      <description>Description 2319.check-if-matrix-is-X-matrix&#xA;Solution Analog&#xA;Code class Solution { public: bool checkXMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { bool res = true; for (int i = 0; i &amp;lt; grid.size(); i++) { for (int j = 0; j &amp;lt; grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>2319.判断矩阵是否是一个X矩阵</title>
      <link>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix.zh/</link>
      <pubDate>Tue, 31 Jan 2023 09:50:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix.zh/</guid>
      <description>问题描述 2319.判断矩阵是否是一个X矩阵&#xA;解题思路 模拟&#xA;代码 class Solution { public: bool checkXMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { bool res = true; for (int i = 0; i &amp;lt; grid.size(); i++) { for (int j = 0; j &amp;lt; grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>1669.merge in between linked list</title>
      <link>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list/</link>
      <pubDate>Mon, 30 Jan 2023 12:22:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list/</guid>
      <description>Description 1669.merge-in-between-linked-list&#xA;Solution Analog&#xA;Code class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i &amp;lt; a - 1; i++) { head = head-&amp;gt;next; } for (int i = 0; i &amp;lt; b; i++) { head2 = head2-&amp;gt;next; } while (tail2-&amp;gt;next != nullptr) tail2 = tail2-&amp;gt;next; tail2-&amp;gt;next = head2-&amp;gt;next; head2-&amp;gt;next = nullptr; head-&amp;gt;next = list2; return list1; } }; </description>
    </item>
    <item>
      <title>1669.合并两个链表</title>
      <link>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list.zh/</link>
      <pubDate>Mon, 30 Jan 2023 12:22:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list.zh/</guid>
      <description>问题描述 1669.合并两个链表&#xA;解题思路 模拟&#xA;代码 class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i &amp;lt; a - 1; i++) { head = head-&amp;gt;next; } for (int i = 0; i &amp;lt; b; i++) { head2 = head2-&amp;gt;next; } while (tail2-&amp;gt;next != nullptr) tail2 = tail2-&amp;gt;next; tail2-&amp;gt;next = head2-&amp;gt;next; head2-&amp;gt;next = nullptr; head-&amp;gt;next = list2; return list1; } }; </description>
    </item>
    <item>
      <title>1814.count nice pairs in an array</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</link>
      <pubDate>Tue, 17 Jan 2023 17:19:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</guid>
      <description>Description 1814.count-nice-pairs-in-an-array&#xA;Solution We can change the requirements to nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]).&#xA;Then we use hash tables to record the times of occurrence of the value.&#xA;Code class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>1814.统计一个数组中好对子的数目</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</link>
      <pubDate>Tue, 17 Jan 2023 17:12:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</guid>
      <description>问题描述 1814.统计一个数组中好对子的数目&#xA;解题思路 首先，变换一下题目的需求，nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])，然后利用哈希表记录每个值出现了多少次就可以了。&#xA;代码 class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>位运算与集合</title>
      <link>http://localhost:1313/posts/tech/bit_operation.zh/</link>
      <pubDate>Thu, 05 Jan 2023 14:50:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/bit_operation.zh/</guid>
      <description>前言 在刷 LeetCode 的时候，我们常常碰到需要枚举同时选择几个元素，或者说枚举选择一个集合的情况，即同时选择 $\lbrace0, 1, 2\rbrace$ 或者 $\lbrace0, 1,3\rbrace$ 等，这里集合中的数字表示要选择的元素的索引。&#xA;通常情况下，我们往往会使用哈希表来表示集合，好处在于可以方便的在 $O(1)$ 时间内确定元素是否处于集合中，坏处则是当我们需要做集合之间的运算，例如求交集或者并集，那么就需要 $O(n)$ 时间才能实现；另一个缺陷就是，当递归函数的可变实参中存在哈希表（或者对哈希表的引用）时，无法通过添加 $cach$ 数组实现记忆化搜索。&#xA;于是，我们需要想一个新的办法来表示集合，由于集合可以由全集（包含所有元素的集合）中每个元素的选或者不选来表示，因此，很容易联想到二进制上每一位的 $0$ 和 $1$，例如 $101 = 5$ 表示集合中只有第 $0$ 个元素和第 $2$ 个元素。&#xA;使用数学化一点的语言，即集合可以以如下方式压缩成二进制下的一个数字：&#xA;$$f(S)=\sum\limits_{i\in S}2^i$$&#xA;其中 $i$ 表示集合中的元素在原数组中的索引。$\lbrace a[0], a[1], a[3]\rbrace$ 即可由 $2^0+2^1+2^3 = 13$ 即二进制数 $1101$ 表示。&#xA;集合与元素 根据上面提到的二进制表示集合的方法，我们可以在 $O(1)$ 的时间内实现集合与元素之间的运算。&#xA;具体运算表格参见灵神的 从集合论到位运算，常见位运算技巧分类总结！。 无需记忆，自己做题的时候很容易就能推导出来。&#xA;集合与集合 集合与集合之间的运算也可以在用二进制数表示集合的情况下，在 $O(1)$ 时间内完成计算。&#xA;具体运算表格同样参见灵神的 从集合论到位运算，常见位运算技巧分类总结！。&#xA;同样无需记忆，自己做题的时候很容易就能推导出来。&#xA;遍历集合 在集合用二进制数 $mask$ 表示的情况下，集合中的元素个数可以由 C++ 库函数 __builtin_popcount(mask) 计算出来。&#xA;设元素范围从 $0$ 到 $n - 1$，挨个判断元素是否在集合 $s$ 中：</description>
    </item>
    <item>
      <title>2042.check if numbers are ascending in a sentence</title>
      <link>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence/</link>
      <pubDate>Tue, 03 Jan 2023 16:34:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence/</guid>
      <description>Description 2042.check-if-numbers-are-ascending-in-a-sentence&#xA;Solution analog1 I change string s to &amp;quot; &amp;quot; + s + &amp;quot; &amp;quot;, then traverse the new string, check whether substr between two blanks is numbers;&#xA;analog2 We just check whether current char is a number, if that, num = num * 10 + s[i] - &#39;0&#39;, loop until current char is not a number.&#xA;Code code1 class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string &amp;amp;s) { int ans = 0; for (int i = l + 1; i &amp;lt; r; i++) { if (s[i] - &amp;#39;0&amp;#39; &amp;lt;= 9 &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt;= 0) { ans += mpow(s[i] - &amp;#39;0&amp;#39;, r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector&amp;lt;int&amp;gt; numbers; s = &amp;#34; &amp;#34; + s + &amp;#34; &amp;#34;; for (int i = 0; i &amp;lt; s.</description>
    </item>
    <item>
      <title>2042.检查句子中的数字是否递增</title>
      <link>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence.zh/</link>
      <pubDate>Tue, 03 Jan 2023 16:34:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence.zh/</guid>
      <description>问题描述 2042.检查句子中的数字是否递增&#xA;解题思路 模拟一 首先将字符串的首尾都加上空格，然后遍历即可，检查两次空格之间的字符串是否是数字，如果是就转化为数字;&#xA;模拟二 直接判断字符是否是数字，如果是数字，num = num * 10 + s[i] - &#39;0&#39;，循环直到碰到空格&#xA;代码 代码一 class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string &amp;amp;s) { int ans = 0; for (int i = l + 1; i &amp;lt; r; i++) { if (s[i] - &amp;#39;0&amp;#39; &amp;lt;= 9 &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt;= 0) { ans += mpow(s[i] - &amp;#39;0&amp;#39;, r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector&amp;lt;int&amp;gt; numbers; s = &amp;#34; &amp;#34; + s + &amp;#34; &amp;#34;; for (int i = 0; i &amp;lt; s.</description>
    </item>
    <item>
      <title>1751.最多可以参加的会议数目II</title>
      <link>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:09:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</guid>
      <description>问题描述 1751.最多可以参加的会议数目II&#xA;解题思路 动态规划+二分法 令dp[i][j]表示在前i个会议，最多参加j个会议，收获的最大价值:&#xA;考虑选择不参加events[i - 1]，dp[i][j] = dp[i - 1][j]; 选择参加events[i - 1]，dp[i][j] = dp[idx][j - 1] + events[i - 1][2]; 其中idx表示结束日期小于events[i - 1][0]且最接近events[i - 1][0]的会议的索引号，因此这里需要按照结束日期从小到大对events排序; 寻找idx可以使用二分查找; 二分查找要注意其中的不变量，即l左侧的值都小于target，r右侧的值都大于或等于target(这里是否等于取决于具体实现&amp;gt;=或者&amp;gt;)&#xA;代码 class Solution { public: int maxValue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;events, int k) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(events.size() + 1, vector&amp;lt;int&amp;gt;(k + 1, 0)); // 按照会议结束顺序排序 std::sort(events.begin(), events.end(), [](auto &amp;amp;a, auto &amp;amp;b) { return a[1] &amp;lt; b[1]; }); // for (int i = 1; i &amp;lt;= events.</description>
    </item>
    <item>
      <title>1945.sum of digits of string after convert</title>
      <link>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert/</link>
      <pubDate>Thu, 15 Dec 2022 18:06:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert/</guid>
      <description>Solution 1945.sum-of-digits-of-string-after-convert&#xA;Solution Code class Solution { public: int getLucky(string s, int k) { vector&amp;lt;int&amp;gt; num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - &amp;#39;a&amp;#39; + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i &amp;lt; k; i++) { while (sum !</description>
    </item>
    <item>
      <title>1945.字符串转化之后的各位数字之和</title>
      <link>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:06:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert.zh/</guid>
      <description>问题描述 1945.字符串转化后的各位数字之和&#xA;解题思路 正常思路就好。&#xA;代码 class Solution { public: int getLucky(string s, int k) { vector&amp;lt;int&amp;gt; num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - &amp;#39;a&amp;#39; + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i &amp;lt; k; i++) { while (sum !</description>
    </item>
    <item>
      <title>443.压缩字符串</title>
      <link>http://localhost:1313/posts/leet/443.string-compression.zh/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression.zh/</guid>
      <description>问题描述 443.压缩字符串&#xA;解题思路 双指针、滑动窗口，注意for循环中不需要fast++。&#xA;代码 class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.push_back(chars[slow]); res.push_back(cnt + &amp;#39;0&amp;#39;); } else if (cnt &amp;gt;= 10 &amp;amp;&amp;amp; cnt &amp;lt;= 99) { res.</description>
    </item>
    <item>
      <title>443.string compression</title>
      <link>http://localhost:1313/posts/leet/443.string-compression/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression/</guid>
      <description>Description 443.string-compression&#xA;Solution Sliding window, please pay attention to that fast++ is not needed in for loop.&#xA;Code class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.</description>
    </item>
    <item>
      <title>1812.determine color of a chessboard square</title>
      <link>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square/</link>
      <pubDate>Thu, 08 Dec 2022 16:00:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square/</guid>
      <description>Description 1812.determine color of a chessboard square&#xA;Solution Easy&#xA;Code class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - &amp;#39;a&amp;#39; + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>1812.判断国际象棋棋盘中一个格子的颜色</title>
      <link>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square.zh/</link>
      <pubDate>Thu, 08 Dec 2022 16:00:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square.zh/</guid>
      <description>问题描述 1812.判断国际象棋棋盘中一个格子的颜色&#xA;解题思路 太简单了，不写&#xA;代码 class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - &amp;#39;a&amp;#39; + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>698.partition to k equal sum subsets</title>
      <link>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets/</link>
      <pubDate>Thu, 08 Dec 2022 15:47:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets/</guid>
      <description>Description 698.partition-to-k-equal-sum-subsets&#xA;Solution Sort array from large to small, so that we can avoid making mistake of judging arrays like [1, 1, 2, 2].&#xA;We use used[i] to avoid using the same element more than once, if sum == target, sum = 0, if cnt == k, than it can be devided.&#xA;Code class Solution { public: bool dfs(vector&amp;lt;int&amp;gt; &amp;amp;nums, int index, int sum, int target, int cnt, int k, vector&amp;lt;int&amp;gt; &amp;amp;used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); // pay attention to the `idx - 1` rather than `index - 1` } for (int i = index; i &amp;gt;= 0; i--) { if (used[i] || sum + nums[i] &amp;gt; target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k !</description>
    </item>
    <item>
      <title>698.划为k个相等的子集</title>
      <link>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets.zh/</link>
      <pubDate>Thu, 08 Dec 2022 15:47:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets.zh/</guid>
      <description>问题描述 698.划为k个相等的子集&#xA;解题思路 首先，对数组按照从大到小排序，相比从小到大排序，能避免[1, 1, 2, 2]这样的数组的误判;&#xA;利用used[i]数组避免重复使用同一个元素，如果sum == target，就将sum置零，如果cnt == k，说明满足条件。&#xA;代码 class Solution { public: bool dfs(vector&amp;lt;int&amp;gt; &amp;amp;nums, int index, int sum, int target, int cnt, int k, vector&amp;lt;int&amp;gt; &amp;amp;used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); //注意这里是idex - 1而不是index - 1 } for (int i = index; i &amp;gt;= 0; i--) { if (used[i] || sum + nums[i] &amp;gt; target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k !</description>
    </item>
    <item>
      <title>438.find all anagrams in a string</title>
      <link>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string/</link>
      <pubDate>Wed, 07 Dec 2022 19:23:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string/</guid>
      <description>Description 438.find-all-anagrams-in-a-string&#xA;Solution Similar to 30.substring-with-concatenation-of-all-words, easier.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { unordered_map&amp;lt;char, int&amp;gt; mp; for (char &amp;amp;c : p) mp[c]++; vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;char, int&amp;gt; tmp = mp; for (int l = 0, r = 0; r &amp;lt; s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.</description>
    </item>
    <item>
      <title>438.找到字符串中所有字母异位词</title>
      <link>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string.zh/</link>
      <pubDate>Wed, 07 Dec 2022 19:23:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string.zh/</guid>
      <description>问题描述 438.找到字符串中所有字母异位词&#xA;解题思路 参照30.串联所有单词串，思路完全一致。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { unordered_map&amp;lt;char, int&amp;gt; mp; for (char &amp;amp;c : p) mp[c]++; vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;char, int&amp;gt; tmp = mp; for (int l = 0, r = 0; r &amp;lt; s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.find(s[r]) != mp.end()) { while (s[l] !</description>
    </item>
    <item>
      <title>93.restore ip addresses</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses/</guid>
      <description>Description 93.restore-ip-addresses&#xA;Solution Backtracking is actually changing a problem to one like a tree, and doing DFS(depth first search).&#xA;Code class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.</description>
    </item>
    <item>
      <title>93.复原ip地址</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</guid>
      <description>问题描述 93.复原ip地址&#xA;解题思路 回溯实际上就是转化为树形问题，做深度优先遍历。&#xA;代码 class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.size()) { if (cnt == 4) { ip.</description>
    </item>
    <item>
      <title>1775.equal sum arrays with minimum number of operations</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</guid>
      <description>Description 1775.equal-sum-arrays-with-minmum-number-of-operations&#xA;Solution hash table + greedy algorithm The general idea of this problem is hash + greedy algorithm.&#xA;Assuming that the sum1 minus sum2 to be diff and diff &amp;gt; 0, to reduce the difference of the sum of two arrays, we should make diff be value minus the maximum value of changing a number in one of the two array, and make the count of number changed minus 1, until diff &amp;lt; 0.</description>
    </item>
    <item>
      <title>1775.通过最少操作次数使数组的和相等</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</guid>
      <description>问题描述 1775.通过最少操作次数使数组的和相等&#xA;解题思路 哈希+贪心 本题总体思路为哈希+贪心，用两个数组mp1，mp2记录nums1，nums2中每个数各出现了多少次;&#xA;假设nums1的和sum1减去nums2的和sum2的结果为diff，这里假设diff &amp;gt; 0，为了抹平两个数组的和的差距，应该每次减去两个数组中，变化数字引起的数值变化的最大值，并且将变化的数字的计数值减一;&#xA;nums1的和小于nums2的和的情况类似。&#xA;优化 首先假设sum1 &amp;lt; sum2，否则我们交换nums1和nums2并交换sum1和sum2即可，接下来，必定是nums1缩小，nums2增大，对应diff = sum2 - sum1缩小，diff可以减少1,2,3,4,5各若干次，取决于nums1和nums2中原先各个数的数量，用一个哈希表来记录，最后我们从大到小遍历i = 5, 4, 3, 2, 1.&#xA;代码 hash + greedy algorithm class Solution { public: int find_min(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = 1; i &amp;lt; v.size(); i++) { if (v[i] != 0) return i; } return 6; } int find_max(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = v.size() - 1; i &amp;gt;= 1; i--) { if (v[i] !</description>
    </item>
    <item>
      <title>219.contains duplicate ii</title>
      <link>http://localhost:1313/posts/leet/219.contains-duplicate-ii/</link>
      <pubDate>Tue, 06 Dec 2022 20:00:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/219.contains-duplicate-ii/</guid>
      <description>Description 219.contains-duplicate-ii&#xA;Solution We can use unordered_map to record the number of ocurrence of each integer and slide window accrording the unordered_map.&#xA;Code class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] &amp;lt;= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; </description>
    </item>
    <item>
      <title>219.存在重复元素II</title>
      <link>http://localhost:1313/posts/leet/219.contains-duplicate-ii.zh/</link>
      <pubDate>Tue, 06 Dec 2022 20:00:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/219.contains-duplicate-ii.zh/</guid>
      <description>问题描述 219.存在重复元素II&#xA;解题思路 利用unordered_map记录元素出现的次数，使用滑动窗口法。&#xA;代码 class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] &amp;lt;= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; </description>
    </item>
    <item>
      <title>396.rotate function</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function/</guid>
      <description>Description 396. rotate-function&#xA;Solution The key is to find the mathematical laws&#xA;Code class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>396.旋转函数</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function.zh/</guid>
      <description>问题描述 396.旋转函数&#xA;解题思路 关键在于找到数学规律&#xA;代码 class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.size(); i++) { res[i] = res[i - 1] + sum - (nums.</description>
    </item>
    <item>
      <title>1796.second largest digit in a string</title>
      <link>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string/</link>
      <pubDate>Tue, 06 Dec 2022 19:47:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string/</guid>
      <description>Description 1796.second-largest-digit-in-a-string&#xA;Solution Just traversing.&#xA;Code class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] &amp;lt;= &amp;#39;9&amp;#39;) { if (s[i] - &amp;#39;0&amp;#39; &amp;gt; first) { second = first; first = s[i] - &amp;#39;0&amp;#39;; } else if (s[i] - &amp;#39;0&amp;#39; &amp;lt; first &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt; second) second = s[i] - &amp;#39;0&amp;#39;; } } return second; } }; </description>
    </item>
    <item>
      <title>1796.字符串中第二大的数字</title>
      <link>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:47:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string.zh/</guid>
      <description>问题描述 1796.字符串中第二大的数字&#xA;解题思路 遍历就好了&#xA;代码 class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] &amp;lt;= &amp;#39;9&amp;#39;) { if (s[i] - &amp;#39;0&amp;#39; &amp;gt; first) { second = first; first = s[i] - &amp;#39;0&amp;#39;; } else if (s[i] - &amp;#39;0&amp;#39; &amp;lt; first &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt; second) second = s[i] - &amp;#39;0&amp;#39;; } } return second; } }; </description>
    </item>
    <item>
      <title>1805.number of different integers in a string</title>
      <link>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string/</link>
      <pubDate>Tue, 06 Dec 2022 19:14:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string/</guid>
      <description>Descripiton 1805.number-of-different-integers-in-a-string&#xA;Solution Treating numbers as strings, save them in unordered_set, we need pay attention to pilot zero and the condition which last character is a number.&#xA;Code class Solution { public: int numDifferentIntegers(string word) { unordered_set&amp;lt;string&amp;gt; words; string str; for (int i = 0; i &amp;lt; word.size(); i++) { if (str.empty()) { if (word[i] - &amp;#39;0&amp;#39; &amp;lt;= 9) str.push_back(word[i]); } else { if (word[i] - &amp;#39;0&amp;#39; &amp;gt; 9) { if (words.</description>
    </item>
    <item>
      <title>1805.字符串中不同整数的数目</title>
      <link>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:14:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string.zh/</guid>
      <description>问题描述 1805.字符串中不同整数的数目&#xA;解题思路 把数字当作字符串处理，存入unordered_set(哈希表)中，注意最后一个字符是数字的情况。&#xA;代码 class Solution { public: int numDifferentIntegers(string word) { unordered_set&amp;lt;string&amp;gt; words; string str; for (int i = 0; i &amp;lt; word.size(); i++) { if (str.empty()) { if (word[i] - &amp;#39;0&amp;#39; &amp;lt;= 9) str.push_back(word[i]); } else { if (word[i] - &amp;#39;0&amp;#39; &amp;gt; 9) { if (words.find(str) == words.end()) words.insert(str); str.clear(); } else { if (str.size() == 1 &amp;amp;&amp;amp; str[0] == &amp;#39;0&amp;#39;) { // 去除先导0 str.clear(); } str.push_back(word[i]); } } } if (!</description>
    </item>
    <item>
      <title>131.palindrome patitioning</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning/</guid>
      <description>Description 131.palindrome-partitioning&#xA;Solution We can whether it is palindrome by dynamic programming: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;When traversing, pay attention to the order of traversing i;&#xA;Last, we use backtracking to update res.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.</description>
    </item>
    <item>
      <title>131.分割回文串</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</guid>
      <description>问题描述 131.分割回文串&#xA;解题思路 利用动态规划来判断字符串是否是回文串: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;这里遍历的时候要注意i的遍历顺序;&#xA;最后考虑利用回溯法，更新答案。&#xA;代码 class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.size(); i++) { if (dp[index][i]) { res_tmp.push_back(s.substr(index, i - index + 1)); track_back(s, i + 1, dp); res_tmp.pop_back(); } } return; } vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) { vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>3.longest substring without repeating characters</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</guid>
      <description>Description 3.longest-substring-withou-repeating-characters&#xA;Solution We use arr[96] to record the number of occurence of each character. If the number is larger than 1, than there is repeating character between l and r; else, update res, if current length of substr is larger than res.&#xA;Code class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.</description>
    </item>
    <item>
      <title>3.无重复字符的最长子串</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</guid>
      <description>问题描述 3.无重复字符的最长子串&#xA;解题思路 用arr[96]记录每个字符出现的次数，如果字符次数大于1，说明已经包含了重复字符，则要更新l，否则递增r，并记录最大的子串长度。&#xA;代码 class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.size(); r++) { arr[s[r] - &amp;#39; &amp;#39;]++; if (arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) { while (l &amp;lt; r &amp;amp;&amp;amp; arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) arr[s[l++] - &amp;#39; &amp;#39;]--; } else { res = max(r - l + 1, res); } } return res; } }; </description>
    </item>
    <item>
      <title>30.substring with concatenation of all words</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</guid>
      <description>Description 30.substring-with-concatenation-of-all-words&#xA;Solution For each word sequence {s.substr(i, word_len), s.substr(i + word_len, word_len)...} of i($[0, word_len - 1]$), we use sliding window to judge;&#xA;We should pay attention to the detail when judging. We can use mp to determine whether substr is in words, and mp_tmp to determine whether it is concatenated substring, if mp is empty, then it is;&#xA;For key-value in mp_tmp, if value becomes 0, then erase(key);</description>
    </item>
    <item>
      <title>30.串联所有单词串</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</guid>
      <description>问题描述 30.串联所有单词串&#xA;解题思路 首先，由于words中所有字符串长度相同，要比较words与s: - s从i = 0开始，可以划分为一系列的长为word_len = words[0].size()的单词; - s从i = 1开始，可以划分为一系列的长为word_len = words[0].size()的单词; - &amp;hellip;&amp;hellip; - s从i = word_len - 1开始&amp;hellip;&amp;hellip;&#xA;然后要注意利用unordered_map&amp;lt;string, int&amp;gt;判断是否满足条件的细节，mp用于判断word是否在words中;&#xA;mp_tmp的键值对中，如果值为0，就删掉该键;&#xA;还要注意l的处理，分为在mp_tmp为空，和mp_tmp不为空，但是word已经出现了超过words中的次数.&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findSubstring(string s, vector&amp;lt;string&amp;gt; &amp;amp;words) { unordered_map&amp;lt;string, int&amp;gt; mp; int word_len = words[0].size(); int cnt = 0; vector&amp;lt;int&amp;gt; res; for (int i = 0; i &amp;lt; words.size(); i++) { mp[words[i]]++; cnt++; } if (cnt * word_len &amp;gt; s.</description>
    </item>
    <item>
      <title>1610.maximum Number of Visible Points</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</guid>
      <description>Descripiton 1610.maximum-number-of-visible-points&#xA;Soluiton We can use function atan2 to change slope to angle in $-\pi ~ \pi$.&#xA;We need also expand arrays, let angle[n + i] = angle[i] + 360, and the length of array to be 2 * n, so we can avoid omission.&#xA;Code class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>1610.可见点的最大数目</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</guid>
      <description>问题描述 1610.可见点的最大数目&#xA;解题思路 利用atan2函数，即可将斜率转化为$-\pi ~ \pi$的角度;&#xA;扩充数组，令angle[n + i] = angle[i] + 360，使角度数组长度为2 * n，这样就能避免遗漏一四象限。&#xA;代码 class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>303.range sum query-immutable</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</guid>
      <description>Description 303.range-sum-query-immutable&#xA;Solution We can use prefix sum array, so we can get sum without traversing.&#xA;Code class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>303.区域和检索-数组不可变</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</guid>
      <description>问题描述 303.区域和检索-数组不可变&#xA;解题思路 利用前缀和数组，使得求区间和时无需再遍历数组求和。&#xA;代码 class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>1769.minimum number of operation to ove ll balls to each box</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</guid>
      <description>Description 1769.minimum-number-of-operations-to-move-all-balls-to-each-box&#xA;Solution Violent solution: $\Theta(n^2)$&#xA;We could use prefix sum to reduce the time complexity.&#xA;nums[i] denotes the number of ball in first i + 1 boxes, res[i] is the minimum number of operation to ove ll balls to the i + 1th box, sum is the total number of balls. Compared to moving all balls to i th box, if we want to move all ball to the i + 1th box, the balls in 0 =&amp;gt; i - 1 all need move an additional step, while the balls in i =&amp;gt; n - 1 will move one step less.</description>
    </item>
    <item>
      <title>1769.移动所有球到每个盒子所需的最小操作数</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</guid>
      <description>问题描述 1769.移动所有球到每个盒子所需的最小操作数&#xA;解题思路 暴力求解，时间复杂度为$\Theta(n^2)$;&#xA;可以考虑利用前缀和来降低时间复杂度: 设nums[i]是前i + 1个盒子里的球的总个数，res[i]为将所有球移到第i + 1个盒子里所需要的操作数，sum为球总个数，移到第i + 1个盒子相比移到第i个盒子，左边的球各要多移一步，右边的球各少移一步，因此有那么有:res[i] = res[i - 1] + nums[i - 1] - (sum - nums[i - 1])，&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; minOperations(string boxes) { vector&amp;lt;int&amp;gt; nums(boxes.size(), 0); int sum = boxes[0] - &amp;#39;0&amp;#39;; nums[0] = boxes[0] - &amp;#39;0&amp;#39;; for (int i = 1; i &amp;lt; boxes.size(); i++) { if (boxes[i] == &amp;#39;1&amp;#39;) { nums[i] = nums[i - 1] + 1; sum++; } else nums[i] = nums[i - 1]; } vector&amp;lt;int&amp;gt; res(boxes.</description>
    </item>
    <item>
      <title>424.替换后的最长重复字符</title>
      <link>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:47:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</guid>
      <description>问题描述 424.替换后的最长重复字符&#xA;解题思路 首先，注意一点，子串如果能通过k次替换变成只包含相同字母的子串，那么一定有max_cnt + k &amp;gt;= subarray.size();那么不满足条件的子串一定有max_cnt + k &amp;lt; subarray.size()，根据这一点，我们可以采用滑动窗口法;&#xA;如果满足条件，那么只增加right，如果不满足条件，right++、left++，这样right - left一定是递增的，并且会遍历搜寻到所有的不同字符。&#xA;代码 class Solution { public: int characterReplacement(string s, int k) { vector&amp;lt;int&amp;gt; num(26); int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right &amp;lt; n) { num[s[right] - &amp;#39;A&amp;#39;]++; maxn = max(maxn, num[s[right] - &amp;#39;A&amp;#39;]); if (right - left + 1 - maxn &amp;gt; k) { num[s[left] - &amp;#39;A&amp;#39;]--; left++; } right++; } return right - left; } }; </description>
    </item>
    <item>
      <title>413.arithmetic slices</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices/</guid>
      <description>Descritpion 413.arithmetic slices&#xA;Solution We should notice that the number of subarray $cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$(len) is the length of arithmetic array.&#xA;Code class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>413.等差数列划分</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</guid>
      <description>问题描述 413.等差数列划分&#xA;解题思路 注意到子数组个数$cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$，其中len是等差数组的长度，则cnt = (n - 1) * (n - 2) / 2，每次遍历找出连续的等差数组的长度即可。 测试test&#xA;代码 class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.size(); i++) { if (nums[i] - nums[i - 1] == dif) len++; else { if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; len = 2; dif = nums[i] - nums[i - 1]; } } if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; return cnt; } }; </description>
    </item>
    <item>
      <title>88.merge sorted array</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array/</guid>
      <description>Description 88.merge-sorted-array&#xA;Solution We use pointers, assign values of nums1 from end to front, so we use only $\Theta(1)$ extra space.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>88.合并两个有序数组</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</guid>
      <description>问题描述 88.合并两个有序数组&#xA;解题思路 双指针，由于num1的长度是m + n，因此遍历时，可以考虑针对nums1，从后往前赋值，从而只需要$\Theta(1)$的额外空间。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>142.linked list cycle ii</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</guid>
      <description>Description 142.linked-list-cycle-ii&#xA;Solution Like 141.linked-list-cycle, when fast and slow meet each other, we make a pointer p start from virtual head node, traverse one by one, the same as slow. slow and p will meet at the entrance of the cycle.&#xA;Code class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead !</description>
    </item>
    <item>
      <title>142.环形链表II</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</guid>
      <description>问题描述 142.环形链表II&#xA;解题思路 判断是否链表是否存在环的方式与141.环形链表一致，当两个指针相遇时，再让一个指针从虚拟头节点开始一个节点一个节点的遍历，slow指针也是，两个指针会在环的入口处相遇。&#xA;代码 class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead != slow) { vhead = vhead-&amp;gt;next; slow = slow-&amp;gt;next; } delete vhead; return slow; } } return nullptr; } }; </description>
    </item>
    <item>
      <title>141.linked list cycle</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle/</guid>
      <description>Description 141.linked-list-cycle&#xA;Solution We can use two pointers, one fast, one slow. For each time, fast move to next next node, slow move to next node. If there is cycle, fast will be equal to slow, or fast will be nullptr.&#xA;Code class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>141.环形链表</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</guid>
      <description>问题描述 141.环形链表&#xA;解题思路 使用快慢两个指针，fast一次移动两个节点，slow一次移动一个节点，如果链表存在环，那么fast和slow一定会有相等的时候，否则fast会运动到链表末尾。&#xA;代码 class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>345.reverse vowels of a string</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</guid>
      <description>Description 345.reverse-vowels-of-a-string&#xA;Solution We use unordered_set to determine whether it is vowel, two pointers.&#xA;Code class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.</description>
    </item>
    <item>
      <title>345.反转字符串中的元音字母</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</guid>
      <description>问题描述 345.反转字符串中的元音字母&#xA;解题思路 双指针法，使用unordered_set(底层实现为哈希表)来判断是否是元音字母。&#xA;代码 class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) == mset.end()) r--; else if (mset.</description>
    </item>
    <item>
      <title>75.sort colors</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors/</link>
      <pubDate>Fri, 25 Nov 2022 15:27:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors/</guid>
      <description>Description 75.sort-colors&#xA;Solution Here, we need three pointers l, r, idx, l for 0, r for 2, idx for traversing.&#xA;When traversing:&#xA;if nums[idx] == 0,swap(nums[idx], nums[l]);, and idx++; l++ if nums[idx] == 1, idx++; if nums[idx] == 2, swap(nums[idx], nums[r]);, and only r--, because new nums[idx] may be 0 or 1 or 2, so we need determine the value of nums[idx] again. if swap(nums[idx], nums[l]);, new nums[idx] will be 0 only when idx == l, or nums[idx] == 1, so we can increase idx.</description>
    </item>
    <item>
      <title>75.颜色分类</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors.zh/</link>
      <pubDate>Fri, 25 Nov 2022 15:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors.zh/</guid>
      <description>问题描述 75.颜色分类&#xA;解题思路 这里，我们需要三个指针l, r, idx, l用来存放0,r用来存放2，idx用来进行遍历数组。&#xA;要注意的是，在遍历数组时:&#xA;if nums[idx] == 0，需要交换nums[idx]和nums[l]的值，同时idx++; l++; if nums[idx] == 1，idx++即可 if nums[idx] == 2，需要交换nums[idx]和nums[l]的值，但此时只是r--，不会idx++，这是因为新的交换后的nums[idx]的值可能是0、1、2中的任意一个，因此还需要重新判断nums[idx] 如果idx == l，那么[0, idx]区间范围内的数都是0，如果idx != l，那么[0, l - 1]区间范围内都是0，[l, idx)区间范围内都是1，因此可以进行idx++; 代码 class Solution { public: void sortColors(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int tmp = 0, index = 0; int l = 0, r = nums.size() - 1; while (index &amp;lt;= r) { if (nums[index] == 0) { tmp = nums[l]; nums[l++] = 0; nums[index++] = tmp; } else if (nums[index] == 2) { tmp = nums[r]; nums[r--] = 2; nums[index] = tmp; } else index++; } } }; </description>
    </item>
    <item>
      <title>26.remove duplicates from sorted array</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</guid>
      <description>Description 26.remove-duplicates-from-sorted-array&#xA;Solution We use two pointers fast and slow, fast used to check if duplicated, slow use for assignment.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>26.删除有序数组中的重复项</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</guid>
      <description>问题描述 26.删除有序数组中的重复项&#xA;解题思路 采用双指针法，一快一慢，fast用于检测是否重复，slow用来被赋值。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>18.4sum</title>
      <link>http://localhost:1313/posts/leet/18.4sum/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum/</guid>
      <description>Description 18.4sum&#xA;Solution Two pointers, i, j = i + 1, l = j + 1, r = nums.size() - 1;&#xA;Pay attention to overflow exception and deduplication.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    <item>
      <title>18.4四数之和</title>
      <link>http://localhost:1313/posts/leet/18.4sum.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum.zh/</guid>
      <description>问题描述 18.四数之和&#xA;解题思路 双指针法，i, j = i + 1, l, r;&#xA;注意去重和溢出。&#xA;代码 class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.size() - 2; j++) { if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) continue; int l = j + 1, r = nums.</description>
    </item>
    <item>
      <title>19.remove nth node from end of list</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</guid>
      <description>Description 19.remove-nth-node-from-end-of-list&#xA;Solution For convenience, we create a virtual head node pre, pre-&amp;gt;next = head.&#xA;We will use two pointers fast and slow. First, fast go head for n times, then fast and slow go ahead together. When fast arrives at last node, slow points to the last node of the node we need delete.&#xA;Code class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next !</description>
    </item>
    <item>
      <title>19.删除链表的倒数第N个节点</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</guid>
      <description>问题描述 19.删除链表的倒数第N个节点&#xA;解题思路 首先设置一个虚拟头节点pre，pre-&amp;gt;next = head;&#xA;双指针法，考虑使用两个指针fast，slow，一快一慢，fast指针先前进n个位置，然后fast和slow一起遍历，当fast到达最后一个节点的时候，slow刚好位于要删除的节点的前一个节点。&#xA;代码 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next; slow = slow-&amp;gt;next; } slow-&amp;gt;next = slow-&amp;gt;next-&amp;gt;next; return pre-&amp;gt;next; } }; </description>
    </item>
    <item>
      <title>16.3sum closest</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest/</guid>
      <description>Description 16.3sum-closest&#xA;Solution The violent solution: triple cycle, $\Theta(n^3)$&#xA;We should notice that we don&amp;rsquo;t care the original index of array, so we can use two pointers to reduce the time complexity.&#xA;First, we need sort the array, in outer loop, i iterates from 0 to nums.size() - 3, in inner loop, l and r come together from end to the middle.&#xA;Code class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.</description>
    </item>
    <item>
      <title>16.最接近的三数之和</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest.zh/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest.zh/</guid>
      <description>问题描述 16.最接近的三数之和&#xA;解题思路 暴力解法，三重循环，时间复杂度为$\Theta(n^3)$;&#xA;注意到本题不关注数组中元素的初始索引，因此可以考虑利用双指针来降低时间复杂度: 首先将数组排序，最外层i从0遍历到nums.size() - 3，内层循环采用相向双指针l，r从两端向中间靠拢，并且要注意如何去重，(当然，此题可以不关注)。&#xA;代码 class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.begin(), nums.end()); int sum = nums[0] + nums[1] + nums[2]; // 记录三数之和 for (int i = 0; i &amp;lt; nums.size() - 2; i++) { // 跳过重复的 if (i !</description>
    </item>
    <item>
      <title>快速幂与快速乘</title>
      <link>http://localhost:1313/posts/tech/exponentiating-by-squaring.zh/</link>
      <pubDate>Sat, 19 Nov 2022 11:51:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/exponentiating-by-squaring.zh/</guid>
      <description>定义 快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $\Theta(\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $\Theta(n)$ 的时间。&#xA;这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。&#xA;解释 计算 $a$ 的 $n$ 次方表示将 $n$ 个 $a$ 乘在一起：$a^{n} = \underbrace{a \times a \cdots \times a}_{n\text{ 个 a}}$。然而当 $a,n$ 太大的时侯，这种方法就不太适用了。不过我们知道：$a^{b+c} = a^b \cdot a^c,,,a^{2b} = a^b \cdot a^b = (a^b)^2$。二进制取幂的想法是，我们将取幂的任务按照指数的 二进制表示 来分割成更小的任务。&#xA;过程 首先我们将 $n$ 表示为 2 进制，举一个例子吧：&#xA;$$ 3^{13} = 3^{(1101)_2} = 3^8 \cdot 3^4 \cdot 3^1 $$&#xA;因为 $n$ 有 $\lfloor \log_2 n \rfloor + 1$ 个二进制位，因此当我们知道了 $a^1, a^2, a^4, a^8, \dots, a^{2^{\lfloor \log_2 n \rfloor}}$ 后，我们只用计算 $\Theta(\log n)$ 次乘法就可以计算出 $a^n$。</description>
    </item>
    <item>
      <title>11.container with most water</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water/</link>
      <pubDate>Sat, 19 Nov 2022 09:46:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water/</guid>
      <description>Description 11.container-with-most-water&#xA;Solution The violent solution of this problem has a time complexity of $O(n^2)$, to reduce the time complexity, we consider two-pointers.&#xA;So, we need determine how left pointer l and right pointer r will meet each other:&#xA;if (height[l] &amp;gt;= height[r]), the capacity depends on height[r]. If l++, the capacity will become smaller, so we should r--. if (height[l] &amp;lt; height[r]), the capacity depends on height[l]. If r--, the capacity will become smaller, so we should l++.</description>
    </item>
    <item>
      <title>11.盛最多水的容器</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</link>
      <pubDate>Sat, 19 Nov 2022 09:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</guid>
      <description>问题描述 11.盛最多水的容器&#xA;解题思路 本题暴力解法，时间复杂度为$O(n^2)$(会超时，没试过)，为了降低时间复杂度，考虑使用双指针。&#xA;那么，本题需要考虑的就是左指针l和右指针r如何向中间靠拢：&#xA;if (height[l] &amp;gt;= height[r])，说明容器容积是由height[r]来决定的，这时候，l向中间考虑，只可能会缩小容积，因此应该r--; if (height[l] &amp;lt; height[r])，说明容器容积由height[l]来决定，这时候，r向中间靠拢，只会缩小容积，因此应该l++; 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int l = 0, r = height.size() - 1; int res = 0; while (l &amp;lt; r) { if (height[l] &amp;gt;= height[r]) { res = max(res, (r - l) * height[r]); r--; // 因为此时，增加l只可能缩小res，所以减少r } else { res = max(res, (r - l) * height[l]); l++; // height[l] &amp;lt; height[r], 此时减少r也只会缩小res，所以增加l } } return res; } }; </description>
    </item>
    <item>
      <title>42.trapping rain water</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water/</guid>
      <description>Description 42.trapping-rain-water&#xA;Solution We can use monotone stack&#xA;The capacity of unit cosist of height[stk.top()] is (min(height[r], height[l]) - height[stk.top()]) * (l - r - 1), l is next element below the top of the stack, since height[l] &amp;gt;= height[stk.top()] r is the index of first column which height[r] &amp;gt;= height[stk.top()].&#xA;The result is the sum.&#xA;Code ```cpp #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.</description>
    </item>
    <item>
      <title>42.接雨水</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</guid>
      <description>问题描述 42.接雨水&#xA;解题思路 本题考虑使用单调栈(monotone stack)，栈顶到栈底依次递增。&#xA;由height[stk.top()]存放雨水的单元，其计算方式为(min(height[r], height[l]) - height[stk.top()]) * (l - r - 1)，其中l即栈顶的下一个元素，r则是第一个高度大于height[stk.top()]的柱子的索引。&#xA;结果为所有柱子能存放的雨水的累加。&#xA;代码 #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.push(0); int res = 0; for (int i = 1; i &amp;lt; height.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; height[i] &amp;gt; height[stk.top()]) { int mid = stk.top(); stk.pop(); if (!stk.empty()) { int h = min(height[i], height[stk.top()]) - height[mid]; int w = i - stk.</description>
    </item>
    <item>
      <title>503.下一个更大元素II</title>
      <link>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:59:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</guid>
      <description>问题描述 503.下一个更大元素II&#xA;解题思路 相比496.下一个更大元素I，在遍历数组上有所区别，如果i &amp;gt;= nums.size()，用j = i - nums.size();来代替i，因此i的取值范围是[0, 2 * nums.size())。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElements(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; res(nums.size(), -1); stack&amp;lt;int&amp;gt; stk; stk.push(0); int j = 0; for (int i = 1; i &amp;lt; 2 * nums.size(); i++) { if (i &amp;gt;= nums.size()) { j = i - nums.size(); while (!stk.empty() &amp;amp;&amp;amp; nums[j] &amp;gt; nums[stk.top()]) { res[stk.top()] = nums[j]; stk.pop(); } stk.push(j); } else { while (!</description>
    </item>
    <item>
      <title>496.next greater element i</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i/</guid>
      <description>Description 496.next-greater-element-i&#xA;Solution We can use monotone stack to traverse nums2, and use unordered_map to store the element in nums1 and corresponding result.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.</description>
    </item>
    <item>
      <title>496.下一个更大元素I</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</guid>
      <description>问题描述 496.下一个更大元素I&#xA;解题思路 本题利用单调栈(monotone stack)来遍历nums2，并且利用unordered_map来存储nums1中元素和对应的结果。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.find(nums2[stk.top()]) != umap.end()) { umap[nums2[stk.top()]] = nums2[i]; } stk.pop(); } stk.push(i); } vector&amp;lt;int&amp;gt; res(nums1.size(), -1); for (int i = 0; i &amp;lt; nums1.</description>
    </item>
    <item>
      <title>monotone stack</title>
      <link>http://localhost:1313/posts/tech/monotone-stack/</link>
      <pubDate>Fri, 11 Nov 2022 15:55:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/monotone-stack/</guid>
      <description>Description brief Monotone stack is a stack whose elements(from top to bottom) are (strictly) monotonically increasing or decreasing.&#xA;Monotone increasing stack: the element which is smaller than the element in the top can be pushed into stack, else we will pop the element in the top, until the stack is empty or the element is smaller than the element in the top, then we push the element into the stack. This data structure is usually used for problems to find first element that is larger than certain element.</description>
    </item>
    <item>
      <title>单调栈</title>
      <link>http://localhost:1313/posts/tech/monotone-stack.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:54:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/monotone-stack.zh/</guid>
      <description>问题描述 简述 单调栈(monotone stack)是指栈内元素(栈顶到栈底)都是(严格)单调递增或者递减的栈。&#xA;单调递增栈(从栈顶到栈底)：只有比栈顶小的才能入栈，否把栈顶元素弹出，直到栈为空或者或者待处理的元素小于栈顶元素，将元素入栈，适用于求解第一个大于某元素的数的情况；&#xA;单调递减栈，与递增栈相反，适用于求解第一个小于某位置元素的数；&#xA;判断方法 单调递增/递减栈一般根据出栈后顺序来决定，例如栈内顺序[1, 2, 6]，出栈后顺序[6, 2, 1]，这就是单调递减栈。&#xA;哨兵技巧 对于有些时候，如果会用到数组的全部元素，即栈中的元素最后都要出栈，那么很可能因为没有考虑边界而无法通过。所以我们可以使用哨兵法。&#xA;例如在{1, 3, 4, 5, 2, 9, 6}末尾添加一个-1作为哨兵，变成了 {1, 3, 4, 5, 2, 9, 6, -1}，这种技巧可以简化代码逻辑。&#xA;例题 </description>
    </item>
    <item>
      <title>739.daily temperatures</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures/</guid>
      <description>Description 739.dail-temperatures&#xA;Solution We can consider monotone stack. If the stack is empty or the element to deal with is smaller than the element in the top of the stack, we can push the element to the stack, else we should pop the element in the top of the stack until the stack is empty or the element is smaller than the element in the top of the stack.&#xA;It&amp;rsquo;s convenient to push the index i into the stack.</description>
    </item>
    <item>
      <title>739.每日温度</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</guid>
      <description>问题描述 739.每日温度&#xA;解题思路 考虑利用单调栈(monotone stack)来进行处理，如果栈为空或者要入栈的元素小于栈顶元素，那么该元素入栈，否则弹出栈顶元素直到栈为空，或者要入栈的元素小于栈顶元素，再将该元素入栈。&#xA;这里应该将数组索引i入栈会比较方便。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt; &amp;amp;temperatures) { vector&amp;lt;int&amp;gt; res(temperatures.size(), 0); stack&amp;lt;int&amp;gt; st; st.push(0); for (int i = 1; i &amp;lt; temperatures.size(); i++) { int j = i; // if (!st.empty()) { while (!st.empty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[st.top()]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); // } } return res; } }; </description>
    </item>
    <item>
      <title>738.monotone increasing digits</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</guid>
      <description>Description 738.monotone-increasing-digits&#xA;Solution First, we need change the number to a vector&amp;lt;int&amp;gt; dec, for example:1234 to {1, 2, 3, 4}. Then we can traverse the vector, until dec[i] &amp;gt; dec[i + 1], then set dec[i + n] = 9(n &amp;gt;= 1). If dec[i] == dec[i - 1] == ... == dec[j], then dec[j]--, set others as 9, else dec[i]--;&#xA;Code class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n !</description>
    </item>
    <item>
      <title>738.单调递增的数字</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</guid>
      <description>问题描述 738.单调递增的数字&#xA;解题思路 将该数字的每一位数字变成数组dec&amp;lt;int&amp;gt;的一部分，然后依次遍历，直到dec[i] &amp;gt; dec[i + 1]，然后将dec[i + 1]及以后的数字都变成9，如果dec[i] == dec[i - 1] == ··· == dec[j]，就将dec[j]--，其余全设置为9。&#xA;代码 class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n != 0) { res.push_back(n % 10); n = n / 10; } } int ten(int i) { int res = 1; while (i != 0) { i--; res *= 10; } return res; } public: int monotoneIncreasingDigits(int n) { vector&amp;lt;int&amp;gt; dec; vec_dec(n, dec); std::reverse(dec.</description>
    </item>
    <item>
      <title>56.merge intervals</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals/</guid>
      <description>Description 56.merge-intervals&#xA;Solution The solution is similar to 452.minimum-number-of-arrows-to-burst-balloons, if there is common space, change the res.back()[1] to intervals[i][1], while intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); if there is not common space, res.push_back().&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>56.合并区间</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals.zh/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals.zh/</guid>
      <description>问题描述 56.合并区间&#xA;解题思路 思路与452.用最少的箭引爆气球，只不过这里intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])，如果存在重叠，修改res最后一个元素的右端点值；如果不存在重叠，就往res里添加一个新的区间。&#xA;代码 class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i - 1][1] &amp;lt; intervals[i][0]) res.push_back(intervals[i]); else { intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); res[res.size() - 1][1] = intervals[i][1]; } } return res; } }; </description>
    </item>
    <item>
      <title>763.partition labels</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels/</guid>
      <description>Description 763.partition-label&#xA;Solution solution 1 First, we need traverse the string, record the maximum index of each letter in the string.&#xA;Then we need declare a variable right to record the maximum index of letter traversed. When the maximum index is the same as current index, we can partition the string.&#xA;solution 2 First, we need traverse the string, record the number of occurrence of each letter, and record whether the letter occur.</description>
    </item>
    <item>
      <title>763.划分字母区间</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels.zh/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels.zh/</guid>
      <description>问题描述 763.划分字母区间&#xA;解题思路 思路一 首先遍历一遍数组，记录每个字母在字符串中出现的最远位置。&#xA;声明一个变量right，用来记录已经遍历的字符中，最远的位置，当遍历到的位置与记录的最远位置重叠时，就说明可以划分数组了。&#xA;思路二 首先遍历一遍数组，记录每个字母出现的次数，并记录是否出现；&#xA;再遍历一次数组，当第一次碰到该字符时，该字符入栈，最后一次碰到该字符时，弹出栈顶的字符，栈空时，说明可以分割了。&#xA;代码 代码一 class Solution { public: vector&amp;lt;int&amp;gt; partitionLabels(string S) { int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置 for (int i = 0; i &amp;lt; S.size(); i++) { // 统计每一个字符最后出现的位置 hash[S[i] - &amp;#39;a&amp;#39;] = i; } vector&amp;lt;int&amp;gt; result; int left = 0; int right = 0; for (int i = 0; i &amp;lt; S.size(); i++) { right = max(right, hash[S[i] - &amp;#39;a&amp;#39;]); // 找到字符出现的最远边界 if (i == right) { result.</description>
    </item>
    <item>
      <title>435.non overlapping intervals</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</guid>
      <description>Description 435.non-overlapping-intervals&#xA;Solution This problem is almost the same with 452.minimum-number-of-arrows-to-burst-balloons, the number intervals minus the result of 452.minimum-number-of-arrows-to-burst-balloons is the result of this problem.&#xA;Attention, [1, 3], [3, 5] is not overlapping intervals in this problem.&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>435.无重叠区间</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</guid>
      <description>问题描述 435.无重叠区间&#xA;解题思路 本题和452.用最少数量的箭引爆气球可以说解题思路一模一样，区间数减去452.用最少数量的箭引爆气球就可以说是本题要求的答案，但是要注意的是，在本题中，区间端点相同是不认为重叠的。&#xA;代码 class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i][0] &amp;gt;= intervals[i - 1][1]) cnt++; else { intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); } } return intervals.size() - cnt; } }; </description>
    </item>
    <item>
      <title>452.用最少数量的箭引爆气球</title>
      <link>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</link>
      <pubDate>Thu, 03 Nov 2022 13:55:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</guid>
      <description>问题描述 452.用最少数量的箭引爆气球&#xA;解题思路 首先，按照$x_start$从小到大的顺序排序，然后开始分析需要的弓箭数。&#xA;if (points[i][0] &amp;gt; points[i - 1])，说明两个气球不存在重叠，需要两支箭，箭数result++; else，说明两个气球存在重叠，只需要一支箭，但此时，如何判断下一个气球是否需要新的箭呢: if (points[i + 1][0] &amp;gt; min(points[i - 1][1], points[i][1]))，那么就需要新的箭，反之就不需要，因此，令points[i][1] = min(points[i - 1][1], points[i][1])。 代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::sort; using std::vector; class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { return a[0] &amp;lt; b[0]; } public: int findMinArrowShots(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points) { int result = 1; sort(points.begin(), points.end(), cmp); for (int i = 1; i &amp;lt; points.size(); i++) { if (points[i - 1][1] &amp;lt; points[i][0]) result++; else { points[i][1] = min(points[i][1], points[i - 1][1]); } } return result; } }; </description>
    </item>
    <item>
      <title>406.queue reconstruction by height</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</guid>
      <description>Description 406.queue-reconstruction-by-height&#xA;Solution First, we need sort the vector by height, then do insertion according to ki.&#xA;When sorting, we need rewrite the comparing method, in reference to the use of sort() method in C++&#xA;Since there may be performance problem when doing insertion frequently in vector, we should use list based on linked list.&#xA;Code class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.</description>
    </item>
    <item>
      <title>406.根据身高重建队列</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</guid>
      <description>问题描述 406.根据身高重建队列&#xA;解题思路 首先根据身高对数组重新排序，再根据ki进行插入操作。&#xA;排序时，需要对排序的比较方法重写，参见C++ sort排序函数用法。&#xA;同时，考虑到基于使用vector来进行频繁的插入操作可能会存在性能问题，应该使用基于链表的list。&#xA;代码 class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.begin(), people.end(), cmp); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; queue; for (int i = 0; i &amp;lt; people.size(); i++) { int tmp = people[i][1]; queue.insert(tmp + queue.begin(), people[i]); } return queue; } }; class Solution { public: // 身高从大到小排（身高相同k小的站前面） static bool cmp(const vector&amp;lt;int&amp;gt;&amp;amp; a, const vector&amp;lt;int&amp;gt;&amp;amp; b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; people) { sort (people.</description>
    </item>
    <item>
      <title>860.lemonade change</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change/</guid>
      <description>Description 860.lemonade-change&#xA;Solution We can create an array to show the number of $5, $10, $20. When the number of $5 is less than 0, return false. When we receive $20, we should provide change with $10 preferentially.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>860.柠檬水找零</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change.zh/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change.zh/</guid>
      <description>问题描述 860.柠檬水找零&#xA;解题思路 创建一个数组，表示手中的5元纸币、10元纸币、20元纸币的数目，当其中5元纸币数目小于0，说明无法找零，遇到20元纸币时，优先使用10元纸币找零。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>135.candy</title>
      <link>http://localhost:1313/posts/leet/135.candy/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy/</guid>
      <description>Description 135.candy&#xA;Solution The key point of this problem is that we need traverse two times, one from front to back, the other from back to front.&#xA;Code class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // front to back for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // back to front for (int i = ratings.</description>
    </item>
    <item>
      <title>135.分发糖果</title>
      <link>http://localhost:1313/posts/leet/135.candy.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy.zh/</guid>
      <description>问题描述 135.分发糖果&#xA;解题思路 本题的关键在于，需要一次从前往后的遍历，第一次确定最少糖果数，同时还需要从后往前遍历，再一次确定最少糖果数。&#xA;代码 class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // 从前向后 for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // 从后向前 for (int i = ratings.size() - 2; i &amp;gt;= 0; i--) { if (ratings[i] &amp;gt; ratings[i + 1] ) { candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1); } } // 统计结果 int result = 0; for (int i = 0; i &amp;lt; candyVec.</description>
    </item>
    <item>
      <title>1005.maximize sum of array after k negations</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</guid>
      <description>Description 1005.maximize-sum-of-array-after-k-negations&#xA;Solution Greedy algorithm.&#xA;Code class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // first step for (int i = 0; i &amp;lt; A.size(); i++) { // second step if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // third step int result = 0; for (int a : A) result += a; // forth step return result; } }; </description>
    </item>
    <item>
      <title>1005.K次取反后的最大化的数组和</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</guid>
      <description>问题描述 1005.K次取反后最大化的数组和&#xA;解题思路 贪心算法&#xA;代码 class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // 第一步 for (int i = 0; i &amp;lt; A.size(); i++) { // 第二步 if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步 int result = 0; for (int a : A) result += a; // 第四步 return result; } }; </description>
    </item>
    <item>
      <title>45.jump game ii</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii/</guid>
      <description>Description 45.jump-game-ii&#xA;Solution In outer loop, we traverse from back to front, while in inner loop, we traverse from front to back, to find the station with minimum index that can arrive at destination. Make the station the new destination, and cnt++.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>45.跳跃游戏II</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</guid>
      <description>问题描述 45.跳跃游戏II&#xA;解题思路 外循环还是从末尾向前遍历，内循环从前往后遍历，每次找能到达终点的索引最小的位置，该位置作为新的终点，同时步数cnt++。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.size(); i++) { if (nums[i] + i &amp;gt;= cur_end) { cur_end = i; cnt++; break; } } } return cnt; } }; </description>
    </item>
    <item>
      <title>55.jump game</title>
      <link>http://localhost:1313/posts/leet/55.jump-game/</link>
      <pubDate>Sun, 30 Oct 2022 16:04:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game/</guid>
      <description>Description 55.jump-game&#xA;Solution Traversing from back to front, if nums[j] can be achieved from nums[j - 1] or nums in the front, then destination change from nums[j] to nums[j - 1] or num in the front.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r !</description>
    </item>
    <item>
      <title>55.跳跃游戏</title>
      <link>http://localhost:1313/posts/leet/55.jump-game.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:03:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game.zh/</guid>
      <description>问题描述 55.跳跃游戏&#xA;解题思路 从后向前遍历，只要nums[j]能由nums[j - 1]或者更前面的点跳到，那么终点就从nums[j]变成nums[j - 1]或更前面的点。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r != 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>72.edit distance</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance/</guid>
      <description>Description 72.edit-distance&#xA;Solution It&amp;rsquo;s easy to consider what dp[i][j] should denotes.&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else, we can consider in three cases: replace the word1[i - 1]: dp[i][j] = dp[i - 1][j - 1] + 1; remove word1[i - 1]: dp[i][j] = dp[i - 1][j] + 1; insert word2[j - 1] between word[i - 1] and word[i], it&amp;rsquo;s the same as remove word2[j - 1]: dp[i][j] = dp[i][j - 1] + 1; We should also pay attention to the initialzation of dp[i][j].</description>
    </item>
    <item>
      <title>72.编辑距离</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance.zh/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance.zh/</guid>
      <description>问题描述 72.编辑距离&#xA;解题思路 dp[i][j]的含义不再赘述:&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else,分为三种操作情况: 替换末尾字符: dp[i][j] = dp[i - 1][j - 1] + 1; 删除word1的第i个字符: dp[i][j] = dp[i - 1][j] + 1; 删除word2的第j个字符，即相当于在第i个字符后插入word2[j - 1]: dp[i][j] = dp[i][j - 1] 代码 class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 1; i &amp;lt;= word1.</description>
    </item>
    <item>
      <title>583.delete operations for two strings</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</guid>
      <description>Description 583.delete-operation-for-two-strings&#xA;Solution dp[i][j] denotes minimum number of options to make strings the same when considering the first i characters of word1 and the first j characters of word2.&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; Code class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.</description>
    </item>
    <item>
      <title>583.两个字符串的删除操作</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</guid>
      <description>问题描述 583.两个字符串的删除操作&#xA;解题思路 dp[i][j]表示对word1的前i个字符，word2的前j个字符，使得它们相同的最小步数:&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; 代码 class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 0; i &amp;lt;= word1.size(); i++) { dp[i][0] = i; } for (int j = 0; j &amp;lt;= word2.</description>
    </item>
    <item>
      <title>115.distinct subsequences</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences/</guid>
      <description>Description 115.distinct-subsequence&#xA;Solution dp[i][j] denotes the occurrences of the first j characters of t in the first i characters of s:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(uses[i - 1] and not use s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; Code class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>115.不同的子序列</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</guid>
      <description>问题描述 115.不同的子序列&#xA;解题思路 dp[i][j]表示考虑考虑t的前j个字符在s的前i个字符中的出现个数:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(表示使用s[i - 1]匹配和不使用s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; 代码 class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;uint32_t&amp;gt;(t.size() + 1, 0)); // dp[0][0] = 1; for (int i = 0; i &amp;lt;= s.size(); i++) { dp[i][0] = 1; } for (int i = 1; i &amp;lt;= s.</description>
    </item>
    <item>
      <title>392.is subsequence</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence/</guid>
      <description>Description 392.is-subsequence&#xA;Solution It&amp;rsquo;s similar to 1143.longest-common-subsequence. We just need to judge whether the result is equal to s.size().&#xA;Code class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>392.判断子序列</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence.zh/</guid>
      <description>问题描述 392.判断子序列&#xA;解题思路 与1143.最长公共子序列基本一样，只需要再判断结果是否和s.size()相等就好了。&#xA;代码 class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>53.maximum subarray</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray/</link>
      <pubDate>Sun, 30 Oct 2022 14:30:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray/</guid>
      <description>Description 53.maximum-subarray&#xA;Solution dp[i] denotes maximum sum of subarray ending with nums[i - 1], then: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;Code class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>53.最大子数组和</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</guid>
      <description>问题描述 53.最大子数组和&#xA;解题思路 动态规划 令dp[i]表示以nums[i - 1]结尾的连续子数组的最大和，则: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;贪心算法 以第一个正数为起点，开始记录和sum_temp，同时记录最大和sum，当sum_temp小于0时，起点变为新的正数。&#xA;代码 class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>1035.uncrossed lines</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines/</link>
      <pubDate>Sat, 29 Oct 2022 20:45:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines/</guid>
      <description>Description 1035.uncrossed-lines&#xA;Solution The same as 1143.longest-common-subsequence&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1035.不相交的线</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:44:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</guid>
      <description>问题描述 1035.不相交的线&#xA;解题思路 只是1143.最长公共子序列的另一种描述&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1143.longest common subsequence</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</guid>
      <description>Description 1143.longest-common-subsequence&#xA;Solution dp[i][j] denotes the length of longest common subsequence of first i characters of text1 and first j characters of text2:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.</description>
    </item>
    <item>
      <title>1143.最长公共子序列</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</guid>
      <description>问题描述 1143.最长公共子序列&#xA;解题思路 dp[i][j]表示text1的前i个字符和text2的前j个字符里最长公共子序列长度:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); 代码 #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.size() + 1, vector&amp;lt;int&amp;gt;(text2.size() + 1, 0)); int m = 0; int res = 0; for (int i = 1; i &amp;lt;= text1.</description>
    </item>
    <item>
      <title>134.gas station</title>
      <link>http://localhost:1313/posts/leet/134.gas-station/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station/</guid>
      <description>Description 134.gas-station&#xA;Solution We should consider total oil consumption total_oil, and remaining oil from new start station cur_oil(not replenish oil in new station):&#xA;total_oil &amp;lt; 0, can&amp;rsquo;t complete; cur_oil &amp;lt; 0, start at the new station; Code class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //total_oil need &amp;gt; 0, or can&amp;#39;t complete total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // start from i + 1 starting_station = i + 1; // restore to first state cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
    <item>
      <title>134.加油站</title>
      <link>http://localhost:1313/posts/leet/134.gas-station.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station.zh/</guid>
      <description>问题描述 134.加油站&#xA;解题思路 考虑两个变量，一个是总油耗total_oil，一个是从起点到下一个站点后汽车内部剩余的汽油cur_oil(没有在目标站点补充油耗)。 总油耗total_oil &amp;lt; 0，说明不可能到; cur_oil &amp;lt; 0，则以到达的站点作为新的起点再出发;&#xA;代码 class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //总和必须大于等于0，否则不能完成绕行 total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // 一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。 starting_station = i + 1; // 还原到初始状态 cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
    <item>
      <title>718.maximum length of repeated subarray</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</guid>
      <description>Description 718.maximum-length-of-repeated-subarray&#xA;Solution dp[i][j] denotes the length of longest public subarray of two subarray ending with nums1[i - 1], nums2[j - 1];&#xA;Recurrence formula&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; Code class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.</description>
    </item>
    <item>
      <title>718.最长重复子数组</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</guid>
      <description>问题描述 718.最长重复子数组&#xA;解题思路 dp[i][j]表示分别以nums1[i - 1], nums2[j - 1]结尾的两个子数组的最长公共子数组的长度；&#xA;递推关系:&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; 代码 class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) // dp[i][j] = max(dp[i - 1][j - 1] + 1, dp[i][j]); dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] &amp;gt; m) m = dp[i][j]; } } return m; } }; </description>
    </item>
    <item>
      <title>674.longest continuous increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</guid>
      <description>Description 674.longest-continuous-increasing-subsequence&#xA;Solution dp[i] denotes the length of longest continuous increasing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; Code class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>674.最长连续递增序列</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</guid>
      <description>问题描述 674.最长连续递增序列&#xA;解题思路 dp[i]表示以nums[i - 1]结尾的最长连续递增子序列长度;&#xA;递推关系为:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; 代码 class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>300.longest increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</guid>
      <description>Description 300.longest-increasing-subsequence&#xA;Solution The key point is: what dp[i] means is conducive to solving this problem. Since subsequence may be not continuous, dp[i] should denotes maximum length increaing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; i dp[i] = max(dp[j] + 1, dp[i]) Code class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // initialize dp[i] as 1 since there is one element at least // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>300.最长递增子序列</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</guid>
      <description>问题描述 300.最长递增子序列 本题简写为LIS问题，与LCS问题（最长公共子序列）相对。&#xA;解题思路 动态规划 关键在于，dp[i]表示什么含义便于解这道题，子序列不一定连续，所以为了便于求解，dp[i]应该表示为以nums[i - 1]结尾的最长严格递增子序列的长度；&#xA;递推关系为:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; i，表示nums[i - 1]前的任意一个元素 dp[i] = max(dp[j] + 1, dp[i]) 贪心 动态规划的时间复杂度为$O(n^2)$，这里存在一个时间复杂度更低的贪心解法：&#xA;动态规划的时间$O(n^2)$的时间复杂度中，$O(n)$的时间复杂度在与遍历整个数组，这是无法避免的；剩下的$O(n)$的时间复杂度，实际上在找一个满足j &amp;lt; i以及nums[j] &amp;lt; nums[i]的并且使dp[j]最大的j；&#xA;那么，可以转化为找dp[j]固定的情况下，最小的一个nums[j]，这样必然能够优先满足，nums[i] &amp;gt; nums[j]；因此我们构造一个贪心数组：min_len，min_len[i] = x表示长度为i的上升子序列的最小结尾元素为x。考虑到min_len一定是个单调递增的数组（易证），那么我们可以基于这个单调递增的特性，利用二分查找，找到满足min_len[j] &amp;lt; nums[i]的最大的j，即利用$O(\log n)$找到最佳转移位置。&#xA;代码 动态规划 class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // dp[0]不考虑，至少有一个元素，所以初始化为1 // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>714.买卖股票的最佳时机含手续费</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</guid>
      <description>问题描述 714.买卖股票的最佳时机含手续费&#xA;解题思路 分为手中有股票和无股票两种情况讨论，设定在卖出股票时支出手续费:&#xA;手中有股票:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); 手中无股票:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); 初始化:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; 代码 class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); dp[0][0] = -prices[0]; dp[0][1] = -fee; for (int i = 1; i &amp;lt;= prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); } return dp[prices.</description>
    </item>
    <item>
      <title>714.best time to buy and sell stock with transaction fee</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</guid>
      <description>Description 714.best-time-to-buy-and-sell-stock-with-transaction-fee&#xA;解题思路 We can consider this problem in two cases: owning stock and not owning stock, assuming that you need to pay transaction fee when selling stock.&#xA;owning stock:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); not owning stock:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); Initializing dp:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; Code class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>309.best time to buy and sell stock with cooldown</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>Description 309.best-time-to-buy-and-sell-stock-with-cooldown&#xA;Solution The key point is find what dp should denote and its recurrence formula.&#xA;dp[i] indicates only considering first i days, and is devided into five cases: no operation, bought but not sold (stock in hand), exactly sold, cooling off period, and idle, which are noted as dp[i][0], dp[i][1], dp[i][2], dp[i][3], and dp[i][4] correspondingly.&#xA;Recurrence formula:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // last day can be on operation, bought but not sold, cooling off period, idle dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // last day can be cooling off period adn idle.</description>
    </item>
    <item>
      <title>309.最佳买卖股票时机含冷冻期</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</guid>
      <description>问题描述 309.最佳买卖股票时机含冷冻期&#xA;解题思路 本题的关键在于找到dp的实际含义，以及它的递推关系; dp[i]表示只考虑前i天的情况，分为无操作、买入未卖出(手中有股票)、正好卖出、冷静期、空闲五种情况，分别记为dp[i][0], dp[i][1], dp[i][2], dp[i][3], dp[i][4].&#xA;递推关系如下:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // 上一天的可能情况有无操作、买入未卖出、冷静期、空闲四种情况 dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // 上一天可能有冷静期和空闲两种情况 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max3(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ?</description>
    </item>
    <item>
      <title>123.买卖股票的最佳时机III</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</link>
      <pubDate>Wed, 12 Oct 2022 20:04:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</guid>
      <description>问题描述 123.买卖股票的最佳时机III&#xA;解题思路 本题的关键在于找到dp的实际含义，以及它的递推关系;&#xA;dp[i]表示只考虑前i天的情况，那么到了第i天，有五种可能的情况:&#xA;没有做任何操作，记为dp[i][0]; 前i天发生了一次买入，记为dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) 前i天发生了一次卖出，记为dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) 前i天发生了两次买入，记为dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) 前i天发生了两次卖出，记为dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) 初始化:&#xA;dp[0][0] = 0; dp[0][1] = -prices[0]; // 发生了一次买入 dp[0][2] = 0; // 买入又卖出 dp[0][3] = -prices[0]; // 买入-&amp;gt;卖出-&amp;gt;买入 dp[0][4] = 0; // 买入-&amp;gt;卖出-&amp;gt;买入-&amp;gt;卖出 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>122.best time to buy and sell stock ii</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sat, 08 Oct 2022 08:14:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Description 122.best-time-to-buy-and-sell-stock-ii&#xA;Solution The key point of this problem is to find the recurrence formula of dp[i]. Let&amp;rsquo;s discuss this problem in two cases.&#xA;if prices[i - 1] is not selected, then dp[i] = dp[i - 1]. It shows that: prices[i - 1] &amp;lt; prices[i - 2]; if prices[i - 1] is selected, then prices[i - 1] &amp;gt;= prices[i - 2], dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2].</description>
    </item>
    <item>
      <title>122.买卖股票的最佳时机II</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</guid>
      <description>问题描述 122.买卖股票的最佳时机II&#xA;解题思路 本题的关键是要找dp的递推关系，分两种情况讨论:&#xA;prices[i - 1]不会被选择，那么dp[i] = dp[i - 1]，其实也说明，prices[i - 1] &amp;lt; prices[i - 2]； prices[i - 1]被选择，那么prices[i - 1] &amp;gt;= prices[i - 2]，dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]。 代码 class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.size() == 1) return 0; vector&amp;lt;int&amp;gt; dp(prices.size() + 1, 0); for (int i = 2; i &amp;lt;= prices.size(); i++) { if (prices[i - 1] &amp;gt;= prices[i - 2]) dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]; else dp[i] = dp[i - 1]; } return dp[prices.</description>
    </item>
    <item>
      <title>123.best time to buy and sell stock iii</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</guid>
      <description>Description 123.best-time-to-buy-and-sell-stock-iii&#xA;Solution The key point is to find what dp should denotes and the recursion formula:&#xA;dp[i] denotes only considering first i days, then by day i, there are five possible cases:&#xA;no operation, written as dp[i][0]; buy stock once in first i days, written as dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) sell stock once in first i days, written as dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) by stock twice in first i days, written as dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) sell stock twice in first i days, written as dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) Initializaiton:</description>
    </item>
    <item>
      <title>121.best time to buy and sell stock</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 07 Oct 2022 16:34:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</guid>
      <description>Description 121.best-time-to-buy-and-sell-stock&#xA;Solution dynamic programming dp[i] denotes maximum profit in first i days, so the recurrence relation of dp[i] is: dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0).&#xA;greedy algorithm Let&amp;rsquo;s use cur to record the minimum element and replace the value of cur if the element is smaller, if the element is larger than cur, calculate the profit, save the maximum profit.&#xA;Code class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>121.买卖股票的最佳时机</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</link>
      <pubDate>Fri, 07 Oct 2022 16:33:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</guid>
      <description>问题描述 121.买卖股票的最佳时机&#xA;解题思路 动态规划 dp[i]表示前i天的最大收益，那么dp[i]的递推公式为:dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0)。&#xA;贪心算法 利用cur记录最小元素，碰到更小的就替换cur的值，遇到比它大的就进行一次利润计算，保存最大的利润。&#xA;代码 class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } int max(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ? a : c; else return b &amp;gt; c ? b : c; } public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.</description>
    </item>
    <item>
      <title>337.打家劫舍III</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</guid>
      <description>问题描述 337.打家劫舍III&#xA;解题思路 严格来说，这一题和198.打家劫舍，213.打家劫舍II的思路并不一致。&#xA;首先，这一道题遍历的是树，而不是一个数组。要比较的是选择目前节点和目前节点左子节点+右子节点，因此在遍历方式上需要采取后序遍历。&#xA;同时，作为二叉树的问题，一般是考虑递归进行处理：&#xA;递归的终止条件： 当前节点为空； 递归函数的返回值： 返回一个长度为2的数组dp，dp[0]表示不偷当前节点的最大金钱，dp[1]表示偷当前节点的最大金钱； 本级递归做什么： 计算偷当前节点的收益val1，不偷当前节点的收益val2，返回{val2, val1}。 代码 class Solution { public: int rob(TreeNode* root) { vector&amp;lt;int&amp;gt; result = robTree(root); return max(result[0], result[1]); } // 长度为2的数组，0：不偷，1：偷 vector&amp;lt;int&amp;gt; robTree(TreeNode* cur) { if (cur == NULL) return vector&amp;lt;int&amp;gt;{0, 0}; vector&amp;lt;int&amp;gt; left = robTree(cur-&amp;gt;left); vector&amp;lt;int&amp;gt; right = robTree(cur-&amp;gt;right); // 偷cur，那么就不能偷左右节点。 int val1 = cur-&amp;gt;val + left[0] + right[0]; // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况 int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; } }; </description>
    </item>
    <item>
      <title>337.house robber iii</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii/</guid>
      <description>Description 337.house-robber-iii&#xA;Solution Strictly speaking, the idea of this problem is different from 198.house-robber，213.house-robber-ii.&#xA;At first, what this problem need to traverse is tree, rather than an array. We need to compare selecting curent node with selecting left-child node and right-child node rather than current node. So, we should select postorder traversal.&#xA;And as a problem of binary tree, we consider recursion.&#xA;termination conditions of recursion current node is null; return value of recursion function return an array dp of length 2, dp[0] denotes maximum amount when not stealing current node, dp[1] denotes maximum amount when stealing current node; what this level of recursion does calculate the amount val1 when stealing current node, val2 for not stealing current node, return {val2, val1}.</description>
    </item>
    <item>
      <title>213.house robber ii</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii/</guid>
      <description>Description 213.house-robber-ii&#xA;Solution Referring to 198.house-robber, there be another constraint that first and last can&amp;rsquo;t be selected at the same time. So we can split the array into two part: one for [0, n - 1), another for [1, n), corresponding to dp0 and dp1 respectively, just return max(dp0, dp1).&#xA;Code class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.</description>
    </item>
    <item>
      <title>213.打家劫舍II</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</guid>
      <description>问题描述 213.打家劫舍II&#xA;解题思路 参照198.打家劫舍，但是这里多了一个首尾不能同时选择的选项，因此可以考虑将数组分成两部分，一个包含[0, n - 1)，一个包含[1, n)，分别对应dp0和dp1，取最后两者的最大值即可。&#xA;代码 class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.size() - 2); int result2 = robRange(nums, 1, nums.size() - 1); return max(result1, result2); } int robRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int end) { if (end == start) return nums[start]; vector&amp;lt;int&amp;gt; dp(nums.size()); dp[start] = nums[start]; dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i &amp;lt;= end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; } }; </description>
    </item>
    <item>
      <title>198.house robber</title>
      <link>http://localhost:1313/posts/leet/198.house-robber/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber/</guid>
      <description>Description 198.house-robber&#xA;Solution dp[i] denotes the maximum amount when the first i houses are considered.&#xA;Let&amp;rsquo;s consider the recursive relationship:&#xA;If the i-th house was stolen, it means that the i - 1th house was not stolen, so dp[i] = dp[i - 2] + a[i - 1]. If the i-th house was not stolen, then dp[i] = dp[i - 1]. So, dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]).</description>
    </item>
    <item>
      <title>198.打家劫舍</title>
      <link>http://localhost:1313/posts/leet/198.house-robber.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber.zh/</guid>
      <description>问题描述 198.打家劫舍&#xA;解题思路 dp[i]表示考虑前i个房间，能窃取到的最大金额。&#xA;考虑递推关系:&#xA;假设第要窃取第i个房间，那么说明第i - 1个房间，肯定没有被窃取，dp[i] = dp[i - 2] + nums[i - 1]。 假设不窃取第i个房间，则dp[i] = dp[i - 1]。 综上，dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1])。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int rob(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); if (nums.size() == 1) return nums[0]; if (nums.</description>
    </item>
    <item>
      <title>139.word Break</title>
      <link>http://localhost:1313/posts/leet/139.word-break/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break/</guid>
      <description>Description 139.word-break&#xA;Solution First, we should determine what dp array means. In this problem, dp[i] = 1 denotes that a string of length i can be split into words that appear in the dictionary.&#xA;So, we can get the recursive relationship:dp[j] = dp[i] &amp;amp;&amp;amp; substr in [i, j) can be split.&#xA;To initialize dp array: dp[0] = 1.&#xA;Attention: we should traverse volume first, then traverse items; if in the reverse order, it&amp;rsquo;s not convenient to judge whether string can be split.</description>
    </item>
    <item>
      <title>139.单词拆分</title>
      <link>http://localhost:1313/posts/leet/139.word-break.zh/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break.zh/</guid>
      <description>问题描述 139.单词拆分&#xA;解题思路 首先确定dp数组的含义，dp[i] = 1应该表示长度为i的字符串，可以拆分成字典中出现的单词;&#xA;则，dp的递推公式为:dp[j] = dp[i] &amp;amp;&amp;amp; [i, j]区间的字串可以拆分成字典中的单词&#xA;初始化dp数组:dp[0] = 1。&#xA;这里要注意，先遍历体积，再遍历物品；如果倒过来，是不方便判断字串是否可以拆分的。&#xA;代码 #include &amp;lt;string&amp;gt; #include &amp;lt;unordered_set&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::unordered_set; using std::vector; class Solution { public: bool wordBreak(string s, vector&amp;lt;string&amp;gt; &amp;amp;wordDict) { unordered_set&amp;lt;string&amp;gt; wordSet(wordDict.begin(), wordDict.end()); vector&amp;lt;int&amp;gt; dp(s.length() + 1, 0); // 0 为false dp[0] = 1; // 先遍历体积，再遍历物品 for (int j = 0; j &amp;lt;= s.length(); j++) { for (int i = 0; i &amp;lt;= j; i++) { string word = s.</description>
    </item>
    <item>
      <title>279.完全平方数</title>
      <link>http://localhost:1313/posts/leet/279.perfect-squares.zh/</link>
      <pubDate>Wed, 05 Oct 2022 17:07:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/279.perfect-squares.zh/</guid>
      <description>问题描述 279.完全平方数&#xA;解题思路 本题可以转化成一个完全背包问题，“物品”即{1, 4, 9, 16,...}等完全平方数，体积限制即所给的整数$n$。&#xA;代码 class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } public: int numSquares(int n) { int num = 1; for (int i = 1; i * i &amp;lt;= n; i++) num = i; vector&amp;lt;int&amp;gt; nums(num, 0); for (int i = 0; i &amp;lt; num; i++) // nums[i] &amp;lt;= n nums[i] = (i + 1) * (i + 1); vector&amp;lt;int&amp;gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; num; i++) { for (int j = nums[i]; j &amp;lt;= n; j++) { if (dp[j - nums[i]] &amp;lt; INT_MAX) dp[j] = min(dp[j], dp[j - nums[i]] + 1); } } return dp[n]; } }; </description>
    </item>
    <item>
      <title>322.coin change</title>
      <link>http://localhost:1313/posts/leet/322.coin-change/</link>
      <pubDate>Wed, 05 Oct 2022 03:53:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change/</guid>
      <description>Description 322.coin-change&#xA;Solution The recursive relationship change from max to min: dp[j] = min(dp[j], dp[j - coins[i]] + 1).&#xA;We need pay attention to issue about initializing dp array. To ensure that if j - coins[i] can&amp;rsquo;t be come up with, dp[j] is still dp[j] in last loop, we should initialize dp as INT_MAX, and dp[0] = 0.&#xA;Attention: INT_MAX + 1 &amp;lt; INT_MAX(in C++)&#xA;Code #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>322.零钱兑换</title>
      <link>http://localhost:1313/posts/leet/322.coin-change.zh/</link>
      <pubDate>Wed, 05 Oct 2022 03:52:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change.zh/</guid>
      <description>问题描述 322.零钱兑换&#xA;解题思路 首先，递推关系从最大变成了最小，即dp[j] = min(dp[j], dp[j - coins[i]] + 1)。&#xA;同时，要注意对dp数组的初始化问题，为了保证j - coins[i]无法组成时，dp[j]选择的仍是上一次i循环的dp[j]，因此要将dp数组初始化为INT_MAX，同时dp[0] = 0。&#xA;要注意INT_MAX + 1 &amp;lt; INT_MAX(在C++中)&#xA;代码 #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } public: int coinChange(vector&amp;lt;int&amp;gt; &amp;amp;coins, int amount) { if (amount == 0) return 0; vector&amp;lt;int&amp;gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; coins.</description>
    </item>
    <item>
      <title>377.combination sum iv</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv/</guid>
      <description>Description 377.combination-sum-iv&#xA;Solution This problem is still a unbounded-knapsack-problem, however, what this problem want to get is permutations rather than combinations.&#xA;With reference to 518.coin-change-ii, traverse volume first, than traverse items.&#xA;代码 class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // prevent overflow, not dp[j] + dp[j - nums[i]] &amp;lt; INT_MAX if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>377.组合总和IV</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</guid>
      <description>问题描述 377.组合总和IV&#xA;解题思路 本题依旧是一个完全背包问题，但是本题求的是排列而非组合。&#xA;参考518.零钱兑换II，先遍历体积，再遍历物品。&#xA;代码 class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // 防止溢出 if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>518.coin change ii</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii/</guid>
      <description>Description 518.coin-change-ii&#xA;Solution This problem is still a unbounded-knapsack-problem. What this problem need to solve is combination rather than combination.&#xA;If we want to get the number of combination, we should traverse items first, than traverse volume. But if you want to get the number of permutation, you should traverse volume first, than traverse items.&#xA;For example, assume that nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2, combnations: {1, 1, 1}, {1, 2}.</description>
    </item>
    <item>
      <title>518.零钱兑换II</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</guid>
      <description>问题描述 518.零钱兑换II&#xA;解题思路 本题依旧是一个完全背包问题，但是本题求的是组合而非排列。&#xA;求组合时，先遍历物品，再遍历体积；求排列时，则是先遍历体积，再遍历物品。&#xA;例如：假设nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2，选择组合方式为{1, 1, 1}, {1, 2}。&#xA;dp[0] = 1; for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; 2; i++) { if (j &amp;gt;= nums[i]) dp[j] = dp[j] + dp[j - nums[i]]; } } dp[3] = 3，选择的排列方式为{1, 1, 1}, {1, 2}, {2, 1}。</description>
    </item>
    <item>
      <title>474.ones and zeroes</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes/</link>
      <pubDate>Wed, 05 Oct 2022 00:34:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes/</guid>
      <description>Description 474.ones-and-zeroes&#xA;Solution This problem can be viewed as a two-dimensional 01-knapsack-problem. There are two-dimensional limits about &amp;ldquo;volume&amp;rdquo;: numbers of $0$ can not exceed $m$ and numbers of $1$ can not exceed $n$.&#xA;Recursive relation: dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ?</description>
    </item>
    <item>
      <title>474.一和零</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:37:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</guid>
      <description>问题描述 474.一和零&#xA;解题思路 本题可以看成一个二维的01背包问题，体积存在两个维度的限制，即$0$的个数不能超过$m$，$1$的个数不超过$n$。&#xA;递推关系:dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;代码 #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: int findMaxForm(vector&amp;lt;string&amp;gt; &amp;amp;strs, int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; str_num(strs.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); for (int i = 0; i &amp;lt; strs.size(); i++) { for (int j = 0; j &amp;lt; strs[i].</description>
    </item>
    <item>
      <title>494.target sum</title>
      <link>http://localhost:1313/posts/leet/494.target-sum/</link>
      <pubDate>Tue, 04 Oct 2022 04:22:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum/</guid>
      <description>Description 494.target-sum&#xA;Solution Actually, what we need to do is choose some numbers whose sum is $\max((sum + target) / 2, (sum - target) / 2)$ in this array. So we can change this problem to a 01-knapsack-problem, and dynamic programming can be used to solve this problem. Also, backtracking can be used to solve this problem.&#xA;In this problem, dp[i][j] should denotes the number of methods to make the sum of number selected to be j when considering the first i numbers.</description>
    </item>
    <item>
      <title>494.目标和</title>
      <link>http://localhost:1313/posts/leet/494.target-sum.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:09:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum.zh/</guid>
      <description>问题描述 494.目标和&#xA;解题思路 本题表面上说添加&amp;rsquo;+&amp;lsquo;或者&amp;rsquo;-&amp;rsquo;，实际上就是在这个数组中选择一些数，使这些数的总和为$\max((sum + target) / 2, (sum - target) / 2)$。从而转换成01背包问题，利用动态规划求解，当然也可以利用回溯法求解。&#xA;在本题中，dp[i][j]应该表示为考虑前i个数时，使选择的数总和为j的方法数。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int findTargetSumWays(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int sum = 0; vector&amp;lt;int&amp;gt; my_num(nums.size() + 1, 0); for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; my_num[i + 1] = nums[i]; } if ((sum + target) % 2 == 1) return 0; vector&amp;lt;int&amp;gt; res(1001, 0); res[0] = 1; target = max((sum + target) / 2, (sum - target) / 2); // int cnt = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>unbounded knapsack problem</title>
      <link>http://localhost:1313/posts/tech/unbounded-knapsack-problem/</link>
      <pubDate>Tue, 04 Oct 2022 01:33:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/unbounded-knapsack-problem/</guid>
      <description>Description Unbounded Knapsack Problem&#xA;There are $N$ kinds of items and a knapsack with the capacity of $V$, each item has unlimited pieces available.&#xA;The volume of the $i$-th item is $v_i$, and value is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen&amp;rsquo;t exceed the capacity of the pack.&#xA;Solution It&amp;rsquo;s a classic problem of dynamic programming and knapsack problem.</description>
    </item>
    <item>
      <title>完全背包问题</title>
      <link>http://localhost:1313/posts/tech/unbounded-knapsack-problem.zh/</link>
      <pubDate>Mon, 03 Oct 2022 13:50:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/unbounded-knapsack-problem.zh/</guid>
      <description>问题描述 完全背包问题&#xA;有$N$件物品和一个容量是$V$的背包，每件物品都有无限件可用。&#xA;第$i$种物品的体积是$v_i$，价值是$w_i$。求解将哪些物品装入背包，可使这些物品总体积不超过背包容量，且总价值最大。&#xA;解题思路 内层嵌套循环 01背包问题 每样物品只能使用一件，而针对完全背包问题，我们只需要在内层有关体积的循环中，再添加一层循环，枚举一共使用了多少件物品$i$即可。&#xA;for (int i = 1; i &amp;lt;= n; i++) { for (int j = m; j &amp;gt;= v[i]; j--) { for (k = 1; k * v[i] &amp;lt;= j; k++) { dp[j] = max(dp[j], dp[j - k * v[i] + k * w[i]); } } } 更改遍历方向 在01背包问题中，我们内层关于体积的循环，是从大到小的，这是为了保证在比较max(dp[j], dp[j - v[i]] + w[i])时，使用的是上一次i循环的数值；&#xA;而在完全背包问题中，内层关于体积的循环，修改成从小到大即可，此时dp = max(dp[j], dp[j - v[i]] + w[i])中，dp[j - v[i]] + w[i]使用的就是本次i循环中的数值，而i循环中,dp[j - v[i]] = max(dp[j - v[i]], dp[(j - v[i]) - v[i]] + w[i]),依次往前递推，总能找到那个最大值dp[j - k * v[i]] + k * w[i]。</description>
    </item>
    <item>
      <title>1049.last stone weight ii</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</link>
      <pubDate>Sat, 01 Oct 2022 19:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</guid>
      <description>Description 1049.last-stone-weight-ii&#xA;Solution In reality, it&amp;rsquo;s still a 01-pack-problem.&#xA;What it want to get is when you divide the array into two part with least difference of their sum, what the difference is. If you are aware of this, just write code similar to 416.partition-equal-subset-sum.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.</description>
    </item>
    <item>
      <title>1049.最后一块石头的重量II</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:22:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</guid>
      <description>问题描述 1049.最后一块石头的重量II&#xA;解题思路 实际上还是一个01背包问题。本质上是在求将数组分成差值最小的两部分之后，这两部分的差值，理解了这一点之后，参照416.分割等和子集写代码就好了。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.size(); i++) { sum += stones[i]; } vector&amp;lt;int&amp;gt; dp(sum / 2 + 1, 0); for (int i = 0; i &amp;lt; stones.size(); i++) { for (int j = sum / 2; j &amp;gt;= stones[i]; j--) dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); } return sum - 2 * dp[sum / 2]; } }; </description>
    </item>
    <item>
      <title>416.分割等和子集</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</guid>
      <description>问题描述 416.分割等和子集&#xA;解题思路 本题实际上是一个01背包问题，在这个问题中，背包的体积$V$是数组中所有数的的和的一半(向下取整)，物品的价值就是数组中数的取值：&#xA;代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; } if (sum % 2 == 1) return false; sum_half = sum / 2; vector&amp;lt;int&amp;gt; dp(sum_half + 1, 0); for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>416.partition equal subset sum</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</guid>
      <description>Description 416.partition-equal-subset-sum&#xA;Solution This problem can be viewed as one case of 01-pack-problem&#xA;In this problem, the volume of pack $V$ is half of sum of all integers in the array(rounded down), the value of item is just value of integer in the array.&#xA;Code #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>01背包问题</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem.zh/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem.zh/</guid>
      <description>问题描述 01背包问题 有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。&#xA;第$i$件物品的体积是$v_i$，价值是$w_i$，求解将哪些物品装入背包，可使这些物品总体积不超过背包容量，并且总价值最大。&#xA;解题思路 动态规划的经典例题，首先考虑dp[i][j]的含义，这里i表示只考虑前i个物品(i从$1\sim N$)，dp[i][j]表示总体积为j的情况下，考虑前i个物品时，背包里的物品的最大价值。&#xA;可以分成两种情况考虑dp[i][j]的递推关系：&#xA;第i个物品不在背包中时，dp[i][j] = dp[i - 1][j] 此时只有前i - 1个物品，背包中物品体积仍为j。 第i个物品在背包中时，dp[i][j] = dp[i - 1][j - v[i]] + w[i] 前i - 1个物品的体积为j - v[i]。 初始化，显然dp[0][0] = 0。&#xA;根据递推关系和初始化条件写for循环遍历即可。&#xA;代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; const int N = 1010; // 体积不超过1000， 物品件数也不超过1000 int main() { int n, m; // n为物品数量，m为背包体积 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int dp[N][N] = {0}; int v[N] = {0}; // 体积 int w[N] = {0}; // 价值 for (int i = 1; i &amp;lt;=n; i++) cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i]; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { dp[i][j] = dp[i - 1][j]; if (j &amp;gt;= v[i]) // 当前总体积肯定不能小于v[i]，如果小于的话，第i个物品不能放 dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } // int res = 0; // for (int j = 1; j &amp;lt;=m; j++) { // res = max(res, dp[n][j]); // 不需要遍历，直接输出dp[n][m]即可 // } cout &amp;lt;&amp;lt; dp[n][m] &amp;lt;&amp;lt; endl; return 0; } 优化 分析上面的代码，实际上dp[i][j]递推时只会用到dp[i - 1][j]，而不会用到dp[i - 2][j], dp[i - 3][j]等，因此dp数组实际上只需要一维即可，索引为当前总体积。</description>
    </item>
    <item>
      <title>01 kanpsack problem</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem/</guid>
      <description>Description 01-pack-problem&#xA;There are $N$ items and a pack with capacity of $V$, and each item can only be used once.&#xA;The volume of the $i$-th item is $v_i$, and vaule is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen&amp;rsquo;t exceed the capacity of the pack.&#xA;Solution It&amp;rsquo;s a classic problem of dynamic programming.</description>
    </item>
    <item>
      <title>Dynamic Programming</title>
      <link>http://localhost:1313/posts/tech/dynamic-programming/</link>
      <pubDate>Thu, 29 Sep 2022 16:25:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dynamic-programming/</guid>
      <description>Description Usually, One-dimensional dynamic planning problem, the parameter is always $n$, the result is similar to number sequence $a_n$, or $f(n)$($f$ can be viewed as function or corresponding relationship). At the same time, there will be certain corresponding relationship between $a_n$ and $a_{n - 1}, a_{n - 2}&amp;hellip;a_{1}$, such as $a_n = a_{n-1} + a_{n-2}$(fibonacci sequence).&#xA;Solution Number sequence can be corresponded with array in programming language such as C++. If you find the recursive relationship among number sequence, you can write traversal code using for loop to get the answer.</description>
    </item>
    <item>
      <title>746.min cost climbing stairs</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 16:13:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</guid>
      <description>Description 746.min-cost-climbing-stairs&#xA;Solution It&amp;rsquo;s like 70.climbing-stairs plus, the recursive relationship becomes more complicated, but the essence is the same.&#xA;$$dp_n = \min[dp_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2]]$$&#xA;After get the recursive relationship, we can write traversal code to get the answer using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ?</description>
    </item>
    <item>
      <title>509.fibonacci number</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number/</link>
      <pubDate>Thu, 29 Sep 2022 16:10:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number/</guid>
      <description>Description 509.fibonacci number&#xA;Solution $a_n = a_{n - 1} + a_{n - 2}$.&#xA;Based on the recursive relationship, we can easily write traversal code using for loop.&#xA;Code class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>343.integer break</title>
      <link>http://localhost:1313/posts/leet/343.integer-break/</link>
      <pubDate>Thu, 29 Sep 2022 16:05:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break/</guid>
      <description>Description 343.integer-break&#xA;Solution The key point is still find the recursive relationship.&#xA;Notice that when $n &amp;gt; 4$, $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$.&#xA;So we can easily write traversal code using for loop.&#xA;Code class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>70.climbing stairs</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 15:55:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs/</guid>
      <description>Description 70.climbing-stairs&#xA;Solution Actually, it&amp;rsquo;s the same with 509.fibonacci-number. Let $dp_n$ be the number of ways to get to the top, then we have: $$dp_n = dp_{n - 1} + dp_{n - 2}$$ So we can write the traversal code of for loop.&#xA;Code class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>63.unique paths ii</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii/</link>
      <pubDate>Thu, 29 Sep 2022 15:39:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii/</guid>
      <description>Description 63.unique-paths-ii&#xA;Solution Compared with 62.unique-paths, the main difference is that you need to change $dp_{mn}$ when hitting an obstacle(obstacleGrid[i][j] = 0). Just set dp[i][j] = 0.&#xA;And you need pay attention to judging the conditionality in for loop.&#xA;When i = 0 or j = 0, dp[i][j] = dp[i][j - 1] or dp[i][j] = dp[i - 1][j]. dp[0][0] = 0.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.</description>
    </item>
    <item>
      <title>62.unique paths</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths/</link>
      <pubDate>Thu, 29 Sep 2022 15:28:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths/</guid>
      <description>Description 62.unique-paths&#xA;Solution $dp_{mn}$ means the number of paths from (1, 1) to (m, n). Just find the connection among $dp_{mn}, dp_{(m-1)n}, dp_{m(n-1)}$.&#xA;We have: $$dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$$ Based on the relationship, we can write the traversal code using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>343.整数拆分</title>
      <link>http://localhost:1313/posts/leet/343.integer-break.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:59:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break.zh/</guid>
      <description>题目描述 343.整数拆分&#xA;解题思路 还是寻找递推关系,设$dp_n$为正整数$n$所求的最大乘积。 这里可以注意到:$n &amp;gt; 4$时， $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$。 根据递推关系写出for循环递推求解。&#xA;代码 class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>63.不同路径II</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:55:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</guid>
      <description>题目描述 63.不同路径II&#xA;解题思路 相比62.不同路径II， 主要是多了障碍物地判断，设$obstacleGrid[i][j] = 0$，则$dp_{{i}{j}} = 0$，其余递推关系相同。 注意for循环遍历地过程中的条件判断。当i = 0或j = 0，dp[i][j] = dp[i][j - 1]或dp[i][j] = dp[i - 1][j]。 dp[0][0] = 0。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m, vector&amp;lt;int&amp;gt;(n, 0)); dp[0][0] = 1; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (i == 0 &amp;amp;&amp;amp; j == 0) { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = 1; } else { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else { if (i == 0) dp[i][j] = dp[i][j - 1]; else if (j == 0) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } } return dp[m - 1][n - 1]; } }; </description>
    </item>
    <item>
      <title>62.不同路径</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:51:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths.zh/</guid>
      <description>问题描述 62.不同路径&#xA;解题思路 还是找递推关系： $dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>746.使用最小花费爬楼梯</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:36:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</guid>
      <description>题目描述 746.使用最小花费爬楼梯&#xA;解题思路 相当于爬楼梯的进阶版，递推关系变复杂了一些，但本质没有变。 $a_n = min(a_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2])$ 写出递推关系后就能很方便地写出for循环来遍历求解。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ? cost[0] : cost[1]; for (int i = 2; i &amp;lt;= sz; i++) { // 原始版本 // dp[i] = (dp[i - 2] + cost[i - 2]) &amp;lt; (dp[i - 1] + cost[i - 1]) ?</description>
    </item>
    <item>
      <title>70.爬楼梯</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:56:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</guid>
      <description>题目描述 70.爬楼梯&#xA;解题思路 本质上与斐波那契数是一样的：$a_n = a_{n - 1} + a_{n - 2}$ 构建for循环来遍历。&#xA;代码 class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>509.斐波那契数</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:52:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</guid>
      <description>题目描述 509.斐波那契数&#xA;解题思路 $a_n = a_{n-1} + a_{n-2}$，利用这一递推关系构建for循环即可，实际上只需要容量为2的数组。&#xA;代码 class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>一维动态规划-基础版</title>
      <link>http://localhost:1313/posts/tech/dynamic-programming.zh/</link>
      <pubDate>Wed, 28 Sep 2022 19:23:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dynamic-programming.zh/</guid>
      <description>问题描述 一般来说，一维动态规划的问题，其输入的参数一般是$n$，而所求结果有点像数列$a_n$，或者说$f(n)$($f$可以认为是函数或者说对应关系)，同时$a_n$与之前的$a_{n-1},a_{n-2},&amp;hellip;a_{1}$有一个确定的对应的关系，例如$a_n = a_{n-1} + a_{n-2}$(斐波那契数列)&#xA;解题步骤 数列即可与编程语言中的数组对应起来，在找到数列之间的迭代关系时，即可编写for循环来求解。&#xA;例题 509.斐波那契数 509.斐波那契数-题解 70.爬楼梯 70.爬楼梯-题解 746.使用最小花费爬楼梯 746.使用最小花费爬楼梯-题解 343.整数拆分 343.整数拆分-题解 62.不同路径 62.不同路径-题解 63.不同路径II 63.不同路径II-题解 </description>
    </item>
    <item>
      <title>37.sudoku Solver 解数独</title>
      <link>http://localhost:1313/posts/leet/37.sudoku-solver.zh/</link>
      <pubDate>Mon, 26 Sep 2022 15:03:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/37.sudoku-solver.zh/</guid>
      <description>题目描述 链接：37.Sodoku Solver&#xA;解题思路 相比一般的回溯，需要两层for循环，一个处理行，一个处理列，递归的过程来决定，空格处到底填哪个数字； 本递归函数用bool作为返回值类型，要注意返回值在递归中的作用； 另外还有一个判断board是否合规的函数。&#xA;代码 class Solution { private: bool isValid(int row, int col, char val, vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // 判断行里是否重复 if (board[row][i] == val) { return false; } } for (int j = 0; j &amp;lt; 9; j++) { // 判断列里是否重复 if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i &amp;lt; startRow + 3; i++) { // 判断9方格里是否重复 for (int j = startCol; j &amp;lt; startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // 逐行 for (int j = 0; j &amp;lt; 9; j++) { // 逐列 if (board[i][j] !</description>
    </item>
    <item>
      <title>37.解数独</title>
      <link>http://localhost:1313/posts/leet/37.sudoku-solver/</link>
      <pubDate>Mon, 26 Sep 2022 15:03:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/37.sudoku-solver/</guid>
      <description>Description 链接：37.Sodoku Solver&#xA;Solution Compared with usual backtracking, we need for loop of two layers, one for row and another for column. A recursive process is used to determine exactly which number to fill in the space.&#xA;This return type of this function is bool, please pay attention to the role of return value in recursion.&#xA;Also a function to determine whether board is legal is required.&#xA;Code class Solution { private: bool isValid(int row, int col, char val, vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // judge whether there are duplicates in a row if (board[row][i] == val) { return false; } } for (int j = 0; j &amp;lt; 9; j++) { // judge whether there are duplicates in a column if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; // judge whether there are duplicates in ninepin for (int i = startRow; i &amp;lt; startRow + 3; i++) { for (int j = startCol; j &amp;lt; startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // traverse in row for (int j = 0; j &amp;lt; 9; j++) { // traverse in column if (board[i][j] !</description>
    </item>
    <item>
      <title>47.permutations-ii</title>
      <link>http://localhost:1313/posts/leet/47.permutations-ii/</link>
      <pubDate>Sun, 25 Sep 2022 22:05:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/47.permutations-ii/</guid>
      <description>Description 47.permutations-ii&#xA;Solution Compared with 47.permutations, there is interference from duplicate numbers. So we should de-duplicate such as combination-sum-ii&#xA;Judge whether nums[i] is in path by if (used[i] == 1), de-duplicate by if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0).&#xA;Attention: we should sort the array first.&#xA;Code #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; using std::vector; class Solution { private: vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int used[8] = {0}; void track_back(vector&amp;lt;int&amp;gt; nums, int index) { if (path.</description>
    </item>
    <item>
      <title>47.permutations-ii 全排列II</title>
      <link>http://localhost:1313/posts/leet/47.permutations-ii.zh/</link>
      <pubDate>Sun, 25 Sep 2022 22:05:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/47.permutations-ii.zh/</guid>
      <description>问题描述 47.全排列II&#xA;解题思路 相比全排列，多了重复数字的干扰，可以参照带重复数字的组合问题来进行去重:&#xA;if (used[i] == 1)判断nums[i]是否已经在path中，if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0)来进行去重。&#xA;注意，要先对目标数组排序。&#xA;代码 #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; using std::vector; class Solution { private: vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int used[8] = {0}; void track_back(vector&amp;lt;int&amp;gt; nums, int index) { if (path.size() &amp;gt;= nums.size()) { res.push_back(path); return; } for (int i = 0; i &amp;lt; nums.size(); i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0) continue; if (used[i] == 1) continue; path.</description>
    </item>
    <item>
      <title>51.n Queens</title>
      <link>http://localhost:1313/posts/leet/51.n-queens/</link>
      <pubDate>Sun, 25 Sep 2022 21:42:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/51.n-queens/</guid>
      <description>Description 51.n-queens&#xA;Solution Backtracking, please pay attention to how to judge whether chess is in the same diagonal.&#xA;Code class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = &amp;#34;.........&amp;#34;; vector&amp;lt;string&amp;gt; row_str; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; void track_back(int n, int index) { if (index &amp;gt;= n) { res.</description>
    </item>
    <item>
      <title>51.n皇后</title>
      <link>http://localhost:1313/posts/leet/51.n-queens.zh/</link>
      <pubDate>Sun, 25 Sep 2022 21:42:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/51.n-queens.zh/</guid>
      <description>问题描述 51.n皇后&#xA;解题思路 典型的回溯，注意如何判断棋子在同一斜线上。&#xA;代码 class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = &amp;#34;.........&amp;#34;; vector&amp;lt;string&amp;gt; row_str; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; void track_back(int n, int index) { if (index &amp;gt;= n) { res.push_back(row_str); return; } for (int i = 0; i &amp;lt; n; i++) { // i表示在第几列，index表示在第几行 if (col_arr[i] !</description>
    </item>
  </channel>
</rss>
