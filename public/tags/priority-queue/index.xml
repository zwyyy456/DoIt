<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Priority Queue on My New Hugo Site</title>
    <link>http://localhost:1313/tags/priority-queue/</link>
    <description>Recent content in Priority Queue on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Jul 2023 22:19:24 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/priority-queue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1851. Minimum Interval to Include Each Query (Hard)</title>
      <link>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query/</link>
      <pubDate>Tue, 18 Jul 2023 22:19:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query/</guid>
      <description>Description 1851. Minimum Interval to Include Each Query (Hard)&#xA;Solution First, it should be noted that sorting the intervals array will not affect the result. Secondly, sorting the queries array will not have a significant impact on the answer. It merely changes the order of the answers. We just need to associate the result of each query with its corresponding index in the original queries array.&#xA;For convenience, let&amp;rsquo;s convert the queries array into a vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; qrs; where the first element represents the value to be queried, and the second element represents its index in the queries array.</description>
    </item>
    <item>
      <title>1851. 包含每个查询的最小区间 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query.zh/</link>
      <pubDate>Tue, 18 Jul 2023 22:19:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query.zh/</guid>
      <description>问题描述 [1851. 包含每个查询的最小区间] (Hard)&#xA;给你一个二维整数数组 intervals ，其中 intervals[i] = [leftᵢ, rightᵢ] 表示第 i 个区间开始于 le ftᵢ 、结束于 rightᵢ（包含两侧取值， 闭区间）。区间的 长度 定义为区间中包含的整数数目，更 正式地表达是 rightᵢ - leftᵢ + 1 。&#xA;再给你一个整数数组 queries 。第 j 个查询的答案是满足 leftᵢ &amp;lt;= queries[j] &amp;lt;= rightᵢ 的 长度最 小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。&#xA;以数组形式返回对应查询的所有答案。&#xA;示例 1：&#xA;输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] 输出：[3,3,1,4] 解释：查询处理如下： - Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。 - Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。 示例 2：</description>
    </item>
    <item>
      <title>373. 查找和最小的 K 对数字 (Medium)</title>
      <link>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums.zh/</link>
      <pubDate>Sat, 06 May 2023 16:28:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums.zh/</guid>
      <description>问题描述 373. 查找和最小的 K 对数字 (Medium) 给定两个以 升序排列 的整数数组 nums1 和 nums2, 以及 一个整数 k。&#xA;定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来 自 nums2。&#xA;请找到和最小的 k 个数对 (u₁,v₁), (u₂,v₂) &amp;hellip; (uₖ,v ₖ) 。&#xA;示例 1:&#xA;输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 输出: [1,2],[1,4],[1,6] 解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6 ] 示例 2:&#xA;输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 输出: [1,1],[1,1] 解释: 返回序列中的前 2 对数： [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] 示例 3:</description>
    </item>
    <item>
      <title>373. Find K Pairs with Smallest Sums (Medium)</title>
      <link>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums/</link>
      <pubDate>Sat, 06 May 2023 16:28:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums/</guid>
      <description>Description 373. Find K Pairs with Smallest Sums (Medium) You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.&#xA;Define a pair (u, v) which consists of one element from the first array and one element from the second array.&#xA;Return the kpairs (u₁, v₁), (u₂, v₂), ..., (uₖ, vₖ)with the smallest sums.&#xA;Example 1:&#xA;Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2:</description>
    </item>
    <item>
      <title>743. Network Delay Time (Medium)</title>
      <link>http://localhost:1313/posts/leet/743.network-delay-time/</link>
      <pubDate>Sun, 12 Mar 2023 14:23:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/743.network-delay-time/</guid>
      <description>743. Network Delay Time (Medium)&#xA;You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (uᵢ, vᵢ, wᵢ), where uᵢ is the source node, vᵢ is the target node, and wᵢ is the time it takes for a signal to travel from source to target.&#xA;We will send a signal from a given node k.</description>
    </item>
    <item>
      <title>743. 网络延迟时间 (Medium)</title>
      <link>http://localhost:1313/posts/leet/743.network-delay-time.zh/</link>
      <pubDate>Sun, 12 Mar 2023 14:23:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/743.network-delay-time.zh/</guid>
      <description>问题描述 743. 网络延迟时间 (Medium)&#xA;有 n 个网络节点，标记为 1 到 n。&#xA;给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (uᵢ, vᵢ, wᵢ)，其中 uᵢ 是源节点， vᵢ 是目标节点， wᵢ 是一个信号从源节点传递到目标节点的时间。&#xA;现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。&#xA;示例 1：&#xA;输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 输出：2 示例 2：&#xA;输入：times = [[1,2,1]], n = 2, k = 1 输出：1 示例 3：&#xA;输入：times = [[1,2,1]], n = 2, k = 2 输出：-1 提示：&#xA;1 &amp;lt;= k &amp;lt;= n &amp;lt;= 100 1 &amp;lt;= times.</description>
    </item>
    <item>
      <title>1405.longest happy string</title>
      <link>http://localhost:1313/posts/leet/1405.longest-happy-string/</link>
      <pubDate>Wed, 01 Mar 2023 19:29:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1405.longest-happy-string/</guid>
      <description>Description 1405. Longest Happy String (Medium)&#xA;A string s is called happy if it satisfies the following conditions:&#xA;s only contains the letters &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;. s does not contain any of &amp;quot;aaa&amp;quot;, &amp;quot;bbb&amp;quot;, or &amp;quot;ccc&amp;quot; as a substring. s contains at most a occurrences of the letter &#39;a&#39;. s contains at most b occurrences of the letter &#39;b&#39;. s contains at most c occurrences of the letter &#39;c&#39;. Given three integers a, b, and c, return the longest possible happy string.</description>
    </item>
    <item>
      <title>1405.最长快乐字符串</title>
      <link>http://localhost:1313/posts/leet/1405.longest-happy-string.zh/</link>
      <pubDate>Wed, 01 Mar 2023 19:29:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1405.longest-happy-string.zh/</guid>
      <description>问题描述 1405. 最长快乐字符串 (Medium)&#xA;如果字符串中不含有任何 &#39;aaa&#39;， &#39;bbb&#39; 或 &#39;ccc&#39; 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。&#xA;给你三个整数 a， b ， c，请你返回 任意一个 满足下列全部条件的字符串 s：&#xA;s 是一个尽可能长的快乐字符串。 s 中 最多 有 a 个字母 &#39;a&#39;、 b 个字母 &#39;b&#39;、 c 个字母 &#39;c&#39; 。 s 中只含有 &#39;a&#39;、 &#39;b&#39; 、 &#39;c&#39; 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串 &amp;quot;&amp;quot;。&#xA;示例 1：&#xA;输入：a = 1, b = 1, c = 7 输出：&amp;#34;ccaccbcc&amp;#34; 解释：&amp;#34;ccbccacc&amp;#34; 也是一种正确答案。 示例 2：&#xA;输入：a = 2, b = 2, c = 1 输出：&amp;#34;aabbc&amp;#34; 示例 3：</description>
    </item>
    <item>
      <title>1792.maximum average pass ratio</title>
      <link>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio/</link>
      <pubDate>Mon, 20 Feb 2023 14:14:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio/</guid>
      <description>Description 1792. Maximum Average Pass Ratio (Medium)&#xA;There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passᵢ, totalᵢ]. You know beforehand that in the ith class, there are totalᵢ total students, but only passᵢ number of students will pass the exam.&#xA;You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to.</description>
    </item>
    <item>
      <title>1792.最大平均通过率</title>
      <link>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio.zh/</link>
      <pubDate>Mon, 20 Feb 2023 14:14:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio.zh/</guid>
      <description>问题描述 1792. 最大平均通过率 (Medium)&#xA;一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passᵢ, totalᵢ] ，表示你提前知道了第 i 个班级总共有 totalᵢ 个学生，其中只有 passᵢ 个学生可以通过考试。&#xA;给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。&#xA;一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。 平均通过率 是所有班级的通过率之和除以班级数目。&#xA;请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-⁵ 以内的结果都会视为正确结果。&#xA;示例 1：&#xA;输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2 输出：0.78333 解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。 示例 2：&#xA;输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4 输出：0.</description>
    </item>
    <item>
      <title>1833.maximum Ice Cream Bars</title>
      <link>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars/</link>
      <pubDate>Mon, 20 Feb 2023 10:14:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars/</guid>
      <description>Description 1833. Maximum Ice Cream Bars (Medium)&#xA;It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.</description>
    </item>
    <item>
      <title>1833.雪糕的最大数量</title>
      <link>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars.zh/</link>
      <pubDate>Mon, 20 Feb 2023 10:14:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars.zh/</guid>
      <description>问题描述 1833. 雪糕的最大数量 (Medium)&#xA;夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。&#xA;商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。&#xA;注意： Tony 可以按任意顺序购买雪糕。&#xA;给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。&#xA;示例 1：&#xA;输入：costs = [1,3,2,4,1], coins = 7 输出：4 解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7 示例 2：&#xA;输入：costs = [10,6,8,7,7,8], coins = 5 输出：0 解释：Tony 没有足够的钱买任何一支雪糕。 示例 3：</description>
    </item>
    <item>
      <title>1705.maximum number of eaten apples</title>
      <link>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples/</link>
      <pubDate>Wed, 15 Feb 2023 15:59:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples/</guid>
      <description>Description 1705.maximum-number-of-eaten-apples&#xA;Solution The optimal strategy is to eat the apple that rots first, we can use the priority queue to simulate the process.&#xA;app_decay[i][0] indicates the expected decay time of the apples born on day i, and app_decay[i][1] indicates how many apples were born on day i.&#xA;The top() of the priority queue pq must be a vector with the minimum vec[0].&#xA;We traverse the array by time, if there are apples born on this day, we push app_decay[i] to pq, and pop the elements of the top() of pq until the heap is empty or pq.</description>
    </item>
    <item>
      <title>1705.吃苹果的最大数目</title>
      <link>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples.zh/</link>
      <pubDate>Wed, 15 Feb 2023 15:59:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples.zh/</guid>
      <description>问题描述 1705.吃苹果的最大数目 中等&#xA;There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0.</description>
    </item>
    <item>
      <title>871.minimum number of refueling stops</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</guid>
      <description>Description 871.minimum-number-of-refueling-stops&#xA;Solution Dynamic programming In this problem, the number is finite, and there is a recurrence relation, so we can use dynamic programming to solve this problem.&#xA;Let dp[i][j] means the furthest distance we can reach after passing throught i stations and adding fuel for j times. Obviously, i &amp;gt;= j.&#xA;So we can discuss dp[i][j] in two cases:&#xA;We don&amp;rsquo;t add fuel at the ith station: dp[i][j] = dp[i - 1][j] We add fuel in the ith station(We have to arrive at the ith station in the case we have just added fuel for j - 1 times before, that is: dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]): dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1].</description>
    </item>
    <item>
      <title>871.最低加油次数</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</guid>
      <description>问题描述 871.最低加油次数&#xA;解题思路 动态规划 对于这种有限次数，能看出来有递推关系的，可以考虑动态规划。&#xA;这里状态记为dp[i][j]，表示经过前i个加油站，加j次油之后，能够到达的最远距离，这里显然有i &amp;gt;= j。&#xA;那么考虑dp[i][j]的递推关系，可以分在第i个加油站加油和不加油两种情况来讨论：&#xA;在第i个加油站不加油：dp[i][j] = dp[i - 1][j] 在第i个加油站加油（要求第i个加油站可以在之前只加了j - 1次油的情况下到达），即dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]，此时dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1] dp[i][j]取两者中的最大值&#xA;贪心 首先，很容易想到，最佳策略每次加油，都是在油最多的加油站去加油，这里实际上可以认为能直接从经过的加油站中取油，即每次发现到达不了下一个加油站或者终点了，就从已经经过但是没加过油的加油站里加油，直到可以到达下一个加油站或者终点，可以利用优先队列来模拟这个过程，每次需要更新剩余的燃油cur_fuel。&#xA;代码 动态规划 class Solution { public: int minRefuelStops(int target, int startFuel, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;stations) { int n = stations.size(); if (n == 0) { if (startFuel &amp;gt;= target) return 0; return -1; } vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; dp(n + 1, vector&amp;lt;long long&amp;gt;(n + 1, 0)); dp[0][0] = startFuel; for (int i = 1; i &amp;lt;= n; i++) { dp[i][0] = stations[i - 1][0] &amp;lt;= startFuel ?</description>
    </item>
  </channel>
</rss>
