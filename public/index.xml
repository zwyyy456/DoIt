<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 Aug 2024 23:22:48 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RHEL 7 个人开发环境部署</title>
      <link>http://localhost:1313/posts/blog/rhel7-dev-env-deploy.zh/</link>
      <pubDate>Wed, 21 Aug 2024 23:22:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/rhel7-dev-env-deploy.zh/</guid>
      <description>前言 入职了某公司，福利待遇不错，就是这开发环境属实一言难尽，开发机部署在内网，没有网络，只能通过内外网交换软件传文件，没有 root 权限（暂无，后面拿到 root 权限我也不敢用来安装什么软件），开发机的系统版本还特别旧，是 2014 年发布的 RHEL 7，上面的软件版本也是老掉牙了（除了没人用的 cmake），令人无语。故这里记录一下我克服困难，在这个 RHEL 7 上配置开发环境的步骤。&#xA;注，考虑到安全问题，以及权限受限，软件都安装在 $HOME/.local 目录下，然后设置对应的环境变量，其中 bash 不会去设置环境变量。&#xA;整体部署思路如下，利用自己的 VPS 开了一个 CentOS 7 的 docker 镜像，并创建一个与开发机上本人用户一致的用户，并使其 $HOME 目录与开发机的一致，在 CentOS 7 上，通过源码编译安装到 $HOME/.local 目录下，然后将 $HOME/.local 目录拷贝到开发机上，再配置好对应的环境变量，如果再不行，再考虑把源码以及依赖的源码拷贝到开发机上，再进行编译安装。&#xA;可以通过执行 ldd ${binary_name} 来查看运行该程序需要哪些动态链接库。&#xA;软件安装 GCC 执行以下命令即可安装 GCC：&#xA;mkdir src # 安装依赖库 GMP cd $HOME/src wget https://gmplib.org/download/gmp/gmp-6.2.1.tar.xz tar -xvf gmp-6.2.1.tar.xz cd gmp-6.2.1 ./configure --prefix=$HOME/.local make -j$(nproc) make install # 安装依赖库 MPFR cd $HOME/src wget https://www.</description>
    </item>
    <item>
      <title>基于 Hugo 搭建个人博客</title>
      <link>http://localhost:1313/posts/blog/build-site-with-papermod.zh/</link>
      <pubDate>Sun, 11 Aug 2024 09:51:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/build-site-with-papermod.zh/</guid>
      <description>简介与安装 Hugo 是一个用 Go 编写的静态网站生成器，可以轻松生成个人博客。&#xA;Hugo 安装起来也非常方便，以下是 Hugo 的安装命令：&#xA;brew install hugo # mac sudo apt install hugo # Debian scoop install hugo # windows Windows 推荐使用 scoop 包管理器，非常好用&#xA;安装好 Hugo 后，执行 hugo new site blog 就会在当前目录下创建名为 blog 的目录，Hugo 后续将基于该目录中的内容来创建网站。&#xA;主题配置 这里介绍了三个个人比较喜欢的 Hugo 主题的配置方案。读者可以自选其一，我是部署了三个博客网站，当然只有一个能被搜索引擎检索到。&#xA;PaperMod 安装主题 在 blog 目录下，执行以下命令：&#xA;git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 主题就被安装在了 blog/themes/PaperMod 目录下，该目录下就是 PaperMod 主题的源码。</description>
    </item>
    <item>
      <title>计算机教育缺失的一课：Git</title>
      <link>http://localhost:1313/posts/tech/missing-semester-git.zh/</link>
      <pubDate>Sun, 16 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/missing-semester-git.zh/</guid>
      <description>版本控制系统介绍 版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS 通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。&#xA;版本控制系统的事实标准是 Git。&#xA;Git 的许多操作或者说命令看起来非常奇怪，但 Git 的底层设计与思想非常优雅，因此，从 Git 的数据模型开始学习 Git，自底向上，最后再学习 Git 的接口或者说命令，会比较容易让人理解 Git 的命令以及 Git 是如何操作数据模型的。&#xA;Git 的数据模型 Git 将项目的根目录（顶层目录）中的文件夹与文件作为集合，通过这一系列集合的快照来管理项目历史记录。在 Git 的术语中，文件被称为 Blob（数据对象），即一组数据，目录则是被称为 tree。tree 的名称与另一个 tree 又或者文件相对应。&#xA;把目录视为 tree，那么子目录就是 subtree，目录下的文件就是 tree 的子节点。&#xA;一棵 tree 看起来可能是这样的：&#xA;&amp;lt;root&amp;gt; (tree) | +- foo (tree) | | | + bar.txt (blob, contents = &amp;#34;hello world&amp;#34;) | +- baz.txt (blob, contents = &amp;#34;git is wonderful&amp;#34;) Git 历史记录建模：关联快照 Git 中的 object 可以分为 blob、tree、commit 三类，每次我们执行 git commit 时，都会创建一个 commit 对象，又或者说对当前的 work directory 的 snapshot。</description>
    </item>
    <item>
      <title>计算机常用术语中英文对比</title>
      <link>http://localhost:1313/posts/tech/cs-zh-en-translation.zh/</link>
      <pubDate>Sat, 15 Jun 2024 16:19:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/cs-zh-en-translation.zh/</guid>
      <description>前言 在计算机科学中，很多专业术语或者名词的初始版本都是英文的，之后会被翻译成中文而引入国内。然而，个人看来，许多专业名词的中文翻译，看起来都非常奇怪，反而不如其原始的英文表述好理解，故本文列出笔者常见的一些计算机专业术语以及它的英文版本，以供查阅&#xA;术语列表 中文版本 英文版本 个人理解 快照 snapshot 在某个特定时刻，对系统、数据或者文件的状态进行捕捉与记录从而生成的副本，功能上类似备份 会话 session 一段时间内，用户与系统之间的交互或者连接状态 接口 interface 也许可以理解为暴露出来供用户（开发者）调用的函数？ </description>
    </item>
    <item>
      <title>计算机教育缺失的一课：命令行环境</title>
      <link>http://localhost:1313/posts/tech/missing-semester-command-line.zh/</link>
      <pubDate>Sat, 15 Jun 2024 15:18:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/missing-semester-command-line.zh/</guid>
      <description>任务控制 信号与终止进程 shell 会使用 unix 提供的信号机制来进行进程之间的通信，当一个进程接收到信号时，它会停止执行原来的任务、处理该信号、并基于该信号传递的信息来改变任务的执行，可以认为信号是一种 软件中断。&#xA;下面这个 python 程序演示了捕获 SIGINT 信号并忽略该信号，即这个程序在收到 SIGINT 信号时，不会终止程序，我们需要使用 SIGQUIT 信号来停止这个程序，可以通过 &amp;lt;C-\&amp;gt; 来发送该信号。&#xA;#!/usr/bin/env python import signal, time def handler(signum, time): print(&amp;#34;\nI got a SIGINT, but I am not stopping&amp;#34;) signal.signal(signal.SIGINT, handler) i = 0 while True: time.sleep(.1) print(&amp;#34;\r{}&amp;#34;.format(i), end=&amp;#34;&amp;#34;) i += 1 运行该程序，向该程序发送两次 SIGINT，然后发送一次 SIGQUIT，程序反应如下：&#xA;zwyyy in 🌐 d3855u in ~/missing-semester 13s ❯ python3 sig.py 28^C I got a SIGINT, but I am not stopping 53^C I got a SIGINT, but I am not stopping 63^\zsh: quit python3 sig.</description>
    </item>
    <item>
      <title>计算机教育缺失的一课：数据整理</title>
      <link>http://localhost:1313/posts/tech/missing-semester-data-organize.zh/</link>
      <pubDate>Fri, 14 Jun 2024 19:26:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/missing-semester-data-organize.zh/</guid>
      <description>前言 您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！ 这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。&#xA;在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。&#xA;例如这样一条命令 journalctl | grep -i intel，它会找到所有包含intel(不区分大小写)的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。&#xA;让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：&#xA;ssh myserver journalctl 内容太多了。现在让我们把涉及 sshd 的信息过滤出来：&#xA;ssh myserver journalctl | grep sshd 注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 grep 程序！ ssh 太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论 ssh 的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：&#xA;ssh myserver &amp;#39;journalctl | grep sshd | grep &amp;#34;Disconnected from&amp;#34;&amp;#39; | less 多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 less 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：&#xA;$ ssh myserver &amp;#39;journalctl | grep sshd | grep &amp;#34;Disconnected from&amp;#34;&amp;#39; &amp;gt; ssh.log $ less ssh.log 过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下 sed 这个非常强大的工具。&#xA;sed 是一个基于文本编辑器ed构建的&amp;quot;流编辑器&amp;quot; 。在 sed 中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 s，即替换命令，例如我们可以这样写：</description>
    </item>
    <item>
      <title>计算机教育缺失的一课：编辑器（Vim）</title>
      <link>http://localhost:1313/posts/tech/missing-semester-editor-vim.zh/</link>
      <pubDate>Fri, 14 Jun 2024 16:55:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/missing-semester-editor-vim.zh/</guid>
      <description>编辑模式 Vim 的符号说明，对于 Ctlr+v 的组合键，可能有 ^V、Ctrl-v、&amp;lt;C-v&amp;gt; 三种表达方式。&#xA;Vim 的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：&#xA;正常模式：在文件中四处移动光标进行修改 插入模式：插入文本 替换模式：替换文本 可视化模式（一般，行，块）：选中文本块 命令模式：用于执行命令 正常模式即 normal 模式，我更习惯叫 normal 模式。&#xA;Vim 的模式：&#xA;normal &amp;lt;-&amp;gt; insert replace visual command-line 在 normal 模式下，按下 v 可以进入可视（一般）模式，按下 V 则可以进入可视（行）模式，而 &amp;lt;C-v&amp;gt; 则会进入可视（方块）模式。&#xA;buffer，window，tab vim 具有多个 tab（标签），每个 tab 可以包含多个 window，每个 window 对应一个 buffer，而同一个 buffer 可能由多个 window 打开。&#xA;:q 实际上只是关闭当前窗口，假设 vim 已经没有打开的窗口了，那么才会退出 vim。&#xA;命令模式 在 normal 模式下按下 : 可以进入命令模式，这个模式下，可以打开、保存、关闭文件，以及退出 Vim。&#xA;:q 退出（关闭窗口） :w 保存（写） :wq 保存然后退出 :e {文件名} 打开要编辑的文件 :ls 显示打开的缓存 :help {标题} 打开帮助文档 :help :w 打开 :w 命令的帮助文档 :help w 打开 w 移动的帮助文档 移动光标 在 normal 模式下，可以利用移动命令在 buffer 中移动光标，在 Vim 中，移动也被称为“名词”，与编辑命令（i、o）等相对应。</description>
    </item>
    <item>
      <title>安卓电视盒子的折腾之旅</title>
      <link>http://localhost:1313/posts/blog/android-tv-box.zh/</link>
      <pubDate>Tue, 11 Jun 2024 22:39:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/android-tv-box.zh/</guid>
      <description>前言 论文写完之后，以 840 元的价格购入了投影群里群友的优派 PJD7822HDL，只能说还能凑合用吧，噪音与发热巨大，开节能模式之后勉强可以接受，标称 3200 流明，实际上亮度不超过 50% 的情况下才能有比较好的对比度，亮度拉高了之后泛白严重，白天关灯拉窗帘看，由于我房间的窗帘的遮光性一般，感觉亮度还是低了点，晚上看倒不错，自带的音响效果也很一般（从闲鱼上淘了对音箱解决了）。不过好歹也是 dmd0.65，原生的 1080P 分辨率，清晰度还是让人满意的。&#xA;不过，该投影仪并无安卓系统，为了解决影视内容问题，我就开始在闲鱼上淘电视盒子，一共考虑了以下几个设备：移动魔百盒、亚马逊火棒、以及外贸盒子。&#xA;移动魔百盒 我是在 v2ex 上看到有人 60 出 cm211-1 增强版（2+16g），于是买下了它，事实证明这玩意现在最多值 50（因为我在闲鱼上 50r 又买了一个）。&#xA;这个魔百盒的 cpu 为晶晨 S905L3，默认固件是基于老掉牙的安卓 4.4，好在可以刷的固件还是不少的，我选择的是基于 Android TV 9.0 的 slimbox 固件，还是折腾了好一番才刷入的固件。&#xA;步骤如下，首先去淘宝购买了晶晨 S905 的免拆短接 HDMI 刷机工具，将它插在盒子的 HDMI 口，打开商家提供的刷机软件 USB Burning Tool ，和以前 N1 刷机的时候用的其实是同一个软件，该软件非绿色版，安装的时候会为你安装晶晨的相关驱动，安装好之后打开该软件，通过 USB 双头线连接电脑和魔百盒，打开 USB_Burning_Tool，会检测到已连接到设备，点击 文件 -&amp;gt; 导入烧录包 来导入 img 格式的固件，烧录配置选择默认的 擦除 flash 和 擦除 bootloader 即可，就可以开始烧录了，耐心等待即可。&#xA;由于该盒子已经刷过机了，按理来说不需要短接就能直接刷，也不需要什么免拆工具，强烈怀疑之前一直检测不到设备是因为用的绿色版，没有安装驱动。&#xA;刷好机之后，可以通过 Google play store 安装 Plex，理论上就能愉快玩耍了，然而我发现一个严重的问题，那就是用 Plex 播放音轨为 ac3 或者 eac3 格式的视频，会没有声音，经查找资料，应该是因为 S905L3 这个芯片不支持解码杜比全景声，而 Plex 默认对于这两种格式的音轨是在本地客户端直接硬解的，所以播放这样的视频会没有声音，而 Plex 的 tv 端界面无法像手机端那样针对音频格式设置是否硬解，因此，只能放弃这一款魔百盒，安装好 Tvbox 与 Emby，准备拿回去给家里人用了。</description>
    </item>
    <item>
      <title>VSCode 工作空间（Workspace）指北</title>
      <link>http://localhost:1313/posts/blog/vscode-workspace.zh/</link>
      <pubDate>Sat, 25 May 2024 10:33:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/vscode-workspace.zh/</guid>
      <description>为什么要用工作区 VSCode 作为一个轻量的编辑器，对比 IDE 很多功能并非集成。如果想打造成一个 IDE，那么就需要安装很多扩展，然而扩展越多，管理起来也越发困难，VSCode 也就越发“笨重”，例如，当我进行 cpp 开发的时候，python 与 go 的相关插件就不需要了，然而其默认也是开启的，我们当然可以手动关闭，有需要的时候再打开。然而，随着这样的扩展越来越多，手动控制扩展的开启与关闭就变得非常麻烦。&#xA;我认为 VSCode 的工作区（Work Space）诞生的一大重要原因就是扩展的管理。事实上，当我们打开 VSCode 的时候，其实就位于默认的工作区中。&#xA;工作区的创建 假设我只会在 ~/code/blog/zwyb_blog 目录下用 VSCode 写博客，那么我用 VSCode 打开 ~/code/python 目录，我就可以点击 File -&amp;gt; Save Workspace as，保存为 blog.code-workspace。&#xA;目前，其内容如下：&#xA;{ &amp;#34;folders&amp;#34;: [ { &amp;#34;path&amp;#34;: &amp;#34;.&amp;#34; }, ], &amp;#34;settings&amp;#34;: {} } 可以看到，内容分为了 folders 与 settings 两大类，folders 表示处于该工作空间的文件夹所在目录，我们可以点击 File -&amp;gt; Add Folder to Workspace 来添加其他项目文件夹目录到该工作区，例如我添加了 ~/code/blog/papermod 目录，添加后内容修改为如下：&#xA;{ &amp;#34;folders&amp;#34;: [ { &amp;#34;path&amp;#34;: &amp;#34;.&amp;#34; }, { &amp;#34;path&amp;#34;: &amp;#34;.</description>
    </item>
    <item>
      <title>使博客被搜索引擎收录</title>
      <link>http://localhost:1313/posts/blog/blog-google-bing.zh/</link>
      <pubDate>Wed, 15 May 2024 15:44:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/blog-google-bing.zh/</guid>
      <description>前言 在网站没有被搜索引擎收录之前，网站内容是无法通过搜索引擎搜索到的，因此我们手动让网站被 Google 和 Bing 收录。&#xA;Google 进入 Google Search Console，点击 添加资源，资源类型选择 网址前缀，这里我的网址前缀为 https://blog.zwyyy456.tech/，验证方法选择通过 HTML 文件，按照提示，下载一个 google 开头的 html 文件，将这个文件放在 Hugo 博客文件目录的 static 目录下，这是因为 static 目录中的文件与目录在编译时，会被复制到 public 目录，即网站的根目录。&#xA;完成验证之后，下一步则是添加网站地图，如下图所示：&#xA;Hugo 会自动为我们生成 sitemap.xml 文件，即站点地图，由于我的网站支持中英双语，因此站点地图的位置为 https://blog.zwyyy456.tech/zh/sitemap.xml 和 https://blog.zwyyy456.tech/en/sitemap.xml，如果是单语言的 Hugo 博客网站，则是 https://HugoExample.com/sitemap.xml。添加好站点地图之后等待谷歌处理数据即可。&#xA;Bing 进入 Bing Webmaster Tools，可以直接从 Google Search Console 导入网站，提交站点地图的方法是类似的。&#xA;为博客添加搜索功能 我使用的博客主题是秉承简洁纯粹理念的 hugo_coder 主题，该主题不支持搜索功能，而我比较需要这个搜索功能，因此通过 Google 或者 Bing 的自定义搜索功能来为博客添加搜索功能是一个比较简单的做法，这里我使用的是 Bing 的自定义搜索功能。</description>
    </item>
    <item>
      <title>计算机教育缺失的一课：Shell 工具与脚本</title>
      <link>http://localhost:1313/posts/tech/missing-semester-shell.zh/</link>
      <pubDate>Thu, 09 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/missing-semester-shell.zh/</guid>
      <description>$ 符号的功能 Shell 中，$ 符号可以与数字或者其他符号组合在一起表示特殊的值或者变量，如下：&#xA;#!/bin/bash echo $0 # $0 用于获取当前脚本文件名名称 echo &amp;#34;The first parameter: $1&amp;#34; # $1 表示第一个参数 echo &amp;#34;The eleventh parameter: ${11}2&amp;#34; echo &amp;#34;The eleventh parameter: ${11}x&amp;#34; echo &amp;#34;The eleventh parameter: $11x&amp;#34; echo &amp;#34;The eleventh parameter: $12&amp;#34; tmp=&amp;#34;hello&amp;#34; echo &amp;#34;$tmp world&amp;#34; 将以上脚本文件命名为 test.sh 并执行 bash test.sh 1 2 3 4 5 6 7 8 9 10 13 14，输出如下：&#xA;test.sh The first parameter: 1 The eleventh parameter: 132 The eleventh parameter: 13x The eleventh parameter: 11x The eleventh parameter: 12 hello wolrd 这是因为，只有 $n 才能表示第 n 个参数（n 为单个数字），如果想表示第 11 个参数，就必须使用 ${11}（加上大括号）来表示，bash 会将 $12 处理为名为 12 的变量。</description>
    </item>
    <item>
      <title>Json 快速入门</title>
      <link>http://localhost:1313/posts/tech/json-startup.zh/</link>
      <pubDate>Sat, 04 May 2024 10:10:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/json-startup.zh/</guid>
      <description>简介 Json 格式的全称为 JavaScript Object Notation，是一种起源于编程语言 JavaScript 的序列化数据格式，其特点在于，可以通过特定的文本格式表达一定程度的复杂数据，被广泛应用于其他编程语言中。&#xA;六个构造字符 Json 有六种有效符号，如下：&#xA;符号 名称 [ 左方括号 ] 右方括号 { 左花括号 } 右花括号 , 逗号 : 冒号 在这些符号之间的空格与换行在 Json 中没有实际意义，一般用于使 Json 代码更加规整。注意，Json 标准中无法表示注释。&#xA;五种数据类型 Json 中存在 5 种数据类型，分别是 数字、字符串、数组、对象、字面名（也可以理解为保留值）。&#xA;数字 数字是最基础的数据类型，可以是一个整数、也可以是一个小数&#xA;1234, 12.34 字符串 类似其他编程语言中的字符串。&#xA;&amp;#34;Json&amp;#34;, &amp;#34;中文&amp;#34; 数组 数组表示一串有固定的顺序的值，相比起 C++ 中的数组，Json 中的数组中的值的数据类型可以不同，数组中的值的元素类型也可以是 数组 或者 对象。&#xA;数组的格式如下：以 [ 作为起始，以 ] 作为结束，数组中的值之间以 , 分隔。&#xA;[ 12345, &amp;#34;start&amp;#34;, [&amp;#34;end&amp;#34;], {&amp;#34;123&amp;#34;: &amp;#34;45&amp;#34;} ] 对象 对象可以简单理解为一系列的键值对。&#xA;对象基本格式是以 { 为起始，以 } 作为结束，每个键值对以 , 进行分割，键值对中的键与值利用 : 进行分隔。</description>
    </item>
    <item>
      <title>Win11 重装记录</title>
      <link>http://localhost:1313/posts/blog/win-reinstall.zh/</link>
      <pubDate>Sun, 03 Mar 2024 11:45:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/win-reinstall.zh/</guid>
      <description>起因 最近一两个月，时常碰到笔记本电脑死机的情况，具体表现为电脑卡死没反应，同时发出嗡嗡的电流声，前两天还出现了电脑蓝屏的情况，错误码为 &amp;ldquo;Clock Watchdog Timeout&amp;rdquo;，网上找了一圈，有不少人碰到了和我一样的问题，有个解决方案说要在电源模式下设置硬盘永不休眠，我尝试了，并没有用，推测可能的原因有以下几种：&#xA;笔记本过热，一般都是一边看视频一边打游戏时出现卡死的情况，并且我的笔记本电脑是外接了 4K 显示器在用，卡死的时候，能感觉到笔记本非常烫；&#xA;固态掉盘，用的海康威视 c2000 pro，据说有掉盘的先例；&#xA;奇奇怪怪的驱动、硬件兼容性问题；&#xA;正好，这个笔记本电脑的系统已经很久没有重装过了，里面的东西、配置也被我搞得挺乱了，干脆重装一遍系统，看看是否还有问题。&#xA;这篇文章主要是记录一下重装系统的过程和一些重要步骤以及要安装的软件。&#xA;备份 需要备份的文件与文件夹都在 C:\Users\zwyyy 目录下，手动把要备份的文件夹打包，拷贝到了我的移动硬盘中去。&#xA;制作系统安装 U 盘 首先，在微软官网下载 64 位的 Win11 系统镜像，下载好之后，利用 Rufus 软件将镜像写入到 U 盘中去。&#xA;然后是很重要的一步，如果直接开始安装系统，在安装过程中会发现无法识别 U 盘，对 11 代及以上的 Intel CPU 的笔记本，要识别 NVME 协议的固态硬盘，需要安装一个名为 Intel Rapid Storage Technology（IRST）的驱动程序，可以去笔记本厂商的官网下载对应的驱动，将驱动压缩包解压到系统安装 U 盘中即可，在安装系统，选择将 Windows 安装在哪里时，点击加载驱动程序，选择之前驱动程序解压到的那个目录，即可找到对应的驱动程序，加载了驱动程序之后，就能识别到硬盘了，之后的安装就是正常按照指引来就行了。&#xA;acer 下载驱动需要先下载一个序列号检测识别软件，识别到序列号之后，就能下载电脑型号的对应驱动程序了。&#xA;我的笔记本型号为 SWIFT SF314-511&#xA;驱动安装 重装好系统之后发现触控板和指纹不可用，需要安装驱动，打开 设置 -&amp;gt; Windows 更新 -&amp;gt; 高级选项 -&amp;gt; 可选更新 -&amp;gt; 驱动程序更新，即可安装这些驱动程序。&#xA;软件安装 Scoop 打开 Microsoft Store，安装 Windows Terminal，然后将 Shell 设置为 Windows PowerShell，执行以下两条指令：</description>
    </item>
    <item>
      <title>利用 Latex 写毕业论文</title>
      <link>http://localhost:1313/posts/blog/latex-sjtu.zh/</link>
      <pubDate>Thu, 22 Feb 2024 20:18:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/latex-sjtu.zh/</guid>
      <description>前言 本科写毕业论文的时候，是用的学校的 word 模板，体验比较糟糕，当时跟我一组的同学就是用的 Latex 的本科学位论文模板，当时由于我写本科毕业论文的时间比较紧迫了，所以没有折腾这些，此外，当时的 Latex 学位论文模板属于是纯民间支持的性质，而现在，学校已经半官方地支持了 Latex 学位论文模板，因此，研究生毕业论文我就准备使用 Latex 而不再使用 word 来写了。&#xA;模板介绍 首先观察 main.tex，其中 \input{contents/abstract} 就是表示会加载 main.tex 所在目录的的 contents 目录下的 abstract.tex 的内容，即摘要。&#xA;然后是 \tablecontents 命令以生成目录，目录生成方式应该是由模板决定的。&#xA;以下这些则是正文内容：&#xA;\input{contents/intro} \input{contents/math_and_citations} \input{contents/floats} \input{contents/summary} 我们可以观察一下 contents 目录下的 intro.tex，首先是 \chapter{简介}，这里的大括号中的内容就是这一章的标题，后续则分别是一级标题、二级标题、三级标题、四级标题，对应的 Latex 语法如下：&#xA;\section{二级标题} \subsection{三级标题} \subsubsection{四级标题} 模板的默认字体应该就是宋体，模板中给出了手动指定该段落的字体的方法。&#xA;contents 目录下的 math_and_citations.tex 给出了 Latex 中的数学公式（包括字符）与引用文献的标注方法。&#xA;contents 目录下的 floats.tex 则是给出了 Latex 插入图片与表格的方法。&#xA;setup.tex 中则是封面以及 Latex 的样式控制的相关信息。&#xA;SJTUThesis 模板食用方法 Overleaf 学校网络信息中心应该是根据 Overleaf 自己搭建了一个可以在线编译 Latex 的平台：Latex 文档助手。&#xA;首先去 SJTUThesis 的 GitHub 页面下载论文模板的 压缩包：master.</description>
    </item>
    <item>
      <title>Mac 与 win 之间的云同步处理</title>
      <link>http://localhost:1313/posts/blog/cloud-sync.zh/</link>
      <pubDate>Mon, 15 Jan 2024 16:02:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/cloud-sync.zh/</guid>
      <description>iCloud iCloud 是 Mac 的默认云盘，Apple 为 Mac 提供了一定程度上的 iCloud 集成，在 Apple ID -&amp;gt; iCloud -&amp;gt; iCloud 云盘 中，可以选择让“桌面与文稿文件夹”也使用 iCloud 云盘，此时，你原先的 /Users/Documents 和 /Users/Desktop 会被替换为 iCloud/Documents 中的 文稿 - zwy - mbp14 以及 icloud/Desktop 中的 桌面 - zwy - mpb14 目录，同时 iCloud 中的 文稿 目录与 桌面 目录会被分别作为 Mac 的 /Users/Documents 与 /Users/Desktop 目录，推测是通过符号链接来实现的？&#xA;此后所有的对 /Users/Docuements 与 /Users/Desktop 的修改都会反映到 iCloud 中。&#xA;要注意一点，推荐关闭 iCloud 的 优化 Mac 储存空间 功能，否则当你的 Mac 存储空间不足的时候，/Users/Documents 与 /Users/Desktop 目录中的内容会变成仅保存在 iCloud 云端，而本地没有保存内容，这会导致在这两个目录中执行 git 与 cd 等命令非常卡顿。</description>
    </item>
    <item>
      <title>简单的 GPW 发种教程</title>
      <link>http://localhost:1313/posts/blog/gpw-upload-tutorial.zh/</link>
      <pubDate>Sun, 31 Dec 2023 15:38:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/gpw-upload-tutorial.zh/</guid>
      <description>简介 主要使用基于 Debian 的 VPS 进行发种，流程上与纯粹的 Windows 平台发种略有不同，需要依赖命令行工具进行处理。&#xA;mediainfo 执行 sudo apt install mediainfo 即可安装 mediainfo，执行 mediainfo video_name 即可生成对应的 mediainfo。&#xA;可以利用 &amp;gt; 将输出重定向到指定文件。&#xA;视频截图 海豹要求三张原始分辨率的视频截图，我们可以利用 ffmpeg 来抓取截图。&#xA;执行 sudo apt install ffmpeg 即可安装 ffmpeg。&#xA;通过执行 ffmpeg -ss 00:08:06 -i $video_file -vframes 1 -f image2 -y test1.png 即可生成原始分辨率的 png 截图，其中 $video_file 要替换成对应的文件名。&#xA;生成种子 执行 sudo apt install mktorrent 安装 mktorrent，执行 mktorrent&#xA;脚本 将 mediainfo 和 视频截图整合成了一个简单的 bash 脚本：&#xA;#!/bin/bash video_file=&amp;#34;&amp;#34; # 遍历当前目录下所有 .</description>
    </item>
    <item>
      <title>简单的 GPW 发种教程</title>
      <link>http://localhost:1313/posts/blog/vscode-leetcode-cookie/</link>
      <pubDate>Sun, 31 Dec 2023 15:38:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/vscode-leetcode-cookie/</guid>
      <description>简介 主要使用基于 Debian 的 VPS 进行发种，流程上与纯粹的 Windows 平台发种略有不同，需要依赖命令行工具进行处理。&#xA;mediainfo 执行 sudo apt install mediainfo 即可安装 mediainfo，执行 mediainfo video_name 即可生成对应的 mediainfo。&#xA;可以利用 &amp;gt; 将输出重定向到指定文件。&#xA;视频截图 海豹要求三张原始分辨率的视频截图，我们可以利用 ffmpeg 来抓取截图。&#xA;执行 sudo apt install ffmpeg 即可安装 ffmpeg。&#xA;通过执行 ffmpeg -ss 00:08:06 -i $video_file -vframes 1 -f image2 -y test1.png 即可生成原始分辨率的 png 截图，其中 $video_file 要替换成对应的文件名。&#xA;生成种子 执行 sudo apt install mktorrent 安装 mktorrent，执行 mktorrent&#xA;脚本 将 mediainfo 和 视频截图整合成了一个简单的 bash 脚本：&#xA;#!/bin/bash video_file=&amp;#34;&amp;#34; # 遍历当前目录下所有 .</description>
    </item>
    <item>
      <title>将博客的图床从 SM.MS 迁移到又拍云</title>
      <link>http://localhost:1313/posts/blog/change-image-src-from-smms-to-upyun.zh/</link>
      <pubDate>Tue, 26 Dec 2023 16:25:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/change-image-src-from-smms-to-upyun.zh/</guid>
      <description>前言 为了存储博客的图片，我需要一个图床，一开始本来是想用七牛云或者又拍云提供的免费存储服务和流量来做图床的，奈何它们都需要一个通过了备案的域名才能实现，于是退而求其次选择了 SM.MS，在 picgo 或者 upic 中配置 SM.MS 图床非常方便，填一个 token 即可，在科学加持的情况下，图片显示也是很快速的。&#xA;但是，由于我的博客很多内容是我自己的学习笔记，因此其中的图片内容也是很重要的，考虑到 SM.MS 的图床稳定性与国内的可直接访问性，当我的 zwyyy456.tech 域名通过备案之后，我就着手将图床从 SM.MS 迁移到了又拍云。&#xA;又拍云设置 又拍云联盟的用户每月可获得 10GB 免费存储空间与 15GB 免费 CDN 流量，要加入又拍云联盟也很简单，只需要在网站地步添加又拍云 LOGO 与又拍云网站的对应链接即可。&#xA;在博客所属根目录下，将 layouts/partials/foot.html 的内容修改为如下：&#xA;&amp;lt;footer class=&amp;#34;footer&amp;#34;&amp;gt; &amp;lt;section class=&amp;#34;container&amp;#34;&amp;gt; © {{ if (and .Site.Params.since (lt .Site.Params.since now.Year)) }} {{ .Site.Params.since }} - {{ end }} {{ now.Year }} {{ with .Site.Params.author }} {{ . }} {{ end }} · {{ if (and .Site.Params.license) }} {{ i18n &amp;#34;licensed_under&amp;#34; }} {{ .</description>
    </item>
    <item>
      <title>Git 如何避免 &#39;warning: LF will be replaced by CRLF&#39;</title>
      <link>http://localhost:1313/posts/blog/git-crlf-lf.zh/</link>
      <pubDate>Mon, 18 Dec 2023 22:02:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/git-crlf-lf.zh/</guid>
      <description>问题描述 前面提到，我会使用 Filen 来同步文件，例如当我在 macOS 上创建了 .md 文件而忘记 push 到 GitHub 时，回到宿舍，打开我 Windows 系统的 Acer 笔记本（后续以 Acer 指代该笔记本）时，Filen 会自动将 .md 文件同步到 Acer，然后当我在 Acer 上完成对该 .md 的编辑并 commit 时，就会提示如下内容：&#xA;CR 表示 \r，LF 表示 \n&#xA;warning: LF will be replaced by CRLF in content/posts/blog/n1-plex-music.zh.md. The file will have its original line endings in your working directory 我们在安装 Git 时，默认 core.autocrlf = true，即 Git 会认为，工作区的文件都应该用 \r\n 来换行，如果工作区因为新增（在这个情境下就是因为 Filen 把文件同步到了 Acer）或编辑出现了 \n 换行符的文件，git add 这些文件时，发现准备提交的文件是 \n 作为换行符，就会出现这个警告，并提示哪些文件是 \n 换行的，但是 Git 不会对工作区这些文件做换行符的转换）。</description>
    </item>
    <item>
      <title>解决 Netlify 部署 Hugo 静态博客时的 `fatal: remote error: upload-pack: not our ref` 问题</title>
      <link>http://localhost:1313/posts/blog/netlify-build-error.zh/</link>
      <pubDate>Mon, 18 Dec 2023 12:46:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/netlify-build-error.zh/</guid>
      <description>问题描述 我的其中一个 Hugo 博客采用了 PaperMod 主题，另一个是 hugo-coder 主题，都是通过 Netlify 部署，昨天晚上发现，Netlify 显示 paper.191000.xyz 对应的站点部署失败。&#xA;问题日志显示：&#xA;12:26:05 PM: Waiting for other deploys from your team to complete. Check the queue: https://app.netlify.com/teams/zwyyy456/builds 12:26:20 PM: build-image version: 3ffff9df3d5419545acc1b673a54de348174406d (focal) 12:26:20 PM: buildbot version: 4613af4169363e3b38cfadfa4665d34cd1d1427b 12:26:20 PM: Fetching cached dependencies 12:26:20 PM: Starting to download cache of 106.8MB 12:26:22 PM: Finished downloading cache in 1.935s 12:26:22 PM: Starting to extract cache 12:26:23 PM: Finished extracting cache in 720ms 12:26:23 PM: Finished fetching cache in 2.</description>
    </item>
    <item>
      <title>解决 macOS 上的 fish 出现的 &#39;et_color Unkown color &#39; 问题</title>
      <link>http://localhost:1313/posts/blog/win-macos-fish_variables.zh/</link>
      <pubDate>Mon, 18 Dec 2023 11:14:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/win-macos-fish_variables.zh/</guid>
      <description>问题简介 我主要使用的 shell 是开箱即用的 fish，fish 的配置文件位于 ~/.config/fish 中，整个 .config 目录使用 Filen 实现在 macOS 和 Windows 之间的同步，并且使用 Git 进行版本管理。&#xA;当我昨天在 Windows 下修改了 .config/nvim 目录中的文件，将修改 push 到 GitHub 之后，今天在 Mac 上将修改 pull 到本地之后，fish 就出现了 &#39;et_color: Unkown color &#39; 问题，如下图所示：&#xA;解决方案 检查 ~/.config/fish/fish_variables 文件，与 Filen 中记录的历史版本进行对比，发现每一行结尾都多了 \x0d，经查阅资料， \0d 表示回车，即 \r，而 mac 默认的换行标识为 \n。&#xA;删掉所有的 \x0d 之后就正常了，而问题出现的原因也很清楚了，在编辑文件（也可能是 Git 同步）的时候，fish_variables 文件的换行被从 \n 替换成了 \r\n，于是，就出现了上述的问题。&#xA;在我记忆中，我在 Windows 下应该是没有修改过 fish_variables文件的。&#xA;后续需要配置一下 Windows 下 Git 的换行符设置问题。</description>
    </item>
    <item>
      <title>RemNote 入门教程</title>
      <link>http://localhost:1313/posts/blog/remnote-tutorial.zh/</link>
      <pubDate>Thu, 14 Dec 2023 14:57:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/remnote-tutorial.zh/</guid>
      <description>自定义字体 RemNote 的默认字体用于代码块时，显示效果十分拉垮，i 与 e 这两个字母的看起来明显比 m 之类的字母更细。&#xA;RemNote 可以通过 Custom CSS 来自定义显示效果，关键在于找到对应的 CSS selector。&#xA;我们可以在 Firefox 上打开 www.remnote.com，点开一篇笔记，例如 200 秋招，然后鼠标划词选中内容，右键点击 检查，如下图所示：&#xA;因此，可以注意到，行内代码对应的 selector 为 .rn-code-node .w-full .font-mono，因此 Custom CSS 添加&#xA;.rn-code-node .w-full, .font-mono { font-family: Monaco Nerd Font Mono; font-size: 14px } 而对于启用了 Lab 中的 rem code block 之后的代码块，使用同样的方式找到对应的 CSS selector：&#xA;因此 Custom CSS 添加&#xA;.rn-code-node .w-full, .font-mono { font-family: Monaco Nerd Font Mono; font-size: 14px } 同时，对于 RemNote 的笔记中的字体，这里修改为 霞鹜文楷，很好看。</description>
    </item>
    <item>
      <title>Nas 预组</title>
      <link>http://localhost:1313/posts/blog/nas-build.zh/</link>
      <pubDate>Mon, 04 Dec 2023 23:22:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/nas-build.zh/</guid>
      <description>功能简介 应该可以说是一台 AIO，利用 PVE 虚拟化多个系统，实现不同功能：&#xA;基于 Debian 的开发机，ssh 连接上去进行远程开发、编译； Nas，预计采用 TrueNAS SCALE； 其他服务，都通过 Docker 运行，考虑采用 FlatCar 这种容器化系统，也可能直接跑在 Debian 上。 qBittorrent; Immich; Memos; Restic; Plex Media Server CloudDrive2 IYUUPlus Alist Rclone 硬件选择 联想 RD450x CPU 拟采用 E5 2680v4。&#xA;优点：硬件成本低，机箱 + 主板 + CPU 仅需 ￥600，且有极强的扩展性；&#xA;缺点：功耗高，不带硬盘的待机功耗约为 80W，满载功耗约为 200W，无 GPU 硬件转码功能；&#xA;梵隆机箱 主板可以选择 MATX 主板，CPU 考虑使用 12400？&#xA;优点：功耗相比服务器更低，12400 待机功耗约 30W，待机功耗大概能低 50W？考虑到上海电费，一年能省下 50 * 24 /1000 * 365 * 0.75 = 300 元人民币左右，可以使用 GPU 硬件进行转码；</description>
    </item>
    <item>
      <title>使用 Filen 同步文件夹</title>
      <link>http://localhost:1313/posts/blog/filen_use.zh/</link>
      <pubDate>Tue, 28 Nov 2023 15:36:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/filen_use.zh/</guid>
      <description>Filen 介绍 这里直接引用官网的介绍：&amp;ldquo;Zero knowledge end-to-end encrypted cloud storage, redefined&amp;rdquo;。&#xA;即这是一个端对端加密的同步盘，类似 Dropbox 和坚果云，不同于百度网盘、115、阿里云盘这样的资源盘，支持文件历史版本。&#xA;通过他人的邀请链接注册可以获得 20G 的初始容量，之后邀请 3 个人注册可以再获得 30G 的容量，就同步来说，50G 其实也够了，我趁着黑五促销，又买了 100G 的永久容量。&#xA;目前看来，它的同步功能做得不如坚果云，不支持 webdav，也没有云桥功能（虽然这个功能我用不到）但是坚果云不付费的限制比较多，而 Filen 付费与否只与容量相关。&#xA;此外，Filen 对我而言有一个杀手级别的功能，那就是支持设置 .filenignore，即采用类似 gitignore 的语法，不同步某些特定文件，例如 build 的产物等。&#xA;文件夹同步设置 前文提到，Filen 是一个同步盘，我的用途也是实现 mac 和 windows 笔记本之间的同步，主要包括配置文件、代码文件以及博客文本文件等。&#xA;本来 onedrive 的同步功能也还可以，但是不支持“指定特定文件夹不同步”让他在同步带 .git 的代码文件夹时，非常容易出问题。&#xA;同步文件夹的设置如下图：&#xA;点击 create one 就会让你选择一个本地的文件夹，选定好之后，settings-&amp;gt;syncs 会多出一栏，点击右边的设置图标，即可配置 .filenignore，语法同 .gitignore，sync mode 一般选择 Two Way。然后点击 select remote location，可以选择要同步到云盘中的哪个文件夹，选择好之后就可以开始同步了。&#xA;选择同步的文件夹 目前，mac 上我同步了这些文件夹：&#xA;尽管除了 .ssh 和 Pictures 文件夹之外，其他文件夹都有通过 git 和进行 GitHub 进行版本管理与同步，但是难免有忘记 commit 和 push 的情况。例如，假设我在 mac 上对代码进行了修改，但是忘记 push 到 GitHub 了，然后回到了宿舍，此时宿舍的 Windows 笔记本无法获取到 mac 上对代码的修改，但有了 Filen 同步就不一样了，尽管 git 的状态与 mac 不一致，但源文件的修改是一致的，Windows 修改了之后，再 push 到 GitHub 上即可（实际上不 push 也没啥问题）。</description>
    </item>
    <item>
      <title>Web Day13：服务器完善</title>
      <link>http://localhost:1313/posts/tech/web-day13.zh/</link>
      <pubDate>Mon, 20 Nov 2023 10:45:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/web-day13.zh/</guid>
      <description>定时器定时关闭连接 首先，应该每个 EventLoop 包含一个 Timer，Timer 的主体结构是一个小顶堆，priority_queue&amp;lt;pair&amp;lt;double, Connection *&amp;gt;&amp;gt;，double 表示以微秒计数的超时时间 t，即当前时间如果大于 t，那么就超时了。&#xA;同时 Connection 需要额外添加一个变量，即 cnt，标志该 Connection 在小顶堆中的数量；&#xA;channel 的回调函数中，需要将 Connection 的次数 + 1，同时再 push 这个 Connection 到小顶堆中。&#xA;每次 Loop 循环完成，就获取当前时间，进行一次 pop，直到堆顶的的元素的超时时间大于当前时间。&#xA;每次 pop 的时候，被 pop 的元素的 cnt 减一，如果减到 0 了，那么就调用 delete_conn_callback 函数。&#xA;由于每个 EventLoop 只由一个特定的线程负责，因此小顶堆不需要加锁来保护。&#xA;日志系统 同步日志：产生日志的同时就将其写入至文件中，即在 EventLoop 中，该 EventLoop 线程直接负责写入日志到文件（磁盘）。写日志的过程中，由于要写入磁盘，耗时比内存中的 IO 要长，很可能影响到服务器的效率。&#xA;异步日志：采用一个单独的线程，而非 EventLoop 线程来向磁盘写入日志，可以说是一个典型的生产者消费者模型。&#xA;分为日志前端和日志后端，前端就是生产者，也就是 I/O 线程这些，负责将日志写入到位于内存的 log_buffer 中，而消费者则是后端，负责将日志从 log_buffer 写入到磁盘中去。&#xA;前端线程会调用 current_buffer_-&amp;gt;append，写到 AsyncLogging 类的 写入到 current_buffer_，如果 current_buffer_ 满了，就调用 buffers_.</description>
    </item>
    <item>
      <title>Web Day12：实现主从 Reactor 多线程模式</title>
      <link>http://localhost:1313/posts/tech/web-day12.zh/</link>
      <pubDate>Sun, 19 Nov 2023 13:00:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/web-day12.zh/</guid>
      <description>前言 在 Day11 中，我们实现了一种最容易想到的 Reactor 多线程模式，即将每个 Channel 的任务分配给一个线程执行。&#xA;这个模式逻辑上有不少问题，例如线程池由 EventLoop 来持有，按理来说应该由 Server 类来管理，这是受到了 Channel 类的限制，Channel 类仅有 EventLoop 成员。&#xA;主从 Reactor 模式 主从 Reactor 模式有以下几个特点：&#xA;服务器一般只有一个 main reactor，可以有很多个 sub reactor； 服务器管理一个线程池，每个线程对应一个 sub reactor，每个 sub reactor 负责一部分 Connections 的事件循环，事件执行也在这个线程完成； main reactor 只负责 Acceptor 建立新连接，然后将这个连接分配给一个 sub Reactor。 Server 成员 /todo，测试 accept 和 connect 的时候区分非阻塞与阻塞&#xA;Server 的成员包括一个 main_reactor 和 多个 sub_reactors，每个 sub_reactor 对应一个独有的 EventLoop，每个 sub_reactor 由一个线程负责。这就是所谓的 One Loop per Thread。&#xA;class Server { private: EventLoop *main_reactor_; Acceptor *acceptor_; std::map&amp;lt;int, Connection *&amp;gt; connections_; std::vector&amp;lt;EventLoop *&amp;gt; sub_reactors_; ThreadPool *thpool_; public: Server(EventLoop *evl); ~Server(); void HandleReadEvent(int fd); void NewConn(Socket *serv_sock); void DeleteConn(int sockfd); }; main reactor 的工作流程 Server 创建的时候，会利用 main 函数的 loop 来初始化 Server，并利用 loop 来初始化 main_reactor_，和 acceptor_。 acceptor_ 会有绑定了服务器 ip 和端口的 socket。初始化 acceptor_ 的时候，会将 acceptor_-&amp;gt;new_conn_callback_ 注册为 Server::NewConn(Socket *clnt_sock)，当有连接时，acceptor_ 调用 Acceptor::AcceptConn()，该函数会调用 Socket::Accept(InetAddress *) 来接受连接，以及调用 new_conn_callback_(clnt_sock)，实际上就是调用 Server::NewConn(Socket *clnt_sock)。</description>
    </item>
    <item>
      <title>Web Day11：完成线程池以及加入一个简单的测试程序</title>
      <link>http://localhost:1313/posts/tech/web-day11.zh/</link>
      <pubDate>Sat, 18 Nov 2023 19:40:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/web-day11.zh/</guid>
      <description>需要完善的地方 Day10 中，我们添加了一个简单的线程池，一个完整的 Reactor 模型已经成型。但这个线程池存在的问题还比较多，例如任务队列的取出、添加都存在拷贝，性能较差，只能用于学习。&#xA;正确操作应该使用右值移动、完美转发等来阻止拷贝。&#xA;另外，线程池只能接受 std::function&amp;lt;void()&amp;gt; 类型的函数，所以函数需要使用 Lambda 表达式来创建，或者 std::bind()，且无法得到返回值。&#xA;利用模板 class ThreadPool { private: std::vector&amp;lt;std::thread&amp;gt; threads_; std::queue&amp;lt;std::function&amp;lt;void()&amp;gt;&amp;gt; tasks_; std::mutex tasks_mtx_; std::condition_variable cv_; bool stop_; public: explicit ThreadPool(int size = 8); ~ThreadPool(); template &amp;lt;class F, class... Args&amp;gt; auto add_task(F &amp;amp;&amp;amp;f, Args &amp;amp;&amp;amp;...args) -&amp;gt; std::future&amp;lt;typename std::result_of&amp;lt;F(Args...)&amp;gt;::type&amp;gt;; }; template &amp;lt;class F, class... Args&amp;gt; auto ThreadPool::add_task(F &amp;amp;&amp;amp;f, Args &amp;amp;&amp;amp;...args) -&amp;gt; std::future&amp;lt;typename std::result_of&amp;lt;F(Args...)&amp;gt;::type&amp;gt; { using return_type = typename std::result_of&amp;lt;F(Args...)&amp;gt;::type; auto ptask = std::make_shared&amp;lt;std::packaged_task&amp;lt;return_type()&amp;gt;&amp;gt;( std::bind(std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;Args&amp;gt;(args).</description>
    </item>
    <item>
      <title>Web Day10：加入线程池到服务器</title>
      <link>http://localhost:1313/posts/tech/web-day10.zh/</link>
      <pubDate>Sat, 18 Nov 2023 15:19:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/web-day10.zh/</guid>
      <description>前言 到 day9 的时候，一个单线程的服务器已经算写好了。Reactor 驱动大致成型。&#xA;服务器的启动流程大致如下，先创建 EventLoop 对象 loop（里面包含了 Epoll 对象），然后 Server 会利用 loop 实例化对象 server，Server 对象实例化时，Acceptor 类型的 acceptor_ 对象会被初始化, Acceptor 对象用于建立连接，会在 Server 的构造函数里回调函数 acceptor_-&amp;gt;new_conn_callback_ 会被注册为 server-&amp;gt;NewConn(Socket *clnt_sock) ，由 acceptor_-&amp;gt;AcceptConn() 来调用。而 Acceptor 的构造函数中 Channel 类的实例 accept_ch_ 会被初始化，而回调函数 acceptr_ch-&amp;gt;callback_ 会被注册为 acceptor_-&amp;gt;AcceptConn()，最终还是调用的 server-&amp;gt;NewConn(Socket *clnt_sock)。&#xA;Server::Server(EventLoop *loop) : loop_(loop), acceptor_(nullptr) { acceptor_ = new Acceptor(loop); std::function&amp;lt;void(Socket *)&amp;gt; callback = [this](auto &amp;amp;&amp;amp;PH1) { NewConn(std::forward&amp;lt;decltype(PH1)&amp;gt;(PH1)); }; acceptor_-&amp;gt;set_new_conn_callback(callback); } void Server::NewConn(Socket *sock) { auto *conn = new Connection(loop_, sock); // 这里应该是 clnt_sock std::function&amp;lt;void(Socket *)&amp;gt; callback = [this](auto &amp;amp;&amp;amp;PH1) { DeleteConn(std::forward&amp;lt;decltype(PH1)&amp;gt;(PH1)); }; conn-&amp;gt;set_delete_conn_callback(callback); connections_[sock-&amp;gt;getfd()] = conn; } void Acceptor::AcceptConn() { auto *clnt_addr = new InetAddress(); auto *clnt_sock = new Socket(sock_-&amp;gt;Accpet(clnt_addr)); printf(&amp;#34;new client fd %d!</description>
    </item>
    <item>
      <title>Web Day9：建立读写缓冲类</title>
      <link>http://localhost:1313/posts/tech/web-day9.zh/</link>
      <pubDate>Sat, 18 Nov 2023 14:53:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/web-day9.zh/</guid>
      <description>概述 本节只是额外添加了一个读写的缓冲区，意义不甚明了。暂定。</description>
    </item>
    <item>
      <title>Mac 开发环境配置</title>
      <link>http://localhost:1313/posts/blog/mac-dev-config.zh/</link>
      <pubDate>Fri, 17 Nov 2023 17:00:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/mac-dev-config.zh/</guid>
      <description>前言 本文内容主要是我对 Mac 的所做的配置修改的一些记录。后续会随着时间更新，免得忘记自己对 Mac 做过什么修改了。&#xA;安装 Command Line Tools for Xcode 安装包下载 链接&#xA;安装 Homebrew 执行 /bin/bash -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&amp;quot; 即可。网络环境已自带科学。&#xA;大名鼎鼎的 Homebrew 无需多说，通过 Homebew 我安装了以下软件：&#xA;总的原则大概就是能用 homebrew 安装的都是使用 homebrew 安装，例如 Edge、VScode 等。&#xA;要注意的是，Homebrew 安装软件时，将软件分成了 Formulae 和 Casks 两大类，简单来说就是，有 gui 的就是 Casks，没有的就是 Formulae，安装带 GUI 的软件，例如 Neovide 时，安装指令为 brew install neovide --cask。&#xA;Homebrew 还可以用于安装字体，例如执行 brew install font-fira-mono-nerd-font --cask 即可安装 FiraMono 字体。&#xA;安装 Neovim 执行 brew install neovim 即可，然后 cd ~/.</description>
    </item>
    <item>
      <title>Debian 开发环境配置</title>
      <link>http://localhost:1313/posts/blog/debian-dev-config.zh/</link>
      <pubDate>Fri, 17 Nov 2023 16:16:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/debian-dev-config.zh/</guid>
      <description>前言 开发 web server 等项目，由于会使用到 Linux 的一些 API，用 Mac 来开发并不方便。我的 M1 Macbook Pro，由于采用了 arm 架构，使用虚拟机比较麻烦，并且虚拟机总觉得太笨重，不算方便。此外，也是由于 arm 架构的原因，使用 Docker 不方便，Docker Desktop 据说又卡又难用。&#xA;希望能有一个方案能同时解决以上两个问题（毕竟能用 docker 就能直接在 docker 里面跑 Debian 镜像了）。&#xA;经过一番搜索，发现了一个名为 OrbStack 的工具，可以理解为 Mac 上的 WSL，至于实现原理，这里不去深究。&#xA;OrbStack 使用起来非常方便，brew install orbstack 之后，执行 orbstack create debian orb-deb 就可以创建名为 orb-deb 的虚拟机了，虚拟机和 macOS 之间的文件访问非常方便。Linux 中可以直接访问 macOS 中的文件和目录，macOS 中也一样。并且 CPU / 磁盘 / 内存都是按需使用的。&#xA;此外，可以在 Linux 虚拟机中非常方便地执行 macOS 的命令，在 macOS 中执行虚拟机 Linux 中的命令也同样如此。&#xA;后面的内容都是 Debian 开发环境的配置了，不论是 OrbStack 的 Debian 还是 WSL 又或者是物理机、VPS 都适用。</description>
    </item>
    <item>
      <title>Web Day8：抽象出 Connection 类</title>
      <link>http://localhost:1313/posts/tech/web-day8.zh/</link>
      <pubDate>Thu, 16 Nov 2023 15:25:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/web-day8.zh/</guid>
      <description>Acceptor 类 一言以蔽之，Acceptor 类负责接受连接，调用 AcceptConn，到这里，接受连接已经完全由 Acceptor 类来负责。Acceptconn 会调用被注册的回调函数 new_conn_callback_(clnt_sock)，实际上就是调用 Server::NewConn(clnt_sock)，该函数会将 {clnt_fd, conn} 的键值对添加到 Server 类的 map 中去。&#xA;此外，还会为 Connection 类注册删除 Connection 的回调函数；&#xA;void Acceptor::AcceptConn() { auto *clnt_addr = new InetAddress(); auto *clnt_sock = new Socket(sock_-&amp;gt;Accpet(clnt_addr)); printf(&amp;#34;new client fd %d! IP: %s Port: %d\n&amp;#34;, clnt_sock-&amp;gt;getfd(), inet_ntoa(clnt_addr-&amp;gt;get_addr().sin_addr), ntohs(clnt_addr-&amp;gt;get_addr().sin_port)); clnt_sock-&amp;gt;Setnonblocking(); new_conn_callback_(clnt_sock); delete clnt_addr; } void Server::NewConn(Socket *sock) { auto *conn = new Connection(loop_, sock); // 这里应该是 clnt_sock std::function&amp;lt;void(Socket *)&amp;gt; callback = [this](auto &amp;amp;&amp;amp;PH1) { DeleteConn(std::forward&amp;lt;decltype(PH1)&amp;gt;(PH1)); }; conn-&amp;gt;set_delete_conn_callback(callback); connections_[sock-&amp;gt;getfd()] = conn; Acceptor 的回调函数的注册过程发生在 Server 类的创建过程中。</description>
    </item>
    <item>
      <title>Web Day7：为服务器添加一个 Acceptor</title>
      <link>http://localhost:1313/posts/tech/web-day7.zh/</link>
      <pubDate>Thu, 16 Nov 2023 10:55:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/web-day7.zh/</guid>
      <description>Acceptor 定义 这里我的理解就是，一个 Acceptor 对应一个 EventLoop，当然也有一个独有 Channel，负责分发到对应的 epoll。&#xA;这里实际上是从 Server 中又分离出了一个 Acceptor，负责管理事件循环，服务器 socket 的创建与绑定，listen，同时由 Acceptor 来负责建立连接（逻辑上），调用的底层的建立连接的函数还是 Server::NewConn(Socket *)。&#xA;即实际上，Acceptor 类接管了之前 Server 类的工作。&#xA;Acceptor::Acceptor(EventLoop *loop) : loop_(loop), sock_(nullptr), accept_ch_(nullptr), addr_(nullptr) { sock_ = new Socket(); addr_ = new InetAddress(&amp;#34;127.0.0.1&amp;#34;, 8888); sock_-&amp;gt;Bind(addr_); sock_-&amp;gt;Listen(); sock_-&amp;gt;Setnonblocking(); accept_ch_ = new Channel(loop_, sock_-&amp;gt;getfd()); std::function&amp;lt;void()&amp;gt; callback = [this] { AcceptConn(); }; accept_ch_-&amp;gt;set_callback(callback); accept_ch_-&amp;gt;EnableReading(); } void Acceptor::AcceptConn() { new_conn_callback_(sock_); } void Acceptor::set_new_conn_callback(std::function&amp;lt;void(Socket *)&amp;gt; &amp;amp;callback) { new_conn_callback_ = callback; } Server::Server(EventLoop *loop) : loop_(loop), acceptor_(nullptr) { acceptor_ = new Acceptor(loop); std::function&amp;lt;void(Socket *)&amp;gt; callback = [this](auto &amp;amp;&amp;amp;PH1) { NewConn(std::forward&amp;lt;decltype(PH1)&amp;gt;(PH1)); }; acceptor_-&amp;gt;set_new_conn_callback(callback); } 其中以下两行代码就是让 Acceptor 类可以调用 Server 类中的 NewConn 的关键：</description>
    </item>
    <item>
      <title>Web Day6：EventLoop 类与事件驱动</title>
      <link>http://localhost:1313/posts/tech/web-day6.zh/</link>
      <pubDate>Wed, 15 Nov 2023 20:09:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/web-day6.zh/</guid>
      <description>事件驱动 原先的代码中，不管是接受客户端连接还是处理客户端事件，都是围绕epoll来编程，可以说epoll是整个程序的核心，服务器做的事情就是监听epoll上的事件，然后对不同事件类型进行不同的处理。这种以事件为核心的模式又叫事件驱动，事实上几乎所有的现代服务器都是事件驱动的。和传统的请求驱动模型有很大不同，事件的捕获、通信、处理和持久保留是解决方案的核心结构。&#xA;将服务器改造成 Reactor 模式 我们将服务器抽象成一个 Server 类，类中有一个 main-reactor，main-reactor 的核心是一个 EventLoop，即不断循环，一旦有事件发生，我们就会通过 ep-&amp;gt;Poll 知晓，然后作出对应的处理。&#xA;Channel 的修改 day5 中，每个 channel 里面都含有一个 Epoll * 指针，表示它在哪个 epoll 实例中被关注，这里我们把 Epoll * 替换成了 EventLoop *，表示该 channel 处于哪个事件循环中，事实上 EventLoop 的关键成员就是 Epoll *。&#xA;初始化流程 首先创建 EventLoop 对象 loop，它会创建一个 Epoll 实例，核心就是 epfd，然后利用 loop 初始化 Server 对象，在这个过程中，会完成服务器的 serv_fd 的创建以及 bind，listen，同时将对应着 serv_fd 以及新建连接事件的 Channel 创建出来，将 Channel 的处理事件的回调函数设置为 NewConn；调用 serv_ch-&amp;gt;EnableReading 会将关注的事件类型设置为 EPOLLIN | EPOLLET 并调用 loop-&amp;gt;UpdateChannel(this) 最终调用 ep-&amp;gt;UpdateChannel(ch)，从而将 serv_ch 对应的文件描述符添加到 epoll 关注的文件描述符列表或者修改。</description>
    </item>
    <item>
      <title>Web Day 5 添加 Channel 类</title>
      <link>http://localhost:1313/posts/tech/web-day5.zh/</link>
      <pubDate>Wed, 15 Nov 2023 15:29:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/web-day5.zh/</guid>
      <description>Channel 类 Channel 类相当于将 ep-&amp;gt;addFd 这一步拆成了两步，第一步是 ch-&amp;gt;enablereading，它会调用 ep-&amp;gt;UpdateChannel(this)，this 就是调用 enablereading 的那个 ch。&#xA;如何理解 Channel 类？可以认为每一个 ch 的实例，都对应着一个关注的文件描述符 fd 和一个要关注的事件类型 events，当前其实只有两类 Channel，一个是对应的服务器的 fd，另一类对应的是 accept 客户端的连接之后得到的 fd，ch-&amp;gt;events 是 fd 所在的 Channel 实例需要关注的事件类型。&#xA;而 active_events 表示该 Channel 当前发生的事件类型，在 ep-&amp;gt;Poll() 中会被设置。&#xA;auto Epoll::Poll(int timeout) -&amp;gt; std::vector&amp;lt;Channel *&amp;gt; { std::vector&amp;lt;Channel *&amp;gt; active_channels; int nfds = epoll_wait(epfd, events, MAX_EVENTS, timeout); errif(nfds == -1, &amp;#34;epoll wait error\n&amp;#34;); active_channels.reserve(nfds); for (int i = 0; i &amp;lt; nfds; ++i) { Channel *ch = (Channel *)events[i].</description>
    </item>
    <item>
      <title>Sublime Text4 使用 NeoVintageous 插件</title>
      <link>http://localhost:1313/posts/blog/sublime-neovim.zh/</link>
      <pubDate>Wed, 08 Nov 2023 19:08:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/sublime-neovim.zh/</guid>
      <description>安装插件 利用 Sublime Text4 的 package control 安装 NeoVintageous 插件。&#xA;启用ctrl + [作为esc 点击sublime Text -&amp;gt; settings -&amp;gt;settings，编辑右侧的配置文件，添加&amp;quot;vintageous_ctrl_keys&amp;quot;: true,。&#xA;启用jk为esc 点击sublime Text -&amp;gt; settings -&amp;gt;settings，编辑右侧的配置文件，添加&amp;quot;vintageous_i_escape_jk&amp;quot;: true,&#xA;使yy会复制到系统剪贴板 点击sublime Text -&amp;gt; settings -&amp;gt;settings，编辑右侧的配置文件，添加&amp;quot;vintageous_use_sys_clipboard&amp;quot;: true,</description>
    </item>
    <item>
      <title>vscode使用 vscode-neovim 插件</title>
      <link>http://localhost:1313/posts/blog/vscode-neovim.zh/</link>
      <pubDate>Wed, 08 Nov 2023 16:52:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/vscode-neovim.zh/</guid>
      <description>启用插件 Win11 插件设置：Settings-user页面，Neovim Executable Paths: Win32内容设置为C:\Users\zwyyy\scoop\apps\neovim\current\bin\nvim.exe，Neovim Init Vim Paths: Win32内容无需设置。&#xA;WSL 插件设置：Settings-Remote [WSL:Debian]页面，Neovim Executable Paths: Linux内容设置为/usr/bin/nvim，Neovim Init Vim Paths: Linux内容无需设置。&#xA;MacOS 插件设置：Settings-user页面，Neovim Executable Paths: Darwin 内容设置为 /opt/homebrew/bin/nvim，Neovim Init Vim Paths: Darwin 内容无需设置。&#xA;key bindings 中查找ctrl+c，删除与neovim有关的两项，否则会导致插入模式下无法使用ctrl+c复制（我没有选择删除）。&#xA;设置 jk 为 esc 已于 1.11.1 版本废弃 编辑 keybings.json，添加&#xA;{ &amp;#34;command&amp;#34;: &amp;#34;vscode-neovim.compositeEscape1&amp;#34;, &amp;#34;key&amp;#34;: &amp;#34;j&amp;#34;, &amp;#34;when&amp;#34;: &amp;#34;neovim.mode == insert &amp;amp;&amp;amp; editorTextFocus&amp;#34;, &amp;#34;args&amp;#34;: &amp;#34;j&amp;#34; }, { &amp;#34;command&amp;#34;: &amp;#34;vscode-neovim.compositeEscape2&amp;#34;, &amp;#34;key&amp;#34;: &amp;#34;k&amp;#34;, &amp;#34;when&amp;#34;: &amp;#34;neovim.mode == insert &amp;amp;&amp;amp; editorTextFocus&amp;#34;, &amp;#34;args&amp;#34;: &amp;#34;k&amp;#34; } 使用 gc 作为注释快捷键 已废弃 原先解决方案是在 neovim 的配置目录的 lua/vscode/config 目录下新建 keymaps.</description>
    </item>
    <item>
      <title>C&#43;&#43; 面经</title>
      <link>http://localhost:1313/posts/tech/cpp_interview.zh/</link>
      <pubDate>Tue, 07 Nov 2023 14:28:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/cpp_interview.zh/</guid>
      <description>1. 多态，虚函数 1. 什么是多态，如何实现多态(⭐⭐) 所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为；C++的多态分为编译时多态和运行时多态，编译时多态也称为为静态联编，通过重载和模板来实现，运行时多态称为动态联编，通过继承和虚函数来实现&#xA;2. 虚函数的实现机制(⭐⭐⭐) 虚函数是通过虚函数表来实现的，虚函数表包含了一个类(所有)的虚函数的地址，在有虚函数的类对象中，它内存空间的头部会有一个虚函数表指针(虚表指针)，用来管理虚函数表。当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当我们用一个父类的指针来操作子类对象的时候，它可以指明实际所调用的函数&#xA;3. 虚函数调用是在编译时确定还是运行时确定的，如何确定调用哪个函数 当使用指针或引用调用虚函数的时候，是运行时确定，通过查找虚函数表中的函数地址确定&#xA;而使用普通变量调用虚函数的时候，是编译器确定的，此时没有多态&#xA;虚函数表是在编译阶段生成的，存放在只读数据段.rodata(和全局常量、字符串常量存放在一起)&#xA;4. 在(基类的)构造函数和析构函数中调用虚函数会怎么样(⭐⭐) 从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）；因为调用构造函数的时候，是先进行父类成分的构造，再进行子类的构造。在父类构造期间，子类的特有成分还没有被初始化，此时下降到调用子类的虚函数，使用这些尚未初始化的数据一定会出错；同理，调用析构函数的时候，先对子类的成分进行析构，当进入父类的析构函数的时候，子类的特有成分已经销毁，此时是无法再调用虚函数实现多态的&#xA;5. C 语言可以实现虚函数机制吗，如何实现 需要做的工作：手动构造父子关系、创建虚函数表、设置虚表指针并指向虚函数表、填充虚函数表；当虚函数重写的时候还需要手动修改函数指针等等&#xA;6. 重载、重写和隐藏的区别(⭐⭐) 重载指的是同一个名字的函数，具有不同的参数列表（参数类型、个数），或不同的返回类型，根据参数列表和返回类型决定调用哪一个函数；&#xA;重写（覆盖）指的是，派生类中的函数重写了基类中的虚函数，重写的基类的中函数必须被声明为virtual，并且返回值，参数列表和基类中的函数一致(除非返回类型是基类/派生类的指针/引用)；&#xA;隐藏是指，派生类中的同名函数把基类中的同名函数隐藏了，包括所有的重载版本，不论是不是虚函数都会隐藏&#xA;7. 模板类可以有虚函数吗，模板函数可以是虚函数吗 模板类可以使用虚函数。但使用模板类定义不同的类型则是两个完全不同的类，即使两个泛型参数是父类和子类关系，两个泛型变量也没有任何父子关系&#xA;模板函数不能是虚函数。编译器都期望在处理类的定义的时候就能确定这个类的虚函数表的大小，如果允许有类的虚成员模板函数，那么就必须要求编译器提前知道程序中所有对该类的虚成员模板函数有多少个版本，才能分配虚函数表的大小，而这是不可行的&#xA;8. 内联函数可以是虚函数吗，静态函数可以是虚函数吗(⭐⭐) 内联函数表示在编译阶段进⾏函数体的替换操作(内联函数实际上不是函数)，⽽虚函数意味着在运⾏期间进⾏类型确定，要经过函数调用的过程，所以内联函数不能是虚函数(将函数同时声明inline virtual编译器会直接忽略inline) 静态函数不属于类对象而属于类，静态成员函数没有 this 指针，所以无法找到虚表，也就无法实现虚函数重写的功能，所以不能是虚函数 9. 多个基类的同名虚函数覆写问题(⭐) 假设一个子类继承两个基类，这两个基类都有一个虚函数func，那么直接用子类变量调用func就会出现歧义，因为不知道是哪一个func，其实就是不知道使用哪个虚表的信息&#xA;如果用这两个基类的指针指向这个子类变量，那么用这两个基类指针就能成功调用这个虚函数了，因为两个基类指针确定了是使用自己类的虚表&#xA;若子类又覆写了这个同名的虚函数，此时会将两个虚表中的该函数全部覆写，那直接用子类变量也能直接调用func，此时没有歧义，因为两个虚函数实现是一样的了&#xA;2. 内存与继承 1. C++ 中类对象的内存模型(布局)是怎么样的(⭐⭐⭐) 如果是有虚函数的话，虚函数表的指针始终存放在内存空间的头部&#xA;除了虚函数之外，内存空间会按照类的继承顺序(父类到子类)和字段的声明顺序布局&#xA;如果有多继承，每个包含虚函数的父类都会有自己的虚函数表，并且按照继承顺序布局(虚表指针 + 字段）；如果子类重写父类虚函数，都会在每一个相应的虚函数表中更新相应地址；如果子类有自己的新定义的虚函数或者非虚成员函数，也会加到第一个虚函数表的后面&#xA;如果有菱形继承，并采用了虚继承，则内存空间排列顺序为：各个父类(包含虚表)、子类、公共基类(虚基类，包含虚表)，并且各个父类不再拷贝虚基类中的数据成员&#xA;2. 菱形继承存在什么问题，如何解决 会存在二义性的问题，因为两个父类会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，也会导致编译错误。可以采用虚继承的方法解决这个问题，这样就只会创造一份公共基类的实例，不会造成二义性&#xA;在钻石继承时，使用最高层的公共基类指向最底层的派生类，就会报错，因为编译器不知道是指向哪个派生类的基类区域&#xA;3. C++ 是如何做内存管理的（有哪些内存区域）(⭐⭐⭐) 堆，使用malloc、free动态分配和释放空间，能分配较大的内存 栈，为函数的局部变量分配内存，能分配较小的内存 全局/静态存储区，用于存储全局变量和静态变量 常量存储区，专门用来存放常量 自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池 4. C++ 内存有哪些段 代码段.text存放函数代码 .bss段存放未初始化的全局变量，未初始化的全局静态变量和局部静态变量 数据段.data存放已经初始化的全局变量，已初始化的全局静态变量和局部静态变量 只读数据段.</description>
    </item>
    <item>
      <title>Vimium: 让你像使用 Vim 那样控制浏览器</title>
      <link>http://localhost:1313/posts/blog/vimium.zh/</link>
      <pubDate>Sun, 05 Nov 2023 17:05:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/vimium.zh/</guid>
      <description>简介 Vimium 则继承了 Vim 中的常用键位，让你在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。&#xA;Vim 快速上手 首先，在浏览器界面中输入 ? 即可唤出 Vimium 的默认快捷键列表。&#xA;常用快捷键 页面滚动与导航 快捷键 操作 j 向下滚动 k 向上滚动 h 向左滚动 l 向右滚动 u 向上滚动半屏 d 向下滚动半屏 r 重新加载当前页面 gg 移动到页面顶部 G 移动到页面底部 打开页面 快捷键 操作 yy 将当前页面的网址拷贝到剪贴板 yf 拷贝一条链接，会让你二次选择 p 在当前 tab 打开剪贴板中的链接 P 新建页面打开剪贴板中的链接 o 在当前 tab 打开特定网址或者书签、历史记录中的网址 O 在新 tab 中打开特定网址或者书签、历史记录中的网址 T 在打开的 tab 中搜索 b 在当前 tab 打开书签中的某网址 B 在新 tab 中打开书签中的某网址 查找 快捷键 操作 / 进入查找模式 n 向下循环查找 N 向上循环查找 历史导航 快捷键 操作 H 后退 L 前进 操作 tab 快捷键 操作 K, gt 移动到下一个 tab J, gt 移动到上一个 tab g0 移动到第一个 tab g$ 移动到最后一个 tab t 创建新 tab yt 复制当前 tab 一份 x 关闭当前 tab X 恢复关闭的 tab alt + p pin / unpin 当前 tab 其他 快捷键 操作 f 在当前 tab 打开页面中的某个链接，会需要你二次选择 F 在新 tab 中打开页面中的某个链接，会需要你二次选择 </description>
    </item>
    <item>
      <title>Neovim 快捷键配置</title>
      <link>http://localhost:1313/posts/blog/nvim_keymap.zh/</link>
      <pubDate>Sun, 05 Nov 2023 17:05:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/nvim_keymap.zh/</guid>
      <description>Vim 快捷键 这一部分是 Vim 的默认快捷键，例如 gg、dd 等。&#xA;normal 模式快捷键 按键 操作 按键 操作 i 切换到插入模式 : 切换到命令模式 h 左移一个字符 j 下移一个字符 k 上移一个字符 l 右移一个字符 0 移至行首 $ 移至行尾 ^ 移至本行第一个非空字符 w 向右移动一个单词 W 向右移动一个单词（以空格分隔） 2w 向右移动两个单词 2W 向右移动两个单词（以空格分隔） b 向左移动一个单词 B 向左移动一个单词（以空格分隔） 2b 向左移动 2 个单词 2B 向左移动 2 个单词（以空格分隔） G 移至文档末尾 gg 移至文档首行 a 光标后插入 A 移至行末插入 o 光标下插入一行 O 光标上插入一行 x 删除光标处字符 dw 删除一个词 d0 删至行首 d$ 删至行尾 d) 删至句末 dgg 删至文件开头 dG 删至文件末尾 dd 删除该行 2dd 删除两行 r 替换当前字符 R 切换到 REPLACE 模式 u 撤回操作 &amp;lt;C-r&amp;gt; 重做撤回的操作 yy 复制当前行 p 在当前行之后粘贴内容 P 在当前行之前粘贴内容 v 打开 VISUAL 模式菜单 V 切换到逐行选择的 VISUAL 模式 / 向后搜索 ?</description>
    </item>
    <item>
      <title>798.smallest Rotation With Highest Score</title>
      <link>http://localhost:1313/posts/leet/798.smallest-rotation-with-highest-score/</link>
      <pubDate>Mon, 23 Oct 2023 11:17:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/798.smallest-rotation-with-highest-score/</guid>
      <description>Description 798. Smallest Rotation with Highest Score (Hard) You are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point.&#xA;For example, if we have nums = [2,4,1,3,0], and we rotate by k = 2, it becomes [1,3,0,2,4].</description>
    </item>
    <item>
      <title>798. 得分最高的最小轮调 (Hard)</title>
      <link>http://localhost:1313/posts/leet/798.smallest-rotation-with-highest-score.zh/</link>
      <pubDate>Mon, 23 Oct 2023 11:17:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/798.smallest-rotation-with-highest-score.zh/</guid>
      <description>问题描述 798. 得分最高的最小轮调 (Hard)&#xA;给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]] 的形式。此后，任何值小于或等于其索 引的项都可以记作一分。&#xA;例如，数组为 nums = [2,4,1,3,0]，我们按 k = 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 &amp;gt; 0 [不计分]、 3 &amp;gt; 1 [不计分]、 0 &amp;lt;= 2 [计 1 分]、 2 &amp;lt;= 3 [计 1 分]， 4 &amp;lt;= 4 [计 1 分]。 在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最 小的下标 k 。&#xA;示例 1：&#xA;输入：nums = [2,3,1,4,0] 输出：3 解释： 下面列出了每个 k 的得分： k = 0, nums = [2,3,1,4,0], score 2 k = 1, nums = [3,1,4,0,2], score 3 k = 2, nums = [1,4,0,2,3], score 3 k = 3, nums = [4,0,2,3,1], score 4 k = 4, nums = [0,2,3,1,4], score 3 所以我们应当选择 k = 3，得分最高。 示例 2：</description>
    </item>
    <item>
      <title>1201. Ugly Number III (Medium)</title>
      <link>http://localhost:1313/posts/leet/1201.ugly-number-iii/</link>
      <pubDate>Tue, 17 Oct 2023 11:10:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1201.ugly-number-iii/</guid>
      <description>Description 1201. Ugly Number III (Medium)&#xA;An ugly number is a positive integer that is divisible by a, b, or c.&#xA;Given four integers n, a, b, and c, return the nᵗʰ ugly number.&#xA;Example 1:&#xA;Input: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3ʳᵈ is 4. Example 2:</description>
    </item>
    <item>
      <title>1201. 丑数 III (Medium)</title>
      <link>http://localhost:1313/posts/leet/1201.ugly-number-iii.zh/</link>
      <pubDate>Tue, 17 Oct 2023 11:10:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1201.ugly-number-iii.zh/</guid>
      <description>问题描述 1201. 丑数 III (Medium)&#xA;给你四个整数： n 、 a 、 b 、 c ，请你设计一个算法来找出第 n 个丑数。&#xA;丑数是可以被 a 或 b 或 c 整除的 正整数 。&#xA;示例 1：&#xA;输入：n = 3, a = 2, b = 3, c = 5 输出：4 解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2：&#xA;输入：n = 4, a = 2, b = 3, c = 4 输出：6 解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12.</description>
    </item>
    <item>
      <title>2652. Sum Multiples (Easy)</title>
      <link>http://localhost:1313/posts/leet/2652.sum-multiples/</link>
      <pubDate>Tue, 17 Oct 2023 10:59:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2652.sum-multiples/</guid>
      <description>Description 2652. Sum Multiples (Easy)&#xA;Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.&#xA;Return an integer denoting the sum of all numbers in the given range satisfying the constraint.&#xA;Example 1:&#xA;Input: n = 7 Output: 21 Explanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7.</description>
    </item>
    <item>
      <title>2652. 倍数求和 (Easy)</title>
      <link>http://localhost:1313/posts/leet/2652.sum-multiples.zh/</link>
      <pubDate>Tue, 17 Oct 2023 10:59:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2652.sum-multiples.zh/</guid>
      <description>问题描述 2652. 倍数求和 (Easy) 给你一个正整数 n ，请你计算在 [1，n] 范围内能被 3、 5、 7 整除的所有整数之和。&#xA;返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。&#xA;示例 1：&#xA;输入：n = 7 输出：21 解释：在 [1, 7] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7 。数字之和为 21 。 示例 2：&#xA;输入：n = 10 输出：40 解释：在 [1, 10] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9、10 。数字之和为 40 。 示例 3：&#xA;输入：n = 9 输出：30 解释：在 [1, 9] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9 。数字之和为 30 。 提示：&#xA;1 &amp;lt;= n &amp;lt;= 10³ 解题思路 这题由于数据范围给的小，暴力就能过，但是也有非暴力的方法。</description>
    </item>
    <item>
      <title>446. Arithmetic Slices II - Subsequence (Hard)</title>
      <link>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence/</link>
      <pubDate>Tue, 17 Oct 2023 10:27:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence/</guid>
      <description>Description 446. Arithmetic Slices II - Subsequence (Hard)&#xA;Given an integer array nums, return the number of all the arithmetic subsequences of nums.&#xA;A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.&#xA;For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences. For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.</description>
    </item>
    <item>
      <title>446. 等差数列划分 II - 子序列 (Hard)</title>
      <link>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence.zh/</link>
      <pubDate>Tue, 17 Oct 2023 10:27:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/446.arithmetic-slices-ii-subsequence.zh/</guid>
      <description>问题描述 446. 等差数列划分 II - 子序列 (Hard)&#xA;给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。&#xA;如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。&#xA;例如， [1, 3, 5, 7, 9]、 [7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。 再例如， [1, 1, 2, 5, 7] 不是等差序列。 数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。&#xA;例如， [2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 题目数据保证答案是一个 32-bit 整数。&#xA;示例 1：&#xA;输入：nums = [2,4,6,8,10] 输出：7 解释：所有的等差子序列为： [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10] 示例 2：&#xA;输入：nums = [7,7,7,7,7] 输出：16 解释：数组中的任意子序列都是等差子序列。 提示：</description>
    </item>
    <item>
      <title>260. Single Number III (Medium)</title>
      <link>http://localhost:1313/posts/leet/260.single-number-iii/</link>
      <pubDate>Mon, 16 Oct 2023 10:53:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/260.single-number-iii/</guid>
      <description>Description 260. Single Number III (Medium)&#xA;Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.&#xA;You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.&#xA;Example 1:&#xA;Input: nums = [1,2,1,3,2,5] Output: [3,5] Explanation: [5, 3] is also a valid answer.</description>
    </item>
    <item>
      <title>260. 只出现一次的数字 III (Medium)</title>
      <link>http://localhost:1313/posts/leet/260.single-number-iii.zh/</link>
      <pubDate>Mon, 16 Oct 2023 10:53:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/260.single-number-iii.zh/</guid>
      <description>问题描述 260. 只出现一次的数字 III (Medium)&#xA;给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两 个元素。你可以按 任意顺序 返回答案。&#xA;你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。&#xA;示例 1：&#xA;输入：nums = [1,2,1,3,2,5] 输出：[3,5] 解释：[5, 3] 也是有效的答案。 示例 2：&#xA;输入：nums = [-1,0] 输出：[-1,0] 示例 3：&#xA;输入：nums = [0,1] 输出：[1,0] 提示：&#xA;2 &amp;lt;= nums.length &amp;lt;= 3 * 10⁴ -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 除两个只出现一次的整数外， nums 中的其他数字都出现两次 解题思路 首先对所有数取异或，假设要找出来的元素分别为 $a$ 和 $b$，那么异或的结果就是 $c = a \oplus b$，我们考虑求 $c$ 的 lowbit，即 $c &amp;amp; (-c)$，那么我们就可以把所有元素分成两类，一类是 $nums[i] &amp;amp; lowbit = 0$，另一类是不为 $0$，$a$ 和 $b$ 一定是各属于一类，如果第一类元素的所有值的异或就是 $a$，那么第二类所有元素的异或值就是 $b$。</description>
    </item>
    <item>
      <title>137. Single Number II (Medium)</title>
      <link>http://localhost:1313/posts/leet/137.single-number-ii/</link>
      <pubDate>Mon, 16 Oct 2023 10:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/137.single-number-ii/</guid>
      <description>Description 137. Single Number II (Medium)&#xA;Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.&#xA;You must implement a solution with a linear runtime complexity and use only constant extra space.&#xA;Example 1:&#xA;Input: nums = [2,2,3,2] Output: 3 Example 2:&#xA;Input: nums = [0,1,0,1,0,1,99] Output: 99 Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 3 * 10⁴ -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 Each element in nums appears exactly three times except for one element which appears once.</description>
    </item>
    <item>
      <title>137. 只出现一次的数字 II (Medium)</title>
      <link>http://localhost:1313/posts/leet/137.single-number-ii.zh/</link>
      <pubDate>Mon, 16 Oct 2023 10:43:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/137.single-number-ii.zh/</guid>
      <description>问题描述 137. 只出现一次的数字 II (Medium) 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。 请你找出并 返回那个只出现了一次的元素。&#xA;你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。&#xA;示例 1：&#xA;输入：nums = [2,2,3,2] 输出：3 示例 2：&#xA;输入：nums = [0,1,0,1,0,1,99] 输出：99 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 3 * 10⁴ -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 解题思路 要想保证空间复杂度为 $O(1)$，我们需要考虑 nums 的二进制表示，即统计 nums[i] 的每一位上的数的和，由于只有一个元素出现一次，其他都出现了三次，那么我们对这个和 $ \mod 3$，得到的结果就是待找出的元素的每一位上的数。&#xA;代码 class Solution { public: int singleNumber(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; cnt(32); int n = nums.</description>
    </item>
    <item>
      <title>2906. Construct Product Matrix (Medium)</title>
      <link>http://localhost:1313/posts/leet/2906.construct-product-matrix/</link>
      <pubDate>Mon, 16 Oct 2023 10:37:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2906.construct-product-matrix/</guid>
      <description>Description 2906. Construct Product Matrix (Medium)&#xA;Given a 0-indexed 2D integer matrix grid of size n * m, we define a 0-indexed 2D matrix p of size n * m as the product matrix of grid if the following condition is met:&#xA;Each element p[i][j] is calculated as the product of all elements in grid except for the element grid[i][j]. This product is then taken modulo 12345. Return the product matrix of grid.</description>
    </item>
    <item>
      <title>2906. 构造乘积矩阵 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2906.construct-product-matrix.zh/</link>
      <pubDate>Mon, 16 Oct 2023 10:36:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2906.construct-product-matrix.zh/</guid>
      <description>问题描述 2906. 构造乘积矩阵 (Medium)&#xA;给你一个下标从 0 开始、大小为 n * m 的二维整数矩阵 grid ，定义一个下标从 0 开始、大小为 n * m 的的二维矩阵 p。如果满足以下条件，则称 p 为 grid 的 乘积矩阵 ：&#xA;对于每个元素 p[i][j] ，它的值等于除了 grid[i][j] 外所有元素的乘积。乘积对 12345 取余数。 返回 grid 的乘积矩阵。&#xA;示例 1：&#xA;输入：grid = [[1,2],[3,4]] 输出：[[24,12],[8,6]] 解释：p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24 p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12 p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8 p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6 所以答案是 [[24,12],[8,6]] 。 示例 2：</description>
    </item>
    <item>
      <title>1074. Number of Submatrices That Sum to Target (Hard)</title>
      <link>http://localhost:1313/posts/leet/1074.number-of-submatrices-that-sum-to-target/</link>
      <pubDate>Fri, 13 Oct 2023 11:28:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1074.number-of-submatrices-that-sum-to-target/</guid>
      <description>Description 1074. Number of Submatrices That Sum to Target (Hard)&#xA;Given a matrix and a target, return the number of non-empty submatrices that sum to target.&#xA;A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 &amp;lt;= x &amp;lt;= x2 and y1 &amp;lt;= y &amp;lt;= y2.&#xA;Two submatrices (x1, y1, x2, y2) and (x1&#39;, y1&#39;, x2&#39;, y2&#39;) are different if they have some coordinate that is different: for example, if x1 !</description>
    </item>
    <item>
      <title>1074. 元素和为目标值的子矩阵数量 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1074.number-of-submatrices-that-sum-to-target.zh/</link>
      <pubDate>Fri, 13 Oct 2023 11:27:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1074.number-of-submatrices-that-sum-to-target.zh/</guid>
      <description>问题描述 1074. 元素和为目标值的子矩阵数量 (Hard)&#xA;给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。&#xA;子矩阵 x1, y1, x2, y2 是满足 x1 &amp;lt;= x &amp;lt;= x2 且 y1 &amp;lt;= y &amp;lt;= y2 的所有单元 matrix[x][y] 的集合。&#xA;如果 (x1, y1, x2, y2) 和 (x1&#39;, y1&#39;, x2&#39;, y2&#39;) 两个子矩阵中部分坐标不同（如： x1 != x1&#39;），那么 这两个子矩阵也不同。&#xA;示例 1：&#xA;输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 输出：4 解释：四个只含 0 的 1x1 子矩阵。 示例 2：&#xA;输入：matrix = [[1,-1],[-1,1]], target = 0 输出：5 解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。 示例 3：</description>
    </item>
    <item>
      <title>2251. Number of Flowers in Full Bloom (Hard)</title>
      <link>http://localhost:1313/posts/leet/2251.number-of-flowers-in-full-bloom/</link>
      <pubDate>Fri, 06 Oct 2023 20:33:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2251.number-of-flowers-in-full-bloom/</guid>
      <description>Descriptio 2251. Number of Flowers in Full Bloom (Hard)&#xA;You are given a 0-indexed 2D integer array flowers, where flowers[i] = [startᵢ, endᵢ] means the iᵗʰ flower will be in full bloom from startᵢ to endᵢ ( inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the iᵗʰ person will arrive to see the flowers.&#xA;Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the iᵗʰ person arrives.</description>
    </item>
    <item>
      <title>2251. 花期内花的数目 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2251.number-of-flowers-in-full-bloom.zh/</link>
      <pubDate>Fri, 06 Oct 2023 20:25:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2251.number-of-flowers-in-full-bloom.zh/</guid>
      <description>问题描述 2251. 花期内花的数目 (Hard)&#xA;给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [startᵢ, endᵢ] 表示第 i 朵 花的 花期 从 startᵢ 到 endᵢ （都 包含）。同时给你一个下标从 0 开始大小为 n 的整数 数组 people ， people[i] 是第 i 个人来看花的时间。&#xA;请你返回一个大小为 n 的整数数组 answer ，其中 answer[i] 是第 i 个人到达时在花期内花的 **数目 ** 。&#xA;示例 1：&#xA;输入：flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11] 输出：[1,2,2,2] 解释：上图展示了每朵花的花期时间，和每个人的到达时间。 对每个人，我们返回他们到达时在花期内花的数目。 示例 2：&#xA;输入：flowers = [[1,10],[3,3]], people = [3,3,2] 输出：[2,2,1] 解释：上图展示了每朵花的花期时间，和每个人的到达时间。 对每个人，我们返回他们到达时在花期内花的数目。 提示：</description>
    </item>
    <item>
      <title>差分数组</title>
      <link>http://localhost:1313/posts/tech/difference_array.zh/</link>
      <pubDate>Fri, 06 Oct 2023 17:50:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/difference_array.zh/</guid>
      <description>介绍 考虑原数组为 $[1, 3, 3, 5, 8]$，我们对相邻元素做差，用 $a_i - a_{i - 1}$，可以得到一个差分数组 $[1, 2, 0, 2, 3]$ $diff$，我们认为 $a_{-1}$ 为 $0$，因此&#xA;$$diff[i] = \begin{cases} a[0] &amp;amp; i = 0 \newline a[i] - a[i - 1] &amp;amp; i &amp;gt; 0\end{cases}$$&#xA;性质 差分数组往往和前缀和数组放在一块讨论，事实上，差分数组的前缀和即可还原出原数组。即：&#xA;$$ a[k] = \sum\limits_{i = 0}^k diff[i]$$&#xA;差分数组还有一个非常重要的性质，那就是它可以将区间修改（将区间中的每个元素都加一个值或者减一个值）变成单点修改。&#xA;例如，加入我们要将区间 $[i, j]$ 中的每个元素都加 $c$，那么我们只需要将 $diff[i]$ 加 $c$，并将 $diff[j + 1]$ 减去 $c$ 即可，由这个差分数组取前缀和还原出来的原数组，就是我们修改后的原数组。</description>
    </item>
    <item>
      <title>2136.earliest Possible Day of Full Bloom</title>
      <link>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom/</link>
      <pubDate>Thu, 05 Oct 2023 18:28:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom/</guid>
      <description>Descriptio 2136. Earliest Possible Day of Full Bloom (Hard) You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:&#xA;plantTime[i] is the number of full days it takes you to plant the iᵗʰ seed. Every day, you can work on planting exactly one seed.</description>
    </item>
    <item>
      <title>2136. 全部开花的最早一天 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom.zh/</link>
      <pubDate>Thu, 05 Oct 2023 18:28:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2136.earliest-possible-day-of-full-bloom.zh/</guid>
      <description>问题描述 2136. 全部开花的最早一天 (Hard)&#xA;你有 n 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你 两个下标从 0 开始的整数数组 plantTime 和 growTime ，每个数组的长度都是 n ：&#xA;plantTime[i] 是 播种 第 i 枚种子所需的 完整天数 。每天，你只能为播种某一枚种子而劳作。 无须 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 plantTime[i] 之后才算完成。 growTime[i] 是第 i 枚种子完全种下后生长所需的 完整天数。在它生长的最后一天 之后 ，将会 开花并且永远 绽放 。 从第 0 开始，你可以按 任意 顺序播种种子。&#xA;返回所有种子都开花的 最早 一天是第几天。&#xA;示例 1：&#xA;输入：plantTime = [1,4,3], growTime = [2,3,1] 输出：9 解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 一种最优方案是： 第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。 第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。 第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。 因此，在第 9 天，所有种子都开花。 示例 2：</description>
    </item>
    <item>
      <title>188. Best Time to Buy and Sell Stock IV (Hard)</title>
      <link>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv/</link>
      <pubDate>Thu, 05 Oct 2023 16:16:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv/</guid>
      <description>Description 188. Best Time to Buy and Sell Stock IV (Hard)&#xA;You are given an integer array prices where prices[i] is the price of a given stock on the iᵗʰ day, and an integer k.&#xA;Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.&#xA;Note: You may not engage in multiple transactions simultaneously (i.</description>
    </item>
    <item>
      <title>188. 买卖股票的最佳时机 IV (Hard)</title>
      <link>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv.zh/</link>
      <pubDate>Thu, 05 Oct 2023 16:16:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/188.best-time-to-buy-and-sell-stock-iv.zh/</guid>
      <description>问题描述 188. 买卖股票的最佳时机 IV (Hard)&#xA;给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。&#xA;设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。&#xA;注意： 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&#xA;示例 1：&#xA;输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2：&#xA;输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获 得利润 = 3-0 = 3 。 提示：</description>
    </item>
    <item>
      <title>310. Minimum Height Trees (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees/</guid>
      <description>Description 310. Minimum Height Trees (Medium)&#xA;A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.&#xA;Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [aᵢ, bᵢ] indicates that there is an undirected edge between the two nodes aᵢ and bᵢ in the tree, you can choose any node of the tree as the root.</description>
    </item>
    <item>
      <title>310. 最小高度树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</link>
      <pubDate>Tue, 19 Sep 2023 14:15:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/310.minimum-height-trees.zh/</guid>
      <description>问题描述 310. 最小高度树 (Medium)&#xA;树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵 树。&#xA;给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条无 向边。&#xA;可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中， 具有最小高度的树（即， min(h)）被称为 最小高度树 。&#xA;请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。&#xA;树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。&#xA;示例 1：&#xA;输入：n = 4, edges = [[1,0],[1,2],[1,3]] 输出：[1] 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 示例 2：&#xA;输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] 输出：[3,4] 提示：</description>
    </item>
    <item>
      <title>331. Verify Preorder Serialization of a Binary Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree/</link>
      <pubDate>Wed, 13 Sep 2023 11:10:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree/</guid>
      <description>Description 331. Verify Preorder Serialization of a Binary Tree (Medium)&#xA;One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node&amp;rsquo;s value. If it is a null node, we record using a sentinel value such as &#39;#&#39;.&#xA;For example, the above binary tree can be serialized to the string &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;, where &#39;#&#39; represents a null node.&#xA;Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.</description>
    </item>
    <item>
      <title>331.verify Preorder Serialization of a Binary Tree</title>
      <link>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree.zh/</link>
      <pubDate>Wed, 13 Sep 2023 11:10:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/331.verify-preorder-serialization-of-a-binary-tree.zh/</guid>
      <description>问题描述 331. 验证二叉树的前序序列化 (Medium)&#xA;序列化二叉树的一种方法是使用 前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如 果它是一个空节点，我们可以使用一个标记值记录，例如 #。&#xA;例如，上面的二叉树可以被序列化为字符串 &amp;quot;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;quot;，其中 # 代表一个空节点。&#xA;给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法 。&#xA;保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 &#39;#&#39; 。&#xA;你可以认为输入格式总是有效的&#xA;例如它永远不会包含两个连续的逗号，比如 &amp;quot;1,,3&amp;quot; 。 注意： 不允许重建树。&#xA;示例 1:&#xA;输入: preorder = &amp;#34;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;#34; 输出: true 示例 2:&#xA;输入: preorder = &amp;#34;1,#&amp;#34; 输出: false 示例 3:&#xA;输入: preorder = &amp;#34;9,#,#,1&amp;#34; 输出: false 提示:&#xA;1 &amp;lt;= preorder.length &amp;lt;= 10⁴ preorder 由以逗号 “，” 分隔的 [0,100] 范围内的整数和 “#” 组成 解题思路 归约 本质上还是一种递归的思想，在前序遍历时，我们可以注意到，每个叶子结点必定跟随两个 null，因此，我们可以反过来，将连续的一个非空结点和两个空结点，归约为一个空结点，这个过程有点像消消乐，可以利用栈来实现这个过程，最后根据栈是否只剩下一个空结点来判断。&#xA;递归 递归的思路参照 剑指 Offer 37.</description>
    </item>
    <item>
      <title>1462.course Schedule Iv</title>
      <link>http://localhost:1313/posts/leet/1462.course-schedule-iv/</link>
      <pubDate>Tue, 12 Sep 2023 20:14:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1462.course-schedule-iv/</guid>
      <description>Description 1462. Course Schedule IV (Medium)&#xA;There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [aᵢ, bᵢ] indicates that you must take course aᵢ first if you want to take course bᵢ.&#xA;For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1. Prerequisites can also be indirect.</description>
    </item>
    <item>
      <title>1462. 课程表 IV (Medium)</title>
      <link>http://localhost:1313/posts/leet/1462.course-schedule-iv.zh/</link>
      <pubDate>Tue, 12 Sep 2023 20:14:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1462.course-schedule-iv.zh/</guid>
      <description>问题描述 1462. 课程表 IV (Medium)&#xA;你总共需要上 numCourses 门课，课程编号依次为 0 到 numCourses-1 。你会得到一个数组 prerequisit e ，其中 prerequisites[i] = [aᵢ, bᵢ] 表示如果你想选 bᵢ 课程，你 必须 先选 aᵢ 课程。&#xA;有的课会有直接的先修课程，比如如果想上课程 1 ，你必须先上课程 0 ，那么会以 [0,1] 数对的形式 给出先修课程数对。 先决条件也可以是 间接 的。如果课程 a 是课程 b 的先决条件，课程 b 是课程 c 的先决条件，那 么课程 a 就是课程 c 的先决条件。&#xA;你也得到一个数组 queries ，其中 queries[j] = [uⱼ, vⱼ]。对于第 j 个查询，您应该回答课程 uⱼ 是 否是课程 vⱼ 的先决条件。&#xA;返回一个布尔数组 answer ，其中 answer[j] 是第 j 个查询的答案。</description>
    </item>
    <item>
      <title>解决 vscode remote 无法通过 frp 连接到内网机器的问题</title>
      <link>http://localhost:1313/posts/blog/vscode-frp-solve.zh/</link>
      <pubDate>Mon, 11 Sep 2023 14:58:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/vscode-frp-solve.zh/</guid>
      <description>问题描述 本人有一台无公网 ip 的 Debian 主机，为了能够远程连接上去写代码，因此配置好了 frp，frp 服务商是公益性质的 mossfrp，之前都正常运行，vscode remote 可以正常连接上去使用，体验与本地开发基本一致。然而昨天，突然就莫名其妙地出现了问题，当我 vscode 连接上去之后，会很快断开连接，然后显示重连失败，如下图所示：&#xA;在 vscode 也看不到相关的日志输出。试过重启大法，依旧无效。&#xA;问题解决 本着排除法的原则，我借同学的 windows 电脑上的测试了一下，在它的电脑上，vscode remote 是能正常通过 frp 连接到我的内网机器的，并且不会出现自动断开的情况。此时，我推测可能是 vscode 或者操作系统的问题（这个概率不大）。&#xA;后来在 vscode 的 github 的 issue 中一搜，已经有相关的 issue 了，是 vscode remote 这个扩展在 0.106.1 版本的问题，可以通过降级插件或者切换到最新的预览版解决，又或者是将 remote.SSH.useExecServer 设置为 false。</description>
    </item>
    <item>
      <title>109. Convert Sorted List to Binary Search Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Mon, 11 Sep 2023 14:40:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree/</guid>
      <description>Description 109. Convert Sorted List to Binary Search Tree (Medium)&#xA;Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balancedbinary search tree.&#xA;Example 1:&#xA;Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST. Example 2:&#xA;Input: head = [] Output: [] Constraints:&#xA;The number of nodes in head is in the range [0, 2 * 10⁴].</description>
    </item>
    <item>
      <title>109. 有序链表转换二叉搜索树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree.zh/</link>
      <pubDate>Mon, 11 Sep 2023 14:40:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/109.convert-sorted-list-to-binary-search-tree.zh/</guid>
      <description>问题描述 109. 有序链表转换二叉搜索树 (Medium)&#xA;给定一个单链表的头节点 head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。&#xA;本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。&#xA;示例 1:&#xA;输入: head = [-10,-3,0,5,9] 输出: [0,-3,9,-10,null,5] 解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。 示例 2:&#xA;输入: head = [] 输出: [] 提示:&#xA;head 中的节点数在 [0, 2 * 10⁴] 范围内 -10⁵ &amp;lt;= Node.val &amp;lt;= 10⁵ 解题思路 首先，如果将链表换成数组，可以很方便地在 $O(n)$ 时间内完成，然后由于链表无法像数组那样在 $O(1)$ 时间内实现随机访问，因此不能套用数组的思路。&#xA;我们首先要想到，对二叉搜索树进行中序遍历，就能得到一个升序链表，那么我们也可以通过一个类似中序遍历的过程，得到二叉搜索树。即先计算左子结点，根结点就是当前遍历到的链表结点，然后计算右子结点。&#xA;代码 class Solution { public: TreeNode *dfs(int l, int r, ListNode **head) { if (l &amp;gt;= r) { return nullptr; } int mid = l + (r - l) / 2; TreeNode *left = dfs(l, mid, head); TreeNode *root = new TreeNode((*head)-&amp;gt;val); root-&amp;gt;left = left; *head = (*head)-&amp;gt;next; root-&amp;gt;right = dfs(mid + 1, r, head); return root; } TreeNode *sortedListToBST(ListNode *head) { // 牢记，二叉搜索树的中序遍历结果是一个升序数组 ListNode *tail = head; int cnt = 0; while (tail !</description>
    </item>
    <item>
      <title>99. 恢复二叉搜索树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/99.recover-binary-search-tree.zh/</link>
      <pubDate>Fri, 08 Sep 2023 10:15:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/99.recover-binary-search-tree.zh/</guid>
      <description>问题描述 99. 恢复二叉搜索树 (Medium)&#xA;给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下 ，恢复这棵树 。&#xA;示例 1：&#xA;输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 的左孩子，因为 3 &amp;gt; 1 。交换 1 和 3 使二叉搜索树有效。 示例 2：&#xA;输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 &amp;lt; 3 。交换 2 和 3 使二叉搜索树有效。 提示：&#xA;树上节点的数目在范围 [2, 1000] 内 -2³¹ &amp;lt;= Node.val &amp;lt;= 2³¹ - 1 进阶： 使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用 O(1) 空间的解决方案吗？&#xA;解题思路 这里就直接考虑 $O(1)$ 时间复杂度的解法了，首先我们知道，对二叉搜索树进行中序遍历，其结点值是严格递增的，因此，我们可以利用这一点来找出被交换的两个节点。&#xA;我们考虑一个递增序列，然后交换序列中任意两个元素，如果这两个元素是相邻的，那么当我们遍历时，会出现一次 $a_{i} &amp;lt; a_{i - 1}$ 的情况；而如果这两个元素不相邻，那么会出现两次 $a_{i} &amp;lt; a_{i - 1}$ 的情况。我们将出现 $a_{i} &amp;lt; a_{i - 1}$ 的元素对都存入数组 vec，那么 vec.</description>
    </item>
    <item>
      <title>99. Recover Binary Search Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/99.recover-binary-search-tree/</link>
      <pubDate>Fri, 08 Sep 2023 10:15:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/99.recover-binary-search-tree/</guid>
      <description>Description 99. Recover Binary Search Tree (Medium)&#xA;You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.&#xA;Example 1:&#xA;Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 &amp;gt; 1. Swapping 1 and 3 makes the BST valid. Example 2:</description>
    </item>
    <item>
      <title>31.next Permutation</title>
      <link>http://localhost:1313/posts/leet/31.next-permutation/</link>
      <pubDate>Tue, 08 Aug 2023 13:32:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/31.next-permutation/</guid>
      <description></description>
    </item>
    <item>
      <title>31. 下一个排列 (Medium)</title>
      <link>http://localhost:1313/posts/leet/31.next-permutation.zh/</link>
      <pubDate>Tue, 08 Aug 2023 13:32:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/31.next-permutation.zh/</guid>
      <description>问题描述 31. 下一个排列 (Medium)&#xA;整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。&#xA;例如， arr = [1,2,3] ，以下这些都可以视作 arr 的排列： [1,2,3]、 [1,3,2]、 [3,1,2]、 [2 ,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典 顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如 果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。&#xA;例如， arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地， arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。&#xA;必须 原地 修改，只允许使用 额外常数空间。&#xA;示例 1：&#xA;输入：nums = [1,2,3] 输出：[1,3,2] 示例 2：&#xA;输入：nums = [3,2,1] 输出：[1,2,3] 示例 3：</description>
    </item>
    <item>
      <title>287.find the Duplicate Number</title>
      <link>http://localhost:1313/posts/leet/287.find-the-duplicate-number/</link>
      <pubDate>Fri, 04 Aug 2023 10:59:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/287.find-the-duplicate-number/</guid>
      <description>Solution Binary search The duality of this section is somewhat convoluted. Let us assume that the repeated digit is denoted by $k$. For the array nums, there are more than $k$ occurrences of numbers between $1$ and $k$. Therefore, for a given $mid$, if the count of numbers between $1$ and $mid$ exceeds $mid$, this indicates that $mid \geq k$, otherwise $mid &amp;lt; k$.&#xA;Two pointers Here, we can visualize the array as a singly-linked list.</description>
    </item>
    <item>
      <title>287. 寻找重复数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/287.find-the-duplicate-number.zh/</link>
      <pubDate>Fri, 04 Aug 2023 10:59:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/287.find-the-duplicate-number.zh/</guid>
      <description>问题描述 287. 寻找重复数 (Medium)&#xA;给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存 在一个重复的整数。&#xA;假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。&#xA;你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。&#xA;示例 1：&#xA;输入：nums = [1,3,4,2,2] 输出：2 示例 2：&#xA;输入：nums = [3,1,3,4,2] 输出：3 提示：&#xA;1 &amp;lt;= n &amp;lt;= 10⁵ nums.length == n + 1 1 &amp;lt;= nums[i] &amp;lt;= n nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 进阶：&#xA;如何证明 nums 中至少存在一个重复的数字?</description>
    </item>
    <item>
      <title>Xv6 Lab11: Mmap</title>
      <link>http://localhost:1313/posts/tech/xv6-lab11.zh/</link>
      <pubDate>Thu, 03 Aug 2023 13:53:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/xv6-lab11.zh/</guid>
      <description>思路与实现 添加系统调用就不多说了。&#xA;整体流程应该是这样的，lab 的提示中，要求我们定义一个 vma 结构体，vma 的定义如下；然后 lab 的提示要求我们声明一个大小为 $16$ 的 vma 数组，并按需要从该数组分配，问题来了，数组在哪里声明呢？考虑到每个进程都有自己的虚拟地址空间，因此，每个进程都有自己的 virtual memory areas，要分配 vma 的时候，应该从每个进程自己的 vma 数组进行分配，于是，我们可以考虑为 struct proc 添加 struct vma areas[NVMA] 字段。&#xA;struct vma { int fd; int rw_flag; uint64 start; uint64 cur; uint len; int state; int flags; }; struct proc { // 已有的省略不写 struct vma areas[NVMA]; }; 在 vma 的定义中，start 表示起始地址，$[start, cur)$ 这一段虚拟地址（左闭右开）是已经绑定了 pp 的，pp 的数据与 file 绑定。&#xA;那么我们如何实现 sys_mmap 呢？这里可以参照 sbrk，递增 p-&amp;gt;sz，然后仿照 allocproc，寻找状态为 UNUSED 的 vma，分配给本次 sys_mmap。注意如果文件本身是 read_only，并且以 MAP_SHARED 模式进行 map，那么 flags 不能为 PROT_WRITE，write only 的情况同理（即文件不可读）。</description>
    </item>
    <item>
      <title>Xv6 Lab10: file system</title>
      <link>http://localhost:1313/posts/tech/xv6-lab10.zh/</link>
      <pubDate>Tue, 01 Aug 2023 20:19:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/xv6-lab10.zh/</guid>
      <description>Large files 这个作业需要我们将 xv6 的最大文件大小从 12 + 256 Bytes 修改为 11 + 256 + 256 * 256 Bytes。&#xA;为了达成这个目标，我们需要使用二级索引块，对 inode 的 addrs 字段，首先将 NDIRECT 从 $12$ 修改为 $11$，即前 $11$ 个 block 是 direct block，addrs[NDIRECT] 对应的块是一个一级索引块，这个块中的每个元素（共 BSIZE / sizeof(uint) 个元素）都是一个数据块的编号；而 addrs[NDIRECT + 1] 是一个二级索引块，这个块中的每个元素都是一级索引块的编号，由编号找到一级索引块，然后再由以及索引块找到数据块。&#xA;这个作业的主要任务就是修改 bmap 和 itrunc 两个函数。&#xA;先修改 fs.h 中的 NDIRECT 的相关定义：&#xA;#define FSMAGIC 0x10203040 #define NDIRECT 11 #define NINDIRECT (BSIZE / sizeof(uint)) #define NDINDIRECT (NINDIRECT * NINDIRECT) #define MAXFILE (NDIRECT + NINDIRECT + NDINDIRECT) struct dinode { short type; // File type short major; // Major device number (T_DEVICE only) short minor; // Minor device number (T_DEVICE only) short nlink; // Number of links to inode in file system uint size; // Size of file (bytes) uint addrs[NDIRECT + 2]; // Data block addresses }; 注意 file.</description>
    </item>
    <item>
      <title>Xv6 Lab9: Locks</title>
      <link>http://localhost:1313/posts/tech/xv6-lab9.zh/</link>
      <pubDate>Sat, 29 Jul 2023 14:28:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/xv6-lab9.zh/</guid>
      <description>Memory allocator 这一题很简单，主要任务，就是为每个 cpu 维护一个空闲物理内存的链表 freelist，xv6 默认使用的结构体 kmem，其中包含一个 freelist 供所有的 cpu 使用。我们要做的，就是把 freelist 修改成 freelist 的数组，即 struct run *freelist[NCPU]，其中 NCPU 是定义于 kernel/params.h 的宏，对应 cpu 的个数。 kmem 中的 spinlock 是用来保护 freelist 的，既然 freelist 变成了数组，那么也需要有 NCPU 个 spinlock。因此，修改 kmem 为如下结构体：&#xA;struct { struct spinlock lock[NCPU]; struct run *freelist[NCPU]; // for each cpu, allocate a freelist } kmem; 接着，我们需要修改 kinit，让它初始化每个 spinlock。&#xA;void kinit() { char lockname[6] = {&amp;#39;k&amp;#39;, &amp;#39;m&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;m&amp;#39;, &amp;#39;0&amp;#39;, 0}; for (int i = 0; i &amp;lt; NCPU; ++i) { lockname[4] = &amp;#39;0&amp;#39; + i; initlock(kmem.</description>
    </item>
    <item>
      <title>虚拟内存</title>
      <link>http://localhost:1313/posts/tech/virtual_memory.zh/</link>
      <pubDate>Fri, 28 Jul 2023 19:55:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/virtual_memory.zh/</guid>
      <description>虚拟地址空间与物理地址空间 地址空间（address space）是一个非负整数地址的有序集合：&#xA;$$\lbrace 0, 1, 2, \cdots\rbrace$$&#xA;如果地址空间中的整数是连续的，那么我们说它是个线性地址空间（linear address space），为了简化讨论，我们总是假设我们使用的是线性地址空间。&#xA;地址空间的大小由表示最大地址所需的位数来决定，例如 $N - 1= 2^n - 1$，因此最大地址需要 $n$ 位数来表示，于是一个包含 $N = 2^n$ 个地址的地址空间就叫一个 $n$ 位地址空间。&#xA;虚拟地址空间 在一个带虚拟内存的系统中，CPU 由 $N=2^n$ 的地址空间中生成虚拟地址，这个虚拟地址的有序集合称为虚拟地址空间（virtual address space）：&#xA;$$ \lbrace 0, 1, 2, \cdots N - 1\rbrace$$&#xA;这个地址空间是 $n$ 位的。&#xA;物理地址空间 一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的 $M$ 个字节：&#xA;$$\lbrace0,1,2,\cdots,M-1\rbrace$$&#xA;$M$ 并不要求是 $2$ 的幂，例如可能是 $12GB$，但是为了简化讨论，我们假设 $M=2^m$，即地址空间是 $m$ 位的。&#xA;物理内存作为虚拟内存的缓存 概念上而言，虚拟内存被组织为一个存放在磁盘上的由 $N=2^n$ 个连续字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，作为到数组的索引；对应的，计算机的主存（main memory，后面简称内存）被组织成一个由 $M=2^m$ 个连续的字节大小的单元组成的数组，每字节都有一个唯一的物理地址。&#xA;VM（Virtual Memory）系统通过将虚拟内存分割为称为虚拟页（Virtual Page，VP）的大小固定的块来处理这个问题，每个虚拟页的大小为 $P=2^p$ 字节。相应的，物理内存被分割为物理页（Physical Page，PP）来处理，大小也为 P 字节。这里的物理页就像是 SRAM cache 中的 block。</description>
    </item>
    <item>
      <title>2050. Parallel Courses III (Hard)</title>
      <link>http://localhost:1313/posts/leet/2050.parallel-courses-iii/</link>
      <pubDate>Fri, 28 Jul 2023 15:59:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2050.parallel-courses-iii/</guid>
      <description>Description 2050. Parallel Courses III (Hard)&#xA;Solution The approach to this problem is quite evident, and it requires the utilization of topological sorting. During the process oftopological sorting, the longest required time should be calculated.&#xA;Code class Solution { public: int minimumTime(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;relations, vector&amp;lt;int&amp;gt; &amp;amp;time) { vector&amp;lt;int&amp;gt; cnt(n + 1); vector&amp;lt;unordered_set&amp;lt;int&amp;gt;&amp;gt; next(n + 1); for (auto &amp;amp;vec : relations) { ++cnt[vec[1]]; next[vec[0]].insert(vec[1]); } queue&amp;lt;int&amp;gt; zero; // vector&amp;lt;int&amp;gt; res; vector&amp;lt;int&amp;gt; ans(n + 1); for (int i = 1; i &amp;lt;= n; ++i) { if (cnt[i] == 0) { zero.</description>
    </item>
    <item>
      <title>2050. 并行课程 III (Hard)</title>
      <link>http://localhost:1313/posts/leet/2050.parallel-courses-iii.zh/</link>
      <pubDate>Fri, 28 Jul 2023 15:59:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2050.parallel-courses-iii.zh/</guid>
      <description>问题描述 2050. 并行课程 III (Hard)&#xA;给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ， 其中 relations[j] = [prevCourseⱼ, nextCourseⱼ] ，表示课程 prevCourseⱼ 必须在课程 nextCourseⱼ * 之前* 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完 成第 (i+1) 门课程需要花费的 月份 数。&#xA;请你根据以下规则算出完成所有课程所需要的 最少 月份数：&#xA;如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。 你可以 同时 上 任意门课程 。 请你返回完成所有课程所需要的 最少 月份数。&#xA;注意： 测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。&#xA;示例 1:&#xA;输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5] 输出：8 解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。 你可以在月份 0 同时开始课程 1 和 2 。 课程 1 花费 3 个月，课程 2 花费 2 个月。 所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。 示例 2：</description>
    </item>
    <item>
      <title>335. Self Crossing (Hard)</title>
      <link>http://localhost:1313/posts/leet/335.self-crossing/</link>
      <pubDate>Fri, 28 Jul 2023 14:16:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/335.self-crossing/</guid>
      <description>Description 335. Self Crossing (Hard)&#xA;Solution We can simulate the movement of the robot and consider the possible collisions with other tracks. For example, when moving north, the robot may intersect with tracks moving west, east, or north. Similarly, when moving west, the robot may collide with tracks moving north, south, or west. We can continue this process for other directions as well.&#xA;For instance, when moving west, we can consider the conditions for collisions with tracks moving north, south, or west.</description>
    </item>
    <item>
      <title>335. 路径交叉 (Hard)</title>
      <link>http://localhost:1313/posts/leet/335.self-crossing.zh/</link>
      <pubDate>Fri, 28 Jul 2023 14:15:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/335.self-crossing.zh/</guid>
      <description>问题描述 335. 路径交叉 (Hard)&#xA;给你一个整数数组 distance。&#xA;从 X-Y 平面上的点 (0,0) 开始，先向北移动 distance[0] 米，然后向西移动 distance[1] 米，向南 移动 distance[2] 米，向东移动 distance[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针 变化。&#xA;判断你所经过的路径是否相交。如果相交，返回 true ；否则，返回 false 。&#xA;示例 1：&#xA;输入：distance = [2,1,1,2] 输出：true 示例 2：&#xA;输入：distance = [1,2,3,4] 输出：false 示例 3：&#xA;输入：distance = [1,1,1,1] 输出：true 提示：&#xA;1 &amp;lt;= distance.length &amp;lt;= 10⁵ 1 &amp;lt;= distance[i] &amp;lt;= 10⁵ 解题思路 模拟，以向北为例，可能与向西、向东、或者向北的轨迹发生交叉；向西，则可能会与向北、向南、向西的方向发生碰撞；依次类推。&#xA;再以向西为例，分别考虑与向北、向南、向西轨迹发生碰撞时的条件。&#xA;代码 class Solution { public: bool isSelfCrossing(vector&amp;lt;int&amp;gt; &amp;amp;distance) { int n = distance.</description>
    </item>
    <item>
      <title>MIT 6.S081 File system performance and fast crash recovery</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-lec16.zh/</link>
      <pubDate>Thu, 27 Jul 2023 16:34:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-lec16.zh/</guid>
      <description>引入 当我们针对文件系统讨论 logging 或者 journal 时，其实是在讨论同一件事，二者是同义词。&#xA;这一部分主要是讨论 Linux 的 ext3 文件系统，它相比 ext2，可以就说就是加了一层 logging，其他基本没有改变。我们要关注 ext3 与 xv6 的文件系统的不同之处，重点放在 ext3 是如何在保证 logging 的同时尽可能提升性能的。&#xA;ext3 file system log format ext3 数据结构与 xv6 相似，在内存中存在 block cache，它们是 write-back 的（即改动不会马上写回到磁盘）。&#xA;logging 系统有两个非常重要的准则：&#xA;write-adead rule：必须现在 log 中记录好所有这些写操作，才能将这些写操作应用到磁盘； freeing rule：即我们不能覆盖或者重用 log。 ext3 还维护了一些 transaction 的信息，transaction_t 中包含：&#xA;一个序列号； 一系列该 transaction 修改的 block 的编号，这些 block 编号指向 cache 中的 blcok； 一系列的 handle，handle 对应属于transaction 的系统调用，它们会读写 cache 中的 block； ext3 的磁盘组织与 xv6 类似，存在一个文件系统树，包含 inode、目录、file 等，存在 bimtap lock 来标识每个 data block 是被分配还是空闲的，在磁盘的一个指定区域保存 log。</description>
    </item>
    <item>
      <title>828. Count Unique Characters of All Substrings of a Given String (Hard)</title>
      <link>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string/</link>
      <pubDate>Thu, 27 Jul 2023 09:30:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string/</guid>
      <description>Description 828. Count Unique Characters of All Substrings of a Given String (Hard)&#xA;Solution DP This problem can be easily solved using dynamic programming. Let&amp;rsquo;s define $dp[i]$ as the sum of countUniqueChar(t) values for substrings $t$ ending at $s[i]$. The next step is to find the recurrence relation:&#xA;Suppose the character corresponding to $s[i]$ is $c$. For substrings ending at $s[i-1]$, if the substring does not contain $c$, then the countUniqueChar value for the substring ending at $s[i]$ is equal to the value for the substring ending at $s[i-1]$ (i.</description>
    </item>
    <item>
      <title>[828. 统计子串中的唯一字符] (Hard)</title>
      <link>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/</link>
      <pubDate>Thu, 27 Jul 2023 09:30:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/828.count-unique-characters-of-all-substrings-of-a-given-string.zh/</guid>
      <description>问题描述 828. 统计子串中的唯一字符 (Hard)&#xA;我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。&#xA;例如： s = &amp;quot;LEETCODE&amp;quot; ，则其中 &amp;quot;L&amp;quot;, &amp;quot;T&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;O&amp;quot;, &amp;quot;D&amp;quot; 都是唯一字符，因为它们只出现一次 ，所以 countUniqueChars(s) = 5 。&#xA;本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。 输入用例保证返回值为 32 位整数。&#xA;注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的 所有子字符串中的唯一字符）。&#xA;示例 1：&#xA;输入: s = &amp;#34;ABC&amp;#34; 输出: 10 解释: 所有可能的子串为：&amp;#34;A&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;AB&amp;#34;,&amp;#34;BC&amp;#34; 和 &amp;#34;ABC&amp;#34;。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2：&#xA;输入: s = &amp;#34;ABA&amp;#34; 输出: 8 解释: 除了 countUniqueChars(&amp;#34;ABA&amp;#34;) = 1 之外，其余与示例 1 相同。 示例 3：</description>
    </item>
    <item>
      <title>Mit6.s081 Lec15: xv6 的 logging system</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-lec15.zh/</link>
      <pubDate>Tue, 25 Jul 2023 16:48:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-lec15.zh/</guid>
      <description>Logging layer file system 设计的一大重要问题就是 crash recovery。这是因为文件系统操作往往涉及向磁盘多次写入，而几次写入之后的 crash 可能导致磁盘上的文件系统处于一个不一致的状态。&#xA;For example, suppose a crash occurs during file truncation (setting the length of a file to zero and freeing its content blocks). Depending on the order of the disk writes, the crash may either leave an inode with a reference to a content block that is marked free, or it may leave an allocated but unreferenced content block.&#xA;前者当系统重启之后,可能导致一个磁盘 block 被两个文件所对应，这是一个很严重的问题。</description>
    </item>
    <item>
      <title>MIT 6.S081 Lec14: File system</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-lec14.zh/</link>
      <pubDate>Sat, 22 Jul 2023 19:51:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-lec14.zh/</guid>
      <description>Overview 文件系统的设计目标就是组织和存储数据，文件系统一个比较重要功能是持久化，即重启之后，数据不会丢失。xv6 通过把数据存储在 virtio disk 上来实现持久化。&#xA;文件系统设计的几大挑战：&#xA;The file system needs on-disk data structures to represent the tree of named directories and files, to record the identities of the blocks that hold each file’s content, and to record which areas of the disk are free. 由于文件系统需要实现持久化，因此必须要实现 crash recovery，即如果发生意外的 crash（例如断电），文件系统在计算机重启之后要能依旧正常工作； 可能有多个进程同时操作文件系统； 由于访问磁盘比访问内存要慢得多得多，因此文件系统需要能支持将部分 popluar 的 blocks 缓存在内存中； xv6 的文件系统可以说组织为七层，如下图所示：&#xA;disk layer 负责读写 virtio hard drive 上的 blocks，buffer cache layer 是 blocks 的 cache，并且保证同一时间，只有一个内核进程可以修改存储在特定块上的数据；logging layer 将对几个特定 block 的更新打包为一次 transaction（就是数据库常说的事务？），从而确保这些 blocks 都是被原子化地更新，即要么一次都更新，要么一次都不更新；inode layer 则是用来表示单独的文件，每个文件都是以具有不重复的 index 的 inode 和保存了这个文件的数据的一些 blocks 来表示；而在 directory layer，每个 directory 都是一种特殊的 inode，包含一系列 direcotry entry，directory entry 则是包含了文件名和 index（对应 indode layer 所说的 index）；pathname layer 提供了层级化的路径名，利用递归查找来解析它们；</description>
    </item>
    <item>
      <title>Xv6 Lab7: Multithreading</title>
      <link>http://localhost:1313/posts/tech/xv6-lab7.zh/</link>
      <pubDate>Sat, 22 Jul 2023 11:30:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/xv6-lab7.zh/</guid>
      <description>Uthread: switching between threads 这个题还是对的起它 moderate 的难度了，如果认真看了 book-riscv-rev2.pdf 的 Scheduling 章节，以及看了这个 课程翻译，那么这题可以很快做出来，个人觉得 pdf 讲得更加清楚一些。&#xA;这个题甚至帮你把需要添加代码的地方都标注出来了，参照题目说明，主要有三步：&#xA;修改 thread_create 来保证当 thread_schedule 第一次运行 thread_create 创建出来的线程时，该线程就会在自己的 stack 上执行传递给 thread_create 的函数，这里我们可以参照 allocproc 的实现，在 thread_create 标记出来的要我们添加代码的地方添加如下三行： memset(&amp;amp;t-&amp;gt;context, 0, sizeof(t-&amp;gt;context)); t-&amp;gt;context.ra = (uint64)func; t-&amp;gt;context.sp = (uint64)t-&amp;gt;stack + STACK_SIZE; 保证 thread_switch 会切换并保存寄存器，这里参照 scheduler 的实现即可，在注释标记的地方添加以下语句，并且在 uthread_switch.S 中实现 thread_switch 函数（照抄 swtch 即可）： thread_switch((uint64)&amp;amp;t-&amp;gt;context, (uint64)&amp;amp;current_thread-&amp;gt;context); thread_switch: /* YOUR CODE HERE */ sd ra, 0(a0) sd sp, 8(a0) sd s0, 16(a0) sd s1, 24(a0) sd s2, 32(a0) sd s3, 40(a0) sd s4, 48(a0) sd s5, 56(a0) sd s6, 64(a0) sd s7, 72(a0) sd s8, 80(a0) sd s9, 88(a0) sd s10, 96(a0) sd s11, 104(a0) ld ra, 0(a1) ld sp, 8(a1) ld s0, 16(a1) ld s1, 24(a1) ld s2, 32(a1) ld s3, 40(a1) ld s4, 48(a1) ld s5, 56(a1) ld s6, 64(a1) ld s7, 72(a1) ld s8, 80(a1) ld s9, 88(a1) ld s10, 96(a1) ld s11, 104(a1) ret /* return to ra */ 修改 strcut thread 来存储 thread_switch 时需要保存的寄存器，还是参照 struct proc 即可： struct t_context { uint64 ra; uint64 sp; // callee saved uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11; }; struct thread { char stack[STACK_SIZE]; /* the thread&amp;#39;s stack */ int state; /* FREE, RUNNING, RUNNABLE */ struct t_context context; }; 这样修改之后就能通过 uthread 了。</description>
    </item>
    <item>
      <title>debian 配置文件共享（samba、nfs）与 pt</title>
      <link>http://localhost:1313/posts/blog/debian-file-share-pt.zh/</link>
      <pubDate>Fri, 21 Jul 2023 18:03:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/debian-file-share-pt.zh/</guid>
      <description>nfs 首先执行 sudo apt install nfs-kernel-server 安装 nfs，然后执行 sudo nvim /etc/exports 编辑 /etc/exports 文件，添加以下内容&#xA;# share documents /home/zwyyy/Documents 192.168.6.0/24(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000) # share downloads /home/zwyyy/Downloads 192.168.6.0/24(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000) # external disk /home/zwyyy/mnt/ext 192.168.6.0/24(rw,sync,no_subtree_check,all_squash,anonuid=1000,anongid=1000) 最前面是路径，根据自己需求来写。&#xA;192.168.6.0/24 是为了保证同一局域网下都能连接，all_squash,anonuid,anongid 保证客户端连接到 nfs 服务端的时候，都是以 uid=1000,gid=1000 用户和用户组连接的，这样就解决了 mac 连接上 nfs 之后无法写入的问题。&#xA;然后 debian 执行以下命令&#xA;sudo exportfs -ra sudo systemctl start nfs-server sudo systemctl enable nfs-server 然后 mac 执行 sudo mount -t nfs -o resvport 192.168.6.155:/home/zwyyy/Documents ~/Downloads/deb-doc 将 nfs 服务端的路径挂载到本地，具体路径根据自己需求来写。&#xA;注意确保执行挂载命令前，mac 的对应目录已经存在。</description>
    </item>
    <item>
      <title>MIT 6.S081 Sleep &amp; Wake up</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-lec13.zh/</link>
      <pubDate>Thu, 20 Jul 2023 17:40:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-lec13.zh/</guid>
      <description>Sleep and wakeup Sleep 允许一个内核线程等待某个特定事件的发生，另一个线程可以调用 wakeup 来表示这个正在等待时间发生的线程应该恢复了。&#xA;Sleep and wakeup are often called sequence cooridination or conditional synchronization mechanisms.&#xA;xv6 中利用 sleep 和 wakeup 实现了一种 high-level 的同步机制，被称为信号量（semaphore），用于协调生产者和消费者（xv6 中并未使用信号量）。&#xA;A semaphore maintains a count and provides two operations. The “V” operation (for the producer) increments the count. The “P” operation (for the consumer) waits until the count is non-zero, and then decrements it and returns.&#xA;struct semaphore { struct spinlock lock; int count; }; void V(struct semaphore *s) { acquire(&amp;amp;s-&amp;gt;lock); s-&amp;gt;count += 1; // wakeup(s); release(&amp;amp;s-&amp;gt;lock); } void P(struct *s) { while (s-&amp;gt;count == 0) //sleep(s); ; acquire(&amp;amp;s-&amp;gt;lock); s-&amp;gt;count -= 1; release(&amp;amp;s-&amp;gt;count); } 上述代码给出了一个非常简单但是性能不优秀的 “生产者-消费者” 模型实现，如果生产者很少工作，那么消费者会花费大量时间在 while 循环中。为了避免这一点，消费者应该要有办法主动让出 cpu，并且只在 V 递增 s-&amp;gt;count 之后才恢复执行。</description>
    </item>
    <item>
      <title>918. Maximum Sum Circular Subarray (Medium)</title>
      <link>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray/</link>
      <pubDate>Thu, 20 Jul 2023 14:07:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray/</guid>
      <description>Description 918. Maximum Sum Circular Subarray (Medium)&#xA;Solution We define $dp[i]$ to represent the maximum sum of subarrays that end at $nums[i]$. Then, we can discuss two cases:&#xA;The subarray is a continuous segment, i.e., $tail \geq head$. The subarray is divided into two segments, i.e., $tail &amp;lt; head$. In each case, we can update the $dp[i]$ value accordingly to find the maximum sum of subarrays that end at each element $nums[i]$.</description>
    </item>
    <item>
      <title>918. 环形子数组的最大和 (Medium)</title>
      <link>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray.zh/</link>
      <pubDate>Thu, 20 Jul 2023 14:07:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/918.maximum-sum-circular-subarray.zh/</guid>
      <description>问题描述 918. 环形子数组的最大和 (Medium)&#xA;给定一个长度为 n 的 环形整数数组 nums ，返回nums 的非空 子数组 的最大可能和 。&#xA;环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。&#xA;子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i &amp;lt;= k1, k2 &amp;lt;= j 其中 k1 % n == k2 % n 。&#xA;示例 1：&#xA;输入：nums = [1,-2,3,-2] 输出：3 解释：从子数组 [3] 得到最大和 3 示例 2：</description>
    </item>
    <item>
      <title>950. Reveal Cards In Increasing Order (Medium)</title>
      <link>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order/</link>
      <pubDate>Thu, 20 Jul 2023 10:25:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order/</guid>
      <description>Description 950. Reveal Cards In Increasing Order (Medium)&#xA;Solution This problem can be solved through direct simulation according to the given instructions. The use of recursion is not necessary. Since the problem involves popping the first element, a double-ended queue (deque) is a suitable data structure to use. The deque will store the indices of elements, and we can proceed with the simulation accordingly.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; deckRevealedIncreasing(vector&amp;lt;int&amp;gt;&amp;amp; deck) { sort(deck.</description>
    </item>
    <item>
      <title>950. 按递增顺序显示卡牌 (Medium)</title>
      <link>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order.zh/</link>
      <pubDate>Thu, 20 Jul 2023 10:25:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/950.reveal-cards-in-increasing-order.zh/</guid>
      <description>问题描述 950. 按递增顺序显示卡牌 (Medium)&#xA;牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。&#xA;最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。&#xA;现在，重复执行以下步骤，直到显示所有卡牌为止：&#xA;从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。 如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。 如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。 返回能以 递增顺序 显示卡牌的牌组顺序。&#xA;答案中的第一张牌被认为处于牌堆顶部。&#xA;示例：&#xA;输入：[17,13,11,2,3,5,7] 输出：[2,13,3,11,5,17,7] 解释： 我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。 重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。 我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。 我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。 我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。 我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。 我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。 我们展示 13，然后将 17 移到底部。牌组现在是 [17]。 我们显示 17。 由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。 提示：&#xA;1 &amp;lt;= A.length &amp;lt;= 1000 1 &amp;lt;= A[i] &amp;lt;= 10^6 对于所有的 i !</description>
    </item>
    <item>
      <title>MIT 6.S081 Thread switching</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-lec11.zh/</link>
      <pubDate>Wed, 19 Jul 2023 10:46:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-lec11.zh/</guid>
      <description>Multiplexing xv6 通过将 cpu 从一个进程切换到另一个进程来实现 multiplex（多路复用），进程的切换会在两种情形下发生：&#xA;xv6 的 sleep 与 wakeup 机制在进程等待 IO 完成或者等待子进程退出又或者在 sleep 系统调用中等待的时候切换进程。 xv6 会周期性地强制切换进程，从而应对那些长时间切换而未 sleep 的进程。 这个 multiplex 机制会让进程产生一种自己完全拥有 cpu 的错觉，就像 xv6 用虚拟内存和 page table 机制让进程觉得自己拥有完整的内存空间一样。&#xA;xv6 使用硬件定时器中断来保证 context switch（上下文切换）。&#xA;Code: Context switching 用户进程之间的切换步骤如下图所示：&#xA;用户进程之间的切换其实会经过两次 context switch，以上图为例，第一次是从 shell 用户进程的 kernel thread 切换到 cpu 的 scheduler thread；第二次从 cpu 的 scheduler thread 切换到新用户进程（例如 cat）的 kernel thread。&#xA;在 xv6 中，我们可以认为每个用户进程，包含一个内核线程与一个用户线程，然后每个 cpu 包含一个 scheduler thread，schedular thread 工作在内核中，有只属于它的 kernel stack。&#xA;swtch 执行为内核线程切换的保存和恢复工作。swtch 的主要工作就是保存和恢复 riscv 的寄存器，又被称为上下文。</description>
    </item>
    <item>
      <title>2069. Walking Robot Simulation II (Medium)</title>
      <link>http://localhost:1313/posts/leet/2069.walking-robot-simulation-ii/</link>
      <pubDate>Wed, 19 Jul 2023 09:57:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2069.walking-robot-simulation-ii/</guid>
      <description>Description 2069. Walking Robot Simulation II (Medium)&#xA;Explanation Robot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East. robot.step(2); // It moves two steps East to (2, 0), and faces East. robot.step(2); // It moves two steps East to (4, 0), and faces East. robot.getPos(); // return [4, 0] robot.getDir(); // return &amp;quot;East&amp;quot; robot.step(2); // It moves one step East to (5, 0), and faces East.</description>
    </item>
    <item>
      <title>2069. 模拟行走机器人 II (Medium)</title>
      <link>http://localhost:1313/posts/leet/2069.walking-robot-simulation-ii.zh/</link>
      <pubDate>Wed, 19 Jul 2023 09:57:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2069.walking-robot-simulation-ii.zh/</guid>
      <description>问题描述 2069. 模拟行走机器人 II (Medium)&#xA;给你一个在 XY 平面上的 width x height 的网格图， 左下角 的格子为 (0, 0) ， 右上角 的格子 为 (width - 1, height - 1) 。网格图中相邻格子为四个基本方向之一（ &amp;quot;North&amp;quot;， &amp;quot;East&amp;quot;， &amp;quot;South&amp;quot; 和 &amp;quot;West&amp;quot;）。一个机器人 初始 在格子 (0, 0) ，方向为 &amp;quot;East&amp;quot; 。&#xA;机器人可以根据指令移动指定的 步数 。每一步，它可以执行以下操作。&#xA;沿着当前方向尝试 往前一步 。 如果机器人下一步将到达的格子 超出了边界 ，机器人会 逆时针 转 90 度，然后再尝试往前一步。 如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。&#xA;请你实现 Robot 类：&#xA;Robot(int width, int height) 初始化一个 width x height 的网格图，机器人初始在 (0, 0) ，方向 朝 &amp;quot;East&amp;quot; 。 void step(int num) 给机器人下达前进 num 步的指令。 int[] getPos() 返回机器人当前所处的格子位置，用一个长度为 2 的数组 [x, y] 表示。 String getDir() 返回当前机器人的朝向，为 &amp;quot;North&amp;quot; ， &amp;quot;East&amp;quot; ， &amp;quot;South&amp;quot; 或者 &amp;quot;West&amp;quot; 。 示例 1：</description>
    </item>
    <item>
      <title>1851. Minimum Interval to Include Each Query (Hard)</title>
      <link>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query/</link>
      <pubDate>Tue, 18 Jul 2023 22:19:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query/</guid>
      <description>Description 1851. Minimum Interval to Include Each Query (Hard)&#xA;Solution First, it should be noted that sorting the intervals array will not affect the result. Secondly, sorting the queries array will not have a significant impact on the answer. It merely changes the order of the answers. We just need to associate the result of each query with its corresponding index in the original queries array.&#xA;For convenience, let&amp;rsquo;s convert the queries array into a vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; qrs; where the first element represents the value to be queried, and the second element represents its index in the queries array.</description>
    </item>
    <item>
      <title>1851. 包含每个查询的最小区间 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query.zh/</link>
      <pubDate>Tue, 18 Jul 2023 22:19:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1851.minimum-interval-to-include-each-query.zh/</guid>
      <description>问题描述 [1851. 包含每个查询的最小区间] (Hard)&#xA;给你一个二维整数数组 intervals ，其中 intervals[i] = [leftᵢ, rightᵢ] 表示第 i 个区间开始于 le ftᵢ 、结束于 rightᵢ（包含两侧取值， 闭区间）。区间的 长度 定义为区间中包含的整数数目，更 正式地表达是 rightᵢ - leftᵢ + 1 。&#xA;再给你一个整数数组 queries 。第 j 个查询的答案是满足 leftᵢ &amp;lt;= queries[j] &amp;lt;= rightᵢ 的 长度最 小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。&#xA;以数组形式返回对应查询的所有答案。&#xA;示例 1：&#xA;输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] 输出：[3,3,1,4] 解释：查询处理如下： - Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。 - Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。 示例 2：</description>
    </item>
    <item>
      <title>MIT 6.S081 Multiprocessors and locking</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-lec10.zh/</link>
      <pubDate>Tue, 18 Jul 2023 13:54:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-lec10.zh/</guid>
      <description>why lock 防止多核并行运行下的 race condition 导致的错误。&#xA;内核中的数据是典型的 concurrently-accessed 的数据。&#xA;race condition and how the lock avoid it A race condition is a situation in which a memory location is accessed concurrently, and at least one access is a write.&#xA;Locks ensure mutual exclusion. 锁的持有与释放之间的语句会被原子化，在 xv6 中，就是 acquire 和 release 之间的多条语句，只能被一个进程（CPU）全部执行完了之后，才可能被其他的进程（CPU）执行，这样就避免了 race condition。&#xA;acquire 和 release 之间的多条指令通常被称为 critical section。&#xA;lock 在某种意义上是在维护 critical section 中一些数据的不变量（some collection of invariants），这个不变量在 critical section 中可能会被暂时破坏，但是当 critical section 的最开始，以及结束的时候，这个 invariants 一定成立！ 例如 kfree 中的 lock，就是在维护 kmem.</description>
    </item>
    <item>
      <title>834. Sum of Distances in Tree (Hard)</title>
      <link>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree/</link>
      <pubDate>Tue, 18 Jul 2023 10:09:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree/</guid>
      <description>Description 834. Sum of Distances in Tree (Hard)&#xA;Solution To find the sum of distances to a single node (e.g., $0$) denoted as $dp[0]$, we can easily use DFS to compute it with a time complexity of $O(n)$. However, finding the sum of distances for all $n$ nodes would take $O(n^2)$ time, which would obviously result in a timeout for large graphs.&#xA;However, we notice that there exists a recurrence relationship between the parent node $j$&amp;rsquo;s $dp[j]$ and the child node $i$&amp;rsquo;s $dp[i]$.</description>
    </item>
    <item>
      <title>834. 树中距离之和 (Hard)</title>
      <link>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree.zh/</link>
      <pubDate>Tue, 18 Jul 2023 10:09:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/834.sum-of-distances-in-tree.zh/</guid>
      <description>问题描述 834. 树中距离之和 (Hard)&#xA;给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。&#xA;给定整数 n 和数组 edges ， edges[i] = [aᵢ, bᵢ] 表示树中的节点 aᵢ 和 bᵢ 之间有一条边。&#xA;返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。&#xA;示例 1:&#xA;输入: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] 输出: [8,12,6,10,10,10] 解释: 树如图所示。 我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。 示例 2:</description>
    </item>
    <item>
      <title>无向图形式组织的树</title>
      <link>http://localhost:1313/posts/tech/undirected-graph-tree.zh/</link>
      <pubDate>Tue, 18 Jul 2023 09:30:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/undirected-graph-tree.zh/</guid>
      <description>引入 如 数组形式组织的树 中所说，树一般以链表结点的形式组织，定义如下：&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} }; 也可能以数组的形式组织，即使用 $parent$ 数组，$y = parent[x]$ 说明 $y$ 是 $x$ 的父结点，根结点的父结点为 $-1$，表示父结点不存在。&#xA;还可以使用无向图的形式来表示，例如 leetcode 的 834. 树中距离之和。&#xA;昨天做这个题的时候，整体思路挺好想的，但就是有个地方被困住了，那就是，在树的无向图的表示情况下，如何统计以当前结点为根结点的子树的数量？（没办法转化成有向图！）&#xA;统计以当前结点为根结点的子树的结点数 统计方法还是深度优先搜索（dfs），只不过，相比一般的深度优先搜索，我们需要传入一个额外的参数，即上一次搜索的父结点，如下图所示：&#xA;相应的 dfs 代码为&#xA;for (int child : tree[pa]) { if (child == ancestor) { continue; } // 对子结点进行 dfs ... } 这样就确定出了一个遍历方向，因此，整体思路就是，我们可以任意选择一个结点作为 dfs 的起点（这里就选择 $0$ 号结点），依次进行 dfs，利用递归的方法，统计以当前结点为根结点的子树的结点数。&#xA;因此，834. 树中距离之和 的完整解题代码如下：&#xA;class Solution { public: int count(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;tree, vector&amp;lt;int&amp;gt; &amp;amp;dis, vector&amp;lt;int&amp;gt; &amp;amp;cnt, int pa, int grandpa) { int res = 1; for (int child : tree[pa]) { if (child == grandpa) { // 防止重复遍历，保证 dfs 遍历时的单向性 continue; } dis[child] = dis[pa] + 1; res += count(tree, dis, cnt, child, pa); } cnt[pa] = res; return res; } vector&amp;lt;int&amp;gt; sumOfDistancesInTree(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;edges) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; tree(n); for (auto &amp;amp;vec : edges) { tree[vec[0]].</description>
    </item>
    <item>
      <title>MIT 6.S081 Page faults</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-lec08.zh/</link>
      <pubDate>Mon, 17 Jul 2023 16:27:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-lec08.zh/</guid>
      <description>概述 这一章主要聚焦于，我们利用 virtural memory 和 page fault 这两个机制，能够实现一些什么样的有意思的优化。&#xA;虚拟内存的有两大优势：&#xA;Isolation，保证每个进程都有它自己的虚拟地址空间，写自己的虚拟地址处的数据不会破坏其他进程的数据； Levle of indirection，提供了一层抽象（这里不是很好理解），可以理解为提供了一层从虚拟地址到物理地址的映射关系，利用这个映射关系，我们可以实现很多有意思的优化。 利用 page fault，我们可以更新 page table，即更改虚拟地址和物理地址之间的映射关系（在之前的 xv6 中，可以说 va 和 pa 的映射关系，在进程启动之后，到进程结束之前，都是固定的）。&#xA;对于 page fault，也可以说是一种 trap，之前提到的 system call 是发生了系统调用之后的 trap，因此 trap 完成之后，我们会返回到产生系统调用的指令的下一条指令继续执行；而 page fault 则是异常（exception）导致的 trap，trap 结束之后，我们会返回导致 page fault 的指令，重新执行这一条指令；&#xA;正如 system call 导致的 trap 中，我们需要实现真正执行 systemcall 的函数；而 page fault 导致的 trap 中，我们也需要处理这一异常（一般是在 trap.c 的 usertrap 函数中）。&#xA;对于处理 page fautl 的思路，其实可以参照 system call，我们通过读取 scause 寄存器的值来判断导致 trap 的原因，如果是 $13$ 或者 $15$，则说明是 page fault。</description>
    </item>
    <item>
      <title>Xv6 Lab6: Copy-on-Write Fork for xv6</title>
      <link>http://localhost:1313/posts/tech/xv6-lab6.zh/</link>
      <pubDate>Mon, 17 Jul 2023 13:42:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/xv6-lab6.zh/</guid>
      <description>思路 经过 lab5: lazy page allocation 之后，对 xv6 的 page fault 的处理，算是有所了解了。&#xA;今天这个 COW 实验，在 2020 年的课程视频中有对思路的讲解，可以先看看 课程翻译，厘清一下思路。&#xA;整体思路其实也不难，默认情况下，fork 会调用 uvmcopy，将父进程的 PP（物理页）复制一份，将这个 PP 的副本映射到子进程的 pagetable 的 VP（虚拟页）（子进程和父进程具有相同的虚拟地址，不同的 pagetable，不同的 PP，但是相同虚拟地址对应的 PP 的内容是一样的）。&#xA;我们这里讨论 vaddr、paddr 都是基于地址已经是 PGSIZE 对齐的情况来讨论的。&#xA;我们要做的修改就是，不再复制这个 PP，而是将 PP 的 paddr 同时映射到父进程的 vaddr 以及子进程的 vaddr。&#xA;在未修改 uvmcopy 之前，修改父进程的 vaddr 处的内容并不会影响子进程的 vaddr 处的内容，因为两个 vaddr 对应的是不同的 PP，只是 PP 的内容相同而已（在 pp 是 clean 的情况下）。&#xA;而修改了 uvmcopy 之后，写入父进程的 vaddr 会影响子进程的 vaddr 处的内容，这是我们不希望看到的，因此我们将这个 PP 对应的父进程的 pte 和子进程的 pte 的 PTE_W 位都清零，即标记为不可写，这样，当我们试图往这个 PP 中写入内容的时候，就会出现 page fault。</description>
    </item>
    <item>
      <title>Xv6 Lab5: lazy page allocation</title>
      <link>http://localhost:1313/posts/tech/xv6-lab5.zh/</link>
      <pubDate>Sat, 15 Jul 2023 17:18:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/xv6-lab5.zh/</guid>
      <description>前言 这个实验只有 2020 年的才有，2021 年的课程中是没有的，但是感觉这个实验还是挺有意义的，因此用 docker 创建了一个 debian 12 的容器，在容器中搭建了 2020 的实验环境，实验环境的搭建过程可以参照 MIT 6.s081 实验环境搭建。&#xA;Eliminate allocation from sbrk() 这个算是最简单的：&#xA;// kernel/sysproc.c uint64 sys_sbrk(void) { int addr; int n; if (argint(0, &amp;amp;n) &amp;lt; 0) { return -1; } addr = myproc-&amp;gt;sz; myproc()-&amp;gt;sz += n; // 添加的部分，修改 p-&amp;gt;sz，然后注释掉下面这三行 // if (growproc(n) &amp;lt; 0) { // return -1; // } return addr; } Lazy allocation 在去掉了 sys_sbrk 的 growproc 部分之后，由于只是单纯增加了 p-&amp;gt;sz，而没有给对应的虚拟地址分配物理页，因此，在执行 echo hi 时，会访问到 heap 中的未分配物理页的虚拟地址，于是出现 page fault，默认的 Xv6 的代码中并没有给出对 page fault 的处理，而是会直接杀死进程，因此无法正常执行完 echo hi。</description>
    </item>
    <item>
      <title>Xv6 Lab4: Traps</title>
      <link>http://localhost:1313/posts/tech/xv6-lab4.zh/</link>
      <pubDate>Thu, 13 Jul 2023 12:51:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/xv6-lab4.zh/</guid>
      <description>RISC-V assembly Which registers contain arguments to functions? For example, which register holds 13 in main&amp;rsquo;s call to printf?&#xA;a2 寄存器，函数调用时，参数从左到右会依次保存在 a0, a1, a2, a3 寄存器，似乎是一直到寄存器 a7 的。 Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)&#xA;这里的调用都被内联了 At what address is the function printf located?&#xA;auipc（Add Upper Immediate PC）指令是将一个立即数左移 $12$ 位加上当前指令的地址（pc）中，得到一个绝对地址。&#xA;例如 auipc a0, 0x0 就是将 $\text{0x0}$ 左移 $12$ 位加上当前指令的地址 (pc) 中（pc 的值我们一般认为是在指令执行完成时才发生递增，从而指向下一条指令，使得处理器能够按顺序顺利执行指令序列），因此，执行 auipc a0, 0x0 时，加的就是当前指令的地址，即 $\text{0x28}$。</description>
    </item>
    <item>
      <title>MIT 6.S081 Isolation &amp; System call entry/exit</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-lec06.zh/</link>
      <pubDate>Sat, 08 Jul 2023 15:32:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-lec06.zh/</guid>
      <description>Trap 机制 程序运行往往需要完成用户空间和内核空间的切换，每当：&#xA;程序执行系统调用（system call）； 程序出现了 page fault 等错误； 一个设备触发了中断； 都会发生这样的切换。&#xA;这里用户空间切换到内核空间通常被称为 trap，因此有时候我们会说程序“陷入”到内核态。trap 机制需要尽可能的简单。&#xA;trap 的工作，可以说是让硬件从适合运行用户程序的状态，切换到适合运行内核代码的状态。&#xA;这里说的状态中，我们最关心的状态可能是 $32$ 个用户寄存器，我们尤其需要关注以下硬件寄存器的内容：&#xA;堆栈寄存器（stack register，又称 stack pointer）； 程序计数器（Program Counter Register）； 表明当前 mode 的标志位的寄存器，表明当前是 supervisor mode 还是 user mode； 控制 CPU 工作方式的寄存器，例如 SATP（Supervisor Address Translation and Protection）寄存器，它包含了指向 page table 的物理内存地址； STVEC（Supervisor Trap Vector Base Address Register）寄存器，它指向了内核中处理 trap 的指令的起始地址； SEPC（Supervisor Exception Program Counter）寄存器，在 trap 的过程中保存程序计数器的值； sscratch（Supervisor Scratch Register）寄存器； 在 trap 的最开始，CPU 所有的状态肯定还是在运行用户代码而不是内核代码，在 trap 处理的过程中，我们会逐渐更改状态，或者对状态做一些操作，我们可以设想一下我们需要做哪些操作：&#xA;保存 $32$ 个用户寄存器的状态，例如，当响应中断完成后，我们会希望能恢复用户程序的执行，而这些寄存器需要被内核代码所使用，因此，在 trap 之前，我们需要保存这 $32$ 个用户寄存器的内容； 保存 PC 的内容，原因类似于保存 $32$ 个用户寄存器； 将 mode 修改为 supervisor mode； 运行内核代码前，将 SATP 由指向 user page table 修改为指向 kernel page table； trap 机制不会依赖于 $32$ 个用户寄存器；</description>
    </item>
    <item>
      <title>解决远程主机的默认 shell 为 fish 时，vscode remote 无法连接的问题</title>
      <link>http://localhost:1313/posts/blog/fish-vscode-remote.zh/</link>
      <pubDate>Sat, 08 Jul 2023 11:30:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/fish-vscode-remote.zh/</guid>
      <description>问题描述 我主要用的 shell 就是 fish，主打一个开箱即用，虽然也配置过 zsh，但是感觉配置好的 zsh 在易用性上也就是 fish 的水平。&#xA;此前，一直以来默认的 shell 都是 bash，ssh 或者 vscode remote 远程连接上去之后，再输入 fish 来进行手动切换，后来嫌麻烦，就执行 chsh -s /usr/bin/fish 将默认 shell 切换到了 fish，然后 vscode remote 就连接不上了。&#xA;出现该问题的原因见该 issue 里的讨论&#xA;we still have a bug connecting to remotes with fish shells as their default shell. Using the remotePlatform setting we added a work around to make the connection work. It&amp;rsquo;s not ideal but it works. The bug specifically has to do with what seems that Fish shells don&amp;rsquo;t let us pipe in scripts after connection unless we connect with a command like ssh your_host bash.</description>
    </item>
    <item>
      <title>MIT 6.S081 页表</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-page-table.zh/</link>
      <pubDate>Mon, 03 Jul 2023 09:19:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-page-table.zh/</guid>
      <description>Paging hardware 总的来说，Xv6 的虚拟内存到物理内存的映射方式与 x64 是一致的，都是使用页表来进行映射。区别在于，Xv6 只使用了三级页表，而 x64 则是使用四级页表，另外，二者的页表层级的命名也有区别，对 Xv6 来说，最高级的页表是 L3（其地址存放于寄存器 satp 中）。&#xA;每个 page table 含有 512 个 page table entry，而每个 page table entry 的大小是 8KB，因此一个 page table 占据的大小正好是 4KB，即一个 VP 的大小！&#xA;标志位可以说是顾名思义，除了这个 dirty？（留待之后处理）&#xA;Kernel address space Xv6 中，每个进程都有属于自己的地址空间，以及一个全局唯一的描述内核地址空间的 page table，（kernel page table）。&#xA;内核内存布局：&#xA;QEMU 模拟了一台带 RAM（物理内存）的电脑，该 RAM 的起始地址是 $\text{0x80000000}$ ,结束地址至少是 $\text{0x86400000}$（该地址在 Xv6 中被定义为 PHYSTOP），这里的地址说的都是物理地址。&#xA;QEMU 会将设备接口以内存映射的控制寄存器暴露给系统软件，这些寄存器地址映射的内存都是在 $\text{0x80000000}$，即系统要访问这些设备，都是通过 $\text{0x80000000}$ 以下的物理地址直接访问，但通过这样的物理地址访问设备就不会经过 RAM 了。&#xA;内核空间的虚拟地址是直接映射到物理地址的，例如 KERNBASE=0x80000000，虚拟地址和物理地址都是这个值，可以理解为虚拟地址等于物理地址。&#xA;但是有几个内核虚拟地址不是直接映射的，如下图所示：&#xA;trampoline page（蹦床页面），它映射在虚拟地址空间的顶部，user page table 具有相同的映射，即不论 kernel page table 还是 user page table，trampoline page 的虚拟地址都是在虚拟地址空间的顶部； kernel stack page，每个进程都有自己的 kernel stack，会映射到虚拟地址空间中比较高的那个 kernel stack，这样可以利用到 kernel stack 下方的那个 guard page。Guard page is invalid!</description>
    </item>
    <item>
      <title>Xv6 Lab2: System calls</title>
      <link>http://localhost:1313/posts/tech/xv6-lab2.zh/</link>
      <pubDate>Sat, 01 Jul 2023 15:15:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/xv6-lab2.zh/</guid>
      <description>系统调用 Lab1 主要是基于提供的系统调用接口来编写一些小工具程序，而 Lab2 则是要我们自己实现系统调用，并提供系统调用的接口。&#xA;以本次 Lab 要我们实现的 trace 调用为例，说明一下系统调用的流程：&#xA;在 user/trace.c 的第 $15$ 行，调用了属于 system call 的 trace 函数，当前执行 make qemu 是无法成功的，因为我们还没有给用户提供接口。因此，我们需要在 user/user.h 里面添加系统调用 trace 的函数声明（prototype）。&#xA;我们需要在 user/usys.pl 中追加 entry(&amp;quot;trace&amp;quot;); 这一行，从而添加一个 trap entry，从而实现调用 trace 时会发生 trap，从而会执行 ECALL 指令，并且会将系统调用的接口的参数（这里就是 trace 的参数）的存入寄存器 a0、a1 等（从左往右第一个参数的地址存入 a0，依次类推），此外，还会将 trace 对应的系统调用号存入寄存器 a7。&#xA;之后控制权来到 kernel 中的 syscall 函数，它从 a7 中取出系统调用号，并执行系统调用号对应的 sys_func。&#xA;这里的系统调用号可以理解为数组索引，在本次 Lab 中需要我们修改 kernel/syscall.c 和 kenel/syscall.h 从而添加 trace 对应的系统调用号，以及内核中 trace 对应的 sys_trace 的实现）。&#xA;System call tracing 官网的提示其实是比较全面了，按提示处理，即可添加 trace 的系统调用接口：</description>
    </item>
    <item>
      <title>MIT 6.S081 操作系统组织架构</title>
      <link>http://localhost:1313/posts/tech/xv6-os-organization.zh/</link>
      <pubDate>Thu, 29 Jun 2023 18:59:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/xv6-os-organization.zh/</guid>
      <description>进程概述 64 位的 RISC-V 的 VAS 是 39 位的，即 VA 只有 39 位，而 Xv6 则只有 38 位，最大虚拟地址为 #define MAXVA 0x3fffffffff。&#xA;VAS 的顶端，即最高位存放了两个 page，一个是用于 trampoline，一个用于 mapping the process&amp;rsquo;s trapframe。 Xv6 使用这两个 page 来切换到内核以及返回。&#xA;进程的状态被定义在 kernel/proc.h 的结构体 struct proc 所描述，进程在内核中最重要的信息就是它的 page table、 kernel stack 以及运行状态（run state）。&#xA;A process can make a system call by executing the RISC-V ecall instruction. This instruction raises the hardware privilege level and changes the program counter to a kernel-defined entry point.</description>
    </item>
    <item>
      <title>MIT 6.s081 实验环境搭建</title>
      <link>http://localhost:1313/posts/tech/mit6.s081-env-configuration.zh/</link>
      <pubDate>Wed, 28 Jun 2023 15:45:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/mit6.s081-env-configuration.zh/</guid>
      <description>2021 版 准备工作 Linux 系统，我是在实验室配的主机上装了 Debian Bookworm，然后mac 通过 ssh 连接上去进行操作，宿舍里则是使用的 wsl2，里面的发行版也是 Debian Bookworm。&#xA;开始配置 clone 源码 在 ~/Documents/code/mit 目录下执行 git clone git://g.csail.mit.edu/xv6-labs-2021，将源码 clone 下来。并执行 git clone https://github.com/mit-pdos/xv6-riscv-book.git，这个是参考资料（即 PDF 对应的 Latex 源码）&#xA;前面 clone 下来的 repository 包含了多个分支，每个分支对应一个 Lab。&#xA;执行 cd xv6-labs-2021 &amp;amp;&amp;amp; git checkout util，切换到 Lab Utilities 对应的 分支。&#xA;安装工具 执行以下两条命令：&#xA;$ sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade $ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 从而安装对应工具。&#xA;开始调试 这里会用到 tmux 的功能（非必需），在 util 分支下的 ~/Documents/code/mit/xv6-labs-2021 目录下，执行 make qemu-gdb， 然后先按 ctrl+b 再按 % 键，在 iterm2 的右侧创建一个新 panel，如图</description>
    </item>
    <item>
      <title>异常控制流（Exceptional Control Flow, ECF）</title>
      <link>http://localhost:1313/posts/tech/exceptional_control_flow.zh/</link>
      <pubDate>Tue, 27 Jun 2023 15:41:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/exceptional_control_flow.zh/</guid>
      <description>异常控制流简介 从给处理器上电起，直到断电，程序计数器（PC）假设一个值的序列： $$ a_0, a_1, \cdots, a_{n - 1}$$&#xA;每个 $a_k$ 是某个相应的指令 $I_k$ 的地址，每次从 $a_k$ 到 $a_{k + 1}$ 的过渡称为控制转移（control transfer）。这样的控制转移序列叫做处理器的控制流（flow of control 或 control flow）。&#xA;最简单的控制流是一个平滑的序列，即 $I_k$ 和 $I_{k + 1}$ 在内存中是连续的。&#xA;现代系统通过使控制流发生突变来应对系统状态的变化。一般而言我们把这些突变称为异常控制流（Exceptional Control Flow, ECF）。&#xA;例如当前程序在执行地址 $a_k$ 对应的指令 $I_k$，正常情况下，下一个指令应该是应该是地址 $a_{k + 1}$ 对应的指令 $I_{a_{k + 1}}$，但是由于发生了 page fault，它转去执行内核态的缺页异常处理程序，对应指令 $I_j$，执行完 $I_j$ 之后，它又回来执行 $I_k$。&#xA;For example, at the hardware level, events detected by the hardware trigger abrupt control transfers to exception handlers.</description>
    </item>
    <item>
      <title>红黑树</title>
      <link>http://localhost:1313/posts/tech/red-black-tree.zh/</link>
      <pubDate>Mon, 26 Jun 2023 19:44:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/red-black-tree.zh/</guid>
      <description>自顶向下的 2-3-4 树 插入结点 2-3-4 树的插入算法，简而言之，就是在往下查找应该将待插入的 new_key 插入到何处的时候，一旦碰到 4- 结点，就将 4- 结点中间的 key 上溢，剩下的两个 key 作为两个 2- 结点，这个上溢的过程也是递归的，可以理解为向原先 4- 结点的父结点插入 4- 结点中间的这个 key，4- 结点剩下的部分作为两个 2- 结点。我们的这个分解算法，保证了4- 结点的父结点不会是 4- 结点。（这里可以用数学归纳法给出证明）&#xA;这样处理到最后，我们的 new_key 要插入的结点一定是 2- 结点或者 3- 结点，因此，我们可以直接插入。&#xA;要实现这个插入算法，我们需要：&#xA;将 4- 结点表示为由三个 2- 结点组成的一个平衡的子树，根结点和两个子结点都用 red link 连接； 在向下的过程中分解所有 4- 结点并进行颜色转换； 和插入操作一样，在向上的过程中用旋转将 4- 结点配平； 但实际上，我们只要移动 put 方法中的三行代码就能由 2-3 树对应的红黑树操作转移到 2-3-4 树对应的红黑树操作；即将 FlipColors 语句（以及 if 判断）移动到 nullptr 测试之后，递归调用之前，如下：&#xA;void Put(int key, int val) { root_ = Put(key, val, root_); root_-&amp;gt;color_ = kBlack; // 根结点的颜色一定是黑色！ } auto Put(int key, int val, Node *h) -&amp;gt; Node * { // h 表示我们往以 h 为根结点的树中插入结点 if (h == nullptr) { return new Node(key, val, 1, kRed); } if (isRed(h-&amp;gt;left_) &amp;amp;&amp;amp; isRed(h-&amp;gt;right_)) { // 左右子结点都是红色，翻转颜色 // 即碰到 4- 结点就分解成两个 2- 结点 FlipColors(h); } if (key &amp;lt; h-&amp;gt;key_) { h-&amp;gt;left_ = Put(key, val, h-&amp;gt;left_); } else if (key &amp;gt; h-&amp;gt;key_) { h-&amp;gt;right_ = Put(key, val, h-&amp;gt;right_); } else { h-&amp;gt;val_ = val; } if (!</description>
    </item>
    <item>
      <title>左倾红黑树 （LLRB）</title>
      <link>http://localhost:1313/posts/tech/left-lean-red-black-tree.zh/</link>
      <pubDate>Sat, 24 Jun 2023 13:36:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/left-lean-red-black-tree.zh/</guid>
      <description>简介 红黑树是平衡二叉查找树的一种，前面我们提到，非平衡的 BST，在只有随机插入和查询的情况下，时间复杂度是 $O(\log n)$ 的，然而，如果同时存在随机插入和随机删除，那么时间复杂度会退化到 $O(\sqrt n)$，这是我们无法接受的。&#xA;红黑树在插入和删除时，会维持树的平衡，即保证树的高度在 $[\log n, \log(n + 1)]$，理论上极端情况可能树高最大会到达 $2 * \log n$，实际上很难遇到（尽管这样，还是保证了 $O(\log n)$ 的增删查改时间复杂度。&#xA;红黑树其实是 2-3 查找树或者 2-3-4 查找树的一种二叉树的实现方式。其中基于 2-3 树实现的红黑树被称为左倾红黑树（Left-Leaning Red-Black Trees, LLRB），基于 2-3-4 树实现的就是普通的红黑树，左倾红黑树实现起来比红黑树更简单一些（《算法 第四版》里面也主要讲的左倾红黑树），因此先讲左倾红黑树。&#xA;2-3 查找树 在普通的二叉树中，非叶子结点可以有一个或者两个子结点，如果没有子结点，那么就是叶子结点。&#xA;而 2-3 查找树的限制要严格很多。我们将拥有一个 key 和两个链接 的结点称为 2- 结点，拥有两个 key 和三个链接的结点称为 3- 结点。&#xA;2- 结点含有一个 key，两个 link； 3- 结点含有两个不同的 key，三个 link。 3- 结点含有两个 key（$key_1 &amp;lt; key_2$），三个链接，左链接指向 2-3 树中的 key 都小于 $key_1$，中间链接指向的 2-3 树中的 key 都满足 $key_1 &amp;lt; key &amp;lt; key_2$，右链接指向的 2-3 树中的 key 都大于 $key_2$。</description>
    </item>
    <item>
      <title>树状数组</title>
      <link>http://localhost:1313/posts/tech/binary_index_tree.zh/</link>
      <pubDate>Fri, 23 Jun 2023 23:55:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/binary_index_tree.zh/</guid>
      <description>引入 数装数组是一种支持单点修改和区间查询的数据结构。&#xA;这里的区间查询一般指求和。&#xA;普通树状数组维护的信息以及运算要满足结合律并且可以差分。&#xA;定义 考虑下标从 $1$ 开始的数组 $a[1]\sim a[8]$，如下图所示：&#xA;我们可以发现：&#xA;$c[2]$ 管辖 $\sum\limits_{i = 1}^2 a[i]$； $c[4]$ 管辖 $\sum\limits_{i = 1}^4 a[i]$； $c[6]$ 管辖 $\sum\limits_{i = 5}^6 a[i]$； $c[8]$ 管辖 $\sum\limits_{i = 1}^8 a[i]$； 即 $c[x]$ 管辖 $\sum\limits_{i = x - (x \text{AND} -x) + 1}^x a[i]$。例如 $6\text{AND}(-6) + 1 = 5$。&#xA;同时我们定义 $\text{lowbit}(x) = x \text{AND} -x$&#xA;使用 那么如何使用树状数组呢，第一步是初始化，我们先假定原数组也是下标从 $1$ 开始，从 $0$ 开始那么做相应变换即可。&#xA;初始化 我们先令 $c[i] = 0$，然后遍历 $a[j]$，每次遍历相当于是（假设原数组元素均为 $0$，然后将其值加上 $a[i]$），即初始化树状数组相当于是做了 $n$ 次单点修改。</description>
    </item>
    <item>
      <title>354. Russian Doll Envelopes (Hard)</title>
      <link>http://localhost:1313/posts/leet/354.russian-doll-envelopes/</link>
      <pubDate>Fri, 23 Jun 2023 23:38:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/354.russian-doll-envelopes/</guid>
      <description>Description 354. Russian Doll Envelopes (Hard)&#xA;Solution The initial reaction to this problem is definitely sorting. The question is, should the second dimension be sorted in ascending or descending order?&#xA;Firstly, let&amp;rsquo;s observe the question. It states that both dimensions must be strictly smaller. When I attempted the problem myself, I didn&amp;rsquo;t notice this point and got stuck for a while. However, once we consider this requirement, it becomes much clearer.</description>
    </item>
    <item>
      <title>354. 俄罗斯套娃信封问题 (Hard)</title>
      <link>http://localhost:1313/posts/leet/354.russian-doll-envelopes.zh/</link>
      <pubDate>Fri, 23 Jun 2023 23:38:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/354.russian-doll-envelopes.zh/</guid>
      <description>问题描述 354. 俄罗斯套娃信封问题 (Hard)&#xA;给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wᵢ, hᵢ] ，表示第 i 个信封的宽度和高度。&#xA;当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。&#xA;请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。&#xA;注意：不允许旋转信封。&#xA;示例 1：&#xA;输入：envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出：3 解释：最多信封的个数为 3, 组合为: [2,3] =&amp;gt; [5,4] =&amp;gt; [6,7]。 示例 2：&#xA;输入：envelopes = [[1,1],[1,1],[1,1]] 输出：1 提示：&#xA;1 &amp;lt;= envelopes.length &amp;lt;= 10⁵ envelopes[i].length == 2 1 &amp;lt;= wᵢ, hᵢ &amp;lt;= 10⁵ 解题思路 本题的第一反应肯定是排序，按照第数组的第一个维度升序排序，问题在于，第二个维度是应该升序还是降序呢？&#xA;首先，观察题目，题目要求是两个维度都必须严格小于才行，我自己做的时候就没观察到这一点，卡了很久，注意到这一点的话，其实就好想很多了。&#xA;我们先假设按照第二个升序排列，当我们选择了 $(w_i, h_i)$ 之后，那么我们就是要找满足 $(w_j, h_j)$ 两个维度都严格小于 $(w_i, h_i)$ 的最大的 $(w_j, h_j)$，这里就可以联系到 LIS 问题了。</description>
    </item>
    <item>
      <title>二叉搜索树</title>
      <link>http://localhost:1313/posts/tech/bst.zh/</link>
      <pubDate>Fri, 23 Jun 2023 15:08:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/bst.zh/</guid>
      <description>二叉搜索树 二叉搜索树（Binary Search Tree，BST）是指一颗空树或者有下列性质的二叉树：&#xA;若任意节点的左子树不为空，那么左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不为空，那么右子树上所有节点的值均小于它的根节点的值； 任意节点的左、右子树也分别为二叉搜索树； 二叉树的定义是从一个递归的角度来定义的，验证二叉树其实很简单，即中序遍历二叉树，节点的值从严格递增。换言之，二叉搜索树也可以定义成中序遍历时节点值严格递增的二叉树。&#xA;BST 的删除 对树的定义，我们采取 Leetcode 中的定义：&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) { } TreeNode(int x) : val(x), left(nullptr), right(nullptr) { } TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) { } }; 首先，我们定义两个辅助函数 TreeNode *delMax(TreeNode *root, int key); 和 TreeNode *delMin(TreeNode *root, int key);，分别表示删除二叉树中的值最大的节点和值最小的节点。还需要辅助函数 int getMin(TreeNode *root); 和 int getMax(TreeNode *root)。&#xA;getMin 和 getMax 自不必多说，以 delMax 为例，都是利用递归进行处理，递归返回的是当前以 root 为根节点的树，删除了最大值之后的 root。递归终止条件即 root-&amp;gt;right == nullptr，说明找到了树的最大值，此时返回 root-&amp;gt;left。（以避免左子树不为空的情况，左子树为空则相当于返回了 nulltpr）</description>
    </item>
    <item>
      <title>macOS 配置算法（第四版）的开发环境</title>
      <link>http://localhost:1313/posts/blog/algs4-java-mac-configure.zh/</link>
      <pubDate>Thu, 22 Jun 2023 17:36:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/algs4-java-mac-configure.zh/</guid>
      <description>Java 环境配置 前往 Adoptium 下载他们预编译的 JDK 17（最新的 LTS 版本）的安装器，安装好之后，命令行执行 java -version，输出如下：&#xA;openjdk version &amp;#34;17.0.7&amp;#34; 2023-04-18 OpenJDK Runtime Environment Temurin-17.0.7+7 (build 17.0.7+7) OpenJDK 64-Bit Server VM Temurin-17.0.7+7 (build 17.0.7+7, mixed mode) 说明环境变量已经自动配置好了。&#xA;同时前往 Jetbrains 官网下载 IntelliJ IDEA CE（懒得再申请教育优惠了），安装好之后打开，在 ~/Documets/zCode/Algs_4th/ 目录下创建名为 algs4 的新项目，JDK 选择我们安装的 JDK 17。如下图：&#xA;algs4 配置 先去书籍官网下载 algs4.jar，我这里直接放到了上面 IDEA 创建的项目的目录下，即 ~/Documets/zCode/Algs_4th/algs4/，然后用 IDEA 打开该项目，File-&amp;gt;Project Structure-&amp;gt;Modules-&amp;gt;Dependencies 点击 Module SDK 下面的加号，选择 JARs or directories，再选择我们放在项目目录下的 algs4.jar 文件，然后就会看到 algs4.jar 已经被添加到该工程的 Dependencies 依赖包中，勾选，然后点击确定，就完成了环境的搭建。</description>
    </item>
    <item>
      <title>741. Cherry Pickup (Hard)</title>
      <link>http://localhost:1313/posts/leet/741.cherry-pickup/</link>
      <pubDate>Wed, 21 Jun 2023 12:32:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/741.cherry-pickup/</guid>
      <description>Description 741. Cherry Pickup (Hard)&#xA;Solution This problem can be approached using dynamic programming, and although the concept is straightforward, there are several details to consider.&#xA;The process of picking cherries back and forth is equivalent to two individuals moving from $[0, 0]$ to $[n - 1, n - 1]$.&#xA;Let&amp;rsquo;s use $k$ to represent the number of steps taken, $x_1$ to represent the current $x$ coordinate of the first person, and $x_2$ to represent the current $x$ coordinate of the second person.</description>
    </item>
    <item>
      <title>741. 摘樱桃 (Hard)</title>
      <link>http://localhost:1313/posts/leet/741.cherry-pickup.zh/</link>
      <pubDate>Wed, 21 Jun 2023 12:32:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/741.cherry-pickup.zh/</guid>
      <description>问题描述 741. 摘樱桃 (Hard)&#xA;给你一个 n x n 的网格 grid ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：&#xA;0 表示这个格子是空的，所以你可以穿过它。 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 -1 表示这个格子里有荆棘，挡着你的路。 请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：&#xA;从位置 (0, 0) 出发，最后到达 (n - 1, n - 1) ，只能向下或向右走，并且只能穿越有效的格子（即只可 以穿过值为 0 或者 1 的格子）； 当到达 (n - 1, n - 1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的 格子； 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 0 ）； 如果在 (0, 0) 和 (n - 1, n - 1) 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。 示例 1：&#xA;输入：grid = [[0,1,-1],[1,0,-1],[1,1,1]] 输出：5 解释：玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。 在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。 然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。 总共捡到 5 个樱桃，这是最大可能值。 示例 2：</description>
    </item>
    <item>
      <title>1595. Minimum Cost to Connect Two Groups of Points] (Hard)</title>
      <link>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points/</link>
      <pubDate>Wed, 21 Jun 2023 11:43:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points/</guid>
      <description>Description 1595. Minimum Cost to Connect Two Groups of Points (Hard)&#xA;Solution Dynamic Programming + State Compression&#xA;We use a binary number $j$ to represent the set of chosen elements from the second group. $dp[i][j]$ denotes the minimum cost of connecting the first $i$ elements from the first group and the set of elements $j$ from the second group.&#xA;To establish the recurrence relation, we consider the elements from the first group.</description>
    </item>
    <item>
      <title>1595. 连通两组点的最小成本 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points.zh/</link>
      <pubDate>Wed, 21 Jun 2023 11:43:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1595.minimum-cost-to-connect-two-groups-of-points.zh/</guid>
      <description>问题描述 1595. 连通两组点的最小成本 (Hard)&#xA;给你两组点，其中第一组中有 size₁ 个点，第二组中有 size₂ 个点，且 size₁ &amp;gt;= size₂ 。&#xA;任意两点间的连接成本 cost 由大小为 size₁ x size₂ 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。 如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是 连通的。 换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一 组中的一个点连接。&#xA;返回连通两组点所需的最小成本。&#xA;示例 1：&#xA;输入：cost = [[15, 96], [36, 2]] 输出：17 解释：连通两组点的最佳方法是： 1--A 2--B 总成本为 17 。 示例 2：&#xA;输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]] 输出：4 解释：连通两组点的最佳方法是： 1--A 2--B 2--C 3--A 最小成本为 4 。 请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需 要关心最低总成本。 示例 3：</description>
    </item>
    <item>
      <title>Linux 动态内存分配</title>
      <link>http://localhost:1313/posts/tech/linux_memory_allocate.zh/</link>
      <pubDate>Tue, 20 Jun 2023 15:29:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/linux_memory_allocate.zh/</guid>
      <description>动态内存分配器 进程中名为 heap 的 VM area 就是由动态内存分配器（dynamic memory allocator）来维护的。Heap 会向高地址（向上）增长。对每个进程，内核维护着一个名为 brk 的变量，该变量指向 Heap 的顶部，如下图所示：&#xA;Allocator 将 Heap 视为一组不同大小的 block 组成的集合来维护。这里 block 和 chunk 的概念是等价的，该 block 要么是已分配的（allocated），要么是空闲的（free）。&#xA;Each block is a contiguous chunk of virtual memory that is either allocated or free.&#xA;Allocator 可以分为显式分配器（explicit allocator）和隐式分配器（implicit allocator）。&#xA;显示分配器要求应用显示地释放任何已分配的块，分配也需要手动分配。例如 C 中的 malloc 和 free，C++ 中的 new 和 delete； 隐式分配器又被称为垃圾收集（garbage collection），例如 Java、C#。 malloc 和 free $32$ 位系统中，malloc 返回的地址总是 $8$ 的倍数，即 malloc 返回的地址的最低三位总是 $0$，亦即 malloc 分配的 block 至少占据 $8$ 的倍数个 byte；而 $64$ 位系统中，malloc 返回的地址总是 $16$ 的倍数。</description>
    </item>
    <item>
      <title>Linux 虚拟内存系统</title>
      <link>http://localhost:1313/posts/tech/linux_virtual_memory.zh/</link>
      <pubDate>Sun, 18 Jun 2023 14:50:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/linux_virtual_memory.zh/</guid>
      <description>Linux 虚拟内存系统 首先，对 Linux 的虚拟内存系统做一个概述，以了解一个实际的操作系统是如何组织虚拟内存，以及如何处理缺页（page fault）的。&#xA;Linux 位为每个进程维护了一个单独的虚拟地址空间，形式如下：&#xA;可以看到，虚拟地址空间可以分为内核虚拟内存空间和用户虚拟内存空间两部分，实际上，$64$ 位系统的虚拟空间划分是这样的：&#xA;我们可以看到，在用户内存空间和内核内存空间之间还有一大片的“未定义”的区域，这是为什么呢？（注意，后续图片将有灵魂画手出没！）。&#xA;之前我们提到，AMD 制定的 $64$ 位 CPU 架构时，虽然是 $64$ 位的，即总的虚拟地址空间是 $64$ 位的，但实际上，用到的虚拟地址其实只有其中的低 $48$ 位。&#xA;当我们把 addr_val 解释为一个虚拟地址时，我们使用的真正的虚拟地址，其实只有它的低 $48$ 位，（由 AMD 设计 CPU 架构的时候规定，其实 $48$ 位也完全够用了），后 $16$ 位的值会与 addr_val 的第 $47$ 位保持一致（全 $0$ 或者全 $1$），全 $0$ 表示该虚拟地址处于当前虚拟地址空间的用户态部分，全 $1$ 表示处于内核态部分。&#xA;换言之，虚拟地址的高 $16$ 位是由 CPU 在生成要访问的虚拟地址时，先生成低 $48$ 位的虚拟地址，再根据第 $47$ 位的值是 $0$ 还是 $1$，判断地址属于内核虚拟地址空间还是用户虚拟地址空间（或者说进程虚拟地址空间），再生成虚拟地址的高 $16$ 位。&#xA;如下图所示：&#xA;Linux 虚拟内存区域（area） Linux organizes the virtual memory as a collection of areas (also called segments).</description>
    </item>
    <item>
      <title>1494. Parallel Courses II (Hard)</title>
      <link>http://localhost:1313/posts/leet/1494.parallel-courses-ii/</link>
      <pubDate>Fri, 16 Jun 2023 23:54:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1494.parallel-courses-ii/</guid>
      <description>Description 1494. Parallel Courses II (Hard)&#xA;Solution This problem readily brings to mind the concept of topological sorting, followed by a greedy approach. However, this approach is erroneous! In essence, this problem is NP-Hard and can only be solved through brute force.&#xA;Let&amp;rsquo;s consider the application of state-compressed dynamic programming (DP). The subproblems are relatively straightforward to identify. We start by choosing $1, 2$, followed by selecting $3, 4, 5 $(meeting the prerequisites).</description>
    </item>
    <item>
      <title>1494. 并行课程 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/1494.parallel-courses-ii.zh/</link>
      <pubDate>Fri, 16 Jun 2023 23:54:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1494.parallel-courses-ii.zh/</guid>
      <description>问题描述 1494. 并行课程 II (Hard)&#xA;给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 relations 中， relations[i] = [xᵢ, yᵢ] 表示一个先修课的关系，也就是课程 xᵢ 必须在课程 yᵢ 之前上。同时你还有一个整数 k 。&#xA;在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。&#xA;请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。&#xA;示例 1：&#xA;输入：n = 4, relations = [[2,1],[3,1],[1,4]], k = 2 输出：3 解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ， 第三个学期上课程 4 。 示例 2：&#xA;输入：n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2 输出：4 解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课 程 1 ，第四学期上课程 5 。 示例 3：</description>
    </item>
    <item>
      <title>关于我</title>
      <link>http://localhost:1313/posts/blog/about_me.zh/</link>
      <pubDate>Wed, 14 Jun 2023 15:39:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/about_me.zh/</guid>
      <description>我写博客的初心很简单，一是记录一些软件的配置过程（防止第二次配置的时候又抓瞎）；二是记录下一下自己学习过程中的一些心得体会。&#xA;在 高乙超的博客 中，我曾经看到一句话，叫 &amp;ldquo;To learn, read; To know, write; To master, teach&amp;rdquo;。&#xA;过去二十年里，在学习的过程中，我一直是作为一个输入方，应付考试倒是没啥问题，但也仅此而已了。&#xA;为了更好地体会和领悟这些知识，我决定写写博客，既是做笔记，也是对自己的所学的一种整理和输出，也希望能有更多同道者看到，从而一起交流学习、共同进步。</description>
    </item>
    <item>
      <title>便捷同步本地的博客文档到博客园</title>
      <link>http://localhost:1313/posts/blog/cnblog_hugo.zh/</link>
      <pubDate>Wed, 14 Jun 2023 14:22:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/cnblog_hugo.zh/</guid>
      <description>前言 我写博客的初心很简单，一是一些软件的配置过程（防止第二次配置的时候又抓瞎）；二是记录下一下自己学习过程中的一些心得体会，在 高乙超的博客 中，我曾经看到一句话，叫 &amp;ldquo;To learn, read; To know, write; To master, teach&amp;rdquo;。&#xA;过去二十年里，在学习的过程中，一直是作为一个输入方，应付考试倒是没啥问题，但也仅此而已了。为了更好地体会和领悟这些知识，我决定写写博客，既是做笔记，也是对自己的所学的一种整理和输出，也希望能有更多同道者看到，从而一起交流学习、共同进步。&#xA;最一开始么，其实是告诫自己，写博客的核心在于动笔输出，而不是折腾博客的主题又或是如何搭建博客站点，因此就想着选择一个现有的公开的博客平台，经过一番比较之下选择了博客园。说是比较，其实也没得太多选择的余地，除了博客园也就是 CSDN 了，然而对于 CSDN 我实在是深恶痛绝。博客园相较之下克制很多，广告少，更聚焦于技术，原创内容更多且更有深度，虽然界面以 2023 年的眼光来看比较老土了，但博客园支持自定义 CSS 啊。&#xA;没错，我还是无法控制自己，折腾了一下博客园的主题，鉴于本人对前端一窍不通，就算以后了解了，以我这种纠结来纠结去的性子，自己动手写主题，选择配色、主题、字号等绝对是噩梦，因此仅限于在 GitHub 上搜索他人做好的主题，挑了一番之后，网上比较热门的诸如 Silence 之类的主题，我都觉得太花里胡哨了，而且字体并不喜欢，找到一个设计风格不错的，奈何主题又太久没更新了，最后作罢。&#xA;最后，我还是选择了博客园自带的 Coding Life 主题，修改了一下代码块的 CSS，主要是改了代码块字体。&#xA;然而写了几篇博客之后，又发现博客园自带的编辑器太难用了。还是要自己现在本地用 VsCode 配合 Markdown Preview Enhanced 插件写好，再复制粘贴到博客园上发布，就觉得有点麻烦，倒不如用 Hugo 或者 Hexo 了，配置好之后，写好博客再敲一下命令就能搞定了。&#xA;于是我又动了用 Hexo 或者 Hugo 自己搭一个博客网站的念头，首先简单对比了一下，选择了 Hugo，比起 Hexo 来说，它性能高，配置起来更方便，Hexo 非常流行的 Next 主题我也并不喜欢，倒是 Hugo 的不少主题我非常喜欢，我个人在用的主题是 hugo-PaperMod 和 hugo-coder，没错，我一口气搭了两个网站，在我看来 hugo-coder 更好看一点，而 hugo-PaperMod 功能更为齐全，用的人更多，教程也更多。&#xA;两个博客网址分别是 zwyyy456.tech 和 paper.zwyyy456.tech。&#xA;我这两个基于 Hugo 的博客可以说是纯白嫖实现的，域名是白嫖的 Freenom 的 .</description>
    </item>
    <item>
      <title>线段树</title>
      <link>http://localhost:1313/posts/tech/seg_tree.zh/</link>
      <pubDate>Tue, 13 Jun 2023 19:44:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/seg_tree.zh/</guid>
      <description>引入 线段树是算法竞赛中常用的用来维护区间信息的数据结构。&#xA;树状数组可以在 $O(\log n)$ 的时间内实现单点修改、区间查询（求和、求最值、求异或等）；而线段树还可以在 $O(\log n)$ 时间内实现区间修改操作，例如将 $[L, R]$ 区间范围内的值都加上一个常数，乘以一个常数，或者都置为某个数。&#xA;常规线段树 结构 就我的理解而言，常规的线段树能实现的功能其实与树状数组没什么区别，都只能在 $O(\log n)$ 时间内实现单点修改和区间查询。&#xA;线段树的构造：给定一个区间 $[L, R]$，取 $mid = L + (R - L) / 2$，将它划分为 $[L, mid]$ 和 $[mid + 1, R]$ 两个区间，如此递归地划分，直到区间长度为 $1$ 为止，这些父区间和划分为左右两边的子区间，在组织结构上很像二叉树的父结点和子结点，这也就是线段树的名字由来。&#xA;我们这里以区间求和为例，线段树的每个结点对应着相应的线段上的点的和，以数组 $a = {1,2,3,4,5,6,7,8,9,10}$ 为例，线段树的结构如图所示：&#xA;可以看到，线段树存储的基础形式是数组，与二叉堆的存储方式一致，假设当前父结点的编号为 $p$，那么左儿子的编号为 $2 * p$，右儿子的编号为 $2 * p + 1$，结点的值为对应区间的和。&#xA;构建线段树的方式其实与“求以该节点为根节点的子树的和”类似，递归处理是很容易的。&#xA;代码实现：&#xA;void Build(int idx, int l, int r, vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (l == r) { seg[idx] = nums[l]; return; } int mid = l + (r - l) / 2; Build(2 * idx, l, mid, nums); // 递归构建左子树 Build(2 * idx, mid + 1, r, nums); // 递归构建右子树 seg[idx] = seg[2 * idx] + seg[2 * idx + 1]; // 更新 seg[idx] } 区间查询 线段树的区间查询，其实只要掌握了递归，就很好理解了。</description>
    </item>
    <item>
      <title>数组形式组织的树</title>
      <link>http://localhost:1313/posts/tech/tree_in_array.zh/</link>
      <pubDate>Mon, 12 Jun 2023 13:47:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/tree_in_array.zh/</guid>
      <description>引入 在 LeetCode 中，二叉树一般是以链表结点的形式组织的，定义如下：&#xA;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(nullptr), right(nullptr) {} }; 其实也可以用数组的形式组织，即使用 $parent$ 数组，$y = parent[x]$ 说明 $y$ 是 $x$ 的父结点，根结点的父结点为 $-1$，表示父结点不存在。&#xA;最近公共祖先 链表形式 对链表形式树，求最近公共祖先可以使用递归很方便的解决：&#xA;/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr || root == p || root == q) { return root; } TreeNode *left = lowestCommonAncestor(root-&amp;gt;left, p, q); TreeNode *right = lowestCommonAncestor(root-&amp;gt;right, p, q); if (left !</description>
    </item>
    <item>
      <title>1483. Kth Ancestor of a Tree Node (Hard)</title>
      <link>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node/</link>
      <pubDate>Mon, 12 Jun 2023 13:07:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node/</guid>
      <description>Description 1483. Kth Ancestor of a Tree Node (Hard) You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.&#xA;The kth ancestor of a tree node is the kth node in the path from that node to the root node.</description>
    </item>
    <item>
      <title>1483. 树节点的第 K 个祖先 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node.zh/</link>
      <pubDate>Mon, 12 Jun 2023 13:06:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1483.kth-ancestor-of-a-tree-node.zh/</guid>
      <description>问题描述 1483. 树节点的第 K 个祖先 (Hard) 给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。&#xA;树节点的第 k个祖先节点是从该节点到根节点路径上的第 k 个节点。&#xA;实现 TreeAncestor 类：&#xA;TreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。 getKthAncestor (int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。 示例 1：&#xA;输入： [&amp;#34;TreeAncestor&amp;#34;,&amp;#34;getKthAncestor&amp;#34;,&amp;#34;getKthAncestor&amp;#34;,&amp;#34;getKthAncestor&amp;#34;] [[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]] 输出： [null,1,0,-1] 解释： TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // 返回 1 ，它是 3 的父节点 treeAncestor.</description>
    </item>
    <item>
      <title>CPU 缓存一致性：MESI</title>
      <link>http://localhost:1313/posts/tech/cache_mesi.zh/</link>
      <pubDate>Wed, 07 Jun 2023 10:36:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/cache_mesi.zh/</guid>
      <description>概述 MESI（也称伊利诺斯协议）是一种广泛使用的支持 write-back 策略的缓存一致性协议。&#xA;MESI 状态 我们假设 CPU 中共有 $k$ 个核； CPU 中每个 cacheline 使用 $4$ 种状态进行标记：&#xA;状态 介绍 所有核中该状态的个数 MODIFIED 实际上是 exclusive dirty，说明该核的缓存数据被修改了，且并未写入到更低一层存储中；当某个核的缓存处于该状态时，其余核的对应 cacheline 均为 INVALID 1 EXCLUSIVE 实际上是 exclusive clean，说明该核的缓存刚从更低一层存储中读取到了最新的数据；当某个核的缓存处于该状态时，其余核的对应 cacheline 均为 INVALID 1 SHARED 实际上是 shared clean，说明多个核的缓存从更低一层存储中读到的数据都是最新的，处于该状态的核的数量一定 $\geq 2$，其余核的对应 cacheline 均为 INVALID $\geq 2$ INVALID 说明该核的 cacheline 无效 状态切换 我们以四个核为例，用四元组如 $(M, I, I, I)$ 表示四个核的 cacheline 状态，假设只操作第一个核的 cacheline：&#xA;执行读操作 $(M,I,I,I)$ 执行读，状态仍为 $(M, I, I, I)$； $(E,I,I,I)$ 执行读，状态仍为 $(E, I, I, I)$； $(S,S,I,I)$ 执行读，状态仍为 $(S, S, I, I)$； $(I,M,I,I)$ 执行读，将第二个核的 cacheline 的数值 $val$ 写入内存，然后更新第一个核的 cacheline 的值为 $val$，状态切换为 $(S,S,I,I)$； $(I,E,I,I)$ 执行读，更新第一个核的 cacheline 为第二个核的数值 $val$，状态切换为 $(S,S,I,I)$； $(I,S,S,I)$ 执行读，更新第一个核的 cacheline 为第二个或第三个核的数值 $val$，状态切换为 $(S,S,S,I)$； $(I,I,I,I)$ 执行读，从内存中读取对应的地址的数值 $*addr$ 到 cacheline，状态切换为 $(E, I, I, I)$； 执行写操作 $(M,I,I,I)$ 执行写，状态仍为 $(M, I, I, I)$； $(E,I,I,I)$ 执行写，状态变为 $(M, I, I, I)$； $(S,S,I,I)$ 执行写，将其他所有状态为 $S$ 的 cacheline 的状态全都设置为 $I$，状态变为 $(M, I, I, I)$； $(I,M,I,I)$ 执行写，将第二个核的 cacheline 的数值 $val$ 写入内存（为了防止 ABA 问题，这里为什么要写回 TODO(zwyyy)，是否和指令原子性有关），状态变为 $I$，然后更新第一个核的 cacheline 的值为 $val$，再更新值为待写入的值 $write$_$value$，状态切换为 $(M,I,I,I)$； $(I,E,I,I)$ 执行写，更新第一个核的 cacheline 为第二个核的数值 $val$，将第二个核的状态设为 $I$，状态切换为 $(M,I,I,I)$； $(I,I,I,I)$ 执行写，将 $write$_$val$ 写到 cacheline 中，状态切换为 $(M, I, I, I)$； 执行 evict 操作 </description>
    </item>
    <item>
      <title>跳表</title>
      <link>http://localhost:1313/posts/tech/skiplist.zh/</link>
      <pubDate>Tue, 06 Jun 2023 18:28:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/skiplist.zh/</guid>
      <description>跳表介绍 跳表是一种数据结构，使得包含 $n$ 个元素的有序序列的查找和插入操作的平均时间复杂度都是 $O(\log n)$，与红黑树、AVL 性能类似。&#xA;跳表的快速查询效果是通过维护一个多层次的链表实现的，且与前一层（下面一层）的链表元素相比，每一层链表中的元素的数量更少，一开始，算法在最上层（也是最稀疏的一层）查找，直到要查询的元素在该层相邻的两个元素中间。这时，算法将跳转到下一个层，重复刚才的搜索，直到找到需要查找的元素为止如下图所示：&#xA;层数索引从低到高逐渐递增。&#xA;描述 跳表是按照层构建的，跳表的最底层是一个普通的有序链表，每个更高层都是下层列表的子列表，相当于下层列表的快速通道，这里可以类比一下 B树 或者 B+树。&#xA;在跳表中，第 $i$ 层的元素会有概率 $p$ 出现在第 $i + 1$ 层中（$p$ 通常取 $\frac{1}{2}$ 或者 $\frac{1}{4}$），每个元素平均出现在 $\frac{1}{1 - p}$ 个列表中。&#xA;一般认为，列表有 $log_{\frac{1}{p}}n$ 层，在后面的实现中，我们固定了列表的层数为 $klevel = 8$，动态层数的列表实现起来比较复杂。&#xA;在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾：&#xA;如果该元素等于目标元素，则表明该元素已被找到； 如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。 每层链表中预期的查找步数最多为 $\frac{1}{p}$，而层数为 $\log_{\frac{1}{p}}n$，因此查找的总体步数为 $\frac{\frac{1}{p}}{\log_{\frac{1}{p}}n}$，$p$ 是常数，因此总体查找的时间复杂度为 $O(\log n)$ 的。&#xA;跳跃列表不像平衡树等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。&#xA;但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。&#xA;实现 以 1206. Design Skiplist (Hard) 为例，进行跳表的简单实现。&#xA;由上述图片，我们可以构想出结点的数据结构：&#xA;结点值 $val$； 存储当前结点每一层的 $next_$ 指针（这里使用 vector 存储）。 为了方便理解，我们其实可以把每个结点都看成图中 $klevel$ 高度，只是我们只画出来 $next_[i]$ 不为 $nullptr$ 的对应层罢了。 const int klevel = 8; struct Node { int val_; vector&amp;lt;Node *&amp;gt; next_; // next[i] 表示当前结点在第 i 层的 next，i 从 0 开始 Node(int val) : val_(val), next_{klevel, nullptr} { // 初始化 } }; 之后，我们使用一个辅助函数 void Find(int target, veoctor&amp;lt;Node *&amp;gt; pre); 来存储每一层中：满足值小于 $target$ 并且值最大的结点。</description>
    </item>
    <item>
      <title>2718. Sum of Matrix After Queries (Medium)</title>
      <link>http://localhost:1313/posts/leet/2718.sum-of-matrix-after-queries/</link>
      <pubDate>Tue, 06 Jun 2023 13:44:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2718.sum-of-matrix-after-queries/</guid>
      <description>Description 2718. Sum of Matrix After Queries (Medium) You are given an integer n and a 0-indexed 2D array queries where queries[i] = [typeᵢ, indexᵢ, valᵢ].&#xA;Initially, there is a 0-indexed n x n matrix filled with 0&amp;rsquo;s. For each query, you must apply one of the following changes:&#xA;if typeᵢ == 0, set the values in the row with indexᵢ to valᵢ, overwriting any previous values. if typeᵢ == 1, set the values in the column with indexᵢ to valᵢ, overwriting any previous values.</description>
    </item>
    <item>
      <title>2718. 查询后矩阵的和 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2718.sum-of-matrix-after-queries.zh/</link>
      <pubDate>Tue, 06 Jun 2023 13:44:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2718.sum-of-matrix-after-queries.zh/</guid>
      <description>问题描述 2718. 查询后矩阵的和 (Medium) 给你一个整数 n 和一个下标从 0 开始的 二维数组 que ries ，其中 queries[i] = [typeᵢ, indexᵢ, valᵢ] 。&#xA;一开始，给你一个下标从 0 开始的 n x n 矩阵，所有元素均 为 0 。每一个查询，你需要执行以下操作之一：&#xA;如果 typeᵢ == 0 ，将第 indexᵢ 行的元素全部修改为 valᵢ ，覆盖任何之前的值。 如果 typeᵢ == 1 ，将第 indexᵢ 列的元素全部修改为 valᵢ ，覆盖任何之前的值。 请你执行完所有查询以后，返回矩阵中所有整数的和。&#xA;示例 1：&#xA;输入：n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]] 输出：23 解释：上图展示了每个查询以后矩阵的值。所有操作执行完以后，矩 阵元素之和为 23 。 示例 2：&#xA;输入：n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2 ,1]] 输出：17 解释：上图展示了每一个查询操作之后的矩阵。所有操作执行完以后 ，矩阵元素之和为 17 。 提示：</description>
    </item>
    <item>
      <title>数位 DP</title>
      <link>http://localhost:1313/posts/tech/number_dp.zh/</link>
      <pubDate>Tue, 06 Jun 2023 10:37:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/number_dp.zh/</guid>
      <description>引入 数位是指把一个数字按照个、十、百、千、万等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 $0\sim 9$。&#xA;数位 DP 一般是用来解决一类特定问题，以 1012. Numbers With Repeated Digits (Hard) 为例，这一类问题的特征非常明显&#xA;要求统计满足一定条件的数的数量； 这些条件经过转化后可以使用“数位”的思想去理解和判断； 输入会提供一个数字区间（有时候只提供上界）来作为统计的限制； 上界很大（例如 $10^{22}$），暴力枚举会超时。 思路 对 1012. Numbers With Repeated Digits (Hard)，思路如下：&#xA;首先，正难则反，我们可以考虑 $[1, n]$ 范围内无重复数字的正整数的个数，记为 $res$，然后最终结果就是 $n - res + 1$（至于为什么还要再加上 $1$，后面会说明）。&#xA;因此问题转化为求 $[1, n]$ 范围内无重复数字的正整数的个数，符合上述的数位 DP 的特征，我们可以从记忆化搜索的角度去考虑，首先将 $n$ 转化为对应的字符串，对字符串的每一位，枚举每一位可能的数，如果最后组成的数字满足 $num &amp;lt; n$，那么 $res += 1$，这里很容易想到 dfs(string &amp;amp;str, int idx, int mask)，$mask$ 以二进制的形式表示 $0\sim 9$ 范围内的数是否被选择过；&#xA;但是仅仅是这样，我们不能方便的判断当前组成的数字是否满足 $num &amp;lt; n$，因此，我们需要一个额外的参数 $is_limit$。例如对数字 $n = 12345$，如果前面已经选择的数字为 $123$，那么对本次枚举，$is_limit$ 为 $true$，即数字只能选择 $0\sim4$，又因为 $1,\ 2,\ 3$ 已经选择了，$mask = 14$，因此只有 $0,\ 4$ 可以选，事实上，我们可以发现，在递归的过程中，当且仅当当前 $is_limit$ 为 $true$，且当前选择的数字与对应数位上的数字相等时，更深一层递归的 $is_limit$ 仍为 $true$，至此，递归函数为 dfs(string &amp;amp;str, int idx, int mask, bool is_limit)；</description>
    </item>
    <item>
      <title>1156. Swap For Longest Repeated Character Substring (Medium)</title>
      <link>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring/</link>
      <pubDate>Sat, 03 Jun 2023 14:02:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring/</guid>
      <description>Description 1156. Swap For Longest Repeated Character Substring (Medium) You are given a string text. You can swap two of the characters in the text.&#xA;Return the length of the longest substring with repeated characters.&#xA;Example 1:&#xA;Input: text = &amp;#34;ababa&amp;#34; Output: 3 Explanation: We can swap the first &amp;#39;b&amp;#39; with the last &amp;#39;a&amp;#39;, or the last &amp;#39;b&amp;#39; with the first &amp;#39;a&amp;#39;. Then, the longest repeated character substring is &amp;#34;aaa&amp;#34; with length 3.</description>
    </item>
    <item>
      <title>1156. 单字符重复子串的最大长度 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring.zh/</link>
      <pubDate>Sat, 03 Jun 2023 14:02:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1156.swap-for-longest-repeated-character-substring.zh/</guid>
      <description>问题描述 1156. 单字符重复子串的最大长度 (Medium) 如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字 符串。&#xA;给你一个字符串 text，你只能交换其中两个字符一次或者什么都 不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度 。&#xA;示例 1：&#xA;输入：text = &amp;#34;ababa&amp;#34; 输出：3 示例 2：&#xA;输入：text = &amp;#34;aaabaaa&amp;#34; 输出：6 示例 3：&#xA;输入：text = &amp;#34;aaabbaaa&amp;#34; 输出：4 示例 4：&#xA;输入：text = &amp;#34;aaaaa&amp;#34; 输出：5 示例 5：&#xA;输入：text = &amp;#34;abcdef&amp;#34; 输出：1 提示：&#xA;1 &amp;lt;= text.length &amp;lt;= 20000 text 仅由小写英文字母组成。 解题思路 可以利用双指针解决，我们先用数组 $cnt$ 统计 $text$ 中每个字符的出现的次数。&#xA;然后我们定一个三个指针，分别为 $i$，$j$，$k$。初始时都为 $0$，然后我们让 $j$ 右移，直到 $text[j] \neq text[i]$，然后令 $k = j + 1$，再右移 $k$，直到 $text[k] \neq text[i]$，这里可以统计一次结果，$res = \max(res, \min(k - i, cnt[text[i]]))$，然后令 $i = j$，重复以上步骤直到 $i &amp;gt;= text.</description>
    </item>
    <item>
      <title>2517. Maximum Tastiness of Candy Basket (Medium)</title>
      <link>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket/</guid>
      <description>Description 2517. Maximum Tastiness of Candy Basket (Medium) You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.&#xA;The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.&#xA;Return the maximum tastiness of a candy basket.&#xA;Example 1:</description>
    </item>
    <item>
      <title>517. 礼盒的最大甜蜜度 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket.zh/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2517.maximum-tastiness-of-candy-basket.zh/</guid>
      <description>问题描述 2517. 礼盒的最大甜蜜度 (Medium) 给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖 果的价格，另给你一个正整数 k 。&#xA;商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 **甜蜜度 ** 是礼盒中任意两种糖果 价格 绝对差的最小值。&#xA;返回礼盒的 最大 甜蜜度。&#xA;示例 1：&#xA;输入：price = [13,5,1,8,21,2], k = 3 输出：8 解释：选出价格分别为 [13,5,21] 的三类糖果。 礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8 , 16) = 8 。 可以证明能够取得的最大甜蜜度就是 8 。 示例 2：&#xA;输入：price = [1,3,1], k = 2 输出：2 解释：选出价格分别为 [1,3] 的两类糖果。 礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。 可以证明能够取得的最大甜蜜度就是 2 。 示例 3：</description>
    </item>
    <item>
      <title>二分答案</title>
      <link>http://localhost:1313/posts/tech/binary_search.zh/</link>
      <pubDate>Thu, 01 Jun 2023 15:53:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/binary_search.zh/</guid>
      <description>概述 二分答案即利用二分查找来得到答案，一般情况下，左边界 $left$ 是 $0$ 或者 $1$；右边界 $right$ 则视题目条件而定，取一个很大的数，然后利用二分查找的思想，来找到答案。&#xA;二分答案的要求 如果题目能够使用二分答案的思想来解决，那么 $[left, right]$ 范围内，要满足二段性，即对 $[left, res]$ 满足条件 $A$，而 $(res, right]$ 不满足条件 $A$，并且 res 的取值范围是连续的。&#xA;适用情况 如果题目要求满足 xxx 条件下的最大值或者最小值，就可以考虑二分答案，特别的，如果题目要求最小化的最大值或者最大化的最小值，那么要首先考虑使用二分答案。&#xA;例题 2517. 礼盒的最大甜蜜度 (Medium)&#xA;class Solution { public: int Bsearch(int target, vector&amp;lt;int&amp;gt; &amp;amp;price, int left) { int right = price.size(); while (left &amp;lt; right) { int mid = left + (right - left) / 2; if (price[mid] &amp;lt; target) { left = mid + 1; } else { right = mid; } } return left; } bool Check(int mid, vector&amp;lt;int&amp;gt; &amp;amp;price, int k, int n) { int start = 0; for (int i = 0; i &amp;lt; k - 1; ++i) { start = Bsearch(price[start] + mid, price, start); // cout &amp;lt;&amp;lt; start &amp;lt;&amp;lt; &amp;#34; start\n&amp;#34;; if (start &amp;gt;= n) { return false; } } return true; } int maximumTastiness(vector&amp;lt;int&amp;gt; &amp;amp;price, int k) { // 先排序，然后考虑是二分答案还是双指针 sort(price.</description>
    </item>
    <item>
      <title>LRU 算法与 LFU 算法</title>
      <link>http://localhost:1313/posts/tech/lru_lfu.zh/</link>
      <pubDate>Wed, 31 May 2023 16:36:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/lru_lfu.zh/</guid>
      <description>算法介绍 LRU LRU 全称是 Least Recently Used，即最近最久未使用算法。&#xA;LRU 根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高，它是页面置换算法的一种，也常用于缓存设计。&#xA;LFU LFU 全称是 Least Frequently Used，根据频率来选择要淘汰的元素，即删除访问频率最低的元素，如果两个元素的访问频率相同，则淘汰访问频率最低的元素中最久没有被访问的元素。&#xA;数据结构 不管是 LRU 还是 LFU 算法，我们都需要使用到双向链表作为基础数据结构，由于 LRU 与 LFU 涉及的对双向链表的元素的操作比较复杂，还涉及对链表结点的其他操作，因此选择自己手写一个简单的双向链表，同时复习双向链表的实现（阿里一面就被问到了，半天没写对😅）。&#xA;这里根据 LRU 和 LFU 的需要，简单封装了删除结点、尾部插入结点、和判断双向链表是否为空三个函数，很大程度上简化了 LRU 和 LFU 的实现，降低了写算法实现代码的出错概率。&#xA;struct Node { Node() { } Node(int val, int key) : val_(val), key_(key), next_(nullptr), pre_(nullptr) { } int val_; int freq_; Node *next_; Node *pre_; int key_; }; struct List { Node *vhead_; // 虚拟头结点 Node *vtail_; // 虚拟尾结点 int size_ = 0; // 链表中有效结点的数量 List() : vhead_(new Node()), vtail_(new Node()) { vhead_-&amp;gt;next_ = vtail_; vtail_-&amp;gt;pre_ = vhead_; vhead_-&amp;gt;pre_ = nullptr; vtail_-&amp;gt;next_ = nullptr; } ~List() { delete vtail_; delete vhead_; vhead_ = nullptr; vtail_ = nullptr; } void Insert(Node *node) { // 双向链表的插入, node 表示待插入结点，插入作为双向链表的尾结点 node-&amp;gt;pre_ = vtail_-&amp;gt;pre_; vtail_-&amp;gt;pre_-&amp;gt;next_ = node; vtail_-&amp;gt;pre_ = node; node-&amp;gt;next_ = vtail_; ++size_; } void Delete(Node *node) { // node 指向待删除结点 node-&amp;gt;next_-&amp;gt;pre_ = node-&amp;gt;pre_; node-&amp;gt;pre_-&amp;gt;next_ = node-&amp;gt;next_; --size_; } bool Empty() { return size_ &amp;lt;= 0; } }; LRU 实现 对于 LRU 的实现，我们需要借助两个数组结构哈希表和双向链表来组成一个新的数据结构。我们利用哈希表实现 $O(1)$ 时间复杂度的查找，获取元素的 val 以及在双向链表中的位置；利用双向链表实现 $O(1)$ 时间复杂度内的元素插入和删除。</description>
    </item>
    <item>
      <title>2646.minimize the Total Price of the Trips</title>
      <link>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips/</link>
      <pubDate>Wed, 31 May 2023 14:05:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips/</guid>
      <description></description>
    </item>
    <item>
      <title>2646. 最小化旅行的价格总和 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips.zh/</link>
      <pubDate>Wed, 31 May 2023 14:05:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2646.minimize-the-total-price-of-the-trips.zh/</guid>
      <description>问题描述 2646. 最小化旅行的价格总和 (Hard) 现有一棵无向、无根的树，树中有 n 个节点，按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数 组 edges ，其中 edges[i] = [aᵢ, bᵢ] 表示树中节点 aᵢ 和 bᵢ 之间存在一条边。&#xA;每个节点都关联一个价格。给你一个整数数组 price ，其中 pri ce[i] 是第 i 个节点的价格。&#xA;给定路径的 价格总和 是该路径上所有节点的价格之和。&#xA;另给你一个二维整数数组 trips ，其中 trips[i] = [startᵢ, e ndᵢ] 表示您从节点 startᵢ 开始第 i 次旅行，并通过任何你 喜欢的路径前往节点 endᵢ 。&#xA;在执行第一次旅行之前，你可以选择一些 非相邻节点 并将价格 减半。&#xA;返回执行所有旅行的最小价格总和。&#xA;示例 1：&#xA;![](https://assets.leetcode.com/uploads/2023/03/16/diagram2. png)&#xA;输入：n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6] , trips = [[0,3],[2,1],[2,3]] 输出：23 解释： 上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第 二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。 第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。 第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。 第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。 所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实 现的最小答案。 示例 2：</description>
    </item>
    <item>
      <title>421. Maximum XOR of Two Numbers in an Array (Medium)</title>
      <link>http://localhost:1313/posts/leet/421.maximum-xor-of-two-numbers-in-an-array/</link>
      <pubDate>Tue, 30 May 2023 14:22:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/421.maximum-xor-of-two-numbers-in-an-array/</guid>
      <description>Description 421. Maximum XOR of Two Numbers in an Array (Medium) Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &amp;lt;= i &amp;lt;= j &amp;lt; n.&#xA;Example 1:&#xA;Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28. Example 2:&#xA;Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127 Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁵ 0 &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 Solution If we directly use a brute-force approach to find the maximum XOR value, the time complexity would be $O(n^2)$, which would inevitably lead to timeout errors.</description>
    </item>
    <item>
      <title>421. 数组中两个数的最大异或值 (Medium)</title>
      <link>http://localhost:1313/posts/leet/421.maximum-xor-of-two-numbers-in-an-array.zh/</link>
      <pubDate>Tue, 30 May 2023 14:22:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/421.maximum-xor-of-two-numbers-in-an-array.zh/</guid>
      <description>问题描述 421. 数组中两个数的最大异或值 (Medium) 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大 运算结果，其中 0 ≤ i ≤ j &amp;lt; n 。&#xA;示例 1：&#xA;输入：nums = [3,10,5,25,2,8] 输出：28 解释：最大运算结果是 5 XOR 25 = 28. 示例 2：&#xA;输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70] 输出：127 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁵ 0 &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 解题思路 如果直接暴力，求解最大异或值，时间复杂度为 $O(n^2)$，必定会超时。&#xA;实际上，我们可以把每个数字的二进制表示看成字符串，因此可以使用 字典树 这一数据结构来优化求解异或值的过程。暴力情况下，求解 nums[i] 与其他值的异或值，需要遍历整个数组，时间复杂度为 $O(n)$，而利用字典树，我们可以将这个比较的时间复杂度从 $O(n)$ 优化为 $O(\log_2C)$，其中 $C$ 为数字的大小，$\log_2C$ 即为数字的二进制表示的位数。&#xA;如果我们要找到最大异或值，应该从数字的最高位开始比较，字典树也应该从数字的高位开始构建，由于 0 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1，因此我们可以将 nums[i] 右移 j 位的结果插入字典树，j 从 $31$ 递减到 $0$。</description>
    </item>
    <item>
      <title>2681.power of Heroes</title>
      <link>http://localhost:1313/posts/leet/2681.power-of-heroes/</link>
      <pubDate>Mon, 29 May 2023 13:23:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2681.power-of-heroes/</guid>
      <description>Description 2681. Power of Heroes (Hard) You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows:&#xA;Let i₀, i₁, &amp;hellip; , iₖ be the indices of the heroes in a group. Then, the power of this group is max(nums[i₀], nums[i₁], ... ,nums[iₖ])² * min(nums[i₀], nums[i₁], ... ,nums[iₖ]). Return the sum of the power of all non-empty groups of heroes possible.</description>
    </item>
    <item>
      <title>2681. 英雄的力量 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2681.power-of-heroes.zh/</link>
      <pubDate>Mon, 29 May 2023 13:23:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2681.power-of-heroes.zh/</guid>
      <description>问题描述 2681. 英雄的力量 (Hard) 给你一个下标从 0 开始的整数数组 nums ，它表示英雄的能 力值。如果我们选出一部分英雄，这组英雄的 力量 定义为：&#xA;i₀ ， i₁ ，&amp;hellip; iₖ 表示这组英雄在数组中的下标。那么这组英雄的力量为 max(nums[i₀],nums[i₁] ... nums[iₖ])² * min(nums[i₀],nums[i₁] ... nums[iₖ]) 。 请你返回所有可能的 非空 英雄组的 力量 之和。由于答案 可能非常大，请你将结果对 10⁹ + 7 取余。&#xA;示例 1：&#xA;输入：nums = [2,1,4] 输出：141 解释： 第 1 组：[2] 的力量为 2² * 2 = 8 。 第 2 组：[1] 的力量为 1² * 1 = 1 。 第 3 组：[4] 的力量为 4² * 4 = 64 。 第 4 组：[2,1] 的力量为 2² * 1 = 4 。 第 5 组：[2,4] 的力量为 4² * 2 = 32 。 第 6 组：[1,4] 的力量为 4² * 1 = 16 。 第 7 组：[2,1,4] 的力量为 4² * 1 = 16 。 所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。 示例 2：</description>
    </item>
    <item>
      <title>2712. 使所有字符相等的最小成本 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal.zh/</link>
      <pubDate>Mon, 29 May 2023 11:57:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal.zh/</guid>
      <description>问题描述 2712. 使所有字符相等的最小成本 (Medium) 给你一个下标从 0 开始、长度为 n 的二进制字符串 s ， 你可以对其执行两种操作：&#xA;选中一个下标 i 并且反转从下标 0 到下标 i（包括下标 0 和下标 i ）的所有字符，成本为 i + 1 。 选中一个下标 i 并且反转从下标 i 到下标 n - 1（包括下 标 i 和下标 n - 1 ）的所有字符，成本为 n - i 。 返回使字符串内所有字符 相等 需要的 最小成本 。&#xA;反转 字符意味着：如果原来的值是 &amp;lsquo;0&amp;rsquo; ，则反转后值变为 &amp;lsquo;1&amp;rsquo; ，反之亦然。&#xA;示例 1：&#xA;输入：s = &amp;#34;0011&amp;#34; 输出：2 解释：执行第二种操作，选中下标 i = 2 ，可以得到 s = &amp;#34;0000&amp;#34; ，成本为 2 。可以证明 2 是使所有字符相等的最小成本。 示例 2：</description>
    </item>
    <item>
      <title>2712. Minimum Cost to Make All Characters Equal (Medium)</title>
      <link>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal/</link>
      <pubDate>Mon, 29 May 2023 11:57:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2712.minimum-cost-to-make-all-characters-equal/</guid>
      <description>Description 2712. Minimum Cost to Make All Characters Equal (Medium) You are given a 0-indexed binary string s of length n on which you can apply two types of operations:&#xA;Choose an index i and invert all characters from index 0 to index i (both inclusive), with a cost of i + 1 Choose an index i and invert all characters from index i to index n - 1 (both inclusive), with a cost of n - i Return the minimum cost to make all characters of the string equal.</description>
    </item>
    <item>
      <title>字典树</title>
      <link>http://localhost:1313/posts/tech/trie.zh/</link>
      <pubDate>Mon, 29 May 2023 09:54:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/trie.zh/</guid>
      <description>定义 字典树（Trie），是一个像字典一样的树，又称前缀树。&#xA;可以高效的查询某个字符串是否在一组给定的字符串中，或者说查询某个单词是否在字典中。&#xA;字典树的查询时间复杂度可以认为是 $O(l)$，其中 $l$ 为待查询单词的长度。&#xA;引入 字典树示意图：&#xA;可以发现，这棵字典树用边来代表字母，而根结点到树上面某一个节点的路径就代表一个字符串，例如 $1\rightarrow 4\rightarrow 8\rightarrow 12$ 表示的就是字符串 caa，如果结点 $12$ 对应的 end_ 字段的值为 $true$，说明 caa 是字典树中一个完整的字符串，否则只是一个前缀。&#xA;trie 的结构非常好懂，我们用 $\delta(u,c)$ 表示结点 $u$ 的 $c$ 字符指向的下一个结点，或着说是结点 $u$ 代表的字符串后面添加一个字符 $c$ 形成的字符串的结点。（ $c$ 的取值范围和字符集大小有关，不一定是 $0\sim 26$ 。）&#xA;字典树的实现 这里放一个简单的前缀树的类的实现，&#xA;struct Trie { int nex[10000][26], cnt; // nex 的第一维度表示前缀树的结点数量，与上面的图相对应 bool end[10000]; // 该结点结尾的字符串是否存在 void insert(char *s, int l) { // 插入字符串 int p = 0; for (int i = 0; i &amp;lt; l; i++) { int c = s[i] - &amp;#39;a&amp;#39;; if (!</description>
    </item>
    <item>
      <title>ELF 文件结构分析</title>
      <link>http://localhost:1313/posts/tech/elf_file_structure.zh/</link>
      <pubDate>Sun, 28 May 2023 15:59:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/elf_file_structure.zh/</guid>
      <description>目标文件的格式 目前，Linux 平台流行的 可执行文件（Executable）主要包含以下格式：&#xA;Linux 下的 ELF（Executable Linkable Format），注意这里是二进制文件其内容的组织格式，与后缀无关； 目标文件是源代码经过编译后但是未进行链接的那些中间文件（Linux 下为 .o 文件），它与可执行文件格式非常相似，一般与可执行文件一起采用同一种格式存储，Linux 下采用 ELF 文件格式。&#xA;动态链接库（Dynamic Linking Library）、静态链接库（Static Linking Library）均采用可执行文件格式存储，Linux 下均按照 ELF 格式存储。&#xA;Linux 下的 .so、.a； ELF 文件结构 CSAPP 上的 ELF 格式文件结构图：&#xA;更详细的 ELF 文件结构图：&#xA;可以看到，ELF 文件包含四个部分：&#xA;第一部分为 ELF Header； 第二部分为 Program Header Table，Relocatable object file 中该部分不存在，Executable object file 中该部分存在； 第三部分为 ELF Sections，包括 .text、.rodata、.data、.bss等； 第四部分为 ELF Section Header Table（或称节头表，后面以 sht 指代），注意 sht 不像 ELF Header 那样只有一块，它由多个 Section header table entry 组成。 ELF 的 16 进制内容 elf.</description>
    </item>
    <item>
      <title>85. Maximal Rectangle (Hard)</title>
      <link>http://localhost:1313/posts/leet/85.maximal-rectangle/</link>
      <pubDate>Tue, 23 May 2023 15:24:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/85.maximal-rectangle/</guid>
      <description>Description Maximal Rectangle (Hard) Given a rows x cols binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest rectangle containing only 1&amp;rsquo;s and return its area. Example 1:&#xA;Input: matrix = [[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Example 2:&#xA;Input: matrix = [[&amp;#34;0&amp;#34;]] Output: 0 Example 3:&#xA;Input: matrix = [[&amp;#34;1&amp;#34;]] Output: 1 Constraints:&#xA;rows == matrix.length cols == matrix[i].length 1 &amp;lt;= row, cols &amp;lt;= 200 matrix[i][j] is &#39;0&#39; or &#39;1&#39;.</description>
    </item>
    <item>
      <title>85. 最大矩形 (Hard)</title>
      <link>http://localhost:1313/posts/leet/85.maximal-rectangle.zh/</link>
      <pubDate>Tue, 23 May 2023 15:24:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/85.maximal-rectangle.zh/</guid>
      <description>问题描述 85. 最大矩形 (Hard) 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进 制矩阵，找出只包含 1 的最大矩形，并返回其面积。&#xA;示例 1：&#xA;![](https://assets.leetcode.com/uploads/2020/09/14/maximal.j pg)&#xA;输入：matrix = [[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;]] 输出：6 解释：最大矩形如上图所示。 示例 2：&#xA;输入：matrix = [] 输出：0 示例 3：&#xA;输入：matrix = [[&amp;#34;0&amp;#34;]] 输出：0 示例 4：&#xA;输入：matrix = [[&amp;#34;1&amp;#34;]] 输出：1 示例 5：&#xA;输入：matrix = [[&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;]] 输出：0 提示：&#xA;rows == matrix.length cols == matrix[0].length 1 &amp;lt;= row, cols &amp;lt;= 200 matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39; 解题思路 其实本题就相当于是 84.</description>
    </item>
    <item>
      <title>84. Largest Rectangle in Histogram (Hard)</title>
      <link>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram/</link>
      <pubDate>Tue, 23 May 2023 15:08:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram/</guid>
      <description>Description 84. Largest Rectangle in Histogram (Hard) Given an array of integers heights representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.&#xA;Example 1:&#xA;Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.</description>
    </item>
    <item>
      <title>84. 柱状图中最大的矩形 (Hard)</title>
      <link>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram.zh/</link>
      <pubDate>Tue, 23 May 2023 15:08:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/84.largest-rectangle-in-histogram.zh/</guid>
      <description>问题描述 84. 柱状图中最大的矩形 (Hard) 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子 彼此相邻，且宽度为 1 。&#xA;求在该柱状图中，能够勾勒出来的矩形的最大面积。&#xA;示例 1:&#xA;![](https://assets.leetcode.com/uploads/2021/01/04/histogram .jpg)&#xA;输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2：&#xA;![](https://assets.leetcode.com/uploads/2021/01/04/histogram -1.jpg)&#xA;输入： heights = [2,4] 输出： 4 提示：&#xA;1 &amp;lt;= heights.length &amp;lt;=10⁵ 0 &amp;lt;= heights[i] &amp;lt;= 10⁴ 解题思路 本题其实还是求一个连续变长区间的最小值，以及该区间的长度，可以考虑到使用单调栈来解决，至于使用单调递增还是单调递减栈，代入题目中的示例模拟一下就知道了，本题应该使用单调递增栈（栈底到栈顶单调递增）。&#xA;在本题中，我们遍历数组，对 nums[i]，找到满足 nums[r] &amp;lt; nums[i] 且 r &amp;gt; i 的最小的 r，记为 ridx，找到满足 nums[l] &amp;lt; nums[i] 且 l &amp;lt; i 的最大的 l，记为 lidx，则 res = max(res, nums[i] * (ridx - lidx - 1))，我们可以利用单调栈在 $O(n)$ 时间内完成求解。</description>
    </item>
    <item>
      <title>2104. Sum of Subarray Ranges (Medium)</title>
      <link>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges/</link>
      <pubDate>Sun, 21 May 2023 19:00:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges/</guid>
      <description>Description 2104. Sum of Subarray Ranges (Medium) You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.&#xA;Return the sum of all subarray ranges of nums.&#xA;A subarray is a contiguous non-empty sequence of elements within an array.&#xA;Example 1:&#xA;Input: nums = [1,2,3] Output: 4 Explanation: The 6 subarrays of nums are the following: [1], range = largest - smallest = 1 - 1 = 0 [2], range = 2 - 2 = 0 [3], range = 3 - 3 = 0 [1,2], range = 2 - 1 = 1 [2,3], range = 3 - 2 = 1 [1,2,3], range = 3 - 1 = 2 So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.</description>
    </item>
    <item>
      <title>2104. 子数组范围和 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges.zh/</link>
      <pubDate>Sun, 21 May 2023 19:00:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2104.sum-of-subarray-ranges.zh/</guid>
      <description>问题描述 2104. 子数组范围和 (Medium) 给你一个整数数组 nums 。 nums 中，子数组的 范围 是子 数组中最大元素和最小元素的差值。&#xA;返回 nums 中 所有 子数组范围的 和。&#xA;子数组是数组中一个连续 非空 的元素序列。&#xA;示例 1：&#xA;输入：nums = [1,2,3] 输出：4 解释：nums 的 6 个子数组如下所示： [1]，范围 = 最大 - 最小 = 1 - 1 = 0 [2]，范围 = 2 - 2 = 0 [3]，范围 = 3 - 3 = 0 [1,2]，范围 = 2 - 1 = 1 [2,3]，范围 = 3 - 2 = 1 [1,2,3]，范围 = 3 - 1 = 2 所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4 示例 2：</description>
    </item>
    <item>
      <title>795.区间子数组个数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum.zh/</link>
      <pubDate>Sun, 21 May 2023 18:30:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum.zh/</guid>
      <description>问题描述 795. 区间子数组个数 (Medium) 给你一个整数数组 nums 和两个整数： left 及 right 。找 出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。&#xA;生成的测试用例保证结果符合 32-bit 整数范围。&#xA;示例 1：&#xA;输入：nums = [2,1,4,3], left = 2, right = 3 输出：3 解释：满足条件的三个子数组：[2], [2, 1], [3] 示例 2：&#xA;输入：nums = [2,9,2,5,6], left = 2, right = 8 输出：7 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 10⁵ 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ 0 &amp;lt;= left &amp;lt;= right &amp;lt;= 10⁹ 解题思路 单调栈 当我们看到这种连续区间中的最大值的题目时，就可以考虑使用单调栈。&#xA;对 nums[idx]，我们需要找到以 nums[idx] 为最大值的子数组的数量，设 lidx 为满足 nums[l] &amp;gt;= nums[idx] 且 l &amp;lt; idx 的最大的 l；设 ridx 为满足 nums[r] &amp;gt; nums[idx] 且 r &amp;gt; idx 中的最小的 r。我们要做的就是枚举满足 0 &amp;lt;= idx &amp;lt; n 的所有的 idx，找到对应的 lidx 和 ridx，从而计算出子数组的数量。</description>
    </item>
    <item>
      <title>795.number of Subarrays With Bounded Maximum</title>
      <link>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum/</link>
      <pubDate>Sun, 21 May 2023 18:30:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/795.number-of-subarrays-with-bounded-maximum/</guid>
      <description>Description 795. Number of Subarrays with Bounded Maximum (Medium) Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right].&#xA;The test cases are generated so that the answer will fit in a 32-bit integer.&#xA;Example 1:&#xA;Input: nums = [2,1,4,3], left = 2, right = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].</description>
    </item>
    <item>
      <title>字符串哈希算法</title>
      <link>http://localhost:1313/posts/tech/string_hash.zh/</link>
      <pubDate>Mon, 15 May 2023 11:52:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/string_hash.zh/</guid>
      <description>问题描述 考虑 1044. 最长重复子串 (Hard)，本题思路并不难，可以使用二分答案来解决，假设答案为 mid，那么长度大于 mid 的子串在 s 中只会出现一次，否则至少出现两次。&#xA;因此只需要考虑子串在 s 中的出现次数即可，比较直接的想法是使用 key 为 string 的 unordered_map，然而 unoredere_map 自带的哈希函数，其时间复杂度和空间复杂度都很高，为 $O(len)$，因此，需要一个简单一点的哈希函数。&#xA;字符串哈希 参照宫水三叶大佬的 字符串哈希。&#xA;我们需要使用一个比字符串 s 略长的哈希数组 vector&amp;lt;int&amp;gt; h(s.size() + 10)，以及次方数组 vector&amp;lt;int&amp;gt; p(s.size() + 10)。 对长度为 len 的数组，只需要利用前缀和思想 h[i + len] - h[i] * p[len] 即可在 $O(1)$ 时间内计算出哈希值。&#xA;其中 p[0] = 1，h[i] = h[i - 1] * P + s[i - 1]；p[i] = p[i - 1] * P。&#xA;$P$ 可以依次取 $131,\ 13131,\ 1313131$ 等，出现哈希碰撞就考虑取更大的质数。</description>
    </item>
    <item>
      <title>二进制下的补码、反码、原码——适用于有符号整数</title>
      <link>http://localhost:1313/posts/tech/2_complement.zh/</link>
      <pubDate>Mon, 08 May 2023 18:40:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/2_complement.zh/</guid>
      <description>简单定义 简单起见，我们这里只考虑三位二进制数所能表示的范围，即$[-4, -3, -2, -1, 0,\ 1,\ 2,\ 3]$。&#xA;机器数和真值 一个数在计算机中的二进制表现形式，就是这个数的机器数（相当于数的原码）。 例如，$-3$ 的机器数即为 $111$，$2$ 的机器数为 $010$。&#xA;机器数在考虑最高位为符号位的情况下，换算出来的值就是真值，例如 $111$ 的真值为 $-3$，而形式值为 $7$；$010$ 的形式值和真值都为 $2$。&#xA;原码、反码、补码 有符号整数的原码就是它的机器数，正数的反码与原码相同，而负数的反码则是符号位不变，其余位取反。&#xA;正数的补码（Complement）不变，负数的补码则是它的反码 $+1$，例如 $-1$ 的反码为 $110$，补码为 $111$；也可以说负数的补码是该负数的相反数的原码取反 $+1$。&#xA;为什么要用补码？ 使用补码可以解决减法运算的问题。 例如 $2 - 1 = 2 + (-1) = 010 + 111 = 001 = 1$ （$1001$ 去掉超出的最高位）。&#xA;使用原码或者反码都不好处理这个问题。&#xA;为什么补码会有这个效果？ 我们首先要意识到一点，$-1$ 的补码为 $111$，$111$ 对应的形式值为 $7$，而 $7 - (-1) = 8$。&#xA;例如，当我们使用 $2 - 1$ 时，相当于 $2 + 7 = 9$，然而，由于我们只能表示 $-4 \sim 3$ 这个范围内的所有数，大于 3 的数，就变成了 $9\mod 8 = 1$。</description>
    </item>
    <item>
      <title>373. 查找和最小的 K 对数字 (Medium)</title>
      <link>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums.zh/</link>
      <pubDate>Sat, 06 May 2023 16:28:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums.zh/</guid>
      <description>问题描述 373. 查找和最小的 K 对数字 (Medium) 给定两个以 升序排列 的整数数组 nums1 和 nums2, 以及 一个整数 k。&#xA;定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来 自 nums2。&#xA;请找到和最小的 k 个数对 (u₁,v₁), (u₂,v₂) &amp;hellip; (uₖ,v ₖ) 。&#xA;示例 1:&#xA;输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 输出: [1,2],[1,4],[1,6] 解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6 ] 示例 2:&#xA;输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 输出: [1,1],[1,1] 解释: 返回序列中的前 2 对数： [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] 示例 3:</description>
    </item>
    <item>
      <title>373. Find K Pairs with Smallest Sums (Medium)</title>
      <link>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums/</link>
      <pubDate>Sat, 06 May 2023 16:28:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/373.find-k-pairs-with-smallest-sums/</guid>
      <description>Description 373. Find K Pairs with Smallest Sums (Medium) You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.&#xA;Define a pair (u, v) which consists of one element from the first array and one element from the second array.&#xA;Return the kpairs (u₁, v₁), (u₂, v₂), ..., (uₖ, vₖ)with the smallest sums.&#xA;Example 1:&#xA;Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2:</description>
    </item>
    <item>
      <title>从汇编的角度理解 C/Cpp 的函数调用过程</title>
      <link>http://localhost:1313/posts/tech/function_call_stack.zh/</link>
      <pubDate>Mon, 01 May 2023 17:45:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/function_call_stack.zh/</guid>
      <description>代码 测试代码内容如下，定义了一个 add 函数，用来求两个函数的和。&#xA;int add(int a, int b) { return a + b; } int sum(int a, int b) { return 10 + add(a, b); } int main() { int res = sum(10, 20); return 0; } 汇编代码如下:&#xA;.file&#x9;&amp;#34;add.c&amp;#34; .text .globl&#x9;add .type&#x9;add, @function add: .LFB0: .cfi_startproc pushq&#x9;%rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq&#x9;%rsp, %rbp .cfi_def_cfa_register 6 movl&#x9;%edi, -4(%rbp) movl&#x9;%esi, -8(%rbp) movl&#x9;-4(%rbp), %edx movl&#x9;-8(%rbp), %eax addl&#x9;%edx, %eax popq&#x9;%rbp .</description>
    </item>
    <item>
      <title>C&#43;&#43; 虚函数与动态绑定</title>
      <link>http://localhost:1313/posts/tech/virtual_func.zh/</link>
      <pubDate>Sun, 23 Apr 2023 22:59:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/virtual_func.zh/</guid>
      <description>多态与动态绑定 为了实现 C++ 的多态，C++ 使用了动态绑定技术，该技术的核心是虚函数表（简称虚表）。&#xA;类的虚函数表 每个包含了虚函数的类都包含一个虚表，一个子类如果继承了包含虚函数的父类，那么这个类也拥有自己的虚表，例如&#xA;class A { public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int data1_, data2_; }; class B : public A { public: void vfunc1() override; void func1(); }; class C : public B { public: void vfunc2() override; void func2(); private: int data1_, data2_; }; A 包含虚函数 vfunc1() ，B 继承自 A，A 的虚表如图所示 虚表是一个指针数组，其元素是虚函数的指针，数组中的每个元素对应一个虚函数的指针。普通的函数（即非虚函数），其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。&#xA;虚函数指针的赋值发生在编译器的编译阶段，也就是在编译阶段，虚表就被构建出来了。&#xA;虚表指针 虚表是属于类的（有点像静态成员变量），而不属于某个具体的对象，一个类只需要一个虚表即可，同一个类的所有对象都使用同一个虚表。&#xA;为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。&#xA;一个子类的父类如果包含虚函数，那么这个子类也拥有自己的虚表，所以这个子类的对象也包含一个虚表指针，用来指向它的虚表。 类 A 包括两个虚函数，故 A 的虚函数表包含两个指针，分别指向 A::vfunc1()和 A::vfunc2()。</description>
    </item>
    <item>
      <title>Cmake 基础教程</title>
      <link>http://localhost:1313/posts/tech/cmake_tutorial.zh/</link>
      <pubDate>Thu, 13 Apr 2023 13:42:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/cmake_tutorial.zh/</guid>
      <description>介绍 CMake是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个库。 它用配置文件控制建构过程（build process）的方式和Unix的make相似，只是CMake的配置文件取名为CMakeLists.txt。CMake并不直接建构出最终的软件，而是产生标准的建构档（如Unix的Makefile或Windows Visual C++的projects/workspaces），然后再依一般的建构方式使用。&#xA;CmakeLists.txt 一个简单的CmakeLists.txt示例如下:&#xA;# 指定最小 CMake 版本要求 cmake_minimum_required(VERSION 3.9) # 设置项目名称 project(answer) #[[ 添加可执行文件 target，类似于原来 Makefile 的： answer: main.o answer.o main.o: main.cpp answer.hpp answer.o: answer.cpp answer.hpp CMake 会自动找到依赖的头文件，因此不需要特别指定， 当头文件修改的时候，会重新编译依赖它的目标文件。 #]] add_executable(answer main.cpp answer.cpp) #[[ 使用如下命令构建本项目： cmake -B build # 生成构建目录 cmake --build build # 执行构建 ./build/answer # 运行 answer 程序 #]] 其中cmake -B build命令中的-B参数是可选的，生成的文件会放到build文件夹中（没有该文件夹则会自动创建，最好原先没有）。&#xA;cmake --build build是执行构建，生成可执行文件，build指的是上一步-B参数指定的文件夹。&#xA;分离库文件情形下的CMakeLists.txt cmake_minimum_required(VERSION 3.9) project(answer) # 添加 libanswer 库目标，STATIC 指定为静态库 add_library(libanswer STATIC answer.</description>
    </item>
    <item>
      <title>1020.Number of Enclaves (Medium)</title>
      <link>http://localhost:1313/posts/leet/1020.number-of-enclaves/</link>
      <pubDate>Thu, 13 Apr 2023 10:17:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1020.number-of-enclaves/</guid>
      <description>Description 1020. Number of Enclaves (Medium)&#xA;You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.&#xA;A move consists of walking from one land cell to another adjacent ( 4-directionally) land cell or walking off the boundary of the grid.&#xA;Return the number of land cells in gridfor which we cannot walk off the boundary of the grid in any number of moves.</description>
    </item>
    <item>
      <title>1020.飞地的数量 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1020.number-of-enclaves.zh/</link>
      <pubDate>Thu, 13 Apr 2023 10:16:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1020.number-of-enclaves.zh/</guid>
      <description>问题描述 1020. 飞地的数量 (Medium)&#xA;给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、 1 表示一个陆地单元格。&#xA;一次 移动 是指从一个陆地单元格走到另一个相邻（ 上、下、左、右）的陆地单元格或跨过 grid 的边界。&#xA;返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。&#xA;示例 1：&#xA;输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] 输出：3 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。 示例 2：&#xA;输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] 输出：0 解释：所有 1 都在边界上或可以到达边界。 提示：&#xA;m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 500 grid[i][j] 的值为 0 或 1 解题思路 使用并查集，令cnt1为包含索引为m * n的节点树的节点数，cnt2为海水的节点数，res = m * n - (cnt1 - 1) - cnt2;。</description>
    </item>
    <item>
      <title>快速选择算法</title>
      <link>http://localhost:1313/posts/tech/quick-select.zh/</link>
      <pubDate>Tue, 11 Apr 2023 19:55:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/quick-select.zh/</guid>
      <description>问题描述 给定一个长度为$n$的数组，如何在$O(n)$的时间复杂度内找到第$k$大的数。&#xA;思路 朴素的想法是先排序，然后直接找到第$k$个元素，时间复杂度为$O(n\log n)$。&#xA;我们可以利用快速排序的思想来解决这个问题，考虑快速排序的划分过程，在快速排序的“划分”结束后，数组$A_p \cdots A_r$被分成了$A_p\cdots A_q$和$A_{q+1}\cdots A_r$，此时可以按照左边元素的个数（$q-p+1$）和$k$的大小关系来判断是只在左边还是右边递归的求解。&#xA;代码 template &amp;lt;Typename T&amp;gt; // 类型T需要定义 &amp;lt; 运算 // arr 为查找范围数组，rk 为需要查找的排名（从 0 开始），len 为数组长度 T find_kth_element(T arr[], int rk, const int len) { if (len &amp;lt;= 1) { return arr[0]; } // 随机选择基准 const T pivot = arr[rand() % len]; // i 当前操作的元素 // j 第一个等于pivot的元素 // k 第一个大于pivot的元素 // 完成一趟三路快排，将序列分为： // 小于 pivot 的元素 ｜ 等于 pivot 的元素 ｜ 大于 pivot 的元素 int i = 0, j = 0, k = len; while (i &amp;lt; k) { if (arr[i] &amp;lt; pivot) { swap(arr[i++], arr[j++]); } else if (arr[i] &amp;gt; pivot) { swap(arr[i], arr[--k]); } else { ++i; } } // 根据要找的排名与两条分界线的位置，去不同的区间递归查找第k大的数 // 如果小于pivot的元素个数比k多，则第k大的元素一定是一个小于pivot的数 if (rk &amp;lt; j) { return find_kth_element(arr, rk, j); } else if (rk &amp;gt;= k){ // 否则，如果小于pivot和等于pivot的元素加起来也没有k多 // 则第k大的元素一定是一个大于pivot的元素 return find_kth_element(arr + k, rk - k, len - k); } else { // 否则，pivot就是第k大的元素 return pivot; } } 优化：中位数的中位数 中位数中的中位数（英文：Median of medians），提供了一种确定性的选择划分过程中分界值的方法，从而能够让找第$k$大的数算法在最坏情况下也能实现线性时间复杂度。</description>
    </item>
    <item>
      <title>851.喧闹和富有 (Medium)</title>
      <link>http://localhost:1313/posts/leet/851.loud-and-rich/</link>
      <pubDate>Mon, 10 Apr 2023 15:07:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/851.loud-and-rich/</guid>
      <description>Description 851. Loud and Rich (Medium)&#xA;There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.&#xA;You are given an array richer where richer[i] = [aᵢ, bᵢ] indicates that aᵢ has more money than bᵢ and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.</description>
    </item>
    <item>
      <title>851.喧闹和富有 (Medium)</title>
      <link>http://localhost:1313/posts/leet/851.loud-and-rich.zh/</link>
      <pubDate>Mon, 10 Apr 2023 15:06:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/851.loud-and-rich.zh/</guid>
      <description>问题描述 851. 喧闹和富有 (Medium)&#xA;有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 &amp;ldquo;person x &amp;ldquo;。&#xA;给你一个数组 richer ，其中 richer[i] = [aᵢ, bᵢ] 表示 person aᵢ 比 person bᵢ 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。 richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。&#xA;现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。&#xA;示例 1：</description>
    </item>
    <item>
      <title>802.Find Eventual Safe States (Medium)</title>
      <link>http://localhost:1313/posts/leet/802.find-eventual-safe-states/</link>
      <pubDate>Mon, 10 Apr 2023 14:49:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/802.find-eventual-safe-states/</guid>
      <description>Description 802. Find Eventual Safe States (Medium)&#xA;There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].&#xA;A node is a terminal node if there are no outgoing edges.</description>
    </item>
    <item>
      <title>802.找到最终的安全状态 (Medium)</title>
      <link>http://localhost:1313/posts/leet/802.find-eventual-safe-states.zh/</link>
      <pubDate>Mon, 10 Apr 2023 14:46:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/802.find-eventual-safe-states.zh/</guid>
      <description>问题描述 802. 找到最终的安全状态 (Medium)&#xA;有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph 表示， graph[i] 是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i] 中的每个节点都有一条边。&#xA;如果一个节点没有连出的有向边，则它是 终端节点 。如果没有出边，则节点为终端节点。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。&#xA;返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。&#xA;示例 1：&#xA;输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]] 输出：[2,4,5,6] 解释：示意图如上。 节点 5 和节点 6 是终端节点，因为它们都没有出边。 从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。 示例 2：&#xA;输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] 输出：[4] 解释: 只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。 提示：</description>
    </item>
    <item>
      <title>拓扑排序</title>
      <link>http://localhost:1313/posts/tech/topo-sort.zh/</link>
      <pubDate>Mon, 10 Apr 2023 14:13:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/topo-sort.zh/</guid>
      <description>定义 拓扑排序（Topological sorting）要解决的问题是给一个有向图的所有节点排序。&#xA;这里直接使用OI-Wiki中举的例子来说明：&#xA;我们可以拿大学选课的例子来描述这个过程，比如学习大学课程中有：单变量微积分，线性代数，离散数学概述，概率论与统计学概述，语言基础，算法导论，机器学习。当我们想要学习 算法导论 的时候，就必须先学会 离散数学概述 和 概率论与统计学概述，不然在课堂就会听的一脸懵逼。当然还有一个更加前的课程 单变量微积分。&#xA;这些课程就相当于几个顶点$u$, 顶点之间的有向边$(u,v)$就相当于学习课程的顺序。显然拓扑排序不是那么的麻烦，不然你是如何选出合适的学习顺序。下面将介绍如何将这个过程抽象出来，用算法来实现。&#xA;但是如果某一天排课的老师打瞌睡了，说想要学习 算法导论，还得先学 机器学习，而 机器学习 的前置课程又是 算法导论，然后你就一万脸懵逼了，我到底应该先学哪一个？当然我们在这里不考虑什么同时学几个课程的情况。在这里，算法导论 和 机器学习 间就出现了一个环，显然你现在没办法弄清楚你需要学什么了，于是你也没办法进行拓扑排序了。因而如果有向图中存在环路，那么我们就没办法进行拓扑排序了。&#xA;因此我们可以说在一个[[DAG（有向无环图）]]中，我们将图中顶点以线性方式排序，使得对于任意顶点$u$到$v$的有向边$(u, v)$，都有$u$在$v$的前面。&#xA;或者说给定一个DAG，如果$i$到$j$有边，则认为$j$依赖于$i$，如果$i$到$j$有路径，则称$j$间接依赖于$i$； 拓扑排序的目标是将所有节点排序，使得在前面的节点不能依赖于排在后面的节点。&#xA;bfs 拓扑排序有广度优先搜索（bfs）和深度优先搜索（dfs）两种实现方式，这里我们先讨论bfs。&#xA;利用bfs实现拓扑排序需要根据节点的入度：&#xA;入度：有多少条边直接指向该节点&#xA;思路 起始时，将所有入度为$0$的点放入队列q_in0； 将队首元素出队，出队序列就是我们要求的拓扑序，对当前弹出的节点u，res.push_back(u)，遍历u的所有出度，即遍历所有由u直接指向的节点v，递减节点v的入度； 如果节点v的入度变为0，将节点v入队； 循环2、3流程直到队列为空； 如果res最后恰好有$n$个节点，说明原图为DAG，res中的节点序列即要求的拓扑序；否则说明图中存在环。&#xA;代码实现 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph; int n = graph.size(); int in[n]; // 存储每个节点的入度 bool toposrot() { vector&amp;lt;int&amp;gt; res; queue&amp;lt;int&amp;gt; q_in0; for (int i = 0; i &amp;lt; n; ++i) { if (in[i] == 0) { q_in0.push(i); } } while (!</description>
    </item>
    <item>
      <title>通过 frp 使用 ssh 连接内网服务器</title>
      <link>http://localhost:1313/posts/blog/frp_ssh.zh/</link>
      <pubDate>Sun, 02 Apr 2023 17:41:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/frp_ssh.zh/</guid>
      <description>配置frp 安装frp ~/Prog目录下执行wget https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz下载压缩包，然后执行tar -zxvf file.path来解压，将解压生成的文件夹重命名为frp。&#xA;设置frpc.toml 修改frpc.toml文件为以下内容:&#xA;serverAddr = &amp;#34;nj1.mossfrp.cn&amp;#34; serverPort = 51960 token = &amp;#34;3nj117667696278235715&amp;#34; tls_enable = true use_encryption = true [[proxies]] name = &amp;#34;ssh&amp;#34; type = &amp;#34;tcp&amp;#34; localIP = &amp;#34;127.0.0.1&amp;#34; localPort = 22333 remotePort = 51962 [[vscode]] name = &amp;#34;vsc&amp;#34; type = &amp;#34;tcp&amp;#34; localIP = &amp;#34;127.0.0.1&amp;#34; localPort = 5433 remotePort = 51963 [[qbit]] name = &amp;#34;qbit&amp;#34; type = &amp;#34;tcp&amp;#34; localIP = &amp;#34;127.0.0.1&amp;#34; localPort = 28080 remotePort = 51968 [[qbit]] name = &amp;#34;iyuu&amp;#34; type = &amp;#34;tcp&amp;#34; localIP = &amp;#34;127.</description>
    </item>
    <item>
      <title>442.Find All Duplicates in an Array (Medium)</title>
      <link>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array/</link>
      <pubDate>Tue, 28 Mar 2023 14:45:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array/</guid>
      <description>Description 442. Find All Duplicates in an Array (Medium)&#xA;Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.&#xA;You must write an algorithm that runs in O(n) time and uses only constant extra space.&#xA;Example 1:&#xA;Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Example 2:</description>
    </item>
    <item>
      <title>442.数组中重复的数据 (Medium)</title>
      <link>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array.zh/</link>
      <pubDate>Tue, 28 Mar 2023 14:45:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/442.find-all-duplicates-in-an-array.zh/</guid>
      <description>问题描述 442. 数组中重复的数据 (Medium)&#xA;给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。&#xA;你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。&#xA;示例 1：&#xA;输入：nums = [4,3,2,7,8,2,3,1] 输出：[2,3] 示例 2：&#xA;输入：nums = [1,1,2] 输出：[1] 示例 3：&#xA;输入：nums = [1] 输出：[] 提示：&#xA;n == nums.length 1 &amp;lt;= n &amp;lt;= 10⁵ 1 &amp;lt;= nums[i] &amp;lt;= n nums 中的每个元素出现 一次 或 两次 解题思路 参照41.缺失的第一个正数 (Hard)，将数置反，如果已经是负数了，再减去nums.size()。&#xA;这里要注意nums.size()是无符号整数，直接加上负号结果也不是负数。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>41.First Missing Positive (Hard)</title>
      <link>http://localhost:1313/posts/leet/41.first-missing-positive/</link>
      <pubDate>Tue, 28 Mar 2023 11:44:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/41.first-missing-positive/</guid>
      <description>Description 41. First Missing Positive (Hard)&#xA;Given an unsorted integer array nums, return the smallest missing positive integer.&#xA;You must implement an algorithm that runs in O(n) time and uses constant extra space.&#xA;Example 1:&#xA;Input: nums = [1,2,0] Output: 3 Explanation: The numbers in the range [1,2] are all in the array. Example 2:&#xA;Input: nums = [3,4,-1,1] Output: 2 Explanation: 1 is in the array but 2 is missing.</description>
    </item>
    <item>
      <title>41.缺失的第一个正数 (Hard)</title>
      <link>http://localhost:1313/posts/leet/41.first-missing-positive.zh/</link>
      <pubDate>Tue, 28 Mar 2023 11:44:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/41.first-missing-positive.zh/</guid>
      <description>问题描述 41. 缺失的第一个正数 (Hard)&#xA;给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。&#xA;请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。&#xA;示例 1：&#xA;输入：nums = [1,2,0] 输出：3 示例 2：&#xA;输入：nums = [3,4,-1,1] 输出：2 示例 3：&#xA;输入：nums = [7,8,9,11,12] 输出：1 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 5 * 10⁵ -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 解题思路 标记 在nums[i]数组上做标记，我们可以将nums数组中的负数都设为n + 1，令num = abs(nums[i])，然后将nums[num - 1]取反，最后遍历修改后的nums[i]，如果都是负数，返回n + 1，否则返回碰到的第一个非负数的索引加一；&#xA;置换 如果nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp; nums[i] &amp;gt; 0，那么就将它与nums[num[i] - 1]置换，为了防止死循环，还要判断nums[i] != nums[nums[i] - 1]&#xA;代码 标记 class Solution { public: int firstMissingPositive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description>
    </item>
    <item>
      <title>686 Repeated String Match</title>
      <link>http://localhost:1313/posts/leet/686-repeated-string-match/</link>
      <pubDate>Mon, 27 Mar 2023 21:22:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/686-repeated-string-match/</guid>
      <description>Description 686. Repeated String Match (Medium)&#xA;Given two strings a and b, return the minimum number of times you should repeat string a so that string bis a substring of it. If it is impossible for b to be a substring of a after repeating it, return -1.&#xA;Notice: string &amp;quot;abc&amp;quot; repeated 0 times is &amp;quot;&amp;quot;, repeated 1 time is &amp;quot;abc&amp;quot; and repeated 2 times is &amp;quot;abcabc&amp;quot;.&#xA;Example 1:&#xA;Input: a = &amp;#34;abcd&amp;#34;, b = &amp;#34;cdabcdab&amp;#34; Output: 3 Explanation: We return 3 because by repeating a three times &amp;#34;abcdabcdabcd&amp;#34;, b is a substring of it.</description>
    </item>
    <item>
      <title>686.重复叠加字符串匹配 (Medium)</title>
      <link>http://localhost:1313/posts/leet/686-repeated-string-match.zh/</link>
      <pubDate>Mon, 27 Mar 2023 21:22:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/686-repeated-string-match.zh/</guid>
      <description>问题描述 686. 重复叠加字符串匹配 (Medium)&#xA;给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。&#xA;注意： 字符串 &amp;quot;abc&amp;quot; 重复叠加 0 次是 &amp;quot;&amp;quot;，重复叠加 1 次是 &amp;quot;abc&amp;quot;，重复叠加 2 次是 &amp;quot;abcabc&amp;quot;。&#xA;示例 1：&#xA;输入：a = &amp;#34;abcd&amp;#34;, b = &amp;#34;cdabcdab&amp;#34; 输出：3 解释：a 重复叠加三遍后为 &amp;#34;abcdabcdabcd&amp;#34;, 此时 b 是其子串。 示例 2：&#xA;输入：a = &amp;#34;a&amp;#34;, b = &amp;#34;aa&amp;#34; 输出：2 示例 3：&#xA;输入：a = &amp;#34;a&amp;#34;, b = &amp;#34;a&amp;#34; 输出：1 示例 4：&#xA;输入：a = &amp;#34;abc&amp;#34;, b = &amp;#34;wxyz&amp;#34; 输出：-1 提示：</description>
    </item>
    <item>
      <title>28.Find the Index of the First Occurrence in a String (Easy)</title>
      <link>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string/</link>
      <pubDate>Mon, 27 Mar 2023 21:15:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string/</guid>
      <description>Description 28. Find the Index of the First Occurrence in a String (Easy)&#xA;Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&#xA;Example 1:&#xA;Input: haystack = &amp;#34;sadbutsad&amp;#34;, needle = &amp;#34;sad&amp;#34; Output: 0 Explanation: &amp;#34;sad&amp;#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2:</description>
    </item>
    <item>
      <title>28.找出字符串中第一个匹配项的下标 (Medium)</title>
      <link>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string.zh/</link>
      <pubDate>Mon, 27 Mar 2023 21:15:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/28.find-the-index-of-the-first-occurrence-in-a-string.zh/</guid>
      <description>问题描述 28. 找出字符串中第一个匹配项的下标 (Medium)&#xA;给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1。&#xA;示例 1：&#xA;输入：haystack = &amp;#34;sadbutsad&amp;#34;, needle = &amp;#34;sad&amp;#34; 输出：0 解释：&amp;#34;sad&amp;#34; 在下标 0 和 6 处匹配。 第一个匹配项的下标是 0 ，所以返回 0 。 示例 2：&#xA;输入：haystack = &amp;#34;leetcode&amp;#34;, needle = &amp;#34;leeto&amp;#34; 输出：-1 解释：&amp;#34;leeto&amp;#34; 没有在 &amp;#34;leetcode&amp;#34; 中出现，所以返回 -1 。 提示：&#xA;1 &amp;lt;= haystack.length, needle.length &amp;lt;= 10⁴ haystack 和 needle 仅由小写英文字符组成 解题思路 标准的kmp算法模板题。&#xA;代码 class Solution { public: void SetNext(vector&amp;lt;int&amp;gt; &amp;amp;next, string needle) { int x = 1, now = 0; while (x &amp;lt; needle.</description>
    </item>
    <item>
      <title>kmp 算法</title>
      <link>http://localhost:1313/posts/tech/kmp.zh/</link>
      <pubDate>Mon, 27 Mar 2023 16:45:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/kmp.zh/</guid>
      <description>问题描述 kmp算法解决的是字符串匹配问题，即:字符串P是否是字符串S的子串？如果是，它出现在s的哪些位置？这里我们称 S 为主串，P 为模式串。&#xA;思路 首先是暴力匹配算法（Brute-Force算法），代码如下：&#xA;void BruteForce(string s, string p) { int len_s = s.size(), len_p = p.size(); for (int i = 0; i &amp;lt;= len_s - len_p; ++i) { int flag = true; for (int j = 0; j &amp;lt; len_p; ++j) { if (s[i + j] != p[j]) { flag = false; break; } } if (flag) { printf(&amp;#34;pos = %d\n&amp;#34;, i); } } } 易得时间复杂度的最坏情况是$O(mn)$的，其中$n$为s的长度，$m$为p的长度。</description>
    </item>
    <item>
      <title>vscode 使用 clangd</title>
      <link>http://localhost:1313/posts/blog/clangd_vscode.zh/</link>
      <pubDate>Thu, 23 Mar 2023 15:56:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/clangd_vscode.zh/</guid>
      <description>环境要求 使用 wsl 或者 macOS，Linux 下同理，暂时不考虑纯 winodws。&#xA;以 wsl 为例，执行以下指令&#xA;sudo apt install clang clangd lldb cmake macOS如果安装过xcode工具包，就附带了Apple Clang编译器，否则执行brew install llvm，然后输入以下指令添加环境变量&#xA;echo &amp;#39;export PATH=&amp;#34;/opt/homebrew/opt/llvm/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc echo &amp;#39;export LDFLAGS=&amp;#34;-L/opt/homebrew/opt/llvm/lib&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc echo &amp;#39;export CPPFLAGS=&amp;#34;-I/opt/homebrew/opt/llvm/include&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc 以上是针对默认 shell 为 zsh 的配置，如果你像我一样，mac 的默认 shell 是 fish，那么需要修改 ~/.config/fish/config.fish，添加环境变量，添加下方法为追加以下内容：&#xA;set -gx PATH /opt/homebrew/opt/llvm/bin $PATH set -gx LDFLAGS -L/opt/homebrew/opt/llvm/lib set -gx CPPFLAGS -I/opt/homebrew/opt/llvm/include 然后在vscode中安装 CodeLLDB、clangd、Cmake、Xmake、Cmake Tools 这几个插件，其中除了Xmake之外都必须安装。&#xA;开始 随便找一个空文件打开，然后Ctrl+shift+p（macOS下为cmd+shift_p）打开下拉菜单，搜索camke，选择Quick start： 之后给项目起个名字，如webserver，输出类型选Executable而不是lib，Kit选择Clangxxxxx-gnu。&#xA;macOS 必须选择 homebrew 安装的 clang kit，否则会出现无法找到 ninja 的问题。</description>
    </item>
    <item>
      <title>Zsh 的简单配置与使用</title>
      <link>http://localhost:1313/posts/blog/zsh_configuration.zh/</link>
      <pubDate>Thu, 23 Mar 2023 10:55:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/zsh_configuration.zh/</guid>
      <description>安装starship MacOS下执行curl -sS https://starship.rs/install.sh | sh即可，Linux下（如Debian），执行curl -sS https://starship.rs/install.sh | sh即可，然后执行starship preset pure-preset &amp;gt; ~/.config/starship.toml将预设主题设置为pure。&#xA;安装zinit插件 执行bash -c &amp;quot;$(curl --fail --show-error --silent --location https://raw.githubusercontent.com/zdharma-continuum/zinit/HEAD/scripts/install.sh)&amp;quot;以自动安装**zinit。&#xA;修改~/.zshrc为以下内容&#xA;## 启用starship eval &amp;#34;$(starship init zsh)&amp;#34; ### Added by Zinit&amp;#39;s installer if [[ ! -f $HOME/.local/share/zinit/zinit.git/zinit.zsh ]]; then print -P &amp;#34;%F{33} %F{220}Installing %F{33}ZDHARMA-CONTINUUM%F{220} Initiative Plugin Manager (%F{33}zdharma-continuum/zinit%F{220})…%f&amp;#34; command mkdir -p &amp;#34;$HOME/.local/share/zinit&amp;#34; &amp;amp;&amp;amp; command chmod g-rwX &amp;#34;$HOME/.local/share/zinit&amp;#34; command git clone https://github.com/zdharma-continuum/zinit &amp;#34;$HOME/.local/share/zinit/zinit.git&amp;#34; &amp;amp;&amp;amp; \ print -P &amp;#34;%F{33} %F{34}Installation successful.</description>
    </item>
    <item>
      <title>297.serialize and Deserialize Binary Tree</title>
      <link>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree/</link>
      <pubDate>Thu, 23 Mar 2023 10:41:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree/</guid>
      <description></description>
    </item>
    <item>
      <title>297.二叉树的序列化与反序列化 (Hard)</title>
      <link>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree.zh/</link>
      <pubDate>Thu, 23 Mar 2023 10:40:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/297.serialize-and-deserialize-binary-tree.zh/</guid>
      <description>问题描述 297. 二叉树的序列化与反序列化 (Hard)&#xA;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。&#xA;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。&#xA;提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。&#xA;示例 1：&#xA;输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2：&#xA;输入：root = [] 输出：[] 示例 3：&#xA;输入：root = [1] 输出：[1] 示例 4：&#xA;输入：root = [1,2] 输出：[1,2] 提示：&#xA;树中结点数在范围 [0, 10⁴] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 解题思路 首先利用前序遍历的dfs，将节点的值存放到字符串中，如果遇到空节点，则str += &amp;quot;null_&amp;quot;，然后return。&#xA;反序列化时，首先将字符串转化为字符串链表，然后递归地进行反序列化，如果链表首元素为null，则为当前子树的root节点，然后先反序列化左子树，然后反序列化又子树，如果首元素为null，则直接返回。&#xA;可以注意到与前序遍历是相对应的的。&#xA;代码 class Codec { public: void rserialize(TreeNode* root, string&amp;amp; str) { if (root == nullptr) { str += &amp;#34;None,&amp;#34;; } else { str += to_string(root-&amp;gt;val) + &amp;#34;,&amp;#34;; rserialize(root-&amp;gt;left, str); rserialize(root-&amp;gt;right, str); } } string serialize(TreeNode* root) { string ret; rserialize(root, ret); return ret; } TreeNode* rdeserialize(list&amp;lt;string&amp;gt;&amp;amp; dataArray) { if (dataArray.</description>
    </item>
    <item>
      <title>2071.Maximum Number of Tasks You Can Assign (Hard)</title>
      <link>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign/</link>
      <pubDate>Wed, 22 Mar 2023 19:49:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign/</guid>
      <description>Description Maximum Number of Tasks You Can Assign (Hard) You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task&amp;rsquo;s strength requirement (i.</description>
    </item>
    <item>
      <title>2071.你可以安排的最多任务数目 (Hard)</title>
      <link>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign.zh/</link>
      <pubDate>Wed, 22 Mar 2023 19:49:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2071.maximum-number-of-tasks-you-can-assign.zh/</guid>
      <description>问题描述 2071. 你可以安排的最多任务数目 (Hard)&#xA;给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 0 开始的整数数组 tasks 中，第 i 个任务需要 tasks[i] 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 workers 中，第 j 个工人的力量值为 workers[j] 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 workers[j] &amp;gt;= tasks[i] ）。&#xA;除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。&#xA;给你下标从 0 开始的整数数组 tasks 和 workers 以及两个整数 pills 和 strength ，请你返回 最多 有多少个任务可以被完成。&#xA;示例 1：&#xA;输入：tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1 输出：3 解释： 我们可以按照如下方案安排药丸： - 给 0 号工人药丸。 - 0 号工人完成任务 2（0 + 1 &amp;gt;= 1） - 1 号工人完成任务 1（3 &amp;gt;= 2） - 2 号工人完成任务 0（3 &amp;gt;= 3） 示例 2：</description>
    </item>
    <item>
      <title>952.Largest Component Size by Common Factor (Hard)</title>
      <link>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor/</link>
      <pubDate>Wed, 22 Mar 2023 19:45:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor/</guid>
      <description>Description 952. Largest Component Size by Common Factor (Hard)&#xA;You are given an integer array of unique positive integers nums. Consider the following graph:&#xA;There are nums.length nodes, labeled nums[0] to nums[nums.length - 1], There is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph.&#xA;Example 1:&#xA;Input: nums = [4,6,15,35] Output: 4 Example 2:</description>
    </item>
    <item>
      <title>952.按公因数计算最大组件大小 (Hard)</title>
      <link>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor.zh/</link>
      <pubDate>Wed, 22 Mar 2023 19:29:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/952.largest-component-size-by-common-factor.zh/</guid>
      <description>问题描述 952. 按公因数计算最大组件大小 (Hard)&#xA;给定一个由不同正整数的组成的非空数组 nums ，考虑下面的图：&#xA;有 nums.length 个节点，按从 nums[0] 到 nums[nums.length - 1] 标记； 只有当 nums[i] 和 nums[j] 共用一个大于 1 的公因数时， nums[i] 和 nums[j] 之间才有一条边。 返回 图中最大连通组件的大小 。&#xA;示例 1：&#xA;输入：nums = [4,6,15,35] 输出：4 示例 2：&#xA;输入：nums = [20,50,9,63] 输出：2 示例 3：&#xA;输入：nums = [2,3,6,7,4,12,21,39] 输出：8 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁴ 1 &amp;lt;= nums[i] &amp;lt;= 10⁵ nums 中所有值都 不同 解题思路 使用并查集，并注意质因数分解的求法。&#xA;由于nums[i] &amp;lt;= 100000，因此我们设置初始的并查集的节点为$100001$个，遍历数组中的每个元素，将每个元素和他的质因数连接起来，我们只将size_[nums[i]]初始化为1，其余均为0，这样不属于nums[i]的质因数的个数就不会被统计到树的数量中，遍历数组的元素时，更新ans即可。&#xA;注意，由于时间复杂度的要求，我们需要压缩路径并且使用启发式合并。</description>
    </item>
    <item>
      <title>并查集</title>
      <link>http://localhost:1313/posts/tech/dsu-oi-wiki.zh/</link>
      <pubDate>Wed, 22 Mar 2023 17:59:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dsu-oi-wiki.zh/</guid>
      <description>引入 并查集是一种用于管理元素所属的集合的数据结构，其实现或者说表现为一片森林，其中，每棵树表示了一个集合，树中的节点表示对应的集合中的元素：&#xA;顾名思义，并查集支持两种操作：&#xA;合并（Union）：合并两个元素所属的集合（合并对应的树）； 查询（Find）：查询某个元素所属的集合（即查询对应的树的根节点），这可以用于判断两个元素是否属于同一个集合； 并查集在经过修改后还可以支持单个元素的移动、删除；使用动态开点线段树还可以实现可持久化并查集；&#xA;初始化 初始时，我们设置每个元素都属于一个单独的集合，表示为一棵只有根节点的树，每个根节点的父亲都设置为自己。&#xA;class Dsu { vector&amp;lt;size_t&amp;gt; parent_; // 表示每个节点的父节点 vector&amp;lt;size_t&amp;gt; size_; // 表示每棵树有多少节点 Dsu(size_t size) : parent_(size), size_(size, 1) { iota(parent_.begin(), parent_.end()); } } 查询 我们只需要沿着树向上移动，直到找到根节点 size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x]; } 查询时进行路径压缩 查询过程中，经过的每个元素都属于该集合，因此我们可以直接将其连接到根节点，以加快后续查询。 size_t Dsu::find(size_t x) { return parent_[x] == x ? x : parent_[x] = find(parent_[x]); } 合并 要合并两棵树，我们只需要将一棵树的根节点连接到另一棵树的根节点。 void Dsu::Unite(size_t x, size_t y) { parent_(find(x)) = find(y); } 启发式合并 即将节点较小或者深度较小的树连接到另一棵，这里以按节点数合并的实现作为参考:</description>
    </item>
    <item>
      <title>git 使用技巧</title>
      <link>http://localhost:1313/posts/tech/git_tutorial.zh/</link>
      <pubDate>Wed, 22 Mar 2023 09:56:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/git_tutorial.zh/</guid>
      <description>设置默认编辑器为 vim git config --global core.editor vim 问题fatal: in unpopulated submodule &#39;xxx&#39;的解决 出现这个问题的原因clone的别人的项目之后，删除项目里的.git文件就直接添加到了自己的版本控制里面，解决方案，执行 git rm --cached . -rf，再添加文件和提交。&#xA;&amp;ldquo;merge conflict&amp;rdquo; 解决 对于纯文本文件的冲突解决，可以参考该文章，没什么太多好说的。&#xA;对于二进制文件，编辑二进制文件来解决冲突是不现实的，要么选择对方的修改，要么选择自己的修改，可以使用git checkout的--theirs或者--ours选项：&#xA;git pull git checkout --theirs YOUR_BINARY_FILE // git checkout --ours YOUR_BINARY_FILE git add YOUR_BINARY_FILE git commit -m &amp;#39;merged with the remote repos.&amp;#39; git push </description>
    </item>
    <item>
      <title>654.Maximum Binary Tree (Medium)</title>
      <link>http://localhost:1313/posts/leet/654.maximum-binary-tree/</link>
      <pubDate>Sun, 19 Mar 2023 17:25:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/654.maximum-binary-tree/</guid>
      <description>Description 654. Maximum Binary Tree (Medium)&#xA;You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:&#xA;Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value.</description>
    </item>
    <item>
      <title>654.最大二叉树 (Medium)</title>
      <link>http://localhost:1313/posts/leet/654.maximum-binary-tree.zh/</link>
      <pubDate>Sun, 19 Mar 2023 17:25:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/654.maximum-binary-tree.zh/</guid>
      <description>问题描述 654. 最大二叉树 (Medium)&#xA;给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:&#xA;创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树。&#xA;示例 1：&#xA;输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2：</description>
    </item>
    <item>
      <title>自行制作 nerd font</title>
      <link>http://localhost:1313/posts/blog/patch_my_own_nerd_font.zh/</link>
      <pubDate>Sat, 18 Mar 2023 15:06:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/patch_my_own_nerd_font.zh/</guid>
      <description>前言 Nerd Fonts 是一个使用大量字体图标来解决程序员在开发过程中缺少合适字体的问题的项目。它可以从流行的字体图标库中将大量外部字体引入待开发的项目中。&#xA;Nerd Fonts官方提供的Fura Mono字体将r修改成了Fira Mono的变种形式，个人不太喜欢，于是考虑自行打包。&#xA;同时，由于版权原因，未提供monaco字体的Nerd Fonts，因此也需要自行打包。&#xA;patch Fira Mono 参照Option 9: Patch Your Own Font,下载font patcher并解压，保证待打包字体位于解压之后的文件夹，然后执行&#xA;./font-patcher FiraMono-Regular.ttf -s -c --also-windows -ext otf patch Monaco 与Fira Mono类似，从此处下载Monaco字体，然后执行：&#xA;./font-patcher Monaco.ttf -s -c --also-windows -ext otf </description>
    </item>
    <item>
      <title>2389.Longest Subsequence With Limited Sum (Easy)</title>
      <link>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum/</link>
      <pubDate>Fri, 17 Mar 2023 15:44:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum/</guid>
      <description>Description 2389. Longest Subsequence With Limited Sum (Easy)&#xA;You are given an integer array nums of length n, and an integer array queries of length m.&#xA;Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].&#xA;A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</description>
    </item>
    <item>
      <title>2389.和有限的最长子序列 (Easy)</title>
      <link>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum.zh/</link>
      <pubDate>Fri, 17 Mar 2023 15:44:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2389.longest-subsequence-with-limited-sum.zh/</guid>
      <description>问题描述 和有限的最长子序列 (Easy) 给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。&#xA;返回一个长度为 m 的数组 answer，其中 answer[i] 是 nums 中元素之和小于等于 queries[i] 的 子序列 的 最大 长度。&#xA;子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。&#xA;示例 1：&#xA;输入：nums = [4,5,2,1], queries = [3,10,21] 输出：[2,3,4] 解释：queries 对应的 answer 如下： - 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。 - 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。 - 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。 示例 2：</description>
    </item>
    <item>
      <title>778.Swim in Rising Water (Hard)</title>
      <link>http://localhost:1313/posts/leet/778.swim-in-rising-water/</link>
      <pubDate>Fri, 17 Mar 2023 15:29:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/778.swim-in-rising-water/</guid>
      <description>Description 778. Swim in Rising Water (Hard)&#xA;You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).&#xA;The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time.</description>
    </item>
    <item>
      <title>778.水位上升的泳池中游泳 (Hard)</title>
      <link>http://localhost:1313/posts/leet/778.swim-in-rising-water.zh/</link>
      <pubDate>Fri, 17 Mar 2023 15:29:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/778.swim-in-rising-water.zh/</guid>
      <description>问题描述 778. 水位上升的泳池中游泳 (Hard)&#xA;在一个 n x n 的整数矩阵 grid 中，每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。&#xA;当开始下雨时，在时间为 t 时，水池中的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。&#xA;你从坐标方格的左上平台 (0，0) 出发。返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间 。&#xA;示例 1:&#xA;输入: grid = [[0,2],[1,3]] 输出: 3 解释: 时间为0时，你位于坐标方格的位置为 (0, 0)。 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。 等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置 示例 2:&#xA;输入: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] 输出: 16 解释: 最终的路线用加粗进行了标记。 我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的 提示:</description>
    </item>
    <item>
      <title>Neovim 的配置与使用</title>
      <link>http://localhost:1313/posts/blog/neovim_tutorial.zh/</link>
      <pubDate>Fri, 17 Mar 2023 15:08:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/neovim_tutorial.zh/</guid>
      <description>安装 LazyVim 参考 Lazyvim 的官方安装教程即可安装，要求系统已经安装好了 npm。&#xA;实际上就是 clone folke 的适用于 LazyVim 的初始 配置文件 到 Neovim 的配置文件所处的目录，Linux 和 macOS 都是 ~/.config，Windows 比较特殊，位于 ~/AppData/Local/。&#xA;由于我对初始配置文件做了一定的修改，因此我这里直接 clone 我自己的 配置文件&#xA;It is recommended to run :checkhealth after installation&#xA;值得注意的是，LazyVim 会安装 nvim-treesitter 插件，而 nvim-treesitter 插件会自动编译安装 C/C++ 等语言的解析器，而编译安装是需要 C/C++ 的运行环境的，对安装了 Command Line Tool 的 Mac 或者 Linux 而言，这一步一般不会存在问题，Windows 则是容易出现问题，我在重装 Windows 系统后尝试过只通过 scoop 安装了 llvm，尽管命令行中执行 clang --version 是有正常输出的，即 C/C++ 运行环境已经正常安装好了，但是 nvim-treesitter 始终无法正常编译解释器，不得已，我又通过 scoop install mingw 安装了 mingw（gcc），安装好 mingw 之后，解释器就能正常被编译安装了，此后执行 scoop uninstall mingw 卸载掉 mingw 也还是能正常使用。</description>
    </item>
    <item>
      <title>1631.Path With Minimum Effort (Medium)</title>
      <link>http://localhost:1313/posts/leet/1631.path-with-minimum-effort/</link>
      <pubDate>Thu, 16 Mar 2023 13:53:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1631.path-with-minimum-effort/</guid>
      <description>Solution 1631. Path With Minimum Effort (Medium)&#xA;You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.</description>
    </item>
    <item>
      <title>1631.最小体力消耗路径 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1631.path-with-minimum-effort.zh/</link>
      <pubDate>Thu, 16 Mar 2023 13:49:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1631.path-with-minimum-effort.zh/</guid>
      <description>问题描述 1631. 最小体力消耗路径 (Medium)&#xA;你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上， 下， 左， 右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。&#xA;一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。&#xA;请你返回从左上角走到右下角的最小 体力消耗值 。&#xA;示例 1：&#xA;输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。 示例 2：&#xA;输入：heights = [[1,2,3],[3,8,4],[5,3,5]] 输出：1 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3：</description>
    </item>
    <item>
      <title>407.Trapping Rain Water II (Hard)</title>
      <link>http://localhost:1313/posts/leet/407.trapping-rain-water-ii/</link>
      <pubDate>Wed, 15 Mar 2023 15:01:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/407.trapping-rain-water-ii/</guid>
      <description>Description 407. Trapping Rain Water II (Hard)&#xA;Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.&#xA;Example 1:&#xA;Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] Output: 4 Explanation: After the rain, water is trapped between the blocks. We have two small ponds 1 and 3 units trapped. The total volume of water trapped is 4.</description>
    </item>
    <item>
      <title>407.接雨水 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/407.trapping-rain-water-ii.zh/</link>
      <pubDate>Wed, 15 Mar 2023 15:01:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/407.trapping-rain-water-ii.zh/</guid>
      <description>问题描述 407. 接雨水 II (Hard)&#xA;给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。&#xA;示例 1:&#xA;输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] 输出: 4 解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。 示例 2:&#xA;输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] 输出: 10 提示:&#xA;m == heightMap.length n == heightMap[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= heightMap[i][j] &amp;lt;= 2 * 10⁴ 解题思路 设方格$(i, j)$到边界上的点$(x, y)$的路径的最大高度为$h_{x,y}$，那么方格$(i, j)$所能存放的雨水就是$h_xy$的最小值减去height[i][j]；&#xA;$h_{x,y}$也可以转化成边界上的点$(x, y)$到方格$(i, j)$的路径的上的方格的最大高度，那么就可以使用Dijkstra算法来解决，初始时将边界上所有的点都加入优先队列中，即可求边界上所有方格到$(i, j)$的最大高度的最小值，还是使用小顶堆。&#xA;代码 class Solution { public: int trapRainWater(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;heightMap) { // 找边界上所有点，到x,y的路径上的最大高度的最小值（不包括x,y） // (x,y)处的存放的雨水即这个高度h-heightMap[x][y]; int m = heightMap.</description>
    </item>
    <item>
      <title>1615.Maximal Network Rank (Medium)</title>
      <link>http://localhost:1313/posts/leet/1615.maximal-network-rank/</link>
      <pubDate>Wed, 15 Mar 2023 09:46:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1615.maximal-network-rank/</guid>
      <description>Description 1615. Maximal Network Rank (Medium)&#xA;There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [aᵢ, bᵢ] indicates that there is a bidirectional road between cities aᵢ and bᵢ.&#xA;The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.</description>
    </item>
    <item>
      <title>1615.最大网络秩 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1615.maximal-network-rank.zh/</link>
      <pubDate>Wed, 15 Mar 2023 09:46:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1615.maximal-network-rank.zh/</guid>
      <description>问题描述 1615. 最大网络秩 (Medium)&#xA;n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [aᵢ, bᵢ] 都表示在城市 aᵢ 和 bᵢ 之间有一条双向道路。&#xA;两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。&#xA;整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。&#xA;给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。&#xA;示例 1：&#xA;输入：n = 4, roads = [[0,1],[0,3],[1,2],[1,3]] 输出：4 解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。 示例 2：&#xA;输入：n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] 输出：5 解释：共有 5 条道路与城市 1 或 2 相连。 示例 3：</description>
    </item>
    <item>
      <title>C&#43;&#43; 模板类编译过程中出现“undefined reference to”问题</title>
      <link>http://localhost:1313/posts/tech/cpp_templdate_undefined.zh/</link>
      <pubDate>Tue, 14 Mar 2023 18:35:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/cpp_templdate_undefined.zh/</guid>
      <description>问题描述 C++在使用模板(template)类的时候，如果将类的成员函数的声明和实现分别放在.h头文件和.cpp源文件中，编译时会报错undefined reference xxx，找不到对应成员函数。&#xA;起因 .h文件中类的声明为：&#xA;// 线程池，定义成模板类，为了代码的复用 template &amp;lt;typename T&amp;gt; class ThreadPool { ... public: bool append(T *request); ... }; .cpp文件中成员函数的实现为：&#xA;template &amp;lt;typename T&amp;gt; bool ThreadPool&amp;lt;T&amp;gt;::append(T *request) { // 操作工作队列时一定要加锁，因为它被所有线程共享 queue_locker_.lock(); if (work_queue_.size() &amp;gt; max_requests_) { queue_locker_.unlock(); return false; } work_queue_.push_back(request); queue_locker_.unlock(); queue_sta_.post(); return true; } 直接使用g++编译，会报错： 原因分析 template其实是一种类似语法糖的东西，C++中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道，模板类中使用模板类型的对象的所占用的空间的大小的。只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。这也就是模板类为什么只是称之为模板，而不是泛型的缘故。&#xA;即ThreadPool&amp;lt;int&amp;gt;和Thread&amp;lt;HttpConn&amp;gt;是两个不同的类型，其成员函数也是两个不同的成员函数。&#xA;在编译thread_pool.cpp时，编译器会去查找对类Thread&amp;lt;HttpConn&amp;gt;的声明，如果找不到这个声明，那么就报错了。&#xA;解决方案 在成员函数的实现的代码所在的源文件的开头，声明该类，即添加：&#xA;template class ThreadPool&amp;lt;HttpConn&amp;gt;; 或者将函数的实现也写在头文件中（不推荐）。</description>
    </item>
    <item>
      <title>ssh 简单教程</title>
      <link>http://localhost:1313/posts/blog/ssh_tips.zh/</link>
      <pubDate>Tue, 14 Mar 2023 16:23:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/ssh_tips.zh/</guid>
      <description>ssh配置免密码登录服务器 生成密钥对 执行ssh-keygen -t ed25519 -C &amp;quot;zwyyy456@hotmail.com&amp;quot;以生成密钥对，存放在~/.ssh文件夹下，id_ed25519.pub为公钥，id_ed25519为私钥。&#xA;上传公钥到服务器 这里以我的N1为例，执行ssh-copy-id -i ~/.ssh/id_ed25519.pub root@192.168.6.217和ssh-copy-id -i ~/.ssh/id_ed25519.pub zwyyy@192.168.6.217，将公钥上传到服务器，root和zwyyy分别是两个用户。&#xA;配置局域网ssh连接到wsl hyper-v创建虚拟交换机 打开hyper-v管理器，选择虚拟交换机管理器，选择创建外部类型的虚拟交换机，这里命名为wsl_ssh。&#xA;win11上新建wsl配置文件 cd ~ New-Item .wslconfig nvim .wslconfig 修改配置文件内容为&#xA;[wsl2] networkingMode=bridged vmSwitch=wsl_ssh # 这里为你创建的虚拟交换机名称 ipv6=true 之后执行wsl --shutdown再启动wsl，就会发现ip地址为电脑本身的ip了。&#xA;openwrt上固定电脑的ip 进入openwrt的管理界面，点击网络-&amp;gt;DHCP/DNS，选择静态地址分配，固定windows笔记本的ip&#xA;启用wsl上的ssh 执行sudo nvim /etc/ssh/sshd_config，将#port 22修改为port 2222，取消注释#PasswordAuthentication yes和#PubekyAuthentcation yes，重启ssh服务，执行sudo service ssh restart。&#xA;win11设置端口转发 参照该链接&#xA;之后同一局域网的mac执行ssh -p 2222 zwyyy456@192.168.6.209，即可连接到wsl。</description>
    </item>
    <item>
      <title>ssh简单教程</title>
      <link>http://localhost:1313/posts/leet/ssh_tips.zh/</link>
      <pubDate>Tue, 14 Mar 2023 16:23:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/ssh_tips.zh/</guid>
      <description>ssh配置免密码登录服务器 生成密钥对 执行ssh-keygen -t ed25519 -C &amp;quot;zwyyy456@hotmail.com&amp;quot;以生成密钥对，存放在~/.ssh文件夹下，id_ed25519.pub为公钥，id_ed25519为私钥。&#xA;上传公钥到服务器 这里以我的N1为例，执行ssh-copy-id -i ~/.ssh/id_ed25519.pub root@192.168.6.217和ssh-copy-id -i ~/.ssh/id_ed25519.pub zwyyy@192.168.6.217，将公钥上传到服务器，root和zwyyy分别是两个用户。&#xA;配置局域网ssh连接到wsl hyper-v创建虚拟交换机 打开hyper-v管理器，选择虚拟交换机管理器，选择创建外部类型的虚拟交换机，这里命名为wsl_ssh。&#xA;win11上新建wsl配置文件 cd ~ New-Item .wslconfig nvim .wslconfig 修改配置文件内容为&#xA;[wsl2] networkingMode=bridged vmSwitch=wsl_ssh # 这里为你创建的虚拟交换机名称 ipv6=true 之后执行wsl --shutdown再启动wsl，就会发现ip地址为电脑本身的ip了。&#xA;openwrt上固定电脑的ip 进入openwrt的管理界面，点击网络-&amp;gt;DHCP/DNS，选择静态地址分配，固定windows笔记本的ip&#xA;启用wsl上的ssh 执行sudo nvim /etc/ssh/sshd_config，将#port 22修改为port 2222，取消注释#PasswordAuthentication yes和#PubekyAuthentcation yes，重启ssh服务，执行sudo service ssh restart。&#xA;win11设置端口转发 参照该链接&#xA;之后同一局域网的mac执行ssh -p 2222 zwyyy456@192.168.6.209，即可连接到wsl。</description>
    </item>
    <item>
      <title>1976.Number of Ways to Arrive at Destination (Medium)</title>
      <link>http://localhost:1313/posts/leet/1976.number-of-ways-to-arrive-at-destination/</link>
      <pubDate>Tue, 14 Mar 2023 14:39:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1976.number-of-ways-to-arrive-at-destination/</guid>
      <description>Description 1976. Number of Ways to Arrive at Destination (Medium)&#xA;You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.&#xA;You are given an integer n and a 2D integer array roads where roads[i] = [uᵢ, vᵢ, timeᵢ] means that there is a road between intersections uᵢ and vᵢ that takes timeᵢ minutes to travel.</description>
    </item>
    <item>
      <title>1976.到达目的地的方案数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1976.number-of-ways-to-arrive-at-destination.zh/</link>
      <pubDate>Tue, 14 Mar 2023 14:39:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1976.number-of-ways-to-arrive-at-destination.zh/</guid>
      <description>问题描述 1976. 到达目的地的方案数 (Medium)&#xA;你在一个城市里，城市由 n 个路口组成，路口编号为 0 到 n - 1 ，某些路口之间有 双向 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。&#xA;给你一个整数 n 和二维整数数组 roads ，其中 roads[i] = [uᵢ, vᵢ, timeᵢ] 表示在路口 uᵢ 和 vᵢ 之间有一条需要花费 timeᵢ 时间才能通过的道路。你想知道花费 最少时间 从路口 0 出发到达路口 n - 1 的方案数。&#xA;请返回花费 最少时间 到达目的地的 路径数目 。由于答案可能很大，将结果对 10⁹ + 7 取余 后返回。&#xA;示例 1：&#xA;输入：n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]] 输出：4 解释：从路口 0 出发到路口 6 花费的最少时间是 7 分钟。 四条花费 7 分钟的路径分别为： - 0 ➝ 6 - 0 ➝ 4 ➝ 6 - 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6 - 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6 示例 2：</description>
    </item>
    <item>
      <title>787.Cheapest Flights Within K Stops (Medium)</title>
      <link>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops/</link>
      <pubDate>Mon, 13 Mar 2023 14:16:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops/</guid>
      <description>Description 787. Cheapest Flights Within K Stops (Medium)&#xA;There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromᵢ, toᵢ, priceᵢ] indicates that there is a flight from city fromᵢ to city toᵢ with cost priceᵢ.&#xA;You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.</description>
    </item>
    <item>
      <title>787.K 站中转内最便宜的航班 (Medium)</title>
      <link>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops.zh/</link>
      <pubDate>Mon, 13 Mar 2023 14:14:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/787.cheapest-flights-within-k-stops.zh/</guid>
      <description>问题描述 787. K 站中转内最便宜的航班 (Medium)&#xA;有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromᵢ, toᵢ, priceᵢ] ，表示该航班都从城市 fromᵢ 开始，以价格 priceᵢ 抵达 toᵢ。&#xA;现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。&#xA;示例 1：&#xA;输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 输出: 200 解释: 城市航班图如下 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 示例 2：&#xA;输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 输出: 500 解释: 城市航班图如下 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。 提示：</description>
    </item>
    <item>
      <title>1786.Number of Restricted Paths From First to Last Node (Medium)</title>
      <link>http://localhost:1313/posts/leet/1786.number-of-restricted-paths-from-first-to-last-node/</link>
      <pubDate>Mon, 13 Mar 2023 13:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1786.number-of-restricted-paths-from-first-to-last-node/</guid>
      <description>Description Number of Restricted Paths From First to Last Node (Medium) There is an undirected weighted connected graph. You are given a positive integer n which denotes that the graph has n nodes labeled from 1 to n, and an array edges where each edges[i] = [uᵢ, vᵢ, weightᵢ] denotes that there is an edge between nodes uᵢ and vᵢ with weight equal to weightᵢ.&#xA;A path from node start to node end is a sequence of nodes [z₀, z₁,z₂, .</description>
    </item>
    <item>
      <title>1786. 从第一个节点出发到最后一个节点的受限路径数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1786.number-of-restricted-paths-from-first-to-last-node.zh/</link>
      <pubDate>Mon, 13 Mar 2023 13:27:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1786.number-of-restricted-paths-from-first-to-last-node.zh/</guid>
      <description>问题描述 1786. 从第一个节点出发到最后一个节点的受限路径数 (Medium)&#xA;现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [uᵢ, vᵢ, weightᵢ] 表示存在一条位于节点 uᵢ 和 vᵢ 之间的边，这条边的权重为 weightᵢ 。&#xA;从节点 start 出发到节点 end 的路径是一个形如 [z₀, z₁,z₂, ..., zₖ] 的节点序列，满足 z₀ = start 、 zₖ = end 且在所有符合 0 &amp;lt;= i &amp;lt;= k-1 的节点 zᵢ 和 zᵢ+₁ 之间存在一条边。&#xA;路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。 受限路径 为满足 distanceToLastNode(zᵢ) &amp;gt; distanceToLastNode(zᵢ+₁) 的一条路径，其中 0 &amp;lt;= i &amp;lt;= k-1 。</description>
    </item>
    <item>
      <title>2383. Minimum Hours of Training to Win a Competition (Easy)</title>
      <link>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition/</link>
      <pubDate>Mon, 13 Mar 2023 09:34:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition/</guid>
      <description>Description Minimum Hours of Training to Win a Competition (Easy) You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively.&#xA;You are also given two 0-indexed integer arrays energy and experience, both of length n.&#xA;You will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available.</description>
    </item>
    <item>
      <title>2383.赢得比赛需要的最少训练时长 (Easy)</title>
      <link>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition.zh/</link>
      <pubDate>Mon, 13 Mar 2023 09:34:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2383.minimum-hours-of-training-to-win-a-competition.zh/</guid>
      <description>问题描述 2383. 赢得比赛需要的最少训练时长 (Easy)&#xA;你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。&#xA;另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。&#xA;你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。&#xA;击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少 energy[i] 。&#xA;在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。&#xA;返回击败全部 n 个对手需要训练的 最少 小时数目。&#xA;示例 1：&#xA;输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1] 输出：8 解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。 按以下顺序与对手比赛： - 你的精力与经验都超过第 0 个对手，所以获胜。 精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。 - 你的精力与经验都超过第 1 个对手，所以获胜。 精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。 - 你的精力与经验都超过第 2 个对手，所以获胜。 精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。 - 你的精力与经验都超过第 3 个对手，所以获胜。 精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。 在比赛前进行了 8 小时训练，所以返回 8 。 可以证明不存在更小的答案。 示例 2：</description>
    </item>
    <item>
      <title>743. Network Delay Time (Medium)</title>
      <link>http://localhost:1313/posts/leet/743.network-delay-time/</link>
      <pubDate>Sun, 12 Mar 2023 14:23:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/743.network-delay-time/</guid>
      <description>743. Network Delay Time (Medium)&#xA;You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (uᵢ, vᵢ, wᵢ), where uᵢ is the source node, vᵢ is the target node, and wᵢ is the time it takes for a signal to travel from source to target.&#xA;We will send a signal from a given node k.</description>
    </item>
    <item>
      <title>743. 网络延迟时间 (Medium)</title>
      <link>http://localhost:1313/posts/leet/743.network-delay-time.zh/</link>
      <pubDate>Sun, 12 Mar 2023 14:23:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/743.network-delay-time.zh/</guid>
      <description>问题描述 743. 网络延迟时间 (Medium)&#xA;有 n 个网络节点，标记为 1 到 n。&#xA;给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (uᵢ, vᵢ, wᵢ)，其中 uᵢ 是源节点， vᵢ 是目标节点， wᵢ 是一个信号从源节点传递到目标节点的时间。&#xA;现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。&#xA;示例 1：&#xA;输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 输出：2 示例 2：&#xA;输入：times = [[1,2,1]], n = 2, k = 1 输出：1 示例 3：&#xA;输入：times = [[1,2,1]], n = 2, k = 2 输出：-1 提示：&#xA;1 &amp;lt;= k &amp;lt;= n &amp;lt;= 100 1 &amp;lt;= times.</description>
    </item>
    <item>
      <title>面试题 17.05.  字母与数字 (Medium)</title>
      <link>http://localhost:1313/posts/leet/interview-17.05.zh/</link>
      <pubDate>Sat, 11 Mar 2023 15:31:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/interview-17.05.zh/</guid>
      <description>问题描述 面试题 17.05. 字母与数字 (Medium)&#xA;给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。&#xA;返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。&#xA;示例 1:&#xA;输入: [&amp;#34;A&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;2&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;4&amp;#34;,&amp;#34;E&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;F&amp;#34;,&amp;#34;G&amp;#34;,&amp;#34;6&amp;#34;,&amp;#34;7&amp;#34;,&amp;#34;H&amp;#34;,&amp;#34;I&amp;#34;,&amp;#34;J&amp;#34;,&amp;#34;K&amp;#34;,&amp;#34;L&amp;#34;,&amp;#34;M&amp;#34;] 输出: [&amp;#34;A&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;2&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;4&amp;#34;,&amp;#34;E&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;F&amp;#34;,&amp;#34;G&amp;#34;,&amp;#34;6&amp;#34;,&amp;#34;7&amp;#34;] 示例 2:&#xA;输入: [&amp;#34;A&amp;#34;,&amp;#34;A&amp;#34;] 输出: [] 提示：&#xA;array.length &amp;lt;= 100000 解题思路 首先使用一个前缀和数组prefix，prefix[i]表示前i个数里，数字的数量减去字母的数量，遍历array，更新prefix，同时在哈希表中查找key-&amp;gt;prefix[i]是否存在：&#xA;如果存在，比较记录的最长长度len，如果大于len，则更新idx = ump[prefix[i]]，并更新len = i - ump[prefix[i]]； 否则，更新哈希表，即ump[prefix[i]] = i； 代码 class Solution { public: vector&amp;lt;string&amp;gt; findLongestSubarray(vector&amp;lt;string&amp;gt; &amp;amp;array) { int n = array.size(); vector&amp;lt;string&amp;gt; res; if (n &amp;lt; 2) { return res; } unordered_set&amp;lt;string&amp;gt; ust; for (char c = &amp;#39;a&amp;#39;; c &amp;lt;= &amp;#39;z&amp;#39;; c++) { // 统计所有的字母 string s(1, c); ust.</description>
    </item>
    <item>
      <title>1590. Make Sum Divisible by P (Medium)</title>
      <link>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p/</link>
      <pubDate>Fri, 10 Mar 2023 09:31:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p/</guid>
      <description>Description 1590. Make Sum Divisible by P (Medium)&#xA;Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.&#xA;Return the length of the smallest subarray that you need to remove, or -1 if it&amp;rsquo;s impossible.&#xA;A subarray is defined as a contiguous block of elements in the array.</description>
    </item>
    <item>
      <title>1590.使数组和能被 P 整除 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p.zh/</link>
      <pubDate>Fri, 10 Mar 2023 09:31:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1590.make-sum-divisible-by-p.zh/</guid>
      <description>问题描述 1590. 使数组和能被 P 整除 (Medium)&#xA;给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。&#xA;请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。&#xA;子数组 定义为原数组中连续的一组元素。&#xA;示例 1：&#xA;输入：nums = [3,1,4,2], p = 6 输出：1 解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。 示例 2：&#xA;输入：nums = [6,3,5,2], p = 9 输出：2 解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。 示例 3：&#xA;输入：nums = [1,2,3], p = 3 输出：0 解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。 示例 4：</description>
    </item>
    <item>
      <title>1310.XOR Queries of a Subarray (Medium)</title>
      <link>http://localhost:1313/posts/leet/1310.xor-queries-of-a-subarray/</link>
      <pubDate>Thu, 09 Mar 2023 09:16:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1310.xor-queries-of-a-subarray/</guid>
      <description>Description 1310. XOR Queries of a Subarray (Medium)&#xA;You are given an array arr of positive integers. You are also given the array queries where queries[i] = [leftᵢ, rightᵢ].&#xA;For each query i compute the XOR of elements from leftᵢ to rightᵢ (that is, arr[leftᵢ] XOR arr[leftᵢ + 1] XOR ... XOR arr[rightᵢ] ).&#xA;Return an array answer where answer[i] is the answer to the ith query.&#xA;Example 1:&#xA;Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] Output: [2,7,14,8] Explanation: The binary representation of the elements in the array are: 1 = 0001 3 = 0011 4 = 0100 8 = 1000 The XOR values for queries are: [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 Example 2:</description>
    </item>
    <item>
      <title>1310. 子数组异或查询 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1310.xor-queries-of-a-subarray.zh/</link>
      <pubDate>Thu, 09 Mar 2023 09:16:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1310.xor-queries-of-a-subarray.zh/</guid>
      <description>问题描述 1310. 子数组异或查询 (Medium)&#xA;有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Lᵢ, Rᵢ]。&#xA;对于每个查询 i，请你计算从 Lᵢ 到 Rᵢ 的 XOR 值（即 arr[Lᵢ] xor arr[Lᵢ+1] xor ... xor arr[Rᵢ]）作为本次查询的结果。&#xA;并返回一个包含给定查询 queries 所有结果的数组。&#xA;示例 1：&#xA;输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] 输出：[2,7,14,8] 解释： 数组中元素的二进制表示形式是： 1 = 0001 3 = 0011 4 = 0100 8 = 1000 查询的 XOR 值为： [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 示例 2：</description>
    </item>
    <item>
      <title>629. K Inverse Pairs Array (Hard)</title>
      <link>http://localhost:1313/posts/leet/629.k-inverse-pairs-array/</link>
      <pubDate>Wed, 08 Mar 2023 13:09:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/629.k-inverse-pairs-array/</guid>
      <description>Description K Inverse Pairs Array (Hard) For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length and nums[i] &amp;gt; nums[j].&#xA;Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 10⁹ + 7.</description>
    </item>
    <item>
      <title>629.K个逆序对数组 (Hard)</title>
      <link>http://localhost:1313/posts/leet/629.k-inverse-pairs-array.zh/</link>
      <pubDate>Wed, 08 Mar 2023 13:09:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/629.k-inverse-pairs-array.zh/</guid>
      <description>问题描述 629. K个逆序对数组 (Hard)&#xA;给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。&#xA;逆序对的定义如下：对于数组的第 i 个和第 j 个元素，如果满 i &amp;lt; j 且 a[i] &amp;gt; a[j]，则其为一个逆序对；否则不是。&#xA;由于答案可能很大，只需要返回 答案 mod 10 + 7 的值。&#xA;示例 1:&#xA;输入: n = 3, k = 0 输出: 1 解释: 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。 示例 2:&#xA;输入: n = 3, k = 1 输出: 2 解释: 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。 说明:</description>
    </item>
    <item>
      <title>560. Subarray Sum Equals K (Medium)</title>
      <link>http://localhost:1313/posts/leet/560.subarray-sum-equals-k/</link>
      <pubDate>Tue, 07 Mar 2023 15:28:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/560.subarray-sum-equals-k/</guid>
      <description>Description 560. Subarray Sum Equals K (Medium)&#xA;Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.&#xA;A subarray is a contiguous non-empty sequence of elements within an array.&#xA;Example 1:&#xA;Input: nums = [1,1,1], k = 2 Output: 2 Example 2:&#xA;Input: nums = [1,2,3], k = 3 Output: 2 Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁴ -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -10⁷ &amp;lt;= k &amp;lt;= 10⁷ Solution We only need traverse once.</description>
    </item>
    <item>
      <title>560. 和为 K 的子数组 (Medium)</title>
      <link>http://localhost:1313/posts/leet/560.subarray-sum-equals-k.zh/</link>
      <pubDate>Tue, 07 Mar 2023 15:28:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/560.subarray-sum-equals-k.zh/</guid>
      <description>问题描述 560. 和为 K 的子数组 (Medium)&#xA;给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。&#xA;示例 1：&#xA;输入：nums = [1,1,1], k = 2 输出：2 示例 2：&#xA;输入：nums = [1,2,3], k = 3 输出：2 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 10⁴ -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -10⁷ &amp;lt;= k &amp;lt;= 10⁷ 解题思路 一次遍历，记录数组的前缀和prefix[i]，然后在ump中查找key为prefix[i] - target的元素是否存在，如果存在res += ump[prefix[i] - k]，++ump[prefix[i]]。&#xA;代码 class Solution { public: int subarraySum(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { vector&amp;lt;int&amp;gt; prefix(nums.</description>
    </item>
    <item>
      <title>497.Random Point in Non-overlapping Rectangles (Medium)</title>
      <link>http://localhost:1313/posts/leet/497.random-point-in-non-overlapping-rectangles/</link>
      <pubDate>Tue, 07 Mar 2023 14:45:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/497.random-point-in-non-overlapping-rectangles/</guid>
      <description>Description 497. Random Point in Non-overlapping Rectangles (Medium)&#xA;You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [aᵢ, bᵢ, xᵢ, yᵢ] indicates that (aᵢ, bᵢ) is the bottom-left corner point of the ith rectangle and (xᵢ, yᵢ) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.</description>
    </item>
    <item>
      <title>497.非重叠矩形中的随机点 (Medium)</title>
      <link>http://localhost:1313/posts/leet/497.random-point-in-non-overlapping-rectangles.zh/</link>
      <pubDate>Tue, 07 Mar 2023 14:45:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/497.random-point-in-non-overlapping-rectangles.zh/</guid>
      <description>问题描述 497. 非重叠矩形中的随机点 (Medium)&#xA;给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点， (xi, yi) 是第 i 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。&#xA;在给定的矩形覆盖的空间内的任何整数点都有可能被返回。&#xA;请注意，整数点是具有整数坐标的点。&#xA;实现 Solution 类:&#xA;Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。 int[] pick() 返回一个随机的整数点 [u, v] 在给定的矩形所覆盖的空间内。 示例 1：&#xA;输入: [&amp;#34;Solution&amp;#34;, &amp;#34;pick&amp;#34;, &amp;#34;pick&amp;#34;, &amp;#34;pick&amp;#34;, &amp;#34;pick&amp;#34;, &amp;#34;pick&amp;#34;] [[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []] 输出: [null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]] 解释： Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]); solution.</description>
    </item>
    <item>
      <title>162.Find Peak Element (Medium)</title>
      <link>http://localhost:1313/posts/leet/162.find-peak-element/</link>
      <pubDate>Mon, 06 Mar 2023 19:43:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/162.find-peak-element/</guid>
      <description>Description 162. Find Peak Element (Medium)&#xA;A peak element is an element that is strictly greater than its neighbors.&#xA;Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.&#xA;You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</description>
    </item>
    <item>
      <title>162.寻找峰值 (Medium)</title>
      <link>http://localhost:1313/posts/leet/162.find-peak-element.zh/</link>
      <pubDate>Mon, 06 Mar 2023 19:39:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/162.find-peak-element.zh/</guid>
      <description>问题描述 162. 寻找峰值 (Medium)&#xA;峰值元素是指其值严格大于左右相邻值的元素。&#xA;给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。&#xA;你可以假设 nums[-1] = nums[n] = -∞ 。&#xA;你必须实现时间复杂度为 O(log n) 的算法来解决此问题。&#xA;示例 1：&#xA;输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2：&#xA;输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 1000 -2³¹ &amp;lt;= nums[i] &amp;lt;= 2³¹ - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1] 解题思路 本题要求实现时间复杂度为$O(\log n)$的算法来解决问题，因此我们很容易想到二分，二分本质上并不要求单调性，而是要求二段性。&#xA;代码 class Solution { public: int findPeakElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.</description>
    </item>
    <item>
      <title>1599.Maximum Profit of Operating a Centennial Wheel (Medium)</title>
      <link>http://localhost:1313/posts/leet/1599.maximum-profit-of-operating-a-centennial-wheel/</link>
      <pubDate>Mon, 06 Mar 2023 19:35:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1599.maximum-profit-of-operating-a-centennial-wheel/</guid>
      <description>Description 1599. Maximum Profit of Operating a Centennial Wheel (Medium)&#xA;You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.&#xA;You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive.</description>
    </item>
    <item>
      <title>1599.经营摩天轮的最大利润 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1599.maximum-profit-of-operating-a-centennial-wheel.zh/</link>
      <pubDate>Mon, 06 Mar 2023 19:33:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1599.maximum-profit-of-operating-a-centennial-wheel.zh/</guid>
      <description>问题描述 1599. 经营摩天轮的最大利润 (Medium)&#xA;你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。&#xA;给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。&#xA;你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆， 将免费进行 所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。&#xA;返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。&#xA;示例 1：&#xA;输入：customers = [8,3], boardingCost = 5, runningCost = 6 输出：3 解释：座舱上标注的数字是该座舱的当前游客数。 1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。 2.</description>
    </item>
    <item>
      <title>209.Minimum Size Subarray Sum (Medium)</title>
      <link>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum/</link>
      <pubDate>Mon, 06 Mar 2023 19:11:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum/</guid>
      <description>Description 209. Minimum Size Subarray Sum (Medium)&#xA;Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.&#xA;Example 1:&#xA;Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. Example 2:&#xA;Input: target = 4, nums = [1,4,4] Output: 1 Example 3:</description>
    </item>
    <item>
      <title>209.长度最小的子数组 (Medium)</title>
      <link>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum.zh/</link>
      <pubDate>Mon, 06 Mar 2023 19:11:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/209.minimum-size-subarray-sum.zh/</guid>
      <description>问题描述 209. 长度最小的子数组 (Medium)&#xA;给定一个含有 n 个正整数的数组和一个正整数 target 。&#xA;找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsₗ, numsₗ+₁, ..., numsr-₁, numsr] ，并返回其长度 。 如果不存在符合条件的子数组，返回 0 。&#xA;示例 1：&#xA;输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：&#xA;输入：target = 4, nums = [1,4,4] 输出：1 示例 3：&#xA;输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示：&#xA;1 &amp;lt;= target &amp;lt;= 10⁹ 1 &amp;lt;= nums.length &amp;lt;= 10⁵ 1 &amp;lt;= nums[i] &amp;lt;= 10⁵ 进阶：</description>
    </item>
    <item>
      <title>2584.split the Array to Make Coprime Products</title>
      <link>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products/</link>
      <pubDate>Mon, 06 Mar 2023 18:56:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products/</guid>
      <description>Description 2584. Split the Array to Make Coprime Products (Hard)&#xA;You are given a 0-indexed integer array nums of length n.&#xA;A split at an index i where 0 &amp;lt;= i &amp;lt;= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.&#xA;For example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime.</description>
    </item>
    <item>
      <title>2584.分割数组使乘积互质 (Medium)</title>
      <link>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products.zh/</link>
      <pubDate>Mon, 06 Mar 2023 18:56:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2584.split-the-array-to-make-coprime-products.zh/</guid>
      <description>问题描述 2584. 分割数组使乘积互质 (Medium)&#xA;给你一个长度为 n 的整数数组 nums ，下标从 0 开始。&#xA;如果在下标 i 处 分割 数组，其中 0 &amp;lt;= i &amp;lt;= n - 2 ，使前 i + 1 个元素的乘积和剩余元素的乘积互质，则认为该分割 有效 。&#xA;例如，如果 nums = [2, 3, 3] ，那么在下标 i = 0 处的分割有效，因为 2 和 9 互质，而在下标 i = 1 处的分割无效，因为 6 和 3 不互质。在下标 i = 2 处的分割也无效，因为 i == n - 1 。 返回可以有效分割数组的最小下标 i ，如果不存在有效分割，则返回 -1 。&#xA;当且仅当 gcd(val1, val2) == 1 成立时， val1 和 val2 这两个值才是互质的，其中 gcd(val1, val2) 表示 val1 和 val2 的最大公约数。</description>
    </item>
    <item>
      <title>质因数分解</title>
      <link>http://localhost:1313/posts/tech/prime_factorization.zh/</link>
      <pubDate>Mon, 06 Mar 2023 14:32:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/prime_factorization.zh/</guid>
      <description>朴素算法 从$[2, \sqrt(N)]$进行遍历&#xA;vector&amp;lt;int&amp;gt; GetFactor(int N) { vector&amp;lt;int&amp;gt; res; for (int i = 2; i * i &amp;lt;= N; ++i) { if (N % i == 0) { while (N % i == 0) { N /= i; } res.push_back(i); } } if (N != 1) { res.push_back(N); } return res; } 朴素算法的证明 首先证明元素均为 $N$ 的素因数：因为当且仅当 N % i == 0 满足时，result 发生变化：储存 $i$，说明此时 $i$ 能整除 $\frac{N}{A}$，说明了存在一个数 $p$ 使得 $pi=\frac{N}{A}$，即 $piA = N$（其中，$A$ 为 $N$ 自身发生变化后遇到 $i$ 时所除的数。我们注意到 result 若在 push $i$ 之前就已经有数了，为 $R_1,,R_2,,\ldots,,R_n$，那么有 N $=\frac{N}{R_1^{q_1}\cdot R_2^{q_2}\cdot \cdots \cdot R_n^{q_n}}$，被除的乘积即为 $A$）。所以 $i$ 为 $N$ 的因子。</description>
    </item>
    <item>
      <title>1744.can You Eat Your Favorite Candy on Your Favorite Day</title>
      <link>http://localhost:1313/posts/leet/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/</link>
      <pubDate>Mon, 06 Mar 2023 14:10:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1744.can-you-eat-your-favorite-candy-on-your-favorite-day/</guid>
      <description>Description 1744. Can You Eat Your Favorite Candy on Your Favorite Day? (Medium)&#xA;You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. You are also given a 2D array queries where queries[i] = [favoriteTypeᵢ, favoriteDayᵢ, dailyCapᵢ].&#xA;You play a game with the following rules:&#xA;You start eating candies on day 0. You cannot eat any candy of type i unless you have eaten all candies of type i - 1.</description>
    </item>
    <item>
      <title>1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？ (Medium)</title>
      <link>http://localhost:1313/posts/leet/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/</link>
      <pubDate>Mon, 06 Mar 2023 14:10:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1744.can-you-eat-your-favorite-candy-on-your-favorite-day.zh/</guid>
      <description>问题描述 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ (Medium)&#xA;给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypeᵢ, favoriteDayᵢ, dailyCapᵢ] 。&#xA;你按照如下规则进行一场游戏：&#xA;你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前， 不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。 请你构建一个布尔型数组 answer ，用以给出 queries 中每一项的对应答案。此数组满足：&#xA;answer.length == queries.length 。 answer[i] 是 queries[i] 的答案。 answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapᵢ 颗糖果的前提下，你可以在第 favoriteDayᵢ 天吃到第 favoriteTypeᵢ 类糖果；否则 answer[i] 为 false 。 注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</description>
    </item>
    <item>
      <title>1653.minimum deletions to make string balanced</title>
      <link>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced/</link>
      <pubDate>Mon, 06 Mar 2023 10:36:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced/</guid>
      <description>Description 1653. Minimum Deletions to Make String Balanced (Medium)&#xA;You are given a string s consisting only of characters &#39;a&#39; and &#39;b&#39; .&#xA;You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i &amp;lt; j and s[i] = &#39;b&#39; and s[j]= &#39;a&#39;.&#xA;Return the minimum number of deletions needed to make sbalanced.&#xA;Example 1:</description>
    </item>
    <item>
      <title>1653.使字符串平衡的最少删除次数 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced.zh/</link>
      <pubDate>Mon, 06 Mar 2023 10:36:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1653.minimum-deletions-to-make-string-balanced.zh/</guid>
      <description>问题描述 1653. 使字符串平衡的最少删除次数 (Medium)&#xA;给你一个字符串 s ，它仅包含字符 &#39;a&#39; 和 &#39;b&#39; 。&#xA;你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i &amp;lt; j ，且 s[i] = &#39;b&#39; 的同时 s[j]= &#39;a&#39; ，此时认为 s 是 平衡 的。&#xA;请你返回使 s 平衡 的 最少 删除次数。&#xA;示例 1：&#xA;输入：s = &amp;#34;aababbab&amp;#34; 输出：2 解释：你可以选择以下任意一种方案： 下标从 0 开始，删除第 2 和第 6 个字符（&amp;#34;aababbab&amp;#34; -&amp;gt; &amp;#34;aaabbb&amp;#34;）， 下标从 0 开始，删除第 3 和第 6 个字符（&amp;#34;aababbab&amp;#34; -&amp;gt; &amp;#34;aabbbb&amp;#34;）。 示例 2：&#xA;输入：s = &amp;#34;bbaaaaabb&amp;#34; 输出：2 解释：唯一的最优解是删除最前面两个字符。 提示：</description>
    </item>
    <item>
      <title>154.find Minimum in Rotated Sorted Array Ii</title>
      <link>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii/</link>
      <pubDate>Sat, 04 Mar 2023 15:57:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii/</guid>
      <description></description>
    </item>
    <item>
      <title>154.寻找旋转排序数组中的最小值 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii.zh/</link>
      <pubDate>Sat, 04 Mar 2023 15:57:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/154.find-minimum-in-rotated-sorted-array-ii.zh/</guid>
      <description>问题描述 154. 寻找旋转排序数组中的最小值 II (Hard)&#xA;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：&#xA;若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。&#xA;给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。&#xA;你必须尽可能减少整个过程的操作步骤。&#xA;示例 1：&#xA;输入：nums = [1,3,5] 输出：1 示例 2：&#xA;输入：nums = [2,2,2,0,1] 输出：0 提示：&#xA;n == nums.length 1 &amp;lt;= n &amp;lt;= 5000 -5000 &amp;lt;= nums[i] &amp;lt;= 5000 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶： 这道题与 寻找旋转排序数组中的最小值 类似，但 nums 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</description>
    </item>
    <item>
      <title>153.Find Minimum in Rotated Sorted Array (Medium)</title>
      <link>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array/</link>
      <pubDate>Sat, 04 Mar 2023 15:26:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array/</guid>
      <description>Description 153. Find Minimum in Rotated Sorted Array (Medium)&#xA;Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].</description>
    </item>
    <item>
      <title>153.寻找旋转排序数组中的最小值 (Medium)</title>
      <link>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array.zh/</link>
      <pubDate>Sat, 04 Mar 2023 15:26:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/153.find-minimum-in-rotated-sorted-array.zh/</guid>
      <description>问题描述 153. 寻找旋转排序数组中的最小值 (Medium)&#xA;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：&#xA;若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。&#xA;给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。&#xA;你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。&#xA;示例 1：&#xA;输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2：&#xA;输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3：</description>
    </item>
    <item>
      <title>982.Triples with Bitwise AND Equal To Zero (Hard)</title>
      <link>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero/</link>
      <pubDate>Sat, 04 Mar 2023 14:43:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero/</guid>
      <description>Description 982. Triples with Bitwise AND Equal To Zero (Hard)&#xA;Given an integer array nums, return the number of AND triples.&#xA;An AND triple is a triple of indices (i, j, k) such that:&#xA;0 &amp;lt;= i &amp;lt; nums.length 0 &amp;lt;= j &amp;lt; nums.length 0 &amp;lt;= k &amp;lt; nums.length nums[i] &amp;amp; nums[j] &amp;amp; nums[k] == 0, where &amp;amp; represents the bitwise-AND operator. Example 1:&#xA;Input: nums = [2,1,3] Output: 12 Explanation: We could choose the following i, j, k triples: (i=0, j=0, k=1) : 2 &amp;amp; 2 &amp;amp; 1 (i=0, j=1, k=0) : 2 &amp;amp; 1 &amp;amp; 2 (i=0, j=1, k=1) : 2 &amp;amp; 1 &amp;amp; 1 (i=0, j=1, k=2) : 2 &amp;amp; 1 &amp;amp; 3 (i=0, j=2, k=1) : 2 &amp;amp; 3 &amp;amp; 1 (i=1, j=0, k=0) : 1 &amp;amp; 2 &amp;amp; 2 (i=1, j=0, k=1) : 1 &amp;amp; 2 &amp;amp; 1 (i=1, j=0, k=2) : 1 &amp;amp; 2 &amp;amp; 3 (i=1, j=1, k=0) : 1 &amp;amp; 1 &amp;amp; 2 (i=1, j=2, k=0) : 1 &amp;amp; 3 &amp;amp; 2 (i=2, j=0, k=1) : 3 &amp;amp; 2 &amp;amp; 1 (i=2, j=1, k=0) : 3 &amp;amp; 1 &amp;amp; 2 Example 2:</description>
    </item>
    <item>
      <title>982.按位与为零的三元组 (Hard)</title>
      <link>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero.zh/</link>
      <pubDate>Sat, 04 Mar 2023 14:41:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/982.triples-with-bitwise-and-equal-to-zero.zh/</guid>
      <description>问题描述 982. 按位与为零的三元组 (Hard)&#xA;给你一个整数数组 nums ，返回其中 按位与三元组 的数目。&#xA;按位与三元组 是由下标 (i, j, k) 组成的三元组，并满足下述全部条件：&#xA;0 &amp;lt;= i &amp;lt; nums.length 0 &amp;lt;= j &amp;lt; nums.length 0 &amp;lt;= k &amp;lt; nums.length nums[i] &amp;amp; nums[j] &amp;amp; nums[k] == 0 ，其中 &amp;amp; 表示按位与运算符。 示例 1：&#xA;输入：nums = [2,1,3] 输出：12 解释：可以选出如下 i, j, k 三元组： (i=0, j=0, k=1) : 2 &amp;amp; 2 &amp;amp; 1 (i=0, j=1, k=0) : 2 &amp;amp; 1 &amp;amp; 2 (i=0, j=1, k=1) : 2 &amp;amp; 1 &amp;amp; 1 (i=0, j=1, k=2) : 2 &amp;amp; 1 &amp;amp; 3 (i=0, j=2, k=1) : 2 &amp;amp; 3 &amp;amp; 1 (i=1, j=0, k=0) : 1 &amp;amp; 2 &amp;amp; 2 (i=1, j=0, k=1) : 1 &amp;amp; 2 &amp;amp; 1 (i=1, j=0, k=2) : 1 &amp;amp; 2 &amp;amp; 3 (i=1, j=1, k=0) : 1 &amp;amp; 1 &amp;amp; 2 (i=1, j=2, k=0) : 1 &amp;amp; 3 &amp;amp; 2 (i=2, j=0, k=1) : 3 &amp;amp; 2 &amp;amp; 1 (i=2, j=1, k=0) : 3 &amp;amp; 1 &amp;amp; 2 示例 2：</description>
    </item>
    <item>
      <title>1223.Dice Roll Simulation (Hard)</title>
      <link>http://localhost:1313/posts/leet/1223.dice-roll-simulation/</link>
      <pubDate>Fri, 03 Mar 2023 16:46:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1223.dice-roll-simulation/</guid>
      <description>Description 1223. Dice Roll Simulation (Hard)&#xA;A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] ( 1-indexed) consecutive times.&#xA;Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 10⁹ + 7.</description>
    </item>
    <item>
      <title>1223.掷骰子模拟 (Hard)</title>
      <link>http://localhost:1313/posts/leet/1223.dice-roll-simulation.zh/</link>
      <pubDate>Fri, 03 Mar 2023 16:46:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1223.dice-roll-simulation.zh/</guid>
      <description>问题描述 1223. 掷骰子模拟 (Hard)&#xA;有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。&#xA;不过我们在使用它时有个约束，就是使得投掷骰子时， 连续 掷出数字 i 的次数不能超过 rollMax[i]（ i 从 1 开始编号）。&#xA;现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。&#xA;假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。&#xA;示例 1：&#xA;输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。 示例 2：&#xA;输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30 示例 3：</description>
    </item>
    <item>
      <title>552.Student Attendance Record II (Hard)</title>
      <link>http://localhost:1313/posts/leet/552.student-attendance-record-ii/</link>
      <pubDate>Fri, 03 Mar 2023 14:58:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/552.student-attendance-record-ii/</guid>
      <description>Description 552. Student Attendance Record II (Hard)&#xA;An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:&#xA;&#39;A&#39;: Absent. &#39;L&#39;: Late. &#39;P&#39;: Present. Any student is eligible for an attendance award if they meet both of the following criteria:&#xA;The student was absent ( &#39;A&#39;) for strictly fewer than 2 days total.</description>
    </item>
    <item>
      <title>552.学生出勤记录 II (Hard)</title>
      <link>http://localhost:1313/posts/leet/552.student-attendance-record-ii.zh/</link>
      <pubDate>Fri, 03 Mar 2023 14:58:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/552.student-attendance-record-ii.zh/</guid>
      <description>问题描述 552. 学生出勤记录 II (Hard)&#xA;可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：&#xA;&#39;A&#39;：Absent，缺勤 &#39;L&#39;：Late，迟到 &#39;P&#39;：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：&#xA;按 总出勤 计，学生缺勤（ &#39;A&#39;） 严格 少于两天。 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（ &#39;L&#39;）记录。 给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 10⁹ + 7 取余 的结果。&#xA;示例 1：&#xA;输入：n = 2 输出：8 解释： 有 8 种长度为 2 的记录将被视为可奖励： &amp;#34;PP&amp;#34; , &amp;#34;AP&amp;#34;, &amp;#34;PA&amp;#34;, &amp;#34;LP&amp;#34;, &amp;#34;PL&amp;#34;, &amp;#34;AL&amp;#34;, &amp;#34;LA&amp;#34;, &amp;#34;LL&amp;#34; 只有&amp;#34;AA&amp;#34;不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。 示例 2：&#xA;输入：n = 1 输出：3 示例 3：</description>
    </item>
    <item>
      <title>N Th Tribonacci Number</title>
      <link>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number/</link>
      <pubDate>Fri, 03 Mar 2023 10:03:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number/</guid>
      <description>Description 1137. N-th Tribonacci Number (Easy)&#xA;The Tribonacci sequence T is defined as follows:&#xA;T = 0, T = 1, T = 1, and T = T + T + T for n &amp;gt;= 0.&#xA;Given n, return the value of T.&#xA;Example 1:&#xA;Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2:</description>
    </item>
    <item>
      <title>第 N 个泰波那契数 (Easy)</title>
      <link>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number.zh/</link>
      <pubDate>Fri, 03 Mar 2023 10:03:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1137.n-th-tribonacci-number.zh/</guid>
      <description>问题描述 1137. 第 N 个泰波那契数 (Easy)&#xA;泰波那契序列 T 定义如下：&#xA;T = 0, T = 1, T = 1, 且在 n &amp;gt;= 0 的条件下 T = T + T + T&#xA;给你整数 n，请返回第 n 个泰波那契数 T的值。&#xA;示例 1：&#xA;输入：n = 4 输出：4 解释： T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 示例 2：&#xA;输入：n = 25 输出：1389537 提示：&#xA;0 &amp;lt;= n &amp;lt;= 37 答案保证是一个 32 位整数，即 answer &amp;lt;= 2^31 - 1。 解题思路 非常简单的动态规划</description>
    </item>
    <item>
      <title>1487.Making File Names Unique (Medium)</title>
      <link>http://localhost:1313/posts/leet/1487.making-file-names-unique/</link>
      <pubDate>Fri, 03 Mar 2023 09:40:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1487.making-file-names-unique/</guid>
      <description>Description 1487. Making File Names Unique (Medium)&#xA;Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].&#xA;Since two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.</description>
    </item>
    <item>
      <title>1487.保证文件名唯一 (Medium)</title>
      <link>http://localhost:1313/posts/leet/1487.making-file-names-unique.zh/</link>
      <pubDate>Fri, 03 Mar 2023 09:40:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1487.making-file-names-unique.zh/</guid>
      <description>问题描述 1487. 保证文件名唯一 (Medium)&#xA;给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。&#xA;由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。&#xA;返回长度为n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。&#xA;示例 1：&#xA;输入：names = [&amp;#34;pes&amp;#34;,&amp;#34;fifa&amp;#34;,&amp;#34;gta&amp;#34;,&amp;#34;pes(2019)&amp;#34;] 输出：[&amp;#34;pes&amp;#34;,&amp;#34;fifa&amp;#34;,&amp;#34;gta&amp;#34;,&amp;#34;pes(2019)&amp;#34;] 解释：文件系统将会这样创建文件名： &amp;#34;pes&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;pes&amp;#34; &amp;#34;fifa&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;fifa&amp;#34; &amp;#34;gta&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;gta&amp;#34; &amp;#34;pes(2019)&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;pes(2019)&amp;#34; 示例 2：&#xA;输入：names = [&amp;#34;gta&amp;#34;,&amp;#34;gta(1)&amp;#34;,&amp;#34;gta&amp;#34;,&amp;#34;avalon&amp;#34;] 输出：[&amp;#34;gta&amp;#34;,&amp;#34;gta(1)&amp;#34;,&amp;#34;gta(2)&amp;#34;,&amp;#34;avalon&amp;#34;] 解释：文件系统将会这样创建文件名： &amp;#34;gta&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;gta&amp;#34; &amp;#34;gta(1)&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;gta(1)&amp;#34; &amp;#34;gta&amp;#34; --&amp;gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &amp;#34;gta(1)&amp;#34; 也被占用，所以 k = 2 。实际创建的文件名为 &amp;#34;gta(2)&amp;#34; 。 &amp;#34;avalon&amp;#34; --&amp;gt; 之前未分配，仍为 &amp;#34;avalon&amp;#34; 示例 3：</description>
    </item>
    <item>
      <title>464.Can I Win (Medium)</title>
      <link>http://localhost:1313/posts/leet/464.can-i-win/</link>
      <pubDate>Thu, 02 Mar 2023 17:55:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/464.can-i-win/</guid>
      <description>Description 464. Can I Win (Medium)&#xA;In the &amp;ldquo;100 game&amp;rdquo; two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.&#xA;What if we change the game so that players cannot re-use integers?&#xA;For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &amp;gt;= 100.</description>
    </item>
    <item>
      <title>464.我能赢吗 (Medium)</title>
      <link>http://localhost:1313/posts/leet/464.can-i-win.zh/</link>
      <pubDate>Thu, 02 Mar 2023 16:56:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/464.can-i-win.zh/</guid>
      <description>问题描述 464. 我能赢吗 (Medium)&#xA;在 &amp;ldquo;100 game&amp;rdquo; 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过 100 的玩家，即为胜者。&#xA;如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？&#xA;例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &amp;gt;= 100。&#xA;给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。&#xA;示例 1：&#xA;输入：maxChoosableInteger = 10, desiredTotal = 11 输出：false 解释： 无论第一个玩家选择哪个整数，他都会失败。 第一个玩家可以选择从 1 到 10 的整数。 如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。 第二个玩家可以通过选择整数 10（那么累积和为 11 &amp;gt;= desiredTotal），从而取得胜利. 同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。 示例 2:&#xA;输入：maxChoosableInteger = 10, desiredTotal = 0 输出：true 示例 3:</description>
    </item>
    <item>
      <title>2373.largest local values in a matrix</title>
      <link>http://localhost:1313/posts/leet/2373.largest-local-values-in-a-matrix/</link>
      <pubDate>Wed, 01 Mar 2023 19:44:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2373.largest-local-values-in-a-matrix/</guid>
      <description>Description Largest Local Values in a Matrix (Easy) You are given an n x n integer matrix grid.&#xA;Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:&#xA;maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1. In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.</description>
    </item>
    <item>
      <title>2373.矩阵中的局部最大值</title>
      <link>http://localhost:1313/posts/leet/2373.largest-local-values-in-a-matrix.zh/</link>
      <pubDate>Wed, 01 Mar 2023 19:44:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2373.largest-local-values-in-a-matrix.zh/</guid>
      <description>问题描述 2373. 矩阵中的局部最大值 (Easy)&#xA;给你一个大小为 n x n 的整数矩阵 grid 。&#xA;生成一个大小为 (n - 2) x (n - 2) 的整数矩阵 maxLocal ，并满足：&#xA;maxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。 换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。&#xA;返回生成的矩阵。&#xA;示例 1：&#xA;输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] 输出：[[9,9],[8,6]] 解释：原矩阵和生成的矩阵如上图所示。 注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。 示例 2：&#xA;输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] 输出：[[2,2,2],[2,2,2],[2,2,2]] 解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。 提示：</description>
    </item>
    <item>
      <title>1405.longest happy string</title>
      <link>http://localhost:1313/posts/leet/1405.longest-happy-string/</link>
      <pubDate>Wed, 01 Mar 2023 19:29:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1405.longest-happy-string/</guid>
      <description>Description 1405. Longest Happy String (Medium)&#xA;A string s is called happy if it satisfies the following conditions:&#xA;s only contains the letters &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;. s does not contain any of &amp;quot;aaa&amp;quot;, &amp;quot;bbb&amp;quot;, or &amp;quot;ccc&amp;quot; as a substring. s contains at most a occurrences of the letter &#39;a&#39;. s contains at most b occurrences of the letter &#39;b&#39;. s contains at most c occurrences of the letter &#39;c&#39;. Given three integers a, b, and c, return the longest possible happy string.</description>
    </item>
    <item>
      <title>1405.最长快乐字符串</title>
      <link>http://localhost:1313/posts/leet/1405.longest-happy-string.zh/</link>
      <pubDate>Wed, 01 Mar 2023 19:29:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1405.longest-happy-string.zh/</guid>
      <description>问题描述 1405. 最长快乐字符串 (Medium)&#xA;如果字符串中不含有任何 &#39;aaa&#39;， &#39;bbb&#39; 或 &#39;ccc&#39; 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。&#xA;给你三个整数 a， b ， c，请你返回 任意一个 满足下列全部条件的字符串 s：&#xA;s 是一个尽可能长的快乐字符串。 s 中 最多 有 a 个字母 &#39;a&#39;、 b 个字母 &#39;b&#39;、 c 个字母 &#39;c&#39; 。 s 中只含有 &#39;a&#39;、 &#39;b&#39; 、 &#39;c&#39; 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串 &amp;quot;&amp;quot;。&#xA;示例 1：&#xA;输入：a = 1, b = 1, c = 7 输出：&amp;#34;ccaccbcc&amp;#34; 解释：&amp;#34;ccbccacc&amp;#34; 也是一种正确答案。 示例 2：&#xA;输入：a = 2, b = 2, c = 1 输出：&amp;#34;aabbc&amp;#34; 示例 3：</description>
    </item>
    <item>
      <title>Leetcode 常见报错的原因分析</title>
      <link>http://localhost:1313/posts/tech/leetcode_error.zh/</link>
      <pubDate>Wed, 01 Mar 2023 19:02:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/leetcode_error.zh/</guid>
      <description>问题1 问题描述 Line 522: Char 69: runtime error: applying non-zero offset 18446744073709551615 to null pointer (basic_string.h)&#xA;报错原因 string res = 0&#xA;报错分析 这里报错的原因是因为使用了int整型变量来初始化string。&#xA;AddressSanitizer: stack-overflow 栈溢出，通常是由于使用了缺少终止条件的递归调用。</description>
    </item>
    <item>
      <title>403.frog jump</title>
      <link>http://localhost:1313/posts/leet/403.frog-jump/</link>
      <pubDate>Wed, 01 Mar 2023 15:08:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/403.frog-jump/</guid>
      <description>Description 403. Frog Jump (Hard)&#xA;A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.&#xA;Given a list of stones&amp;rsquo; positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone.</description>
    </item>
    <item>
      <title>403.青蛙过河</title>
      <link>http://localhost:1313/posts/leet/403.frog-jump.zh/</link>
      <pubDate>Wed, 01 Mar 2023 15:08:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/403.frog-jump.zh/</guid>
      <description>问题描述 403. 青蛙过河 (Hard)&#xA;一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。&#xA;给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。&#xA;如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、 k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。&#xA;示例 1：&#xA;输入：stones = [0,1,3,5,6,8,12,17] 输出：true 解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。 示例 2：</description>
    </item>
    <item>
      <title>524.longest word in dictionary through deleting</title>
      <link>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting/</link>
      <pubDate>Tue, 28 Feb 2023 16:26:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting/</guid>
      <description>Description 524. Longest Word in Dictionary through Deleting (Medium)&#xA;Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.&#xA;Example 1:&#xA;Input: s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] Output: &amp;#34;apple&amp;#34; Example 2:</description>
    </item>
    <item>
      <title>524.通过删除字母匹配到字典里最长单词</title>
      <link>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting.zh/</link>
      <pubDate>Tue, 28 Feb 2023 16:26:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/524.longest-word-in-dictionary-through-deleting.zh/</guid>
      <description>问题描述 524. 通过删除字母匹配到字典里最长单词 (Medium)&#xA;给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。&#xA;如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。&#xA;示例 1：&#xA;输入：s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;ale&amp;#34;,&amp;#34;apple&amp;#34;,&amp;#34;monkey&amp;#34;,&amp;#34;plea&amp;#34;] 输出：&amp;#34;apple&amp;#34; 示例 2：&#xA;输入：s = &amp;#34;abpcplea&amp;#34;, dictionary = [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 输出：&amp;#34;a&amp;#34; 提示：&#xA;1 &amp;lt;= s.length &amp;lt;= 1000 1 &amp;lt;= dictionary.length &amp;lt;= 1000 1 &amp;lt;= dictionary[i].length &amp;lt;= 1000 s 和 dictionary[i] 仅由小写英文字母组成 解题思路 首先将dictionary按长度从大到小排序，相同长度的字符串，字典序小的在前面；&#xA;判断dictionary中的字符串是否能通过删除s中的某些字符得到可以利用双指针优化时间复杂度为$O(n)$，n为s的长度。&#xA;代码 class Solution { public: bool IsSub(string &amp;amp;s, string &amp;amp;word) { for (int i = 0, j = 0; j &amp;lt; word.</description>
    </item>
    <item>
      <title>179.largest number</title>
      <link>http://localhost:1313/posts/leet/179.largest-number/</link>
      <pubDate>Tue, 28 Feb 2023 10:14:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/179.largest-number/</guid>
      <description>Description 179. Largest Number (Medium)&#xA;Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.&#xA;Since the result may be very large, so you need to return a string instead of an integer.&#xA;Example 1:&#xA;Input: nums = [10,2] Output: &amp;#34;210&amp;#34; Example 2:&#xA;Input: nums = [3,30,34,5,9] Output: &amp;#34;9534330&amp;#34; Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ Solution First, we change the vector&amp;lt;int&amp;gt; to vector&amp;lt;string&amp;gt;.</description>
    </item>
    <item>
      <title>179.最大数</title>
      <link>http://localhost:1313/posts/leet/179.largest-number.zh/</link>
      <pubDate>Tue, 28 Feb 2023 10:13:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/179.largest-number.zh/</guid>
      <description>问题描述 179. 最大数 (Medium)&#xA;给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。&#xA;注意： 输出结果可能非常大，所以你需要返回一个字符串而不是整数。&#xA;示例 1：&#xA;输入：nums = [10,2] 输出：&amp;#34;210&amp;#34; 示例 2：&#xA;输入：nums = [3,30,34,5,9] 输出：&amp;#34;9534330&amp;#34; 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 10⁹ 解题思路 贪心，将数组转化为字符串数组，然后如果s1 + s2 &amp;gt;= s2 + s1，那么就保证s1一定在s2的前面，利用该规则自定义排序，同时要注意对数组中元素全为0的特殊条件的判断。&#xA;代码 class Solution { public: string largestNumber(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { if (nums[i] != 0) { sum += nums[i]; break; } } // 对数组元素全为0的特殊情况的判断 if (sum == 0) { return &amp;#34;0&amp;#34;; } vector&amp;lt;string&amp;gt; tmp; for (int &amp;amp;num : nums) { tmp.</description>
    </item>
    <item>
      <title>2363.merge similar items</title>
      <link>http://localhost:1313/posts/leet/2363.merge-similar-items/</link>
      <pubDate>Tue, 28 Feb 2023 09:22:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2363.merge-similar-items/</guid>
      <description>Description 2363. Merge Similar Items (Easy)&#xA;You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:&#xA;items[i] = [valueᵢ, weightᵢ] where valueᵢ represents the value and weightᵢ represents the weight of the ith item. The value of each item in items is unique. Return a 2D integer array retwhere ret[i] = [valueᵢ, weightᵢ],with weightᵢbeing the sum of weights of all items with value valueᵢ.</description>
    </item>
    <item>
      <title>2363.合并相似的物品</title>
      <link>http://localhost:1313/posts/leet/2363.merge-similar-items.zh/</link>
      <pubDate>Tue, 28 Feb 2023 09:22:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2363.merge-similar-items.zh/</guid>
      <description>问题描述 2363. 合并相似的物品 (Easy)&#xA;给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质：&#xA;items[i] = [valueᵢ, weightᵢ] 其中 valueᵢ 表示第 i 件物品的 价值 ， weightᵢ 表示第 i 件物品的 重量 。 items 中每件物品的价值都是 唯一的 。 请你返回一个二维数组 ret，其中 ret[i] = [valueᵢ, weightᵢ]， weightᵢ 是所有价值为 valueᵢ 物品的 重量之和 。&#xA;注意： ret 应该按价值 升序 排序后返回。&#xA;示例 1：&#xA;输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] 输出：[[1,6],[3,9],[4,5]] 解释： value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。 value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。 value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。 所以，我们返回 [[1,6],[3,9],[4,5]] 。 示例 2：</description>
    </item>
    <item>
      <title>765.couples holding hands</title>
      <link>http://localhost:1313/posts/leet/765.couples-holding-hands/</link>
      <pubDate>Mon, 27 Feb 2023 16:39:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/765.couples-holding-hands/</guid>
      <description>Description 765. Couples Holding Hands (Hard)&#xA;There are n couples sitting in 2n seats arranged in a row and want to hold hands.&#xA;The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).</description>
    </item>
    <item>
      <title>765.情侣牵手</title>
      <link>http://localhost:1313/posts/leet/765.couples-holding-hands.zh/</link>
      <pubDate>Mon, 27 Feb 2023 16:39:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/765.couples-holding-hands.zh/</guid>
      <description>问题描述 765. 情侣牵手 (Hard)&#xA;n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。&#xA;人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。&#xA;返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次 交换可选择任意两人，让他们站起来交换座位。&#xA;示例 1:&#xA;输入: row = [0,2,1,3] 输出: 1 解释: 只需要交换row[1]和row[2]的位置即可。 示例 2:&#xA;输入: row = [3,2,0,1] 输出: 0 解释: 无需交换座位，所有的情侣都已经可以手牵手了。 提示:&#xA;2n == row.length 2 &amp;lt;= n &amp;lt;= 30 n 是偶数 0 &amp;lt;= row[i] &amp;lt; 2n row 中所有元素均 无重复 解题思路 我们只需要遍历i = 0, 2, 4, 6, .</description>
    </item>
    <item>
      <title>1140.stone game ii</title>
      <link>http://localhost:1313/posts/leet/1140.stone-game-ii/</link>
      <pubDate>Mon, 27 Feb 2023 16:02:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1140.stone-game-ii/</guid>
      <description>Description 1140. Stone Game II (Medium)&#xA;Alice and Bob continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones.&#xA;Alice and Bob take turns, with Alice starting first. Initially, M = 1.&#xA;On each player&amp;rsquo;s turn, that player can take all the stones in the first X remaining piles, where 1 &amp;lt;= X &amp;lt;= 2M.</description>
    </item>
    <item>
      <title>1140.石子游戏 II</title>
      <link>http://localhost:1313/posts/leet/1140.stone-game-ii.zh/</link>
      <pubDate>Mon, 27 Feb 2023 16:01:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1140.stone-game-ii.zh/</guid>
      <description>问题描述 1140. 石子游戏 II (Medium)&#xA;爱丽丝和鲍勃继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。&#xA;爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初， M = 1。&#xA;在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 &amp;lt;= X &amp;lt;= 2M。然后，令 M = max(M, X)。&#xA;游戏一直持续到所有石子都被拿走。&#xA;假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。&#xA;示例 1：&#xA;输入：piles = [2,7,9,4,4] 输出：10 解释：如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。 示例 2:&#xA;输入：piles = [1,2,3,4,5,100] 输出：104 提示：&#xA;1 &amp;lt;= piles.length &amp;lt;= 100 1 &amp;lt;= piles[i] &amp;lt;= 10⁴ 解题思路 首先这里要明确发挥最佳水平的含义： 如果自己拿了前x块石子之后，对方所能拿到的石子最少，这就是博弈中的发挥最佳水平，对应到dfs，明白了这一点就能写出递归和记忆化搜索，注意这里还需要用到后缀数组。&#xA;写出记忆化搜索之后可以改写成动态规划。&#xA;代码 记忆化搜索 class Solution { public: int dfs(int idx_start, int M, vector&amp;lt;int&amp;gt; &amp;amp;postfix, int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;cach) { if (idx_start &amp;gt;= n) return 0; int minnum = 100001; if (cach[idx_start][M] &amp;gt;= 0) { return cach[idx_start][M]; } for (int i = idx_start + 1; i &amp;lt;= idx_start + 2 * M &amp;amp;&amp;amp; i &amp;lt;= n; i++) { // i表示下一个人拿石子的开始位置，所以i至少为idx_start+1 int tmp = dfs(i, std::max(i - idx_start, M), postfix, n, cach); if (minnum &amp;gt; tmp) { minnum = tmp; } } cach[idx_start][M] = postfix[idx_start] - minnum; return cach[idx_start][M]; } int stoneGameII(vector&amp;lt;int&amp;gt;&amp;amp; piles) { int n = piles.</description>
    </item>
    <item>
      <title>1255.maximum score words formed by letters</title>
      <link>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters/</link>
      <pubDate>Mon, 27 Feb 2023 15:53:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters/</guid>
      <description>Description 1255. Maximum Score Words Formed by Letters (Hard)&#xA;Given a list of words, list of single letters (might be repeating) and score of every character.&#xA;Return the maximum score of any valid set of words formed by using the given letters ( words[i] cannot be used two or more times).&#xA;It is not necessary to use all characters in letters and each letter can only be used once. Score of letters &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &amp;hellip; , &#39;z&#39; is given by score[0], score[1], &amp;hellip; , score[25] respectively.</description>
    </item>
    <item>
      <title>1255.得分最高的单词集合</title>
      <link>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters.zh/</link>
      <pubDate>Mon, 27 Feb 2023 15:53:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1255.maximum-score-words-formed-by-letters.zh/</guid>
      <description>问题描述 1255. 得分最高的单词集合 (Hard)&#xA;你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。&#xA;请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。&#xA;单词拼写游戏的规则概述如下：&#xA;玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。 可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。 单词表 words 中每个单词只能计分（使用）一次。 根据字母得分情况表 score，字母 &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &amp;hellip; , &#39;z&#39; 对应的得分分别为 score[0], score[1], &amp;hellip;, score[25]。 本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。 示例 1：&#xA;输入：words = [&amp;#34;dog&amp;#34;,&amp;#34;cat&amp;#34;,&amp;#34;dad&amp;#34;,&amp;#34;good&amp;#34;], letters = [&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;c&amp;#34;,&amp;#34;d&amp;#34;,&amp;#34;d&amp;#34;,&amp;#34;d&amp;#34;,&amp;#34;g&amp;#34;,&amp;#34;o&amp;#34;,&amp;#34;o&amp;#34;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] 输出：23 解释： 字母得分为 a=1, c=9, d=5, g=3, o=2 使用给定的字母表 letters，我们可以拼写单词 &amp;#34;dad&amp;#34; (5+1+5)和 &amp;#34;good&amp;#34; (3+2+2+5)，得分为 23 。 而单词 &amp;#34;dad&amp;#34; 和 &amp;#34;dog&amp;#34; 只能得到 21 分。 示例 2：</description>
    </item>
    <item>
      <title>2170.minimum operations to make the array alternating</title>
      <link>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating/</link>
      <pubDate>Mon, 27 Feb 2023 15:38:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating/</guid>
      <description>Description 2170. Minimum Operations to Make the Array Alternating (Medium)&#xA;You are given a 0-indexed array nums consisting of n positive integers.&#xA;The array nums is called alternating if:&#xA;nums[i - 2] == nums[i], where 2 &amp;lt;= i &amp;lt;= n - 1. nums[i - 1] != nums[i], where 1 &amp;lt;= i &amp;lt;= n - 1. In one operation, you can choose an index i and change nums[i] into any positive integer.</description>
    </item>
    <item>
      <title>2170.使数组变成交替数组的最少操作数</title>
      <link>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating.zh/</link>
      <pubDate>Mon, 27 Feb 2023 15:38:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2170.minimum-operations-to-make-the-array-alternating.zh/</guid>
      <description>问题描述 2170. 使数组变成交替数组的最少操作数 (Medium)&#xA;给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。&#xA;如果满足下述条件，则数组 nums 是一个 交替数组 ：&#xA;nums[i - 2] == nums[i] ，其中 2 &amp;lt;= i &amp;lt;= n - 1 。 nums[i - 1] != nums[i] ，其中 1 &amp;lt;= i &amp;lt;= n - 1 。 在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。&#xA;返回使数组变成交替数组的 最少操作数 。&#xA;示例 1：&#xA;输入：nums = [3,1,3,2,4,3] 输出：3 解释： 使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。 在这种情况下，操作数为 3 。 可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。 示例 2：</description>
    </item>
    <item>
      <title>1144.decrease elements to make array zigzag</title>
      <link>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag/</link>
      <pubDate>Mon, 27 Feb 2023 15:28:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag/</guid>
      <description>Description 1144. Decrease Elements To Make Array Zigzag (Medium)&#xA;Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.&#xA;An array A is a zigzag array if either:&#xA;Every even-indexed element is greater than adjacent elements, ie. A[0] &amp;gt; A[1] &amp;lt; A[2] &amp;gt; A[3] &amp;lt; A[4] &amp;gt; ... OR, every odd-indexed element is greater than adjacent elements, ie. A[0] &amp;lt; A[1] &amp;gt; A[2] &amp;lt; A[3] &amp;gt; A[4] &amp;lt; .</description>
    </item>
    <item>
      <title>1144.递减元素使数组呈锯齿状</title>
      <link>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag.zh/</link>
      <pubDate>Mon, 27 Feb 2023 15:28:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1144.decrease-elements-to-make-array-zigzag.zh/</guid>
      <description>问题描述 1144. 递减元素使数组呈锯齿状 (Medium)&#xA;给你一个整数数组 nums，每次 操作 会从中选择一个元素并 将该元素的值减少 1。&#xA;如果符合下列情况之一，则数组 A 就是 锯齿数组：&#xA;每个偶数索引对应的元素都大于相邻的元素，即 A[0] &amp;gt; A[1] &amp;lt; A[2] &amp;gt; A[3] &amp;lt; A[4] &amp;gt; ... 或者，每个奇数索引对应的元素都大于相邻的元素，即 A[0] &amp;lt; A[1] &amp;gt; A[2] &amp;lt; A[3] &amp;gt; A[4] &amp;lt; ... 返回将数组 nums 转换为锯齿数组所需的最小操作次数。&#xA;示例 1：&#xA;输入：nums = [1,2,3] 输出：2 解释：我们可以把 2 递减到 0，或把 3 递减到 1。 示例 2：&#xA;输入：nums = [9,6,1,6,2] 输出：4 提示：&#xA;1 &amp;lt;= nums.length &amp;lt;= 1000 1 &amp;lt;= nums[i] &amp;lt;= 1000 解题思路 首先要注意本题只允许递减数字，只需要考虑分别考虑偶数索引满足情况和奇数索引满足情况的情况，模拟即可。</description>
    </item>
    <item>
      <title>881.boats to save people</title>
      <link>http://localhost:1313/posts/leet/881.boats-to-save-people/</link>
      <pubDate>Sat, 25 Feb 2023 10:24:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/881.boats-to-save-people/</guid>
      <description>Description 881. Boats to Save People (Medium)&#xA;You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.&#xA;Return the minimum number of boats to carry every given person.</description>
    </item>
    <item>
      <title>881.救生艇</title>
      <link>http://localhost:1313/posts/leet/881.boats-to-save-people.zh/</link>
      <pubDate>Sat, 25 Feb 2023 10:23:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/881.boats-to-save-people.zh/</guid>
      <description>问题描述 881. 救生艇 (Medium)&#xA;给定数组 people 。 people[i] 表示第 i 个人的体重 ， 船的数量不限，每艘船可以承载的最大重量为 limit。&#xA;每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。&#xA;返回 承载所有人所需的最小船数 。&#xA;示例 1：&#xA;输入：people = [1,2], limit = 3 输出：1 解释：1 艘船载 (1, 2) 示例 2：&#xA;输入：people = [3,2,2,1], limit = 3 输出：3 解释：3 艘船分别载 (1, 2), (2) 和 (3) 示例 3：&#xA;输入：people = [3,5,3,4], limit = 5 输出：4 解释：4 艘船分别载 (3), (3), (4), (5) 提示：&#xA;1 &amp;lt;= people.length &amp;lt;= 5 * 10⁴ 1 &amp;lt;= people[i] &amp;lt;= limit &amp;lt;= 3 * 10⁴ 解题思路 每次必定选择最轻的的和二者重量和不超过limit的最重的人上船，因此可以将数组排序，然后一左一右双指针向中间遍历。</description>
    </item>
    <item>
      <title>1247.minimum swaps to make strings.equal</title>
      <link>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal/</link>
      <pubDate>Sat, 25 Feb 2023 10:11:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal/</guid>
      <description>Description 1247. Minimum Swaps to Make Strings Equal (Medium)&#xA;You are given two strings s1 and s2 of equal length consisting of letters &amp;quot;x&amp;quot; and &amp;quot;y&amp;quot; only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].&#xA;Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.</description>
    </item>
    <item>
      <title>1247.交换字符使得字符串相同</title>
      <link>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal.zh/</link>
      <pubDate>Sat, 25 Feb 2023 10:01:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1247.minimum-swaps-to-make-strings-equal.zh/</guid>
      <description>问题描述 1247. 交换字符使得字符串相同 (Medium)&#xA;有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 &amp;quot;x&amp;quot; 和 &amp;quot;y&amp;quot;，你需要通过「交换字符」的方式使这两个字符串相同。&#xA;每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。&#xA;交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。&#xA;最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。&#xA;示例 1：&#xA;输入：s1 = &amp;#34;xx&amp;#34;, s2 = &amp;#34;yy&amp;#34; 输出：1 解释： 交换 s1[0] 和 s2[1]，得到 s1 = &amp;#34;yx&amp;#34;，s2 = &amp;#34;yx&amp;#34;。 示例 2：&#xA;输入：s1 = &amp;#34;xy&amp;#34;, s2 = &amp;#34;yx&amp;#34; 输出：2 解释： 交换 s1[0] 和 s2[0]，得到 s1 = &amp;#34;yy&amp;#34;，s2 = &amp;#34;xx&amp;#34; 。 交换 s1[0] 和 s2[1]，得到 s1 = &amp;#34;xy&amp;#34;，s2 = &amp;#34;xy&amp;#34; 。 注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 &amp;#34;yx&amp;#34;，因为我们只能交换属于两个不同字符串的字符。 示例 3：</description>
    </item>
    <item>
      <title>312.burst Balloons</title>
      <link>http://localhost:1313/posts/leet/312.burst-balloons/</link>
      <pubDate>Fri, 24 Feb 2023 09:26:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/312.burst-balloons/</guid>
      <description></description>
    </item>
    <item>
      <title>312.戳气球</title>
      <link>http://localhost:1313/posts/leet/312.burst-balloons.zh/</link>
      <pubDate>Fri, 24 Feb 2023 09:26:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/312.burst-balloons.zh/</guid>
      <description>问题描述 312. 戳气球 (Hard)&#xA;有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&#xA;现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1 或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。&#xA;求所能获得硬币的最大数量。&#xA;示例 1：&#xA;输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8] --&amp;gt; [3,5,8] --&amp;gt; [3,8] --&amp;gt; [8] --&amp;gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 示例 2：</description>
    </item>
    <item>
      <title>2357.make array zero by subtracting equal amounts</title>
      <link>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts/</link>
      <pubDate>Fri, 24 Feb 2023 09:18:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts/</guid>
      <description>Description 2357. Make Array Zero by Subtracting Equal Amounts (Easy)&#xA;You are given a non-negative integer array nums. In one operation, you must:&#xA;Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums. Subtract x from every positive element in nums. Return the minimum number of operations to make every element in nums equal to 0.&#xA;Example 1:&#xA;Input: nums = [1,5,0,3,5] Output: 3 Explanation: In the first operation, choose x = 1.</description>
    </item>
    <item>
      <title>2357.使数组中所有元素都等于零</title>
      <link>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts.zh/</link>
      <pubDate>Fri, 24 Feb 2023 09:17:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2357.make-array-zero-by-subtracting-equal-amounts.zh/</guid>
      <description>问题描述 2357. 使数组中所有元素都等于零 (Easy)&#xA;给你一个非负整数数组 nums 。在一步操作中，你必须：&#xA;选出一个正整数 x ， x 需要小于或等于 nums 中 最小 的 非零 元素。 nums 中的每个正整数都减去 x。 返回使 nums 中所有元素都等于 0 需要的 最少 操作数。&#xA;示例 1：&#xA;输入：nums = [1,5,0,3,5] 输出：3 解释： 第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。 第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。 第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。 示例 2：&#xA;输入：nums = [0] 输出：0 解释：nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。 提示：</description>
    </item>
    <item>
      <title>397.integer replacement</title>
      <link>http://localhost:1313/posts/leet/397.integer-replacement/</link>
      <pubDate>Thu, 23 Feb 2023 16:08:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/397.integer-replacement/</guid>
      <description>Description 397. Integer Replacement (Medium)&#xA;Given a positive integer n, you can apply one of the following operations:&#xA;If n is even, replace n with n / 2. If n is odd, replace n with either n + 1 or n - 1. Return the minimum number of operations needed for nto become 1.&#xA;Example 1:&#xA;Input: n = 8 Output: 3 Explanation: 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 Example 2:</description>
    </item>
    <item>
      <title>397.整数替换</title>
      <link>http://localhost:1313/posts/leet/397.integer-replacement.zh/</link>
      <pubDate>Thu, 23 Feb 2023 16:08:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/397.integer-replacement.zh/</guid>
      <description>问题描述 397. 整数替换 (Medium)&#xA;给定一个正整数 n ，你可以做如下操作：&#xA;如果 n 是偶数，则用 n / 2 替换 n。 如果 n 是奇数，则可以用 n + 1 或 n - 1 替换 n 。 返回 n 变为 1 所需的 最小替换次数 。&#xA;示例 1：&#xA;输入：n = 8 输出：3 解释：8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 示例 2：&#xA;输入：n = 7 输出：4 解释：7 -&amp;gt; 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 或 7 -&amp;gt; 6 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1 示例 3：</description>
    </item>
    <item>
      <title>1238.circular permutation in binary representation</title>
      <link>http://localhost:1313/posts/leet/1238.circular-permutation-in-binary-representation/</link>
      <pubDate>Thu, 23 Feb 2023 15:56:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1238.circular-permutation-in-binary-representation/</guid>
      <description>Description 1238. Circular Permutation in Binary Representation (Medium)&#xA;Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that :&#xA;p[0] = start p[i] and p[i+1] differ by only one bit in their binary representation. p[0] and p[2^n -1] must also differ by only one bit in their binary representation. Example 1:&#xA;Input: n = 2, start = 3 Output: [3,2,0,1] Explanation: The binary representation of the permutation is (11,10,00,01).</description>
    </item>
    <item>
      <title>1238.循环码排列</title>
      <link>http://localhost:1313/posts/leet/1238.circular-permutation-in-binary-representation.zh/</link>
      <pubDate>Thu, 23 Feb 2023 15:56:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1238.circular-permutation-in-binary-representation.zh/</guid>
      <description>问题描述 1238. 循环码排列 (Medium)&#xA;给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,...,2^n-1) 的排列 p，并且满足：&#xA;p[0] = start p[i] 和 p[i+1] 的二进制表示形式只有一位不同 p[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同 示例 1：&#xA;输入：n = 2, start = 3 输出：[3,2,0,1] 解释：这个排列的二进制表示是 (11,10,00,01) 所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2] 示例 2：&#xA;输出：n = 3, start = 2 输出：[2,6,7,5,4,0,1,3] 解释：这个排列的二进制表示是 (010,110,111,101,100,000,001,011) 提示：&#xA;1 &amp;lt;= n &amp;lt;= 16 0 &amp;lt;= start &amp;lt; 2^n 解题思路 参照89.格雷编码，只需要将得到的结果再与start按位异或就好了，因为x ^ 0 = x对任意x恒成立。&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; circularPermutation(int n, int start) { vector&amp;lt;int&amp;gt; res(1 &amp;lt;&amp;lt; n, 0); for (int i = 0; i &amp;lt; res.</description>
    </item>
    <item>
      <title>89.gray code</title>
      <link>http://localhost:1313/posts/leet/89.gray-code/</link>
      <pubDate>Thu, 23 Feb 2023 15:53:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/89.gray-code/</guid>
      <description>Description 89. Gray Code (Medium)&#xA;An n-bit gray code sequence is a sequence of 2ⁿ integers where:&#xA;Every integer is in the inclusive range [0, 2ⁿ - 1], The first integer is 0, An integer appears no more than once in the sequence, The binary representation of every pair of adjacent integers differs by exactly one bit, and The binary representation of the first and last integers differs by exactly one bit.</description>
    </item>
    <item>
      <title>89.格雷编码</title>
      <link>http://localhost:1313/posts/leet/89.gray-code.zh/</link>
      <pubDate>Thu, 23 Feb 2023 15:51:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/89.gray-code.zh/</guid>
      <description>问题描述 89. 格雷编码 (Medium)&#xA;n 位格雷码序列 是一个由 2ⁿ 个整数组成的序列，其中：&#xA;每个整数都在范围 [0, 2ⁿ - 1] 内（含 0 和 2ⁿ - 1） 第一个整数是 0 一个整数在序列中出现 不超过一次 每对 相邻 整数的二进制表示 恰好一位不同 ，且 第一个 和 最后一个 整数的二进制表示 恰好一位不同 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。&#xA;示例 1：&#xA;输入：n = 2 输出：[0,1,3,2] 解释： [0,1,3,2] 的二进制表示是 [00,01,11,10] 。 - 00 和 01 有一位不同 - 01 和 11 有一位不同 - 11 和 10 有一位不同 - 10 和 00 有一位不同 [0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。 - 00 和 10 有一位不同 - 10 和 11 有一位不同 - 11 和 01 有一位不同 - 01 和 00 有一位不同 示例 2：</description>
    </item>
    <item>
      <title>1326.minimum number of taps to open to water a garden</title>
      <link>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden/</link>
      <pubDate>Tue, 21 Feb 2023 15:35:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden/</guid>
      <description>Description 1326. Minimum Number of Taps to Open to Water a Garden (Hard)&#xA;There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).&#xA;There are n + 1 taps located at points [0, 1, ..., n] in the garden.&#xA;Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.</description>
    </item>
    <item>
      <title>1326.浇灌花园的最少水龙头数目</title>
      <link>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/</link>
      <pubDate>Tue, 21 Feb 2023 15:35:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1326.minimum-number-of-taps-to-open-to-water-a-garden.zh/</guid>
      <description>问题描述 1326. 灌溉花园的最少水龙头数目 (Hard)&#xA;在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。&#xA;花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。&#xA;给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i - ranges[i], i + ranges[i]] 。&#xA;请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。&#xA;示例 1：&#xA;输入：n = 5, ranges = [3,4,1,1,0,0] 输出：1 解释： 点 0 处的水龙头可以灌溉区间 [-3,3] 点 1 处的水龙头可以灌溉区间 [-3,5] 点 2 处的水龙头可以灌溉区间 [1,3] 点 3 处的水龙头可以灌溉区间 [2,4] 点 4 处的水龙头可以灌溉区间 [4,4] 点 5 处的水龙头可以灌溉区间 [5,5] 只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。 示例 2：</description>
    </item>
    <item>
      <title>1792.maximum average pass ratio</title>
      <link>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio/</link>
      <pubDate>Mon, 20 Feb 2023 14:14:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio/</guid>
      <description>Description 1792. Maximum Average Pass Ratio (Medium)&#xA;There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passᵢ, totalᵢ]. You know beforehand that in the ith class, there are totalᵢ total students, but only passᵢ number of students will pass the exam.&#xA;You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to.</description>
    </item>
    <item>
      <title>1792.最大平均通过率</title>
      <link>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio.zh/</link>
      <pubDate>Mon, 20 Feb 2023 14:14:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1792.maximum-average-pass-ratio.zh/</guid>
      <description>问题描述 1792. 最大平均通过率 (Medium)&#xA;一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passᵢ, totalᵢ] ，表示你提前知道了第 i 个班级总共有 totalᵢ 个学生，其中只有 passᵢ 个学生可以通过考试。&#xA;给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。&#xA;一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。 平均通过率 是所有班级的通过率之和除以班级数目。&#xA;请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-⁵ 以内的结果都会视为正确结果。&#xA;示例 1：&#xA;输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2 输出：0.78333 解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。 示例 2：&#xA;输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4 输出：0.</description>
    </item>
    <item>
      <title>1833.maximum Ice Cream Bars</title>
      <link>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars/</link>
      <pubDate>Mon, 20 Feb 2023 10:14:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars/</guid>
      <description>Description 1833. Maximum Ice Cream Bars (Medium)&#xA;It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.</description>
    </item>
    <item>
      <title>1833.雪糕的最大数量</title>
      <link>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars.zh/</link>
      <pubDate>Mon, 20 Feb 2023 10:14:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1833.maximum-ice-cream-bars.zh/</guid>
      <description>问题描述 1833. 雪糕的最大数量 (Medium)&#xA;夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。&#xA;商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。&#xA;注意： Tony 可以按任意顺序购买雪糕。&#xA;给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。&#xA;示例 1：&#xA;输入：costs = [1,3,2,4,1], coins = 7 输出：4 解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7 示例 2：&#xA;输入：costs = [10,6,8,7,7,8], coins = 5 输出：0 解释：Tony 没有足够的钱买任何一支雪糕。 示例 3：</description>
    </item>
    <item>
      <title>2347.best poker hand</title>
      <link>http://localhost:1313/posts/leet/2347.best-poker-hand/</link>
      <pubDate>Mon, 20 Feb 2023 09:38:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2347.best-poker-hand/</guid>
      <description>Description 2347. Best Poker Hand (Easy)&#xA;You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i]. The following are the types of poker hands you can make from best to worst:&#xA;&amp;quot;Flush&amp;quot;: Five cards of the same suit. &amp;quot;Three of a Kind&amp;quot;: Three cards of the same rank. &amp;quot;Pair&amp;quot;: Two cards of the same rank.</description>
    </item>
    <item>
      <title>2347.最好的扑克手牌</title>
      <link>http://localhost:1313/posts/leet/2347.best-poker-hand.zh/</link>
      <pubDate>Mon, 20 Feb 2023 09:38:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2347.best-poker-hand.zh/</guid>
      <description>问题描述 2347. 最好的扑克手牌 (Easy)&#xA;给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。 下述是从好到坏你可能持有的 手牌类型：&#xA;&amp;quot;Flush&amp;quot;：同花，五张相同花色的扑克牌。 &amp;quot;Three of a Kind&amp;quot;：三条，有 3 张大小相同的扑克牌。 &amp;quot;Pair&amp;quot;：对子，两张大小一样的扑克牌。 &amp;quot;High Card&amp;quot;：高牌，五张大小互不相同的扑克牌。 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。 注意： 返回的字符串 大小写 需与题目描述相同。 示例 1： 输入：ranks = [13,2,3,1,9], suits = [&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;] 输出：&amp;#34;Flush&amp;#34; 解释：5 张扑克牌的花色相同，所以返回 &amp;#34;Flush&amp;#34; 。 示例 2：&#xA;输入：ranks = [4,4,2,4,4], suits = [&amp;#34;d&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 输出：&amp;#34;Three of a Kind&amp;#34; 解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 &amp;#34;Three of a Kind&amp;#34; 。 注意我们也可以得到 &amp;#34;Pair&amp;#34; ，但是 &amp;#34;Three of a Kind&amp;#34; 是更好的手牌类型。 有其他的 3 张牌也可以组成 &amp;#34;Three of a Kind&amp;#34; 手牌类型。 示例 3：</description>
    </item>
    <item>
      <title>781.rabbits in forest</title>
      <link>http://localhost:1313/posts/leet/781.rabbits-in-forest/</link>
      <pubDate>Sat, 18 Feb 2023 18:14:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/781.rabbits-in-forest/</guid>
      <description>Solution 781. Rabbits in Forest (Medium)&#xA;There is a forest with an unknown number of rabbits. We asked n rabbits &amp;ldquo;How many rabbits have the same color as you?&amp;rdquo; and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit. Given the array answers, return the minimum number of rabbits that could be in the forest. Example 1:&#xA;Input: answers = [1,1,2] Output: 5 Explanation: The two rabbits that answered &amp;#34;1&amp;#34; could both be the same color, say red.</description>
    </item>
    <item>
      <title>781.森林中的兔子</title>
      <link>http://localhost:1313/posts/leet/781.rabbits-in-forest.zh/</link>
      <pubDate>Sat, 18 Feb 2023 18:14:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/781.rabbits-in-forest.zh/</guid>
      <description>问题描述 781. 森林中的兔子 (Medium)&#xA;森林中有未知数量的兔子。提问其中若干只兔子 &amp;ldquo;还有多少只兔子与你（指被提问的兔子）颜色相同?&amp;rdquo; ，将答案收集到一个整数数组 answers 中，其中 answers[i] 是第 i 只兔子的回答。 给你数组 answers ，返回森林中兔子的最少数量。 示例 1：&#xA;输入：answers = [1,1,2] 输出：5 解释： 两只回答了 &amp;#34;1&amp;#34; 的兔子可能有相同的颜色，设为红色。 之后回答了 &amp;#34;2&amp;#34; 的兔子不会是红色，否则他们的回答会相互矛盾。 设回答了 &amp;#34;2&amp;#34; 的兔子为蓝色。 此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。 因此森林中兔子的最少数量是 5 只：3 只回答的和 2 只没有回答的。 示例 2：&#xA;输入：answers = [10,10,10] 输出：11 提示：&#xA;1 &amp;lt;= answers.length &amp;lt;= 1000 0 &amp;lt;= answers[i] &amp;lt; 1000 解题思路 从题目中给出的例子我们可以发现，要想让兔子数量最小，那么要尽量让回答结果相同的兔子是同一个颜色的；&#xA;我们用一个哈希表unordered_map&amp;lt;int, int&amp;gt; ump来记录每种结果有多少只兔子回答了，key为回答结果，value是回答该结果的兔子的数量；&#xA;如果ump[i] &amp;gt; i + 1，说明这批兔子至少有不止一种颜色，颜色数为(ump[i] - 1) / (i + 1) + 1，每种颜色有i + 1个兔子。</description>
    </item>
    <item>
      <title>1996.the number of weak characters in the game</title>
      <link>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game/</link>
      <pubDate>Sat, 18 Feb 2023 17:23:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game/</guid>
      <description>Description 1223. Dice Roll Simulation (Hard)&#xA;A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] ( 1-indexed) consecutive times. Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 10⁹ + 7.</description>
    </item>
    <item>
      <title>1996.游戏中弱角色的数量</title>
      <link>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game.zh/</link>
      <pubDate>Sat, 18 Feb 2023 17:23:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1996.the-number-of-weak-characters-in-the-game.zh/</guid>
      <description>问题描述 1996. 游戏中弱角色的数量 (Medium)&#xA;你正在参加一个多角色游戏，每个角色都有两个主要属性： 攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attackᵢ, defenseᵢ] 表示游戏中第 i 个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackⱼ &amp;gt; attackᵢ 且 defenseⱼ &amp;gt; defenseᵢ 。 返回 弱角色 的数量。 示例 1：&#xA;输入：properties = [[5,5],[6,3],[3,6]] 输出：0 解释：不存在攻击和防御都严格高于其他角色的角色。 示例 2：&#xA;输入：properties = [[2,2],[3,3]] 输出：1 解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 示例 3：&#xA;输入：properties = [[1,5],[10,4],[4,3]] 输出：1 解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 提示：&#xA;2 &amp;lt;= properties.length &amp;lt;= 10⁵ properties[i].length == 2 1 &amp;lt;= attackᵢ, defenseᵢ &amp;lt;= 10⁵ 解题思路 首先将角色按照攻击值从大到小排序，至于相同攻击值之间的角色的排序，有两种思路</description>
    </item>
    <item>
      <title>1797.design authentication manager</title>
      <link>http://localhost:1313/posts/leet/1797.design-authentication-manager/</link>
      <pubDate>Sat, 18 Feb 2023 16:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1797.design-authentication-manager/</guid>
      <description>Description 1797. Design Authentication Manager (Medium)&#xA;There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime. Implement the AuthenticationManager class:&#xA;AuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive. generate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.</description>
    </item>
    <item>
      <title>1797.设计一个验证系统</title>
      <link>http://localhost:1313/posts/leet/1797.design-authentication-manager.zh/</link>
      <pubDate>Sat, 18 Feb 2023 16:43:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1797.design-authentication-manager.zh/</guid>
      <description>问题描述 1797. 设计一个验证系统 (Medium)&#xA;你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。 请你实现 AuthenticationManager 类：&#xA;AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。 generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。 renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。 countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻， 未过期 的验证码数目。 如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（ renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。 示例 1： 输入： [&amp;#34;AuthenticationManager&amp;#34;, &amp;#34;renew&amp;#34;, &amp;#34;generate&amp;#34;, &amp;#34;countUnexpiredTokens&amp;#34;, &amp;#34;generate&amp;#34;, &amp;#34;renew&amp;#34;, &amp;#34;renew&amp;#34;, &amp;#34;countUnexpiredTokens&amp;#34;] [[5], [&amp;#34;aaa&amp;#34;, 1], [&amp;#34;aaa&amp;#34;, 2], [6], [&amp;#34;bbb&amp;#34;, 7], [&amp;#34;aaa&amp;#34;, 8], [&amp;#34;bbb&amp;#34;, 10], [15]] 输出： [null, null, null, 1, null, null, null, 0] 解释： AuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 timeToLive = 5 秒。 authenticationManager.</description>
    </item>
    <item>
      <title>1233.remove sub folders from the filesystem</title>
      <link>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem/</link>
      <pubDate>Sat, 18 Feb 2023 16:37:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem/</guid>
      <description>Description 1233. Remove Sub-Folders from the Filesystem (Medium)&#xA;Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order. If a folder[i] is located within another folder[j], it is called a sub-folder of it. The format of a path is one or more concatenated strings of the form: &#39;/&#39; followed by one or more lowercase English letters.</description>
    </item>
    <item>
      <title>1233.删除子文件夹</title>
      <link>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem.zh/</link>
      <pubDate>Sat, 18 Feb 2023 16:37:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1233.remove-sub-folders-from-the-filesystem.zh/</guid>
      <description>问题描述 [1233. 删除子文件夹 (Medium)]&#xA;你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：&amp;rsquo;/&amp;rsquo; 后跟一个或者多个小写英文字母。&#xA;例如， &amp;quot;/leetcode&amp;quot; 和 &amp;quot;/leetcode/problems&amp;quot; 都是有效的路径，而空字符串和 &amp;quot;/&amp;quot; 不是。 示例 1： 输入：folder = [&amp;#34;/a&amp;#34;,&amp;#34;/a/b&amp;#34;,&amp;#34;/c/d&amp;#34;,&amp;#34;/c/d/e&amp;#34;,&amp;#34;/c/f&amp;#34;] 输出：[&amp;#34;/a&amp;#34;,&amp;#34;/c/d&amp;#34;,&amp;#34;/c/f&amp;#34;] 解释：&amp;#34;/a/b&amp;#34; 是 &amp;#34;/a&amp;#34; 的子文件夹，而 &amp;#34;/c/d/e&amp;#34; 是 &amp;#34;/c/d&amp;#34; 的子文件夹。 示例 2：&#xA;输入：folder = [&amp;#34;/a&amp;#34;,&amp;#34;/a/b/c&amp;#34;,&amp;#34;/a/b/d&amp;#34;] 输出：[&amp;#34;/a&amp;#34;] 解释：文件夹 &amp;#34;/a/b/c&amp;#34; 和 &amp;#34;/a/b/d&amp;#34; 都会被删除，因为它们都是 &amp;#34;/a&amp;#34; 的子文件夹。 示例 3：&#xA;输入: folder = [&amp;#34;/a/b/c&amp;#34;,&amp;#34;/a/b/ca&amp;#34;,&amp;#34;/a/b/d&amp;#34;] 输出: [&amp;#34;/a/b/c&amp;#34;,&amp;#34;/a/b/ca&amp;#34;,&amp;#34;/a/b/d&amp;#34;] 提示：&#xA;1 &amp;lt;= folder.length &amp;lt;= 4 * 10⁴ 2 &amp;lt;= folder[i].</description>
    </item>
    <item>
      <title>646.maximum length of pair chain</title>
      <link>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain/</link>
      <pubDate>Sat, 18 Feb 2023 15:00:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain/</guid>
      <description>Description 646. Maximum Length of Pair Chain (Medium)&#xA;You are given an array of n pairs pairs where pairs[i] = [leftᵢ, rightᵢ] and leftᵢ &amp;lt; rightᵢ. A pair p2 = [c, d] follows a pair p1 = [a, b] if b &amp;lt; c. A chain of pairs can be formed in this fashion. Return the length longest chain which can be formed. You do not need to use up all the given intervals.</description>
    </item>
    <item>
      <title>646.最长数对链</title>
      <link>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain.zh/</link>
      <pubDate>Sat, 18 Feb 2023 15:00:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/646.maximum-length-of-pair-chain.zh/</guid>
      <description>问题描述 646. 最长数对链 (Medium)&#xA;给你一个由 n 个数对组成的数对数组 pairs ，其中 pairs[i] = [leftᵢ, rightᵢ] 且 leftᵢ &amp;lt; rightᵢ 现在，我们定义一种 跟随 关系，当且仅当 b &amp;lt; c 时，数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面。我们用这种形式来构造 数对链 。 找出并返回能够形成的 最长数对链的长度 。 你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例 1：&#xA;输入：pairs = [[1,2], [2,3], [3,4]] 输出：2 解释：最长的数对链是 [1,2] -&amp;gt; [3,4] 。 示例 2：&#xA;输入：pairs = [[1,2],[7,8],[4,5]] 输出：3 解释：最长的数对链是 [1,2] -&amp;gt; [4,5] -&amp;gt; [7,8] 。 提示：&#xA;n == pairs.length 1 &amp;lt;= n &amp;lt;= 1000 -1000 &amp;lt;= leftᵢ &amp;lt; rightᵢ &amp;lt;= 1000 解题思路 贪心 在选择第一个数对时，必定选择使pairs[i][1]最小的那个i，第二个数对则必定选择pairs[j][0] &amp;gt; pairs[i][1]且使pairs[j][0]最小的j，因此类推，因此我们将pairs按照其第二个元素升序排列。</description>
    </item>
    <item>
      <title>1124.longest well performing interval</title>
      <link>http://localhost:1313/posts/leet/1124.longest-well-performing-interval/</link>
      <pubDate>Fri, 17 Feb 2023 16:13:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1124.longest-well-performing-interval/</guid>
      <description>Description 1124. Longest Well-Performing Interval (Medium)&#xA;We are given hours, a list of the number of hours worked per day for a given employee. A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8. A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</description>
    </item>
    <item>
      <title>1124.表现良好的最长时间段</title>
      <link>http://localhost:1313/posts/leet/1124.longest-well-performing-interval.zh/</link>
      <pubDate>Fri, 17 Feb 2023 16:13:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1124.longest-well-performing-interval.zh/</guid>
      <description>问题描述 1124. 表现良好的最长时间段 (Medium)&#xA;给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「 劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。 示例 1：&#xA;输入：hours = [9,9,6,0,6,6,9] 输出：3 解释：最长的表现良好时间段是 [9,9,6]。 示例 2：&#xA;输入：hours = [6,6,6] 输出：0 提示：&#xA;1 &amp;lt;= hours.length &amp;lt;= 10⁴ 0 &amp;lt;= hours[i] &amp;lt;= 16 解题思路 单调栈 首先，将原数组中大于8的值设为1，小于或等于8的值设为-1，分别表示劳累的一天和不劳累的一天，然后求这个新数组的前缀和，得到一个前缀和数组prefix；&#xA;那么我们就是要求满足prefix[j] &amp;gt; prefix[i]条件下的最大的j - i，首先，我们考虑左端点，如果prefix[i1] &amp;lt; prefix[i2]且i1 &amp;lt;= i2，那么我们完全不需要考虑使用i2作为左端点，因为选择i1作为左端点的res一定更大，所以我们可以正向遍历prefix，并将索引idx压入单调栈，满足栈底到栈顶单调递减；&#xA;然后，我们从从右往左遍历prefix找右端点，如果prefix[j1] &amp;gt; prefix[stk.top()]，那就弹出栈顶元素并更新res = std::max(res, r - stk.top())，如果选择从左往右遍历的话，prefix[j2] &amp;lt; prefix[stk.top()]的时候，最终结果可能是j2 - i，其中i是一个被弹出的元素，从左往右遍历右端点，这种情况无法考虑到。&#xA;哈希表 如果prefix[i] &amp;gt; 0，说明这i天内都是表现良好的时间段，那么res = max(i, res)； 如果prefix[i] &amp;lt;= 0，如果key prefix[i]之前未在哈希表ump中出现过，那么ump[prefix[i]] = i, 否则不更新ump[prefix[i]]，因为哈希表中key对应的value一定更小，对应的差值即时间长度会更大， 以第i天结尾表现良好的时间段的最大长度即为ump[prefix[i]] - ump[prefix[i] - 1]（要求key prefix[i] - 1在哈希表中，否则为0，即不存在这样的时间段），这是因为由于新数组中只有1和-1两种元素，那么值prefix[i] - 1一定比prefix[i] - 2先出现在前缀和数组中。 代码 单调栈 class Solution { public: int longestWPI(vector&amp;lt;int&amp;gt; &amp;amp;hours) { int n = hours.</description>
    </item>
    <item>
      <title>926.flip string to monotone increasing</title>
      <link>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing/</link>
      <pubDate>Fri, 17 Feb 2023 16:00:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing/</guid>
      <description>Description 926. Flip String to Monotone Increasing (Medium)&#xA;A binary string is monotone increasing if it consists of some number of 0&amp;rsquo;s (possibly none), followed by some number of 1&amp;rsquo;s (also possibly none). You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0. Return the minimum number of flips to make s monotone increasing. Example 1:&#xA;Input: s = &amp;#34;00110&amp;#34; Output: 1 Explanation: We flip the last digit to get 00111.</description>
    </item>
    <item>
      <title>926.将字符串翻转到单调递增</title>
      <link>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing.zh/</link>
      <pubDate>Fri, 17 Feb 2023 16:00:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/926.flip-string-to-monotone-increasing.zh/</guid>
      <description>问题描述 926. 将字符串翻转到单调递增 (Medium)&#xA;如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。 给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。 返回使 s 单调递增的最小翻转次数。 示例 1：&#xA;输入：s = &amp;#34;00110&amp;#34; 输出：1 解释：翻转最后一位得到 00111. 示例 2：&#xA;输入：s = &amp;#34;010110&amp;#34; 输出：2 解释：翻转得到 011111，或者是 000111。 示例 3：&#xA;输入：s = &amp;#34;00011000&amp;#34; 输出：2 解释：翻转得到 00000000。 提示：&#xA;1 &amp;lt;= s.length &amp;lt;= 10⁵ s[i] 为 &#39;0&#39; 或 &#39;1&#39; 解题思路 令dp[i]为将前i个字符翻转成单调递增的字符串所需要的最少翻转次数，cnt表示前i个字符中&#39;1&#39;的个数，其递推关系很容易分析:&#xA;s[i - 1] == &#39;1&#39;，dp[i] = dp[i - 1]; s[i - 1] == &#39;0&#39;，dp[i] = min(dp[i - 1] + 1, cnt); 代码 class Solution { public: int minFlipsMonoIncr(string s) { int cnt = 0, res = 0; // cnt为遍历中1的个数 vector&amp;lt;int&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>1139.largest 1 bordered square</title>
      <link>http://localhost:1313/posts/leet/1139.largest-1-bordered-square/</link>
      <pubDate>Fri, 17 Feb 2023 15:52:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1139.largest-1-bordered-square/</guid>
      <description>Description 1139. Largest 1-Bordered Square (Medium)&#xA;Given a 2D grid of 0 s and 1 s, return the number of elements in the largest square subgrid that has all 1 s on its border, or 0 if such a subgrid doesn&amp;rsquo;t exist in the grid. Example 1:&#xA;Input: grid = [[1,1,1],[1,0,1],[1,1,1]] Output: 9 Example 2:&#xA;Input: grid = [[1,1,0,0]] Output: 1 Constraints:&#xA;1 &amp;lt;= grid.length &amp;lt;= 100 1 &amp;lt;= grid[0].length &amp;lt;= 100 grid[i][j] is 0 or 1 Solution We can use prefix sum to reduce coumputaional comlexity.</description>
    </item>
    <item>
      <title>1139.最大的以1为边界的正方形</title>
      <link>http://localhost:1313/posts/leet/1139.largest-1-bordered-square.zh/</link>
      <pubDate>Fri, 17 Feb 2023 15:52:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1139.largest-1-bordered-square.zh/</guid>
      <description>问题描述 1139. 最大的以 1 为边界的正方形 (Medium)&#xA;给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。 示例 1：&#xA;输入：grid = [[1,1,1],[1,0,1],[1,1,1]] 输出：9 示例 2：&#xA;输入：grid = [[1,1,0,0]] 输出：1 提示：&#xA;1 &amp;lt;= grid.length &amp;lt;= 100 1 &amp;lt;= grid[0].length &amp;lt;= 100 grid[i][j] 为 0 或 1 解题思路 利用前缀和来简化满足正方形条件的计算，枚举正方形边长，找到最大的l，再和已经得出的结果进行比较。&#xA;代码 class Solution { public: int largest1BorderedSquare(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { // 前缀和 int m = grid.size(), n = grid[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; sum_row(m, vector&amp;lt;int&amp;gt;(n + 1, 0)); // 每行前缀和 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; sum_col(m + 1, vector&amp;lt;int&amp;gt;(n, 0)); // 每列前缀和 for (int i = 0; i &amp;lt; grid.</description>
    </item>
    <item>
      <title>456.132 pattern</title>
      <link>http://localhost:1313/posts/leet/456.132-pattern/</link>
      <pubDate>Fri, 17 Feb 2023 14:46:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/456.132-pattern/</guid>
      <description>Description 456. 132 Pattern (Medium)&#xA;Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false. Example 1:&#xA;Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Example 2:</description>
    </item>
    <item>
      <title>456.132模式</title>
      <link>http://localhost:1313/posts/leet/456.132-pattern.zh/</link>
      <pubDate>Fri, 17 Feb 2023 14:46:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/456.132-pattern.zh/</guid>
      <description>问题描述 456. 132 模式 (Medium)&#xA;给你一个整数数组 nums ，数组中共有 n 个整数。 132 模式的子序列 由三个整数 nums[i]、 nums[j] 和 nums[k] 组成，并同时满足： i &amp;lt; j &amp;lt; k 和 nums[i] &amp;lt; nums[k] &amp;lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 示例 1：&#xA;输入：nums = [1,2,3,4] 输出：false 解释：序列中不存在 132 模式的子序列。 示例 2：&#xA;输入：nums = [3,1,4,2] 输出：true 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3：&#xA;输入：nums = [-1,3,2,0] 输出：true 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示：</description>
    </item>
    <item>
      <title>334.increasing triplet subsequence</title>
      <link>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence/</link>
      <pubDate>Fri, 17 Feb 2023 14:07:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence/</guid>
      <description>Description 334. Increasing Triplet Subsequence (Medium)&#xA;Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[j] &amp;lt; nums[k]. If no such indices exists, return false. Example 1:&#xA;Input: nums = [1,2,3,4,5] Output: true Explanation: Any triplet where i &amp;lt; j &amp;lt; k is valid. Example 2:&#xA;Input: nums = [5,4,3,2,1] Output: false Explanation: No triplet exists.</description>
    </item>
    <item>
      <title>334.递增的三元子序列</title>
      <link>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence.zh/</link>
      <pubDate>Fri, 17 Feb 2023 14:07:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/334.increasing-triplet-subsequence.zh/</guid>
      <description>问题描述 334. 递增的三元子序列 (Medium)&#xA;给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标 (i, j, k) 且满足 i &amp;lt; j &amp;lt; k ，使得 nums[i] &amp;lt; nums[j] &amp;lt; nums[k] ，返回 true ；否则，返回 false 。 示例 1：&#xA;输入：nums = [1,2,3,4,5] 输出：true 解释：任何 i &amp;lt; j &amp;lt; k 的三元组都满足题意 示例 2：&#xA;输入：nums = [5,4,3,2,1] 输出：false 解释：不存在满足题意的三元组 示例 3：&#xA;输入：nums = [2,1,5,0,4,6] 输出：true 解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &amp;lt; nums[4] == 4 &amp;lt; nums[5] == 6 提示：</description>
    </item>
    <item>
      <title>1218.longest arithmetic subsequence of given difference</title>
      <link>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference/</link>
      <pubDate>Thu, 16 Feb 2023 20:01:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference/</guid>
      <description>Description 1218. Longest Arithmetic Subsequence of Given Difference (Medium)&#xA;Longest Arithmetic Subsequence of Given Difference (Medium) Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference. A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.</description>
    </item>
    <item>
      <title>1218.最长定差子序列</title>
      <link>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference.zh/</link>
      <pubDate>Thu, 16 Feb 2023 20:01:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1218.longest-arithmetic-subsequence-of-given-difference.zh/</guid>
      <description>问题描述 1218. 最长定差子序列 (Medium)&#xA;给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。 子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。 示例 1：&#xA;输入：arr = [1,2,3,4], difference = 1 输出：4 解释：最长的等差子序列是 [1,2,3,4]。 示例 2：&#xA;输入：arr = [1,3,5,7], difference = 1 输出：1 解释：最长的等差子序列是任意单个元素。 示例 3：&#xA;输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2 输出：4 解释：最长的等差子序列是 [7,5,3,1]。 提示：&#xA;1 &amp;lt;= arr.length &amp;lt;= 10⁵ -10⁴ &amp;lt;= arr[i], difference &amp;lt;= 10⁴ 解题思路 利用哈希表，记录数组中每个元素，作为子序列末尾元素时，该元素对应的最长子序列的长度，有&#xA;if (ump.find(num - difference) != ump.end()) { ump[num] = ump[num - difference] + 1; } else { ump[num] = 1; } 代码 class Solution { public: int longestSubsequence(vector&amp;lt;int&amp;gt; &amp;amp;arr, int difference) { unordered_map&amp;lt;int, int&amp;gt; ump; for (auto &amp;amp;num : arr) { if (ump.</description>
    </item>
    <item>
      <title>2341.maximum Number of Pairs in Array</title>
      <link>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array/</link>
      <pubDate>Thu, 16 Feb 2023 19:19:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array/</guid>
      <description>Description 2341. Maximum Number of Pairs in Array (Easy)&#xA;You are given a 0-indexed integer array nums. In one operation, you may do the following:&#xA;Choose two integers in nums that are equal. Remove both integers from nums, forming a pair. The operation is done on nums as many times as possible. Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.</description>
    </item>
    <item>
      <title>2341.maximum Number of Pairs in Array</title>
      <link>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array.zh/</link>
      <pubDate>Thu, 16 Feb 2023 19:18:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2341.maximum-number-of-pairs-in-array.zh/</guid>
      <description>问题描述 2341. 数组能形成多少数对 (Easy)&#xA;给你一个下标从 0 开始的整数数组 nums 。在一步操作中，你可以执行以下步骤：&#xA;从 nums 选出 两个 相等的 整数 从 nums 中移除这两个整数，形成一个 数对 请你在 nums 上多次执行此操作直到无法继续执行。 返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目， answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。 示例 1： 输入：nums = [1,3,2,1,3,2,2] 输出：[3,1] 解释： nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。 nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。 nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。 无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。 示例 2：</description>
    </item>
    <item>
      <title>2335.minimum amount of time to fill cups</title>
      <link>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups/</link>
      <pubDate>Wed, 15 Feb 2023 16:51:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups/</guid>
      <description>Description [2335. Minimum Amount of Time to Fill Cups (Easy)]&#xA;You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water. You are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively.</description>
    </item>
    <item>
      <title>2335.装满杯子所需要的最短时长</title>
      <link>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups.zh/</link>
      <pubDate>Wed, 15 Feb 2023 16:51:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2335.minimum-amount-of-time-to-fill-cups.zh/</guid>
      <description>问题描述 2335. 装满杯子需要的最短总时长 (Easy)&#xA;现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。 给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、 amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。 示例 1：&#xA;输入：amount = [1,4,2] 输出：4 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯温水。 第 2 秒：装满一杯温水和一杯热水。 第 3 秒：装满一杯温水和一杯热水。 第 4 秒：装满一杯温水。 可以证明最少需要 4 秒才能装满所有杯子。 示例 2：&#xA;输入：amount = [5,4,4] 输出：7 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯热水。 第 2 秒：装满一杯冷水和一杯温水。 第 3 秒：装满一杯冷水和一杯温水。 第 4 秒：装满一杯温水和一杯热水。 第 5 秒：装满一杯冷水和一杯热水。 第 6 秒：装满一杯冷水和一杯温水。 第 7 秒：装满一杯热水。 示例 3：</description>
    </item>
    <item>
      <title>1705.maximum number of eaten apples</title>
      <link>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples/</link>
      <pubDate>Wed, 15 Feb 2023 15:59:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples/</guid>
      <description>Description 1705.maximum-number-of-eaten-apples&#xA;Solution The optimal strategy is to eat the apple that rots first, we can use the priority queue to simulate the process.&#xA;app_decay[i][0] indicates the expected decay time of the apples born on day i, and app_decay[i][1] indicates how many apples were born on day i.&#xA;The top() of the priority queue pq must be a vector with the minimum vec[0].&#xA;We traverse the array by time, if there are apples born on this day, we push app_decay[i] to pq, and pop the elements of the top() of pq until the heap is empty or pq.</description>
    </item>
    <item>
      <title>1705.吃苹果的最大数目</title>
      <link>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples.zh/</link>
      <pubDate>Wed, 15 Feb 2023 15:59:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1705.maximum-number-of-eaten-apples.zh/</guid>
      <description>问题描述 1705.吃苹果的最大数目 中等&#xA;There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0.</description>
    </item>
    <item>
      <title>871.minimum number of refueling stops</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops/</guid>
      <description>Description 871.minimum-number-of-refueling-stops&#xA;Solution Dynamic programming In this problem, the number is finite, and there is a recurrence relation, so we can use dynamic programming to solve this problem.&#xA;Let dp[i][j] means the furthest distance we can reach after passing throught i stations and adding fuel for j times. Obviously, i &amp;gt;= j.&#xA;So we can discuss dp[i][j] in two cases:&#xA;We don&amp;rsquo;t add fuel at the ith station: dp[i][j] = dp[i - 1][j] We add fuel in the ith station(We have to arrive at the ith station in the case we have just added fuel for j - 1 times before, that is: dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]): dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1].</description>
    </item>
    <item>
      <title>871.最低加油次数</title>
      <link>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</link>
      <pubDate>Wed, 15 Feb 2023 15:12:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/871.minimum-number-of-refueling-stops.zh/</guid>
      <description>问题描述 871.最低加油次数&#xA;解题思路 动态规划 对于这种有限次数，能看出来有递推关系的，可以考虑动态规划。&#xA;这里状态记为dp[i][j]，表示经过前i个加油站，加j次油之后，能够到达的最远距离，这里显然有i &amp;gt;= j。&#xA;那么考虑dp[i][j]的递推关系，可以分在第i个加油站加油和不加油两种情况来讨论：&#xA;在第i个加油站不加油：dp[i][j] = dp[i - 1][j] 在第i个加油站加油（要求第i个加油站可以在之前只加了j - 1次油的情况下到达），即dp[i - 1][j - 1] &amp;gt;= stations[i - 1][0]，此时dp[i][j] = dp[i - 1][j - 1] + stations[i - 1][1] dp[i][j]取两者中的最大值&#xA;贪心 首先，很容易想到，最佳策略每次加油，都是在油最多的加油站去加油，这里实际上可以认为能直接从经过的加油站中取油，即每次发现到达不了下一个加油站或者终点了，就从已经经过但是没加过油的加油站里加油，直到可以到达下一个加油站或者终点，可以利用优先队列来模拟这个过程，每次需要更新剩余的燃油cur_fuel。&#xA;代码 动态规划 class Solution { public: int minRefuelStops(int target, int startFuel, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;stations) { int n = stations.size(); if (n == 0) { if (startFuel &amp;gt;= target) return 0; return -1; } vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; dp(n + 1, vector&amp;lt;long long&amp;gt;(n + 1, 0)); dp[0][0] = startFuel; for (int i = 1; i &amp;lt;= n; i++) { dp[i][0] = stations[i - 1][0] &amp;lt;= startFuel ?</description>
    </item>
    <item>
      <title>1250.check if it is a good array</title>
      <link>http://localhost:1313/posts/leet/1250.check-if-it-is-a-good-array/</link>
      <pubDate>Wed, 15 Feb 2023 14:46:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1250.check-if-it-is-a-good-array/</guid>
      <description>Description 1250.check-if-it-is-a-good-array&#xA;Solution Actually, what we need to determine is whether the maximum common divisor of all elements in the array is 1.&#xA;We can use rolling division to get the maximum common divisor gcd of nums[0] and nums[1], then get the new maximum common divisor gcd of gcd and nums[2]&amp;hellip;&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int gcd(int a, int b) { // b^=a,a^=b,b^=a the same as swap(a, b) while (b ^= (a ^= (b ^= (a %= b)))) ; return a; } bool isGoodArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.</description>
    </item>
    <item>
      <title>1250.检查“好数组”</title>
      <link>http://localhost:1313/posts/leet/1250.check-if-it-is-a-good-array.zh/</link>
      <pubDate>Wed, 15 Feb 2023 14:46:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1250.check-if-it-is-a-good-array.zh/</guid>
      <description>问题描述 1250.检查“好数组”&#xA;解题思路 首先，要注意到，本题的要求，其实可以转化为数组中所有元素的最大公因数为1；&#xA;利用辗转相除法，将nums[0]和nums[1]求得的最大公因数num再与nums[2]求最大公因数作为新的num，如果到最后num == 1，返回true，否则返回false。&#xA;代码 class Solution { public: bool isGoodArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { std::sort(nums.begin(), nums.end()); // 利用哈希表储存不为1的因子，然后遍历，如果最后哈希表为空，return true if (nums[0] == 1) return true; std::unordered_set&amp;lt;int&amp;gt; factor; int root = sqrt(nums[0]); for (int i = 2; i &amp;lt;= root; i++) { if (nums[0] % i == 0) { if (factor.empty()) { factor.insert(i); factor.insert(nums[0] / i); } else { int flag = 0; // 为0说明factor里面没有它的因子 for (auto &amp;amp;num : factor) { if (i % num == 0) { flag = 1; break; } } if (flag == 0) { factor.</description>
    </item>
    <item>
      <title>1234.replace the substring for balanced string</title>
      <link>http://localhost:1313/posts/leet/1234.replace-the-substring-for-balanced-string/</link>
      <pubDate>Mon, 13 Feb 2023 16:21:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1234.replace-the-substring-for-balanced-string/</guid>
      <description>Description 1234.replace-the-substring-for-balanced-string&#xA;Solution We use two pointers left and right. Let&amp;rsquo;s traverse the string throughright from right = 0. If the amount of each character in the string other than [left, right] is less than or equal to n / 4, it means that we can form a balanced string by replacing [left, right], then increment left until [left, right] can&amp;rsquo;t form a balanced string.&#xA;Code class Solution { public: bool check(unordered_map&amp;lt;char, int&amp;gt; &amp;amp;mp, int m) { if (mp[&amp;#39;Q&amp;#39;] &amp;gt; m || mp[&amp;#39;W&amp;#39;] &amp;gt; m || mp[&amp;#39;E&amp;#39;] &amp;gt; m || mp[&amp;#39;R&amp;#39;] &amp;gt; m) return true; else return false; } int balancedString(string s) { int n = s.</description>
    </item>
    <item>
      <title>1234.替换子串得到平衡字符串</title>
      <link>http://localhost:1313/posts/leet/1234.replace-the-substring-for-balanced-string.zh/</link>
      <pubDate>Mon, 13 Feb 2023 16:21:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1234.replace-the-substring-for-balanced-string.zh/</guid>
      <description>问题描述 1234.替换子串得到平衡字符串&#xA;解题思路 利用两个指针left，right，right从0开始遍历，如果[left, right]之外的字符串中，每个字符出现次数都小于或等于n / 4，说明替换[left, right]可以构成平衡字符串，此时递增left，直到移除[left, right]不能构成平衡字符串。&#xA;代码 class Solution { public: bool check(unordered_map&amp;lt;char, int&amp;gt; &amp;amp;mp, int m) { if (mp[&amp;#39;Q&amp;#39;] &amp;gt; m || mp[&amp;#39;W&amp;#39;] &amp;gt; m || mp[&amp;#39;E&amp;#39;] &amp;gt; m || mp[&amp;#39;R&amp;#39;] &amp;gt; m) return true; else return false; } int balancedString(string s) { int n = s.size(), partial = n / 4; int res = n; unordered_map&amp;lt;char, int&amp;gt; chars; for (auto &amp;amp;c : s) chars[c]++; int flag = 1; for (auto &amp;amp;pa : chars) { // 检查字符串本身是否平衡 if (pa.</description>
    </item>
    <item>
      <title>517.super Washing Machines</title>
      <link>http://localhost:1313/posts/leet/517.super-washing-machines/</link>
      <pubDate>Mon, 13 Feb 2023 16:15:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/517.super-washing-machines/</guid>
      <description></description>
    </item>
    <item>
      <title>517.超级洗衣机</title>
      <link>http://localhost:1313/posts/leet/517.super-washing-machines.zh/</link>
      <pubDate>Mon, 13 Feb 2023 16:15:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/517.super-washing-machines.zh/</guid>
      <description>问题描述 517.超级洗衣机&#xA;解题思路 参照直观清晰：理解官方题解——超级洗衣机和贪心,再动一点点脑子。&#xA;这个题我也还没搞懂，先搁置&#xA;代码 class Solution { public: int findMinMoves(vector&amp;lt;int&amp;gt; &amp;amp;machines) { int tot = accumulate(machines.begin(), machines.end(), 0); int n = machines.size(); if (tot % n) { return -1; } int avg = tot / n; int ans = 0, sum = 0; for (int num: machines) { num -= avg; sum += num; ans = max(ans, max(abs(sum), num)); } return ans; } }; </description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo/</guid>
      <description>Description 502.IPO&#xA;Solution Greedy algorithm: if we want to maximize the final capital, we choose the project whose profit is maximum and whose minimum captial required is less than or equal to our current capital.&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;Let key be the profits, value be a map, of which key is the minimum capital required while value is the amount of the corresponding project.&#xA;Code class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.</description>
    </item>
    <item>
      <title>502.IPO</title>
      <link>http://localhost:1313/posts/leet/502.ipo.zh/</link>
      <pubDate>Sun, 12 Feb 2023 19:58:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/502.ipo.zh/</guid>
      <description>问题描述 502.IPO&#xA;解题思路 贪心：要最大化最终资本，因此必然选择满足当前资本需要的纯利润最大的项目。&#xA;map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs&#xA;key为纯利润，value也是map，该map的key为启动所需最小资本、value为项目数量。&#xA;代码 class Solution { public: int findMaximizedCapital(int k, int w, vector&amp;lt;int&amp;gt;&amp;amp; profits, vector&amp;lt;int&amp;gt;&amp;amp; capital) { map&amp;lt;int, map&amp;lt;int, int&amp;gt;, std::greater&amp;lt;int&amp;gt;&amp;gt; projs; for (int i = 0; i &amp;lt; profits.size(); i++) { projs[profits[i]][capital[i]]++; } for (int i = 0; i &amp;lt; k; i++) { int find_flag = 0; for (auto &amp;amp;prj : projs) { if (w &amp;gt;= ((prj.second).begin())-&amp;gt;first) { w += prj.first; prj.</description>
    </item>
    <item>
      <title>1138.alphabet board path</title>
      <link>http://localhost:1313/posts/leet/1138.alphabet-board-path/</link>
      <pubDate>Sun, 12 Feb 2023 19:14:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1138.alphabet-board-path/</guid>
      <description>Description 1138.alphabet-board-path&#xA;Solution Hash table.&#xA;Notice that we shouldn&amp;rsquo;t go left then go down or go right then go up.&#xA;Code class Solution { public: string alphabetBoardPath(string target) { string res; vector&amp;lt;int&amp;gt; cur_loc{0, 0}; vector&amp;lt;int&amp;gt; target_loc{0, 0}; // 要注意边缘的存在 for (auto &amp;amp;c : target) { target_loc[0] = (c - &amp;#39;a&amp;#39;) / 5; target_loc[1] = (c - &amp;#39;a&amp;#39;) % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col &amp;lt; 0) { res.</description>
    </item>
    <item>
      <title>1138.字母板上的路径</title>
      <link>http://localhost:1313/posts/leet/1138.alphabet-board-path.zh/</link>
      <pubDate>Sun, 12 Feb 2023 19:14:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1138.alphabet-board-path.zh/</guid>
      <description>问题描述 1138.字母板上的路径&#xA;解题思路 考虑到&amp;rsquo;z&amp;rsquo;单独在一个地方，因此移动顺序中，左下、右上不能反过来，即不能先往下再往左或者先往右再往上。&#xA;代码 class Solution { public: string alphabetBoardPath(string target) { string res; vector&amp;lt;int&amp;gt; cur_loc{0, 0}; vector&amp;lt;int&amp;gt; target_loc{0, 0}; // 要注意边缘的存在 for (auto &amp;amp;c : target) { target_loc[0] = (c - &amp;#39;a&amp;#39;) / 5; target_loc[1] = (c - &amp;#39;a&amp;#39;) % 5; int move_row = target_loc[0] - cur_loc[0]; int move_col = target_loc[1] - cur_loc[1]; cur_loc[0] = target_loc[0]; cur_loc[1] = target_loc[1]; if (move_col &amp;lt; 0) { res.insert(res.end(), -move_col, &amp;#39;L&amp;#39;); if (move_row &amp;gt;= 0) res.</description>
    </item>
    <item>
      <title>1604.alert using same key card three or more times in a one hour period</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/</guid>
      <description>Description 1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period&#xA;Solution Analog, hash table + sort.&#xA;Code class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>1604.警告一小时内使用相同员工卡大于等于三次的人</title>
      <link>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</link>
      <pubDate>Tue, 07 Feb 2023 13:55:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1604.alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.zh/</guid>
      <description>问题描述 1604.警告一小时内使用相同员工卡大于等于三次的人&#xA;解题思路 模拟，哈希表+排序&#xA;代码 class Solution { public: int to_min(string &amp;amp;s) { return ((s[0] - &amp;#39;0&amp;#39;) * 10 + s[1] - &amp;#39;0&amp;#39;) * 60 + (s[3] - &amp;#39;0&amp;#39;) * 10 + s[4] - &amp;#39;0&amp;#39;; } bool in_hour(vector&amp;lt;string&amp;gt; &amp;amp;time, int j) { return to_min(time[j]) - to_min(time[j - 2]) &amp;lt;= 60; } vector&amp;lt;string&amp;gt; alertNames(vector&amp;lt;string&amp;gt; &amp;amp;keyName, vector&amp;lt;string&amp;gt; &amp;amp;keyTime) { unordered_map&amp;lt;string, set&amp;lt;string&amp;gt;&amp;gt; name_time; vector&amp;lt;string&amp;gt; time; unordered_set&amp;lt;string&amp;gt; res; for (int i = 0; i &amp;lt; keyName.</description>
    </item>
    <item>
      <title>575.分糖果</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies.zh/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies.zh/</guid>
      <description>问题描述 575.分糖果&#xA;解题思路 最优思路为一种糖果只吃一颗。&#xA;代码 class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>575.distribute candies</title>
      <link>http://localhost:1313/posts/leet/575.distribute-candies/</link>
      <pubDate>Tue, 07 Feb 2023 12:42:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/575.distribute-candies/</guid>
      <description>Description 575.distribute-candies&#xA;Solution The optimal way is to eat only one candy for each kind of candy.&#xA;Code class Solution { public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int n = candyType.size(), res = n / 2; std::unordered_set&amp;lt;int&amp;gt; type; for (auto i : candyType) type.insert(i); return res &amp;lt; type.size() ? res : type.size(); } }; </description>
    </item>
    <item>
      <title>2331.evaluate boolean binary tree</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree/</guid>
      <description>Description 2331.evaluate-boolean-binary-tree&#xA;Solution dfs(recursion)&#xA;Code class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
    <item>
      <title>2331.计算布尔二叉树的值</title>
      <link>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</link>
      <pubDate>Mon, 06 Feb 2023 16:30:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2331.evaluate-boolean-binary-tree.zh/</guid>
      <description>问题描述 2331.计算布尔二叉树的值&#xA;解题思路 递归&#xA;代码 class Solution { public: bool dfs(TreeNode *root) { if (root-&amp;gt;left == nullptr) { return root-&amp;gt;val; } if (root-&amp;gt; val == 2) { return dfs(root-&amp;gt;left) || dfs(root-&amp;gt;right); } else { return dfs(root-&amp;gt;left) &amp;amp;&amp;amp; dfs(root-&amp;gt;right); } } bool evaluateTree(TreeNode* root) { return dfs(root); } }; </description>
    </item>
    <item>
      <title>553.optimal division</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division/</guid>
      <description>Description 553.optimal division&#xA;Solution Greedy algorithm&#xA;The optimal method is actually to bracket the penultimate elements.&#xA;Code class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.</description>
    </item>
    <item>
      <title>553.最优除法</title>
      <link>http://localhost:1313/posts/leet/553.optimal-division.zh/</link>
      <pubDate>Mon, 06 Feb 2023 15:52:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/553.optimal-division.zh/</guid>
      <description>问题描述 553.最优除法&#xA;解题思路 贪心，最优的除法实际上就是把第二个到最后一个元素括起来。&#xA;代码 class Solution { public: string optimalDivision(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string res; res += to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + &amp;#34;/&amp;#34; + to_string(nums[1]); return res; } res += &amp;#34;/(&amp;#34;; for (int i = 1; i &amp;lt; nums.size(); i++) { res += to_string(nums[i]); res.push_back(&amp;#39;/&amp;#39;); } res.pop_back(); res.push_back(&amp;#39;)&amp;#39;); return res; } }; </description>
    </item>
    <item>
      <title>配置 Sublime Text4为 C&#43;&#43; 编辑器</title>
      <link>http://localhost:1313/posts/blog/sublime_cpp.zh/</link>
      <pubDate>Mon, 06 Feb 2023 09:06:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/sublime_cpp.zh/</guid>
      <description>概述 涉及以下插件的安装和配置Package Control Terminus LSP LSP-clangd clang-format LSP-pyright LSP-json&#xA;配置sublime 安装Package Control以进行包管理。&#xA;Terminus 安装Terminus以实现sublime text4内的terminal。&#xA;绑定快捷键：&#xA;[ { &amp;#34;keys&amp;#34;: [ &amp;#34;ctrl+shift+t&amp;#34; ], &amp;#34;command&amp;#34;: &amp;#34;terminus_open&amp;#34;, &amp;#34;args&amp;#34;: { // 打开时要执行的命令 // &amp;#34;cmd&amp;#34;: &amp;#34;fish&amp;#34;, &amp;#34;cwd&amp;#34;: &amp;#34;${file_path:${folder}}&amp;#34; } } ] 自定义在Terminus的终端中编译运行cpp文件:&#xA;在Tools-&amp;gt;Build System-&amp;gt;New Build System中新建编译文件，保存为CppTerminus.sublime-build，替换内容为:&#xA;{ // MacOS &amp;#34;cmd&amp;#34;: [ &amp;#34;zsh&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;clang++ &amp;#39;${file}&amp;#39; -std=c++17 -stdlib=libc++ -o &amp;#39;${file_path}/../bin/${file_base_name}&amp;#39; &amp;amp;&amp;amp; ${file_path}/../bin/${file_base_name}&amp;#34; ], &amp;#34;file_regex&amp;#34;: &amp;#34;^(..{FNXX==XXFN}*):([0-9]+):?([0-9]+)?:? (.*)$&amp;#34;, &amp;#34;working_dir&amp;#34;: &amp;#34;${file_path}&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;utf-8&amp;#34;, &amp;#34;selector&amp;#34;: &amp;#34;source.c, source.c++&amp;#34;, &amp;#34;variants&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Run In Terminus&amp;#34;, &amp;#34;target&amp;#34;: &amp;#34;terminus_exec&amp;#34;, &amp;#34;cancel&amp;#34;: &amp;#34;terminus_cancel_build&amp;#34;, &amp;#34;cmd&amp;#34;: [ &amp;#34;zsh&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;clang++ &amp;#39;${file}&amp;#39; -std=c++17 -stdlib=libc++ -o &amp;#39;${file_path}/.</description>
    </item>
    <item>
      <title>1710.maximum units on a truck</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck/</guid>
      <description>Description 1710.maximum-units-on-a-truck&#xA;Solution Sort boxTypes by the units that the box can load, then put the box of which the units are maximum on the truck one by one.&#xA;The time complexity can be decreased to $O(n)$ by using quick select.&#xA;Code class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.</description>
    </item>
    <item>
      <title>1710.卡车上的最大单元数</title>
      <link>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:23:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1710.maximum-units-on-a-truck.zh/</guid>
      <description>问题描述 1710.卡车上的最大单元数&#xA;解题思路 根据每个箱子可以装载的单元数量从大到小对boxTypes排序，然后每次将单元数量最大的箱子填入卡车。&#xA;使用快速选择算法可以将时间复杂度降低到$O(n)$。&#xA;代码 class Solution { public: int maximumUnits(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;boxTypes, int truckSize) { std::sort(boxTypes.begin(), boxTypes.end(), [&amp;amp;](vector&amp;lt;int&amp;gt; vec1, vector&amp;lt;int&amp;gt; vec2) { return vec1[1] &amp;gt;= vec2[1]; }); int cnt = 0, sum = 0; for (int i = 0; i &amp;lt; boxTypes.size(); i++) { if (cnt + boxTypes[i][0] &amp;lt;= truckSize) { sum += boxTypes[i][0] * boxTypes[i][1]; cnt += boxTypes[i][0]; } else { sum += (truckSize - cnt) * boxTypes[i][1]; break; } } return sum; } }; </description>
    </item>
    <item>
      <title>1736.latest time by replacing hidden digits</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits/</guid>
      <description>Description 1736.latest-time-by-replacing-hidden-digits&#xA;Solution Analog + greedy algorithm&#xA;Code class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.</description>
    </item>
    <item>
      <title>1736.替换隐藏数字得到的最晚时间</title>
      <link>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:17:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1736.latest-time-by-replacing-hidden-digits.zh/</guid>
      <description>问题描述 1736.替换隐藏数字得到的最晚时间&#xA;解题思路 模拟+贪心&#xA;代码 class Solution { public: string maximumTime(string time) { string res; // 先考虑小时 if (time[0] == &amp;#39;?&amp;#39;) { if (time[1] == &amp;#39;?&amp;#39;) res += &amp;#34;23&amp;#34;; else { if (time[1] &amp;gt;= &amp;#39;4&amp;#39;) { res.push_back(&amp;#39;1&amp;#39;); res.push_back(time[1]); } else { res.push_back(&amp;#39;2&amp;#39;); res.push_back(time[1]); } } } else { if (time[1] == &amp;#39;?&amp;#39;) { if (time[0] == &amp;#39;2&amp;#39;) { res.push_back(time[0]); res.push_back(&amp;#39;3&amp;#39;); } else { res.push_back(time[0]); res.push_back(&amp;#39;9&amp;#39;); } } else { res.push_back(time[0]); res.</description>
    </item>
    <item>
      <title>1210.minimum moves to reach target with rotations</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations/</guid>
      <description>Description 1210.minimum-moves-to-reach-target-with-rotations&#xA;Solution BFS.&#xA;We can use (x, y state) to denote the position of the snake, x as the abscissa of the tail of the snake, y as the ordinate of the tail of the snake. state indicates whether the snake is vertical or horizontal.&#xA;Code class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.</description>
    </item>
    <item>
      <title>1210.穿过迷宫的最少移动次数</title>
      <link>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</link>
      <pubDate>Sun, 05 Feb 2023 17:03:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1210.minimum-moves-to-reach-target-with-rotations.zh/</guid>
      <description>问题描述 1210.穿过迷宫的最少移动次数&#xA;解题思路 广度优先搜索&#xA;可以用(x, y, state)来表示贪吃蛇当前所处的位置，x为蛇尾的横坐标，y为蛇尾的纵坐标，state表示蛇当前处于水平还是竖直状态。&#xA;代码 class Solution { public: bool is_pos(vector&amp;lt;int&amp;gt; &amp;amp;vec_tmp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid, int i) { if (i == 0) { vec_tmp[1] += 1; vec_tmp[3] += 1; if (vec_tmp[3] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0) return true; else return false; } } else if (i == 1) { vec_tmp[0] += 1; vec_tmp[2] += 1; if (vec_tmp[2] &amp;gt;= grid.size()) return false; else { if (grid[vec_tmp[0]][vec_tmp[1]] == 0 &amp;amp;&amp;amp; grid[vec_tmp[2]][vec_tmp[3]] == 0 &amp;amp;&amp;amp; vec_tmp[2] &amp;lt; grid.</description>
    </item>
    <item>
      <title>1798.maximum number of consecutive values you can make</title>
      <link>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make/</link>
      <pubDate>Sat, 04 Feb 2023 18:26:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make/</guid>
      <description>Description 1798.maximum-number-of-consecutive-values-you-can-make&#xA;Solution Greedy algorithm + dynamic programming&#xA;First, we sort the array in ascending orders. Let res[n] be the maximum value of consecutive integer that we can make by using the first n numbers.&#xA;if (coins[i - 1] &amp;gt; res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; Code class Solution { public: int getMaximumConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; coins) { std::sort(coins.begin(), coins.</description>
    </item>
    <item>
      <title>1798.你能构造出连续值的最大数目</title>
      <link>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make.zh/</link>
      <pubDate>Sat, 04 Feb 2023 18:26:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1798.maximum-number-of-consecutive-values-you-can-make.zh/</guid>
      <description>问题描述 1798.你能构造出连续值的最大数目&#xA;解题思路 贪心+动态规划&#xA;首先将数组按升序排序，令res[n]为前n个数所能构造出的连续整数的最大值:&#xA;if (coins[i - 1] &amp;gt; res[n - 1] + 1), res[n] = res[n - 1] + coins[i - 1]; else, res[n] = res[n - 1]; 代码 class Solution { public: int getMaximumConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; coins) { std::sort(coins.begin(), coins.end()); vector&amp;lt;int&amp;gt; res(coins.size() + 1, 0); // 表示前n个数能表示出来的最大值 for (int i = 1; i &amp;lt;= coins.size(); i++) { if (coins[i - 1] &amp;gt; res[i - 1] + 1) res[i] = res[i - 1]; else res[i] = res[i - 1] + coins[i - 1]; } return res[coins.</description>
    </item>
    <item>
      <title>768.max chunks to make sorted ii</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii/</guid>
      <description>Description 768.max-chunks-to-make-sorted-ii&#xA;Solution A sufficient condition for an array to be divisible into blocks that satisfy the condition is that all elements in the block are less than or equal to any of the undivided elements in the right-hand array.&#xA;Code class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.</description>
    </item>
    <item>
      <title>768.最多能完成排序的块 II</title>
      <link>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:21:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/768.max-chunks-to-make-sorted-ii.zh/</guid>
      <description>问题描述 768.最多能完成排序的块II&#xA;解题思路 可以划分成满足条件的块的充分必要条件是，块内所有元素都小于等于右侧数组中未划分的任一元素。&#xA;本题中使用了map来进行处理，实际上使用单调栈就可以了。&#xA;代码 class Solution { public: int maxChunksToSorted(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int idx = 0; // 表示划分arr int ans = 0; map&amp;lt;int, int, std::greater&amp;lt;int&amp;gt;&amp;gt; l_map; map&amp;lt;int, int&amp;gt; r_map; for (int i = 0; i &amp;lt; arr.size(); i++) r_map[arr[i]]++; while (idx &amp;lt; arr.size()) { for (int i = idx; i &amp;lt; arr.size(); i++) { l_map[arr[i]]++; r_map[arr[i]]--; if (r_map[arr[i]] == 0) r_map.erase(arr[i]); if (r_map.empty()) break; if (l_map.begin()-&amp;gt;first &amp;lt;= r_map.begin()-&amp;gt;first) { idx = i + 1; ans++; break; } } if (r_map.</description>
    </item>
    <item>
      <title>1145.binary tree coloring game</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game/</guid>
      <description>Description 1145.binary-tree-coloring-game&#xA;Solution Greedy algorithm: for second player, if he wants to win, there are three ways to color the node.&#xA;color the parent node of x, then we use dfs to get the number of red nodes, the number of blue nodes is $n$ minus the nubmer of red nodes; color the left child node of x, then we use dfs to get the number of blue nodes, the number of red nodes is $n$ minus the number of blue nodes; color the right child node of x Code class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root !</description>
    </item>
    <item>
      <title>1145.二叉树着色游戏</title>
      <link>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</link>
      <pubDate>Fri, 03 Feb 2023 14:10:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1145.binary-tree-coloring-game.zh/</guid>
      <description>问题描述 1145.二叉树着色游戏&#xA;解题思路 贪心策略：对二号玩家来说，想要取胜，选择染色节点只有三种可能：&#xA;选择x的父节点，则通过深度优先搜索可以求得红色节点数，蓝色节点数为$n$减去红色节点数 选择x的左子节点，则通过dfs可以求得蓝色节点数，红色节点数为$n$减去蓝色节点数 选择x的右子节点 代码 class Solution { public: int get_num(TreeNode *root) { // 获取当前树的节点数 if (root != nullptr) return get_num(root-&amp;gt;left) + get_num(root-&amp;gt;right) + 1; else return 0; } TreeNode *get_pos(int x, int n, TreeNode *root) { // 获取当前x对应的指针 if (root == nullptr) return nullptr; else { if (root-&amp;gt;val == x) return root; else { TreeNode *l = get_pos(x, n, root-&amp;gt;left); TreeNode *r = get_pos(x, n, root-&amp;gt;right); if (l !</description>
    </item>
    <item>
      <title>1877.minimize maximum pair sum in array</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array/</guid>
      <description>Description 1877.minimize-maximum-pair-sum-in-array&#xA;Solution Sort the array from smallest to largest, the smallest and largest pair, the next smallest and next largest pair, in that order. The result we need the maximum value of the sum of those pairs.&#xA;Code class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1877.数组中最大数对和的最小值</title>
      <link>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1877.minimize-maximum-pair-sum-in-array.zh/</guid>
      <description>问题描述 1877.数组中最大数对和的最小值&#xA;解题思路 贪心&#xA;将数组从小到大排序，最小最大配对，次小次大配对，依次配对，结果就是这些配对和的最大值。&#xA;代码 class Solution { public: int minPairSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { res = max(res, nums[i] + nums[nums.size() - 1 -i]); } return res; } }; </description>
    </item>
    <item>
      <title>1129.shortest path with alternating colors</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors/</guid>
      <description>Description 1129.shortest-path-with-alternating-colors&#xA;Solution First, we need represent the graph as an edge matrix, and we use bfs to find the shortest path.&#xA;In this problem, since the edge color of the shortest path must change along the path, when we judge whether the current node is visited, we should distinguish the cases that the current node is visited by red edges and the cases that the current node is visited by blue edges.</description>
    </item>
    <item>
      <title>1129.颜色交替的最短路径</title>
      <link>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</link>
      <pubDate>Thu, 02 Feb 2023 13:41:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1129.shortest-path-with-alternating-colors.zh/</guid>
      <description>问题描述 1129.颜色交替的最短路径&#xA;解题思路 首先，将本题的图结构以边表的形式表现出来，然后采取广度优先搜索的方式寻找最短路径，一般来说广度优先搜索能够保证找到的是最短路径。&#xA;在本题中，由于要求最短路径是交替出现的，那么在判断节点是否已经访问过时，要分红色路径访问节点和蓝色路径访问节点两种情况讨论。&#xA;队列中的元素为三元组tie(point, len, c_flag)，分别表示当前节点的索引、到达当前节点的路径长度（不一定是最短的，本题中存在环）、到达当前节点的路径颜色（0表示蓝色，1表示红色）&#xA;提示bfs(q, red_connect, blue_connect, answer, n)（其中q包含tie(0, 0, 0)和tie(0, 0, 1)）与bfs(q, red_connect, blue_connect, answer, n)执行两次（q分别为tie(0, 0, 0)和tie(0, 0, 1)）的结果是一样的。&#xA;代码 class Solution { public: void bfs(queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;red_connect, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;blue_connect, vector&amp;lt;int&amp;gt; &amp;amp;answer, int n, int i) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; visited(n, vector&amp;lt;int&amp;gt;(2, 0)); // visited[k][1]表示由红到point，visited[k][0]为1表示由蓝到point int tmp_point = 0; while (!q.empty()) { auto [point, len, c_flag] = q.front(); visited[point][c_flag] = 1; q.pop(); if (answer[point] == -1) answer[point] = len; else answer[point] = min(answer[point], len); if (c_flag == 0) { for (int k = 0; k &amp;lt; red_connect[point].</description>
    </item>
    <item>
      <title>2325.decode the message</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message/</guid>
      <description>Description 2325.decode-the-message&#xA;Solution We use arrya as a hash table, to keep track of the order in which the letter appear.&#xA;Code class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // -1 means the letter never appears, other value means the order in which the letter appears for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c !</description>
    </item>
    <item>
      <title>2325.解密消息</title>
      <link>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:57:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2325.decode-the-message.zh/</guid>
      <description>问题描述 2325.解密消息&#xA;解题思路 利用数组作为哈希表，记录每个字母是第几个出现的&#xA;代码 class Solution { public: string decodeMessage(string key, string message) { int cnt = 0; vector&amp;lt;int&amp;gt; arr(26, -1); // 为-1表示这个字母从未出现过，0，1，2等表示这个字母对应的解密字母 for (auto &amp;amp;c : key) { if (c != &amp;#39; &amp;#39;) { if (arr[c - &amp;#39;a&amp;#39;] == -1) { arr[c - &amp;#39;a&amp;#39;] = cnt++; // cnt++; } } } string res; for (auto &amp;amp;c : message) { if (c != &amp;#39; &amp;#39;) res.push_back(&amp;#39;a&amp;#39; + arr[c - &amp;#39;a&amp;#39;]); else res.</description>
    </item>
    <item>
      <title>1846.maximum element after decreasing and rearranging</title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging/</guid>
      <description>Description 1846.maximum-element-after-decreasing-and-rearranging&#xA;Solution Since we can reorder the element in the array as many times as we like, so we should sort the array first. If we want to find the possible maximum number of array whose the first element must be 1 and the absolute difference of any 2 adjacent differences must be less or equal to 1， so we can get arr[i] = min(i + 1, arr[i - 1] + 1).</description>
    </item>
    <item>
      <title>1846.减小和重新排列数组后的最大元素</title>
      <link>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</link>
      <pubDate>Wed, 01 Feb 2023 14:35:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1846.maximum-element-after-decreasing-and-rearranging.zh/</guid>
      <description>问题描述 1846.减小和重新排列数组后的最大元素&#xA;解题思路 由于题目允许我们重新排列数组中的元素任意次，因此首先将数组排序，根据arr中第一个元素必须为1，以及相邻两元素的差的绝对值小于等于1，可得arr[i] = min(i + 1, arr[i - 1] + 1)（因为我们要找arr可能的最大值），又因为不允许增大arr中的元素，所以arr[i] = min(arr[i], i + 1, arr[i - 1] + 1)。&#xA;代码 class Solution { public: int maximumElementAfterDecrementingAndRearranging(vector&amp;lt;int&amp;gt;&amp;amp; arr) { sort(arr.begin(), arr.end()); arr[0] = 1; for (int i = 1; i &amp;lt; arr.size(); i++) { arr[i] = min(arr[i - 1] + 1, min(arr[i], i + 1)); } return arr[arr.size() - 1]; } }; </description>
    </item>
    <item>
      <title>2319.check if matrix is X matrix</title>
      <link>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix/</link>
      <pubDate>Tue, 31 Jan 2023 09:50:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix/</guid>
      <description>Description 2319.check-if-matrix-is-X-matrix&#xA;Solution Analog&#xA;Code class Solution { public: bool checkXMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { bool res = true; for (int i = 0; i &amp;lt; grid.size(); i++) { for (int j = 0; j &amp;lt; grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>2319.判断矩阵是否是一个X矩阵</title>
      <link>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix.zh/</link>
      <pubDate>Tue, 31 Jan 2023 09:50:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2319.check-if-matrix-is-x-matrix.zh/</guid>
      <description>问题描述 2319.判断矩阵是否是一个X矩阵&#xA;解题思路 模拟&#xA;代码 class Solution { public: bool checkXMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;grid) { bool res = true; for (int i = 0; i &amp;lt; grid.size(); i++) { for (int j = 0; j &amp;lt; grid[0].size(); j++) { if (i == j || i + j == grid.size() - 1) { if (grid[i][j] == 0) return false; } else { if (grid[i][j] != 0) return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>1669.merge in between linked list</title>
      <link>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list/</link>
      <pubDate>Mon, 30 Jan 2023 12:22:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list/</guid>
      <description>Description 1669.merge-in-between-linked-list&#xA;Solution Analog&#xA;Code class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i &amp;lt; a - 1; i++) { head = head-&amp;gt;next; } for (int i = 0; i &amp;lt; b; i++) { head2 = head2-&amp;gt;next; } while (tail2-&amp;gt;next != nullptr) tail2 = tail2-&amp;gt;next; tail2-&amp;gt;next = head2-&amp;gt;next; head2-&amp;gt;next = nullptr; head-&amp;gt;next = list2; return list1; } }; </description>
    </item>
    <item>
      <title>1669.合并两个链表</title>
      <link>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list.zh/</link>
      <pubDate>Mon, 30 Jan 2023 12:22:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1669.merge-in-between-linked-list.zh/</guid>
      <description>问题描述 1669.合并两个链表&#xA;解题思路 模拟&#xA;代码 class Solution { public: ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2) { ListNode *head = list1; ListNode *tail2 = list2; ListNode *head2 = list1; for (int i = 0; i &amp;lt; a - 1; i++) { head = head-&amp;gt;next; } for (int i = 0; i &amp;lt; b; i++) { head2 = head2-&amp;gt;next; } while (tail2-&amp;gt;next != nullptr) tail2 = tail2-&amp;gt;next; tail2-&amp;gt;next = head2-&amp;gt;next; head2-&amp;gt;next = nullptr; head-&amp;gt;next = list2; return list1; } }; </description>
    </item>
    <item>
      <title>1817.finding the users active minutes</title>
      <link>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes/</link>
      <pubDate>Fri, 20 Jan 2023 13:01:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes/</guid>
      <description>Description 1817.finding-the-users-active-minutes&#xA;Solution We can use unordered_map&amp;lt;int, unordered_set&amp;lt;int&amp;gt;&amp;gt; mp to record the id and time_i that they operate.&#xA;We can use unordered_map&amp;lt;int, int&amp;gt; mins to record the minutes and their number of users.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; findingUsersActiveMinutes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; logs, int k) { unordered_map&amp;lt;int, unordered_set&amp;lt;int&amp;gt;&amp;gt; mp; for (auto &amp;amp;vec : logs) { mp[vec[0]].insert(vec[1]); } unordered_map&amp;lt;int, int&amp;gt; mins; int num = mp.size(); vector&amp;lt;int&amp;gt; ans(k, 0); for (auto iter = mp.begin(); iter !</description>
    </item>
    <item>
      <title>1817.查找用户活跃分钟数</title>
      <link>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes.zh/</link>
      <pubDate>Fri, 20 Jan 2023 12:32:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1817.finding-the-users-active-minutes.zh/</guid>
      <description>问题描述 1817. 查找用户活跃分钟数 (Medium)&#xA;给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDᵢ, timeᵢ] 表示 ID 为 IDᵢ 的用户在 timeᵢ 分钟时执行了某个操作。&#xA;多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。&#xA;指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。&#xA;请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（ 1 &amp;lt;= j &amp;lt;= k）， answer[j] 表示 用户活跃分钟数 等于 j 的用户数。&#xA;返回上面描述的答案数组 answer。&#xA;示例 1：&#xA;输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5 输出：[0,2,0,0,0] 解释： ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次） ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2 2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0 示例 2：</description>
    </item>
    <item>
      <title>1814.count nice pairs in an array</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</link>
      <pubDate>Tue, 17 Jan 2023 17:19:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array/</guid>
      <description>Description 1814.count-nice-pairs-in-an-array&#xA;Solution We can change the requirements to nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]).&#xA;Then we use hash tables to record the times of occurrence of the value.&#xA;Code class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>1814.统计一个数组中好对子的数目</title>
      <link>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</link>
      <pubDate>Tue, 17 Jan 2023 17:12:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1814.count-nice-pairs-in-an-array.zh/</guid>
      <description>问题描述 1814.统计一个数组中好对子的数目&#xA;解题思路 首先，变换一下题目的需求，nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])，然后利用哈希表记录每个值出现了多少次就可以了。&#xA;代码 class Solution { public: int rev(int num) { vector&amp;lt;int&amp;gt; tmp; int ans = 0; while (num != 0) { tmp.push_back(num % 10); num /= 10; } for (int i = 0; i &amp;lt; tmp.size(); i++) { ans = ans * 10 + tmp[i]; } return ans; } int countNicePairs(vector&amp;lt;int&amp;gt;&amp;amp; nums) { map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>位运算与集合</title>
      <link>http://localhost:1313/posts/tech/bit_operation.zh/</link>
      <pubDate>Thu, 05 Jan 2023 14:50:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/bit_operation.zh/</guid>
      <description>前言 在刷 LeetCode 的时候，我们常常碰到需要枚举同时选择几个元素，或者说枚举选择一个集合的情况，即同时选择 $\lbrace0, 1, 2\rbrace$ 或者 $\lbrace0, 1,3\rbrace$ 等，这里集合中的数字表示要选择的元素的索引。&#xA;通常情况下，我们往往会使用哈希表来表示集合，好处在于可以方便的在 $O(1)$ 时间内确定元素是否处于集合中，坏处则是当我们需要做集合之间的运算，例如求交集或者并集，那么就需要 $O(n)$ 时间才能实现；另一个缺陷就是，当递归函数的可变实参中存在哈希表（或者对哈希表的引用）时，无法通过添加 $cach$ 数组实现记忆化搜索。&#xA;于是，我们需要想一个新的办法来表示集合，由于集合可以由全集（包含所有元素的集合）中每个元素的选或者不选来表示，因此，很容易联想到二进制上每一位的 $0$ 和 $1$，例如 $101 = 5$ 表示集合中只有第 $0$ 个元素和第 $2$ 个元素。&#xA;使用数学化一点的语言，即集合可以以如下方式压缩成二进制下的一个数字：&#xA;$$f(S)=\sum\limits_{i\in S}2^i$$&#xA;其中 $i$ 表示集合中的元素在原数组中的索引。$\lbrace a[0], a[1], a[3]\rbrace$ 即可由 $2^0+2^1+2^3 = 13$ 即二进制数 $1101$ 表示。&#xA;集合与元素 根据上面提到的二进制表示集合的方法，我们可以在 $O(1)$ 的时间内实现集合与元素之间的运算。&#xA;具体运算表格参见灵神的 从集合论到位运算，常见位运算技巧分类总结！。 无需记忆，自己做题的时候很容易就能推导出来。&#xA;集合与集合 集合与集合之间的运算也可以在用二进制数表示集合的情况下，在 $O(1)$ 时间内完成计算。&#xA;具体运算表格同样参见灵神的 从集合论到位运算，常见位运算技巧分类总结！。&#xA;同样无需记忆，自己做题的时候很容易就能推导出来。&#xA;遍历集合 在集合用二进制数 $mask$ 表示的情况下，集合中的元素个数可以由 C++ 库函数 __builtin_popcount(mask) 计算出来。&#xA;设元素范围从 $0$ 到 $n - 1$，挨个判断元素是否在集合 $s$ 中：</description>
    </item>
    <item>
      <title>2042.check if numbers are ascending in a sentence</title>
      <link>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence/</link>
      <pubDate>Tue, 03 Jan 2023 16:34:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence/</guid>
      <description>Description 2042.check-if-numbers-are-ascending-in-a-sentence&#xA;Solution analog1 I change string s to &amp;quot; &amp;quot; + s + &amp;quot; &amp;quot;, then traverse the new string, check whether substr between two blanks is numbers;&#xA;analog2 We just check whether current char is a number, if that, num = num * 10 + s[i] - &#39;0&#39;, loop until current char is not a number.&#xA;Code code1 class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string &amp;amp;s) { int ans = 0; for (int i = l + 1; i &amp;lt; r; i++) { if (s[i] - &amp;#39;0&amp;#39; &amp;lt;= 9 &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt;= 0) { ans += mpow(s[i] - &amp;#39;0&amp;#39;, r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector&amp;lt;int&amp;gt; numbers; s = &amp;#34; &amp;#34; + s + &amp;#34; &amp;#34;; for (int i = 0; i &amp;lt; s.</description>
    </item>
    <item>
      <title>2042.检查句子中的数字是否递增</title>
      <link>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence.zh/</link>
      <pubDate>Tue, 03 Jan 2023 16:34:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/2042.check-if-numbers-are-ascending-in-a-sentence.zh/</guid>
      <description>问题描述 2042.检查句子中的数字是否递增&#xA;解题思路 模拟一 首先将字符串的首尾都加上空格，然后遍历即可，检查两次空格之间的字符串是否是数字，如果是就转化为数字;&#xA;模拟二 直接判断字符是否是数字，如果是数字，num = num * 10 + s[i] - &#39;0&#39;，循环直到碰到空格&#xA;代码 代码一 class Solution { public: int mpow(int e, int x) { while (x--) e *= 10; return e; } int str2num(int l, int r, string &amp;amp;s) { int ans = 0; for (int i = l + 1; i &amp;lt; r; i++) { if (s[i] - &amp;#39;0&amp;#39; &amp;lt;= 9 &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt;= 0) { ans += mpow(s[i] - &amp;#39;0&amp;#39;, r - i - 1); } else { return 0; } } return ans; } bool areNumbersAscending(string s) { int blank_l = 0; int blank_r = 0, tmp = 0; vector&amp;lt;int&amp;gt; numbers; s = &amp;#34; &amp;#34; + s + &amp;#34; &amp;#34;; for (int i = 0; i &amp;lt; s.</description>
    </item>
    <item>
      <title>847.shortest path visiting all nodes</title>
      <link>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes/</link>
      <pubDate>Mon, 02 Jan 2023 20:38:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes/</guid>
      <description>Description 847.shortest-path-visiting-all-nodes&#xA;Solution solution 1: bitmask + bfs For example, $(0101)_2$ means the nodes numbered 0 and 2 have been accessed, while nodes nubmered 1 and 3 have not been accessed.&#xA;bfs;&#xA;Array seen[x][mask_x] means whether node x and path mask_x have been accessed.&#xA;Code class Solution { public: int shortestPathLength(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) { int n = graph.size(); queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; seen(n, vector&amp;lt;int&amp;gt;(1 &amp;lt;&amp;lt; n)); for (int i = 0; i &amp;lt; n; i++) { q.</description>
    </item>
    <item>
      <title>847.访问所有节点的最短路径</title>
      <link>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes.zh/</link>
      <pubDate>Mon, 02 Jan 2023 20:38:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/847.shortest-path-visiting-all-nodes.zh/</guid>
      <description>问题描述 847.访问所有节点的最短路径&#xA;解题思路 方法一:状态压缩+bfs 状态压缩 由于本题中，n只有12，且状态只有访问和未访问两种，因此可以使用二进制表示法，利用int的低12位来代指点是否被访问过;&#xA;例如$(000&amp;hellip;0101)_2$表示编号为0和编号为2的节点已经被访问过，而编号为1和3的节点还没有被访问过;&#xA;假设mask存放了当前一系列点的访问状态，假如要检查编号为x的点是否被访问过，可以使用位运算a = (mask &amp;gt;&amp;gt; x) &amp;amp; 1来检查，如果a为1，那么访问过，为0表示未访问;&#xA;假设如果表示在x未被访问的情况下，要去访问x，那么mask_v = mask | (1 &amp;lt;&amp;lt; x)，其中mask_v表示更新后的状态二进制数。&#xA;代码 class Solution { public: int shortestPathLength(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) { int n = graph.size(); queue&amp;lt;tuple&amp;lt;int, int, int&amp;gt;&amp;gt; q; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; seen(n, vector&amp;lt;int&amp;gt;(1 &amp;lt;&amp;lt; n)); for (int i = 0; i &amp;lt; n; i++) { q.emplace(i, 1 &amp;lt;&amp;lt; i, 0); // 索引、二进制掩码、距离 seen[i][1 &amp;lt;&amp;lt; i] = 1; } int ans = 0; while (!</description>
    </item>
    <item>
      <title>1751.maximum Number of Events That Can Be Attended Ii</title>
      <link>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii/</link>
      <pubDate>Thu, 15 Dec 2022 18:10:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii/</guid>
      <description></description>
    </item>
    <item>
      <title>1751.最多可以参加的会议数目II</title>
      <link>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:09:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1751.maximum-number-of-events-that-can-be-attended-ii.zh/</guid>
      <description>问题描述 1751.最多可以参加的会议数目II&#xA;解题思路 动态规划+二分法 令dp[i][j]表示在前i个会议，最多参加j个会议，收获的最大价值:&#xA;考虑选择不参加events[i - 1]，dp[i][j] = dp[i - 1][j]; 选择参加events[i - 1]，dp[i][j] = dp[idx][j - 1] + events[i - 1][2]; 其中idx表示结束日期小于events[i - 1][0]且最接近events[i - 1][0]的会议的索引号，因此这里需要按照结束日期从小到大对events排序; 寻找idx可以使用二分查找; 二分查找要注意其中的不变量，即l左侧的值都小于target，r右侧的值都大于或等于target(这里是否等于取决于具体实现&amp;gt;=或者&amp;gt;)&#xA;代码 class Solution { public: int maxValue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;events, int k) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(events.size() + 1, vector&amp;lt;int&amp;gt;(k + 1, 0)); // 按照会议结束顺序排序 std::sort(events.begin(), events.end(), [](auto &amp;amp;a, auto &amp;amp;b) { return a[1] &amp;lt; b[1]; }); // for (int i = 1; i &amp;lt;= events.</description>
    </item>
    <item>
      <title>1945.sum of digits of string after convert</title>
      <link>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert/</link>
      <pubDate>Thu, 15 Dec 2022 18:06:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert/</guid>
      <description>Solution 1945.sum-of-digits-of-string-after-convert&#xA;Solution Code class Solution { public: int getLucky(string s, int k) { vector&amp;lt;int&amp;gt; num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - &amp;#39;a&amp;#39; + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i &amp;lt; k; i++) { while (sum !</description>
    </item>
    <item>
      <title>1945.字符串转化之后的各位数字之和</title>
      <link>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert.zh/</link>
      <pubDate>Thu, 15 Dec 2022 18:06:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1945.sum-of-digits-of-string-after-convert.zh/</guid>
      <description>问题描述 1945.字符串转化后的各位数字之和&#xA;解题思路 正常思路就好。&#xA;代码 class Solution { public: int getLucky(string s, int k) { vector&amp;lt;int&amp;gt; num; int tmp = 0; int sum = 0; for (char c : s) { tmp = c - &amp;#39;a&amp;#39; + 1; if (tmp / 10) { num.push_back(tmp / 10); sum += tmp / 10; } num.push_back(tmp % 10); sum += tmp % 10; } int res_sum = 0; for (int i = 1; i &amp;lt; k; i++) { while (sum !</description>
    </item>
    <item>
      <title>N1 Armbian</title>
      <link>http://localhost:1313/posts/blog/n1-armbian/</link>
      <pubDate>Fri, 09 Dec 2022 12:33:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/n1-armbian/</guid>
      <description></description>
    </item>
    <item>
      <title>N1 安装 Armbian 简单教程</title>
      <link>http://localhost:1313/posts/blog/n1-armbian.zh/</link>
      <pubDate>Fri, 09 Dec 2022 12:33:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/n1-armbian.zh/</guid>
      <description>前置 这一步非必须,如果之前 N1 已经刷了 OpenWrt 或者 Armbian 那么就不需要了,否则最好还是先刷入 webpad 的官改 V2.2 固件 解压后利用双公头 usb 线和 usb-burning-tool 刷入到 N1 中。&#xA;具体步骤如下：&#xA;usb-burning-tool 导入 webpad 2.2 线刷包，勾选 擦除 flash，取消勾选 擦除 bootloader； 点击 开始 按钮； 3 秒内让 N1 通电，识别成功自动开始刷入； 完成后拔电再上电，让 N1 重启； 当 N1 能正常开机之后，用鼠标开启 N1 的开发者模式（类似安卓手机，连续点击系统版本号即可）。&#xA;制作镜像 选择Armbian_23.02.0_amlogic_s905d_bullseye_6.0.11_server_2022.12.08.img.gz，下载好之后，解压，利用rufus刷入u盘。&#xA;安装 由于盒子在刷入armbian前为安卓系统，已开启adb，mac的终端执行adb connect 192.168.123.193连接无线adb，192.168.123.193修改成N1的实际的ip地址，然后执行adb reboot update(这些过程最好都在N1外接显示器的环境下进行)，在显示器黑屏的瞬间将前一步的u盘插入到靠近hdmi的usb接口;&#xA;接下来显示器会跑一系列starting xxx的服务，直到最后让login的时候，应该是要先输入用户名root，再输入1234(默认密码)，然后输入两次重复的自定义密码(如x12x12);&#xA;然后会让你创建用户，可以按Ctrl+C跳过;&#xA;当显示已经启动完成，让你再登录之后，输入用户名root和前一步的自定义密码x12x12，即可进入命令行，然后执行nand–sata-install命令将系统刷写进N1的emmc中。&#xA;新的 armbian 镜像的刷入命令改成了 armbian-install，见 github release 的说明&#xA;安装好后的配置 添加用户 执行 adduser zwyyy 创建用户并执行usermod -aG sudo username添加到sudo用户组，之后的命令都在zwyyy用户下执行;</description>
    </item>
    <item>
      <title>443.压缩字符串</title>
      <link>http://localhost:1313/posts/leet/443.string-compression.zh/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression.zh/</guid>
      <description>问题描述 443.压缩字符串&#xA;解题思路 双指针、滑动窗口，注意for循环中不需要fast++。&#xA;代码 class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.push_back(chars[slow]); res.push_back(cnt + &amp;#39;0&amp;#39;); } else if (cnt &amp;gt;= 10 &amp;amp;&amp;amp; cnt &amp;lt;= 99) { res.</description>
    </item>
    <item>
      <title>443.string compression</title>
      <link>http://localhost:1313/posts/leet/443.string-compression/</link>
      <pubDate>Thu, 08 Dec 2022 18:45:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/443.string-compression/</guid>
      <description>Description 443.string-compression&#xA;Solution Sliding window, please pay attention to that fast++ is not needed in for loop.&#xA;Code class Solution { public: int compress(vector&amp;lt;char&amp;gt;&amp;amp; chars) { vector&amp;lt;char&amp;gt; res; int cnt = 0; for (int slow = 0, fast = 0; fast &amp;lt; chars.size(); ) { while (fast &amp;lt; chars.size() &amp;amp;&amp;amp; chars[fast] == chars[slow]) fast++; cnt = fast - slow; if (cnt == 1) res.push_back(chars[slow]); else if (cnt &amp;gt; 1 &amp;amp;&amp;amp; cnt &amp;lt;= 9) { res.</description>
    </item>
    <item>
      <title>1812.determine color of a chessboard square</title>
      <link>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square/</link>
      <pubDate>Thu, 08 Dec 2022 16:00:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square/</guid>
      <description>Description 1812.determine color of a chessboard square&#xA;Solution Easy&#xA;Code class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - &amp;#39;a&amp;#39; + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>1812.判断国际象棋棋盘中一个格子的颜色</title>
      <link>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square.zh/</link>
      <pubDate>Thu, 08 Dec 2022 16:00:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1812.determine-color-of-a-chessboard-square.zh/</guid>
      <description>问题描述 1812.判断国际象棋棋盘中一个格子的颜色&#xA;解题思路 太简单了，不写&#xA;代码 class Solution { public: bool squareIsWhite(string coordinates) { if ((coordinates[0] - &amp;#39;a&amp;#39; + 1 - coordinates[1]) % 2 == 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>698.partition to k equal sum subsets</title>
      <link>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets/</link>
      <pubDate>Thu, 08 Dec 2022 15:47:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets/</guid>
      <description>Description 698.partition-to-k-equal-sum-subsets&#xA;Solution Sort array from large to small, so that we can avoid making mistake of judging arrays like [1, 1, 2, 2].&#xA;We use used[i] to avoid using the same element more than once, if sum == target, sum = 0, if cnt == k, than it can be devided.&#xA;Code class Solution { public: bool dfs(vector&amp;lt;int&amp;gt; &amp;amp;nums, int index, int sum, int target, int cnt, int k, vector&amp;lt;int&amp;gt; &amp;amp;used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); // pay attention to the `idx - 1` rather than `index - 1` } for (int i = index; i &amp;gt;= 0; i--) { if (used[i] || sum + nums[i] &amp;gt; target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k !</description>
    </item>
    <item>
      <title>698.划为k个相等的子集</title>
      <link>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets.zh/</link>
      <pubDate>Thu, 08 Dec 2022 15:47:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/698.partition-to-k-equal-sum-subsets.zh/</guid>
      <description>问题描述 698.划为k个相等的子集&#xA;解题思路 首先，对数组按照从大到小排序，相比从小到大排序，能避免[1, 1, 2, 2]这样的数组的误判;&#xA;利用used[i]数组避免重复使用同一个元素，如果sum == target，就将sum置零，如果cnt == k，说明满足条件。&#xA;代码 class Solution { public: bool dfs(vector&amp;lt;int&amp;gt; &amp;amp;nums, int index, int sum, int target, int cnt, int k, vector&amp;lt;int&amp;gt; &amp;amp;used, int idx) { if (cnt == k) return true; if (sum == target) { return dfs(nums, idx - 1, 0, target, cnt + 1, k, used, idx - 1); //注意这里是idex - 1而不是index - 1 } for (int i = index; i &amp;gt;= 0; i--) { if (used[i] || sum + nums[i] &amp;gt; target) continue; used[i] = 1; if (dfs(nums, i - 1, sum + nums[i], target, cnt, k, used, idx)) return true; used[i] = 0; if (sum == 0) return false; } return false; } bool canPartitionKSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { int sum = 0; for (int i : nums) sum += i; if (sum % k !</description>
    </item>
    <item>
      <title>438.find all anagrams in a string</title>
      <link>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string/</link>
      <pubDate>Wed, 07 Dec 2022 19:23:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string/</guid>
      <description>Description 438.find-all-anagrams-in-a-string&#xA;Solution Similar to 30.substring-with-concatenation-of-all-words, easier.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { unordered_map&amp;lt;char, int&amp;gt; mp; for (char &amp;amp;c : p) mp[c]++; vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;char, int&amp;gt; tmp = mp; for (int l = 0, r = 0; r &amp;lt; s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.</description>
    </item>
    <item>
      <title>438.找到字符串中所有字母异位词</title>
      <link>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string.zh/</link>
      <pubDate>Wed, 07 Dec 2022 19:23:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/438.find-all-anagrams-in-a-string.zh/</guid>
      <description>问题描述 438.找到字符串中所有字母异位词&#xA;解题思路 参照30.串联所有单词串，思路完全一致。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { unordered_map&amp;lt;char, int&amp;gt; mp; for (char &amp;amp;c : p) mp[c]++; vector&amp;lt;int&amp;gt; res; unordered_map&amp;lt;char, int&amp;gt; tmp = mp; for (int l = 0, r = 0; r &amp;lt; s.size(); r++) { if (tmp.find(s[r]) != tmp.end()) { tmp[s[r]]--; if (tmp[s[r]] == 0) { tmp.erase(s[r]); if (tmp.empty()) { res.push_back(l); tmp[s[l++]]++; } } } else { if (mp.find(s[r]) != mp.end()) { while (s[l] !</description>
    </item>
    <item>
      <title>93.restore ip addresses</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses/</guid>
      <description>Description 93.restore-ip-addresses&#xA;Solution Backtracking is actually changing a problem to one like a tree, and doing DFS(depth first search).&#xA;Code class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.</description>
    </item>
    <item>
      <title>93.复原ip地址</title>
      <link>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</link>
      <pubDate>Wed, 07 Dec 2022 15:17:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/93.restore-ip-addresses.zh/</guid>
      <description>问题描述 93.复原ip地址&#xA;解题思路 回溯实际上就是转化为树形问题，做深度优先遍历。&#xA;代码 class Solution { public: vector&amp;lt;string&amp;gt; res; string ip; bool check_ip(string &amp;amp;s) { if (s.size() &amp;gt; 3) return false; if (s[0] == &amp;#39;0&amp;#39;) { if (s.size() == 1) return true; else return false; } else { int num = stoi(s); if (num &amp;gt; 255) return false; else return true; } } void backtrack(string &amp;amp;s, int index, string ip, int cnt) { if (index &amp;gt;= s.size()) { if (cnt == 4) { ip.</description>
    </item>
    <item>
      <title>1775.equal sum arrays with minimum number of operations</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations/</guid>
      <description>Description 1775.equal-sum-arrays-with-minmum-number-of-operations&#xA;Solution hash table + greedy algorithm The general idea of this problem is hash + greedy algorithm.&#xA;Assuming that the sum1 minus sum2 to be diff and diff &amp;gt; 0, to reduce the difference of the sum of two arrays, we should make diff be value minus the maximum value of changing a number in one of the two array, and make the count of number changed minus 1, until diff &amp;lt; 0.</description>
    </item>
    <item>
      <title>1775.通过最少操作次数使数组的和相等</title>
      <link>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</link>
      <pubDate>Wed, 07 Dec 2022 14:53:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1775.equal-sum-arrays-with-minimum-number-of-operations.zh/</guid>
      <description>问题描述 1775.通过最少操作次数使数组的和相等&#xA;解题思路 哈希+贪心 本题总体思路为哈希+贪心，用两个数组mp1，mp2记录nums1，nums2中每个数各出现了多少次;&#xA;假设nums1的和sum1减去nums2的和sum2的结果为diff，这里假设diff &amp;gt; 0，为了抹平两个数组的和的差距，应该每次减去两个数组中，变化数字引起的数值变化的最大值，并且将变化的数字的计数值减一;&#xA;nums1的和小于nums2的和的情况类似。&#xA;优化 首先假设sum1 &amp;lt; sum2，否则我们交换nums1和nums2并交换sum1和sum2即可，接下来，必定是nums1缩小，nums2增大，对应diff = sum2 - sum1缩小，diff可以减少1,2,3,4,5各若干次，取决于nums1和nums2中原先各个数的数量，用一个哈希表来记录，最后我们从大到小遍历i = 5, 4, 3, 2, 1.&#xA;代码 hash + greedy algorithm class Solution { public: int find_min(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = 1; i &amp;lt; v.size(); i++) { if (v[i] != 0) return i; } return 6; } int find_max(vector&amp;lt;int&amp;gt; &amp;amp;v) { for (int i = v.size() - 1; i &amp;gt;= 1; i--) { if (v[i] !</description>
    </item>
    <item>
      <title>219.contains duplicate ii</title>
      <link>http://localhost:1313/posts/leet/219.contains-duplicate-ii/</link>
      <pubDate>Tue, 06 Dec 2022 20:00:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/219.contains-duplicate-ii/</guid>
      <description>Description 219.contains-duplicate-ii&#xA;Solution We can use unordered_map to record the number of ocurrence of each integer and slide window accrording the unordered_map.&#xA;Code class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] &amp;lt;= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; </description>
    </item>
    <item>
      <title>219.存在重复元素II</title>
      <link>http://localhost:1313/posts/leet/219.contains-duplicate-ii.zh/</link>
      <pubDate>Tue, 06 Dec 2022 20:00:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/219.contains-duplicate-ii.zh/</guid>
      <description>问题描述 219.存在重复元素II&#xA;解题思路 利用unordered_map记录元素出现的次数，使用滑动窗口法。&#xA;代码 class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; mp; for (int i = 0; i &amp;lt; nums.size(); i++) { if (mp.find(nums[i]) != mp.end()) { if (i - mp[nums[i]] &amp;lt;= k) return true; else mp[nums[i]] = i; } else { mp[nums[i]] = i; } } return false; } }; </description>
    </item>
    <item>
      <title>396.rotate function</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function/</guid>
      <description>Description 396. rotate-function&#xA;Solution The key is to find the mathematical laws&#xA;Code class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>396.旋转函数</title>
      <link>http://localhost:1313/posts/leet/396.rotate-function.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:52:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/396.rotate-function.zh/</guid>
      <description>问题描述 396.旋转函数&#xA;解题思路 关键在于找到数学规律&#xA;代码 class Solution { public: int maxRotateFunction(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; tmp(2 * nums.size(), 0); vector&amp;lt;int&amp;gt; res(nums.size(), 0); int sum = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { tmp[i] = nums[i]; tmp[i + nums.size()] = nums[i]; res[0] += i * nums[i]; sum += nums[i]; } int max_Fk = res[0]; for (int i = 1; i &amp;lt; nums.size(); i++) { res[i] = res[i - 1] + sum - (nums.</description>
    </item>
    <item>
      <title>1796.second largest digit in a string</title>
      <link>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string/</link>
      <pubDate>Tue, 06 Dec 2022 19:47:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string/</guid>
      <description>Description 1796.second-largest-digit-in-a-string&#xA;Solution Just traversing.&#xA;Code class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] &amp;lt;= &amp;#39;9&amp;#39;) { if (s[i] - &amp;#39;0&amp;#39; &amp;gt; first) { second = first; first = s[i] - &amp;#39;0&amp;#39;; } else if (s[i] - &amp;#39;0&amp;#39; &amp;lt; first &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt; second) second = s[i] - &amp;#39;0&amp;#39;; } } return second; } }; </description>
    </item>
    <item>
      <title>1796.字符串中第二大的数字</title>
      <link>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:47:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1796.second-largest-digit-in-a-string.zh/</guid>
      <description>问题描述 1796.字符串中第二大的数字&#xA;解题思路 遍历就好了&#xA;代码 class Solution { public: int secondHighest(string s) { int first = -1; int second = -1; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] &amp;lt;= &amp;#39;9&amp;#39;) { if (s[i] - &amp;#39;0&amp;#39; &amp;gt; first) { second = first; first = s[i] - &amp;#39;0&amp;#39;; } else if (s[i] - &amp;#39;0&amp;#39; &amp;lt; first &amp;amp;&amp;amp; s[i] - &amp;#39;0&amp;#39; &amp;gt; second) second = s[i] - &amp;#39;0&amp;#39;; } } return second; } }; </description>
    </item>
    <item>
      <title>1774.closest Dessert Cost</title>
      <link>http://localhost:1313/posts/leet/1774.closest-dessert-cost/</link>
      <pubDate>Tue, 06 Dec 2022 19:37:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1774.closest-dessert-cost/</guid>
      <description></description>
    </item>
    <item>
      <title>1774.最接近目标价格的甜点成本</title>
      <link>http://localhost:1313/posts/leet/1774.closest-dessert-cost.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:37:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1774.closest-dessert-cost.zh/</guid>
      <description>问题描述 1774.最接近目标价格的甜点成本&#xA;解题思路 回溯法 动态规划法 代码 回溯法 class Solution { public: // res表示存储的最接近target的成本，sum表示和 int traverse(vector&amp;lt;int&amp;gt; &amp;amp;toppingCosts, int target, int index, int sum, int res, vector&amp;lt;int&amp;gt; &amp;amp;cnt) { if (cnt[index] &amp;gt; 2) return res; if (sum &amp;gt;= target) { // 返回最接近的成本 if (abs(sum - target) &amp;lt; abs(target - res)) return sum; else if (abs(sum - target) == abs(target - res)) return min(res, sum); else return res; } for (int i = index; i &amp;lt; toppingCosts.</description>
    </item>
    <item>
      <title>1805.number of different integers in a string</title>
      <link>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string/</link>
      <pubDate>Tue, 06 Dec 2022 19:14:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string/</guid>
      <description>Descripiton 1805.number-of-different-integers-in-a-string&#xA;Solution Treating numbers as strings, save them in unordered_set, we need pay attention to pilot zero and the condition which last character is a number.&#xA;Code class Solution { public: int numDifferentIntegers(string word) { unordered_set&amp;lt;string&amp;gt; words; string str; for (int i = 0; i &amp;lt; word.size(); i++) { if (str.empty()) { if (word[i] - &amp;#39;0&amp;#39; &amp;lt;= 9) str.push_back(word[i]); } else { if (word[i] - &amp;#39;0&amp;#39; &amp;gt; 9) { if (words.</description>
    </item>
    <item>
      <title>1805.字符串中不同整数的数目</title>
      <link>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:14:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1805.number-of-different-integers-in-a-string.zh/</guid>
      <description>问题描述 1805.字符串中不同整数的数目&#xA;解题思路 把数字当作字符串处理，存入unordered_set(哈希表)中，注意最后一个字符是数字的情况。&#xA;代码 class Solution { public: int numDifferentIntegers(string word) { unordered_set&amp;lt;string&amp;gt; words; string str; for (int i = 0; i &amp;lt; word.size(); i++) { if (str.empty()) { if (word[i] - &amp;#39;0&amp;#39; &amp;lt;= 9) str.push_back(word[i]); } else { if (word[i] - &amp;#39;0&amp;#39; &amp;gt; 9) { if (words.find(str) == words.end()) words.insert(str); str.clear(); } else { if (str.size() == 1 &amp;amp;&amp;amp; str[0] == &amp;#39;0&amp;#39;) { // 去除先导0 str.clear(); } str.push_back(word[i]); } } } if (!</description>
    </item>
    <item>
      <title>131.palindrome patitioning</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning/</guid>
      <description>Description 131.palindrome-partitioning&#xA;Solution We can whether it is palindrome by dynamic programming: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;When traversing, pay attention to the order of traversing i;&#xA;Last, we use backtracking to update res.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.</description>
    </item>
    <item>
      <title>131.分割回文串</title>
      <link>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</link>
      <pubDate>Tue, 06 Dec 2022 19:01:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/131.palindrome-patitioning.zh/</guid>
      <description>问题描述 131.分割回文串&#xA;解题思路 利用动态规划来判断字符串是否是回文串: - if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1];&#xA;这里遍历的时候要注意i的遍历顺序;&#xA;最后考虑利用回溯法，更新答案。&#xA;代码 class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; vector&amp;lt;string&amp;gt; res_tmp; void track_back(string &amp;amp;s, int index, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) { if (index &amp;gt;= s.size()) { res.push_back(res_tmp); return; } for (int i = index; i &amp;lt; s.size(); i++) { if (dp[index][i]) { res_tmp.push_back(s.substr(index, i - index + 1)); track_back(s, i + 1, dp); res_tmp.pop_back(); } } return; } vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) { vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>3.longest substring without repeating characters</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters/</guid>
      <description>Description 3.longest-substring-withou-repeating-characters&#xA;Solution We use arr[96] to record the number of occurence of each character. If the number is larger than 1, than there is repeating character between l and r; else, update res, if current length of substr is larger than res.&#xA;Code class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.</description>
    </item>
    <item>
      <title>3.无重复字符的最长子串</title>
      <link>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</link>
      <pubDate>Mon, 05 Dec 2022 20:20:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/3.longest-substring-without-repeating-characters.zh/</guid>
      <description>问题描述 3.无重复字符的最长子串&#xA;解题思路 用arr[96]记录每个字符出现的次数，如果字符次数大于1，说明已经包含了重复字符，则要更新l，否则递增r，并记录最大的子串长度。&#xA;代码 class Solution { public: int lengthOfLongestSubstring(string s) { int arr[96] = {0}; int res = 0; int l = 0; for (int r = 0; r &amp;lt; s.size(); r++) { arr[s[r] - &amp;#39; &amp;#39;]++; if (arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) { while (l &amp;lt; r &amp;amp;&amp;amp; arr[s[r] - &amp;#39; &amp;#39;] &amp;gt; 1) arr[s[l++] - &amp;#39; &amp;#39;]--; } else { res = max(r - l + 1, res); } } return res; } }; </description>
    </item>
    <item>
      <title>30.substring with concatenation of all words</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words/</guid>
      <description>Description 30.substring-with-concatenation-of-all-words&#xA;Solution For each word sequence {s.substr(i, word_len), s.substr(i + word_len, word_len)...} of i($[0, word_len - 1]$), we use sliding window to judge;&#xA;We should pay attention to the detail when judging. We can use mp to determine whether substr is in words, and mp_tmp to determine whether it is concatenated substring, if mp is empty, then it is;&#xA;For key-value in mp_tmp, if value becomes 0, then erase(key);</description>
    </item>
    <item>
      <title>30.串联所有单词串</title>
      <link>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</link>
      <pubDate>Mon, 05 Dec 2022 19:55:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/30.substring-with-concatenation-of-all-words.zh/</guid>
      <description>问题描述 30.串联所有单词串&#xA;解题思路 首先，由于words中所有字符串长度相同，要比较words与s: - s从i = 0开始，可以划分为一系列的长为word_len = words[0].size()的单词; - s从i = 1开始，可以划分为一系列的长为word_len = words[0].size()的单词; - &amp;hellip;&amp;hellip; - s从i = word_len - 1开始&amp;hellip;&amp;hellip;&#xA;然后要注意利用unordered_map&amp;lt;string, int&amp;gt;判断是否满足条件的细节，mp用于判断word是否在words中;&#xA;mp_tmp的键值对中，如果值为0，就删掉该键;&#xA;还要注意l的处理，分为在mp_tmp为空，和mp_tmp不为空，但是word已经出现了超过words中的次数.&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; findSubstring(string s, vector&amp;lt;string&amp;gt; &amp;amp;words) { unordered_map&amp;lt;string, int&amp;gt; mp; int word_len = words[0].size(); int cnt = 0; vector&amp;lt;int&amp;gt; res; for (int i = 0; i &amp;lt; words.size(); i++) { mp[words[i]]++; cnt++; } if (cnt * word_len &amp;gt; s.</description>
    </item>
    <item>
      <title>1610.maximum Number of Visible Points</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points/</guid>
      <description>Descripiton 1610.maximum-number-of-visible-points&#xA;Soluiton We can use function atan2 to change slope to angle in $-\pi ~ \pi$.&#xA;We need also expand arrays, let angle[n + i] = angle[i] + 360, and the length of array to be 2 * n, so we can avoid omission.&#xA;Code class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>1610.可见点的最大数目</title>
      <link>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</link>
      <pubDate>Sun, 04 Dec 2022 19:42:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1610.maximum-number-of-visible-points.zh/</guid>
      <description>问题描述 1610.可见点的最大数目&#xA;解题思路 利用atan2函数，即可将斜率转化为$-\pi ~ \pi$的角度;&#xA;扩充数组，令angle[n + i] = angle[i] + 360，使角度数组长度为2 * n，这样就能避免遗漏一四象限。&#xA;代码 class Solution { public: int visiblePoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points, int angle, vector&amp;lt;int&amp;gt; &amp;amp;location) { vector&amp;lt;float&amp;gt; point_angle(points.size(), 0); for (int i = 0; i &amp;lt; points.size(); i++) { if (points[i][0] == location[0]) { if (points[i][1] &amp;gt; location[1]) point_angle[i] = 90; else if (points[i][1] == location[1]) point_angle[i] = 361; // 用来标记这是一个重叠的点 else point_angle[i] = -90; } else { point_angle[i] = atan2(points[i][1] - location[1], points[i][0] - location[0]) * 180 / M_PI; } } int cnt = 0; std::sort(point_angle.</description>
    </item>
    <item>
      <title>303.range sum query-immutable</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:58 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable/</guid>
      <description>Description 303.range-sum-query-immutable&#xA;Solution We can use prefix sum array, so we can get sum without traversing.&#xA;Code class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>303.区域和检索-数组不可变</title>
      <link>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:50:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/303.range-sum-query-immutable.zh/</guid>
      <description>问题描述 303.区域和检索-数组不可变&#xA;解题思路 利用前缀和数组，使得求区间和时无需再遍历数组求和。&#xA;代码 class NumArray { private: vector&amp;lt;int&amp;gt; sum; public: NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { sum.resize(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &amp;lt; nums.size(); i++) sum[i] = sum[i - 1] + nums[i]; } int sumRange(int left, int right) { if (left == 0) return sum[right]; return sum[right] - sum[left - 1]; } }; </description>
    </item>
    <item>
      <title>1769.minimum number of operation to ove ll balls to each box</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box/</guid>
      <description>Description 1769.minimum-number-of-operations-to-move-all-balls-to-each-box&#xA;Solution Violent solution: $\Theta(n^2)$&#xA;We could use prefix sum to reduce the time complexity.&#xA;nums[i] denotes the number of ball in first i + 1 boxes, res[i] is the minimum number of operation to ove ll balls to the i + 1th box, sum is the total number of balls. Compared to moving all balls to i th box, if we want to move all ball to the i + 1th box, the balls in 0 =&amp;gt; i - 1 all need move an additional step, while the balls in i =&amp;gt; n - 1 will move one step less.</description>
    </item>
    <item>
      <title>1769.移动所有球到每个盒子所需的最小操作数</title>
      <link>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</link>
      <pubDate>Fri, 02 Dec 2022 16:27:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1769.minimum-number-of-operation-to-move-all-balls-to-each-box.zh/</guid>
      <description>问题描述 1769.移动所有球到每个盒子所需的最小操作数&#xA;解题思路 暴力求解，时间复杂度为$\Theta(n^2)$;&#xA;可以考虑利用前缀和来降低时间复杂度: 设nums[i]是前i + 1个盒子里的球的总个数，res[i]为将所有球移到第i + 1个盒子里所需要的操作数，sum为球总个数，移到第i + 1个盒子相比移到第i个盒子，左边的球各要多移一步，右边的球各少移一步，因此有那么有:res[i] = res[i - 1] + nums[i - 1] - (sum - nums[i - 1])，&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; minOperations(string boxes) { vector&amp;lt;int&amp;gt; nums(boxes.size(), 0); int sum = boxes[0] - &amp;#39;0&amp;#39;; nums[0] = boxes[0] - &amp;#39;0&amp;#39;; for (int i = 1; i &amp;lt; boxes.size(); i++) { if (boxes[i] == &amp;#39;1&amp;#39;) { nums[i] = nums[i - 1] + 1; sum++; } else nums[i] = nums[i - 1]; } vector&amp;lt;int&amp;gt; res(boxes.</description>
    </item>
    <item>
      <title>424.longest repeating character replacement</title>
      <link>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement/</link>
      <pubDate>Tue, 29 Nov 2022 13:47:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement/</guid>
      <description>Description 424.longest-repeating-character-replacement&#xA;Solution First, note that if the substring can be turned into a substring containing only the same letters by substituing for k times, then there must be max_cnt + k &amp;gt;= subarray.size(); then the substring that does not satisfy the condition must have max_cnt + k &amp;lt; subarray.size(), and according to this, we can use the sliding window method;&#xA;If it satifies the condition, just right++, else right++, left++, so right - left must be incremental.</description>
    </item>
    <item>
      <title>424.替换后的最长重复字符</title>
      <link>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:47:51 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/424.longest-repeating-character-replacement.zh/</guid>
      <description>问题描述 424.替换后的最长重复字符&#xA;解题思路 首先，注意一点，子串如果能通过k次替换变成只包含相同字母的子串，那么一定有max_cnt + k &amp;gt;= subarray.size();那么不满足条件的子串一定有max_cnt + k &amp;lt; subarray.size()，根据这一点，我们可以采用滑动窗口法;&#xA;如果满足条件，那么只增加right，如果不满足条件，right++、left++，这样right - left一定是递增的，并且会遍历搜寻到所有的不同字符。&#xA;代码 class Solution { public: int characterReplacement(string s, int k) { vector&amp;lt;int&amp;gt; num(26); int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right &amp;lt; n) { num[s[right] - &amp;#39;A&amp;#39;]++; maxn = max(maxn, num[s[right] - &amp;#39;A&amp;#39;]); if (right - left + 1 - maxn &amp;gt; k) { num[s[left] - &amp;#39;A&amp;#39;]--; left++; } right++; } return right - left; } }; </description>
    </item>
    <item>
      <title>413.arithmetic slices</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices/</guid>
      <description>Descritpion 413.arithmetic slices&#xA;Solution We should notice that the number of subarray $cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$(len) is the length of arithmetic array.&#xA;Code class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>413.等差数列划分</title>
      <link>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</link>
      <pubDate>Tue, 29 Nov 2022 13:36:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/413.arithmetic-slices.zh/</guid>
      <description>问题描述 413.等差数列划分&#xA;解题思路 注意到子数组个数$cnt = len - 3 + 1 + len - 4 + 1 + &amp;hellip; + 1$，其中len是等差数组的长度，则cnt = (n - 1) * (n - 2) / 2，每次遍历找出连续的等差数组的长度即可。 测试test&#xA;代码 class Solution { public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt; &amp;amp;nums) { if (nums.size() &amp;lt; 3) return 0; int dif = nums[1] - nums[0]; int len = 2; int cnt = 0; for (int i = 2; i &amp;lt; nums.size(); i++) { if (nums[i] - nums[i - 1] == dif) len++; else { if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; len = 2; dif = nums[i] - nums[i - 1]; } } if (len &amp;gt;= 3) cnt += (len - 2) * (len - 1) / 2; return cnt; } }; </description>
    </item>
    <item>
      <title>88.merge sorted array</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array/</guid>
      <description>Description 88.merge-sorted-array&#xA;Solution We use pointers, assign values of nums1 from end to front, so we use only $\Theta(1)$ extra space.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>88.合并两个有序数组</title>
      <link>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</link>
      <pubDate>Mon, 28 Nov 2022 14:02:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/88.merge-sorted-array.zh/</guid>
      <description>问题描述 88.合并两个有序数组&#xA;解题思路 双指针，由于num1的长度是m + n，因此遍历时，可以考虑针对nums1，从后往前赋值，从而只需要$\Theta(1)$的额外空间。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int idx = m + n - 1; for (int idx = m + n - 1; idx &amp;gt;= 0; idx--) { if (p1 &amp;lt; 0) nums1[idx] = nums2[p2--]; else if (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p2 &amp;gt;= 0) { if (nums1[p1] &amp;gt; nums2[p2]) nums1[idx] = nums1[p1--]; else nums1[idx] = nums2[p2--]; } } } }; </description>
    </item>
    <item>
      <title>142.linked list cycle ii</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii/</guid>
      <description>Description 142.linked-list-cycle-ii&#xA;Solution Like 141.linked-list-cycle, when fast and slow meet each other, we make a pointer p start from virtual head node, traverse one by one, the same as slow. slow and p will meet at the entrance of the cycle.&#xA;Code class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead !</description>
    </item>
    <item>
      <title>142.环形链表II</title>
      <link>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</link>
      <pubDate>Mon, 28 Nov 2022 13:46:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/142.linked-list-cycle-ii.zh/</guid>
      <description>问题描述 142.环形链表II&#xA;解题思路 判断是否链表是否存在环的方式与141.环形链表一致，当两个指针相遇时，再让一个指针从虚拟头节点开始一个节点一个节点的遍历，slow指针也是，两个指针会在环的入口处相遇。&#xA;代码 class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) { while (vhead != slow) { vhead = vhead-&amp;gt;next; slow = slow-&amp;gt;next; } delete vhead; return slow; } } return nullptr; } }; </description>
    </item>
    <item>
      <title>141.linked list cycle</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle/</guid>
      <description>Description 141.linked-list-cycle&#xA;Solution We can use two pointers, one fast, one slow. For each time, fast move to next next node, slow move to next node. If there is cycle, fast will be equal to slow, or fast will be nullptr.&#xA;Code class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>141.环形链表</title>
      <link>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:09:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/141.linked-list-cycle.zh/</guid>
      <description>问题描述 141.环形链表&#xA;解题思路 使用快慢两个指针，fast一次移动两个节点，slow一次移动一个节点，如果链表存在环，那么fast和slow一定会有相等的时候，否则fast会运动到链表末尾。&#xA;代码 class Solution { public: bool hasCycle(ListNode *head) { ListNode *vhead = new ListNode(0, head); ListNode *fast = vhead, *slow = vhead; while (fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if (fast == slow) return true; } return false; } }; </description>
    </item>
    <item>
      <title>345.reverse vowels of a string</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string/</guid>
      <description>Description 345.reverse-vowels-of-a-string&#xA;Solution We use unordered_set to determine whether it is vowel, two pointers.&#xA;Code class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.</description>
    </item>
    <item>
      <title>345.反转字符串中的元音字母</title>
      <link>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</link>
      <pubDate>Sun, 27 Nov 2022 21:01:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/345.reverse-vowels-of-a-string.zh/</guid>
      <description>问题描述 345.反转字符串中的元音字母&#xA;解题思路 双指针法，使用unordered_set(底层实现为哈希表)来判断是否是元音字母。&#xA;代码 class Solution { public: string reverseVowels(string s) { unordered_set&amp;lt;char&amp;gt; mset{&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;U&amp;#39;}; int l = 0, r = s.size() - 1; while (l &amp;lt;= r) { if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) != mset.end()) { char tmp = s[l]; s[l++] = s[r]; s[r--] = tmp; } else if (mset.find(s[l]) != mset.end() &amp;amp;&amp;amp; mset.find(s[r]) == mset.end()) r--; else if (mset.</description>
    </item>
    <item>
      <title>75.sort colors</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors/</link>
      <pubDate>Fri, 25 Nov 2022 15:27:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors/</guid>
      <description>Description 75.sort-colors&#xA;Solution Here, we need three pointers l, r, idx, l for 0, r for 2, idx for traversing.&#xA;When traversing:&#xA;if nums[idx] == 0,swap(nums[idx], nums[l]);, and idx++; l++ if nums[idx] == 1, idx++; if nums[idx] == 2, swap(nums[idx], nums[r]);, and only r--, because new nums[idx] may be 0 or 1 or 2, so we need determine the value of nums[idx] again. if swap(nums[idx], nums[l]);, new nums[idx] will be 0 only when idx == l, or nums[idx] == 1, so we can increase idx.</description>
    </item>
    <item>
      <title>75.颜色分类</title>
      <link>http://localhost:1313/posts/leet/75.sort-colors.zh/</link>
      <pubDate>Fri, 25 Nov 2022 15:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/75.sort-colors.zh/</guid>
      <description>问题描述 75.颜色分类&#xA;解题思路 这里，我们需要三个指针l, r, idx, l用来存放0,r用来存放2，idx用来进行遍历数组。&#xA;要注意的是，在遍历数组时:&#xA;if nums[idx] == 0，需要交换nums[idx]和nums[l]的值，同时idx++; l++; if nums[idx] == 1，idx++即可 if nums[idx] == 2，需要交换nums[idx]和nums[l]的值，但此时只是r--，不会idx++，这是因为新的交换后的nums[idx]的值可能是0、1、2中的任意一个，因此还需要重新判断nums[idx] 如果idx == l，那么[0, idx]区间范围内的数都是0，如果idx != l，那么[0, l - 1]区间范围内都是0，[l, idx)区间范围内都是1，因此可以进行idx++; 代码 class Solution { public: void sortColors(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int tmp = 0, index = 0; int l = 0, r = nums.size() - 1; while (index &amp;lt;= r) { if (nums[index] == 0) { tmp = nums[l]; nums[l++] = 0; nums[index++] = tmp; } else if (nums[index] == 2) { tmp = nums[r]; nums[r--] = 2; nums[index] = tmp; } else index++; } } }; </description>
    </item>
    <item>
      <title>26.remove duplicates from sorted array</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array/</guid>
      <description>Description 26.remove-duplicates-from-sorted-array&#xA;Solution We use two pointers fast and slow, fast used to check if duplicated, slow use for assignment.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>26.删除有序数组中的重复项</title>
      <link>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</link>
      <pubDate>Thu, 24 Nov 2022 15:12:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/26.remove-duplicates-from-sorted-array.zh/</guid>
      <description>问题描述 26.删除有序数组中的重复项&#xA;解题思路 采用双指针法，一快一慢，fast用于检测是否重复，slow用来被赋值。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int fast = 1; int slow = 0; for (slow = 0; slow &amp;lt; nums.size(); slow++) { while (fast &amp;lt; nums.size() &amp;amp;&amp;amp; nums[fast] == nums[fast - 1]) fast++; if (fast == nums.size()) break; nums[slow + 1] = nums[fast++]; } return slow + 1; } }; </description>
    </item>
    <item>
      <title>18.4sum</title>
      <link>http://localhost:1313/posts/leet/18.4sum/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum/</guid>
      <description>Description 18.4sum&#xA;Solution Two pointers, i, j = i + 1, l = j + 1, r = nums.size() - 1;&#xA;Pay attention to overflow exception and deduplication.&#xA;Code class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    <item>
      <title>18.4四数之和</title>
      <link>http://localhost:1313/posts/leet/18.4sum.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:20:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/18.4sum.zh/</guid>
      <description>问题描述 18.四数之和&#xA;解题思路 双指针法，i, j = i + 1, l, r;&#xA;注意去重和溢出。&#xA;代码 class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { std::sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (nums.size() &amp;lt; 4) return res; for (int i = 0; i &amp;lt; nums.size() - 3; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j &amp;lt; nums.size() - 2; j++) { if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1]) continue; int l = j + 1, r = nums.</description>
    </item>
    <item>
      <title>19.remove nth node from end of list</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list/</guid>
      <description>Description 19.remove-nth-node-from-end-of-list&#xA;Solution For convenience, we create a virtual head node pre, pre-&amp;gt;next = head.&#xA;We will use two pointers fast and slow. First, fast go head for n times, then fast and slow go ahead together. When fast arrives at last node, slow points to the last node of the node we need delete.&#xA;Code class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next !</description>
    </item>
    <item>
      <title>19.删除链表的倒数第N个节点</title>
      <link>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</link>
      <pubDate>Wed, 23 Nov 2022 10:03:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/19.remove-nth-node-from-end-of-list.zh/</guid>
      <description>问题描述 19.删除链表的倒数第N个节点&#xA;解题思路 首先设置一个虚拟头节点pre，pre-&amp;gt;next = head;&#xA;双指针法，考虑使用两个指针fast，slow，一快一慢，fast指针先前进n个位置，然后fast和slow一起遍历，当fast到达最后一个节点的时候，slow刚好位于要删除的节点的前一个节点。&#xA;代码 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *pre = new ListNode(0, head); ListNode *fast = pre, *slow = pre; for (int i = 0; i &amp;lt; n; i++) { fast = fast-&amp;gt;next; } while (fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next; slow = slow-&amp;gt;next; } slow-&amp;gt;next = slow-&amp;gt;next-&amp;gt;next; return pre-&amp;gt;next; } }; </description>
    </item>
    <item>
      <title>16.3sum closest</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest/</guid>
      <description>Description 16.3sum-closest&#xA;Solution The violent solution: triple cycle, $\Theta(n^3)$&#xA;We should notice that we don&amp;rsquo;t care the original index of array, so we can use two pointers to reduce the time complexity.&#xA;First, we need sort the array, in outer loop, i iterates from 0 to nums.size() - 3, in inner loop, l and r come together from end to the middle.&#xA;Code class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.</description>
    </item>
    <item>
      <title>16.最接近的三数之和</title>
      <link>http://localhost:1313/posts/leet/16.3sum-closest.zh/</link>
      <pubDate>Mon, 21 Nov 2022 15:19:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/16.3sum-closest.zh/</guid>
      <description>问题描述 16.最接近的三数之和&#xA;解题思路 暴力解法，三重循环，时间复杂度为$\Theta(n^3)$;&#xA;注意到本题不关注数组中元素的初始索引，因此可以考虑利用双指针来降低时间复杂度: 首先将数组排序，最外层i从0遍历到nums.size() - 3，内层循环采用相向双指针l，r从两端向中间靠拢，并且要注意如何去重，(当然，此题可以不关注)。&#xA;代码 class Solution { private: int mcmp(int a, int b, int target) { if (abs(a - target) &amp;lt; abs(b - target)) return true; else return false; } public: int threeSumClosest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int res = 0; std::sort(nums.begin(), nums.end()); int sum = nums[0] + nums[1] + nums[2]; // 记录三数之和 for (int i = 0; i &amp;lt; nums.size() - 2; i++) { // 跳过重复的 if (i !</description>
    </item>
    <item>
      <title>Exponentiating by Squaring</title>
      <link>http://localhost:1313/posts/tech/exponentiating-by-squaring/</link>
      <pubDate>Sat, 19 Nov 2022 11:51:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/exponentiating-by-squaring/</guid>
      <description></description>
    </item>
    <item>
      <title>快速幂与快速乘</title>
      <link>http://localhost:1313/posts/tech/exponentiating-by-squaring.zh/</link>
      <pubDate>Sat, 19 Nov 2022 11:51:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/exponentiating-by-squaring.zh/</guid>
      <description>定义 快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $\Theta(\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $\Theta(n)$ 的时间。&#xA;这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。&#xA;解释 计算 $a$ 的 $n$ 次方表示将 $n$ 个 $a$ 乘在一起：$a^{n} = \underbrace{a \times a \cdots \times a}_{n\text{ 个 a}}$。然而当 $a,n$ 太大的时侯，这种方法就不太适用了。不过我们知道：$a^{b+c} = a^b \cdot a^c,,,a^{2b} = a^b \cdot a^b = (a^b)^2$。二进制取幂的想法是，我们将取幂的任务按照指数的 二进制表示 来分割成更小的任务。&#xA;过程 首先我们将 $n$ 表示为 2 进制，举一个例子吧：&#xA;$$ 3^{13} = 3^{(1101)_2} = 3^8 \cdot 3^4 \cdot 3^1 $$&#xA;因为 $n$ 有 $\lfloor \log_2 n \rfloor + 1$ 个二进制位，因此当我们知道了 $a^1, a^2, a^4, a^8, \dots, a^{2^{\lfloor \log_2 n \rfloor}}$ 后，我们只用计算 $\Theta(\log n)$ 次乘法就可以计算出 $a^n$。</description>
    </item>
    <item>
      <title>11.container with most water</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water/</link>
      <pubDate>Sat, 19 Nov 2022 09:46:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water/</guid>
      <description>Description 11.container-with-most-water&#xA;Solution The violent solution of this problem has a time complexity of $O(n^2)$, to reduce the time complexity, we consider two-pointers.&#xA;So, we need determine how left pointer l and right pointer r will meet each other:&#xA;if (height[l] &amp;gt;= height[r]), the capacity depends on height[r]. If l++, the capacity will become smaller, so we should r--. if (height[l] &amp;lt; height[r]), the capacity depends on height[l]. If r--, the capacity will become smaller, so we should l++.</description>
    </item>
    <item>
      <title>11.盛最多水的容器</title>
      <link>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</link>
      <pubDate>Sat, 19 Nov 2022 09:43:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/11.container-with-most-water.zh/</guid>
      <description>问题描述 11.盛最多水的容器&#xA;解题思路 本题暴力解法，时间复杂度为$O(n^2)$(会超时，没试过)，为了降低时间复杂度，考虑使用双指针。&#xA;那么，本题需要考虑的就是左指针l和右指针r如何向中间靠拢：&#xA;if (height[l] &amp;gt;= height[r])，说明容器容积是由height[r]来决定的，这时候，l向中间考虑，只可能会缩小容积，因此应该r--; if (height[l] &amp;lt; height[r])，说明容器容积由height[l]来决定，这时候，r向中间靠拢，只会缩小容积，因此应该l++; 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int l = 0, r = height.size() - 1; int res = 0; while (l &amp;lt; r) { if (height[l] &amp;gt;= height[r]) { res = max(res, (r - l) * height[r]); r--; // 因为此时，增加l只可能缩小res，所以减少r } else { res = max(res, (r - l) * height[l]); l++; // height[l] &amp;lt; height[r], 此时减少r也只会缩小res，所以增加l } } return res; } }; </description>
    </item>
    <item>
      <title>42.trapping rain water</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water/</guid>
      <description>Description 42.trapping-rain-water&#xA;Solution We can use monotone stack&#xA;The capacity of unit cosist of height[stk.top()] is (min(height[r], height[l]) - height[stk.top()]) * (l - r - 1), l is next element below the top of the stack, since height[l] &amp;gt;= height[stk.top()] r is the index of first column which height[r] &amp;gt;= height[stk.top()].&#xA;The result is the sum.&#xA;Code ```cpp #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.</description>
    </item>
    <item>
      <title>42.接雨水</title>
      <link>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</link>
      <pubDate>Thu, 17 Nov 2022 15:35:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/42.trapping-rain-water.zh/</guid>
      <description>问题描述 42.接雨水&#xA;解题思路 本题考虑使用单调栈(monotone stack)，栈顶到栈底依次递增。&#xA;由height[stk.top()]存放雨水的单元，其计算方式为(min(height[r], height[l]) - height[stk.top()]) * (l - r - 1)，其中l即栈顶的下一个元素，r则是第一个高度大于height[stk.top()]的柱子的索引。&#xA;结果为所有柱子能存放的雨水的累加。&#xA;代码 #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using std::stack; using std::vector; class Solution { public: int trap(vector&amp;lt;int&amp;gt; &amp;amp;height) { stack&amp;lt;int&amp;gt; stk; stk.push(0); int res = 0; for (int i = 1; i &amp;lt; height.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; height[i] &amp;gt; height[stk.top()]) { int mid = stk.top(); stk.pop(); if (!stk.empty()) { int h = min(height[i], height[stk.top()]) - height[mid]; int w = i - stk.</description>
    </item>
    <item>
      <title>Vercel 部署 Hugo</title>
      <link>http://localhost:1313/posts/blog/vercel_scilence.zh/</link>
      <pubDate>Wed, 16 Nov 2022 16:46:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/vercel_scilence.zh/</guid>
      <description>让 Vercel 部署 GitHub 项目成功时，不再自动发送邮件通知 在github项目根目录下新建vercel.json，内容为:&#xA;{ &amp;#34;github&amp;#34;: { &amp;#34;silent&amp;#34;: true } } Vercel 环境变量设置 Vercel 默认的 Hugo 版本可能很低，需要通过环境变量指定 Hugo 版本，如下：</description>
    </item>
    <item>
      <title>Install debian bookworm</title>
      <link>http://localhost:1313/posts/blog/debian_testing/</link>
      <pubDate>Sat, 12 Nov 2022 09:58:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/debian_testing/</guid>
      <description></description>
    </item>
    <item>
      <title>安装 Debian bookworm</title>
      <link>http://localhost:1313/posts/blog/debian_testing.zh/</link>
      <pubDate>Sat, 12 Nov 2022 09:58:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/debian_testing.zh/</guid>
      <description>配置语言环境 我在安装debian的时候，有个地方选择了HK，因此使用locale命令查看当前的区域相关设置时，显示为: 其中:LANG为默认的区域设置，该变量的值会覆盖所有未设置的LC_*变量的值;&#xA;要修改为en_US，首先执行sudo dpkg-reconfigure locales，然后选中en_US.UTF-8，取消en_HK那个，取消inherit的那个，还可以选中zh_CN.UTF-8，这样就启用了en_US.UTF-8和zh_CN.UTF-8;&#xA;由于我的桌面环境为KDE PLasma，其语言设置会覆盖locale.conf的设置，执行vim ~/.config/plasma-localerc，修改该文件为:&#xA;[Formats] LANG=en_US.UTF-8 LC_ADDRESS=en_US.UTF-8 LC_MEASUREMENT=en_US.UTF-8 LC_MONETARY=en_US.UTF-8 LC_NAME=en_US.UTF-8 LC_NUMERIC=en_US.UTF-8 LC_TELEPHONE=en_US.UTF-8 LC_TIME=en_US.UTF-8 [Translations] LANGUAGE=en_US:C:zh_CN 其中LANGUAGE为备用语言，很多软件并未将其英文locale设置为en或en_US，而是使用默认locale C。如果在LANGUAGE中将非英文locale设置到English之后，例如LANGUAGE=en_US:en:es_ES，那么即使英语字符存在，应用程序可能会选择使用后备locale，解决方法是强制在英语locale后面设置C，例如 LANGUAGE=en_US:en:C:es_ES。&#xA;fcitx-rime 安装fcitx-rime sudo apt install fcitx-rime&#xA;安装小鹤双拼 sudo apt-get install librime-data-double-pinyin&#xA;将小鹤双拼官方网盘，3.1-挂接&amp;ndash;音形码，小鹤音形鼠须管for macos里的default.custom.yaml复制到~/.config/fcitx/rime，并修改为:&#xA;patch: menu: page_size: 8 schema_list: - schema: flypy # 添加小鹤音形 - schema: double_pinyin_flypy - schema: luna_pinyin_simp key_binder/bindings: - when: paging accept: bracketleft send: Page_Up - when: has_menu accept: bracketright send: Page_Down - when: has_menu accept: minus send: Page_Up - when: has_menu accept: equal send: Page_Down 启动fcitx，按Ctrl+Space切换为fcitx，Ctrl+`切换选择输入方案。</description>
    </item>
    <item>
      <title>503.next Greater Element Ii</title>
      <link>http://localhost:1313/posts/leet/503.next-greater-element-ii/</link>
      <pubDate>Fri, 11 Nov 2022 16:59:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/503.next-greater-element-ii/</guid>
      <description></description>
    </item>
    <item>
      <title>503.下一个更大元素II</title>
      <link>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:59:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/503.next-greater-element-ii.zh/</guid>
      <description>问题描述 503.下一个更大元素II&#xA;解题思路 相比496.下一个更大元素I，在遍历数组上有所区别，如果i &amp;gt;= nums.size()，用j = i - nums.size();来代替i，因此i的取值范围是[0, 2 * nums.size())。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElements(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; res(nums.size(), -1); stack&amp;lt;int&amp;gt; stk; stk.push(0); int j = 0; for (int i = 1; i &amp;lt; 2 * nums.size(); i++) { if (i &amp;gt;= nums.size()) { j = i - nums.size(); while (!stk.empty() &amp;amp;&amp;amp; nums[j] &amp;gt; nums[stk.top()]) { res[stk.top()] = nums[j]; stk.pop(); } stk.push(j); } else { while (!</description>
    </item>
    <item>
      <title>496.next greater element i</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i/</guid>
      <description>Description 496.next-greater-element-i&#xA;Solution We can use monotone stack to traverse nums2, and use unordered_map to store the element in nums1 and corresponding result.&#xA;Code class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.</description>
    </item>
    <item>
      <title>496.下一个更大元素I</title>
      <link>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</link>
      <pubDate>Fri, 11 Nov 2022 16:45:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/496.next-greater-element-i.zh/</guid>
      <description>问题描述 496.下一个更大元素I&#xA;解题思路 本题利用单调栈(monotone stack)来遍历nums2，并且利用unordered_map来存储nums1中元素和对应的结果。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; nextGreaterElement(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { unordered_map&amp;lt;int, int&amp;gt; umap; stack&amp;lt;int&amp;gt; stk; for (int i = 0; i &amp;lt; nums1.size(); i++) { umap.insert({nums1[i], -1}); } stk.push(0); for (int i = 1; i &amp;lt; nums2.size(); i++) { while (!stk.empty() &amp;amp;&amp;amp; nums2[i] &amp;gt; nums2[stk.top()]) { if (umap.find(nums2[stk.top()]) != umap.end()) { umap[nums2[stk.top()]] = nums2[i]; } stk.pop(); } stk.push(i); } vector&amp;lt;int&amp;gt; res(nums1.size(), -1); for (int i = 0; i &amp;lt; nums1.</description>
    </item>
    <item>
      <title>miniconda 基础教程</title>
      <link>http://localhost:1313/posts/tech/miniconda.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:55:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/miniconda.zh/</guid>
      <description>创建python虚拟环境 安装python指定环境 conda create -n zwyb python=3.9&#xA;安装python指定环境的时候安装相应的包 conda create -n zwyb python=3.9 pandas&#xA;进入指定的环境 conda activate zwyb&#xA;退出当前环境 conda deactive zwyb&#xA;显示所有环境 conda env list&#xA;删除指定的环境 conda env remove -n zwyb&#xA;更换清华源 vim 编辑~/.condarc，将其中内容修改为&#xA;channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 更换pip源，执行 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple&#xA;关闭启动终端后自动进入conda环境 conda config --set auto_activate_base false</description>
    </item>
    <item>
      <title>monotone stack</title>
      <link>http://localhost:1313/posts/tech/monotone-stack/</link>
      <pubDate>Fri, 11 Nov 2022 15:55:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/monotone-stack/</guid>
      <description>Description brief Monotone stack is a stack whose elements(from top to bottom) are (strictly) monotonically increasing or decreasing.&#xA;Monotone increasing stack: the element which is smaller than the element in the top can be pushed into stack, else we will pop the element in the top, until the stack is empty or the element is smaller than the element in the top, then we push the element into the stack. This data structure is usually used for problems to find first element that is larger than certain element.</description>
    </item>
    <item>
      <title>单调栈</title>
      <link>http://localhost:1313/posts/tech/monotone-stack.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:54:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/monotone-stack.zh/</guid>
      <description>问题描述 简述 单调栈(monotone stack)是指栈内元素(栈顶到栈底)都是(严格)单调递增或者递减的栈。&#xA;单调递增栈(从栈顶到栈底)：只有比栈顶小的才能入栈，否把栈顶元素弹出，直到栈为空或者或者待处理的元素小于栈顶元素，将元素入栈，适用于求解第一个大于某元素的数的情况；&#xA;单调递减栈，与递增栈相反，适用于求解第一个小于某位置元素的数；&#xA;判断方法 单调递增/递减栈一般根据出栈后顺序来决定，例如栈内顺序[1, 2, 6]，出栈后顺序[6, 2, 1]，这就是单调递减栈。&#xA;哨兵技巧 对于有些时候，如果会用到数组的全部元素，即栈中的元素最后都要出栈，那么很可能因为没有考虑边界而无法通过。所以我们可以使用哨兵法。&#xA;例如在{1, 3, 4, 5, 2, 9, 6}末尾添加一个-1作为哨兵，变成了 {1, 3, 4, 5, 2, 9, 6, -1}，这种技巧可以简化代码逻辑。&#xA;例题 </description>
    </item>
    <item>
      <title>739.daily temperatures</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures/</guid>
      <description>Description 739.dail-temperatures&#xA;Solution We can consider monotone stack. If the stack is empty or the element to deal with is smaller than the element in the top of the stack, we can push the element to the stack, else we should pop the element in the top of the stack until the stack is empty or the element is smaller than the element in the top of the stack.&#xA;It&amp;rsquo;s convenient to push the index i into the stack.</description>
    </item>
    <item>
      <title>739.每日温度</title>
      <link>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</link>
      <pubDate>Fri, 11 Nov 2022 15:29:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/739.daily-temperatures.zh/</guid>
      <description>问题描述 739.每日温度&#xA;解题思路 考虑利用单调栈(monotone stack)来进行处理，如果栈为空或者要入栈的元素小于栈顶元素，那么该元素入栈，否则弹出栈顶元素直到栈为空，或者要入栈的元素小于栈顶元素，再将该元素入栈。&#xA;这里应该将数组索引i入栈会比较方便。&#xA;代码 class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt; &amp;amp;temperatures) { vector&amp;lt;int&amp;gt; res(temperatures.size(), 0); stack&amp;lt;int&amp;gt; st; st.push(0); for (int i = 1; i &amp;lt; temperatures.size(); i++) { int j = i; // if (!st.empty()) { while (!st.empty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[st.top()]) { res[st.top()] = i - st.top(); st.pop(); } st.push(i); // } } return res; } }; </description>
    </item>
    <item>
      <title>738.monotone increasing digits</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits/</guid>
      <description>Description 738.monotone-increasing-digits&#xA;Solution First, we need change the number to a vector&amp;lt;int&amp;gt; dec, for example:1234 to {1, 2, 3, 4}. Then we can traverse the vector, until dec[i] &amp;gt; dec[i + 1], then set dec[i + n] = 9(n &amp;gt;= 1). If dec[i] == dec[i - 1] == ... == dec[j], then dec[j]--, set others as 9, else dec[i]--;&#xA;Code class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n !</description>
    </item>
    <item>
      <title>738.单调递增的数字</title>
      <link>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</link>
      <pubDate>Mon, 07 Nov 2022 19:05:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/738.monotone-increasing-digits.zh/</guid>
      <description>问题描述 738.单调递增的数字&#xA;解题思路 将该数字的每一位数字变成数组dec&amp;lt;int&amp;gt;的一部分，然后依次遍历，直到dec[i] &amp;gt; dec[i + 1]，然后将dec[i + 1]及以后的数字都变成9，如果dec[i] == dec[i - 1] == ··· == dec[j]，就将dec[j]--，其余全设置为9。&#xA;代码 class Solution { private: void vec_dec(int n, vector&amp;lt;int&amp;gt; &amp;amp;res) { while (n != 0) { res.push_back(n % 10); n = n / 10; } } int ten(int i) { int res = 1; while (i != 0) { i--; res *= 10; } return res; } public: int monotoneIncreasingDigits(int n) { vector&amp;lt;int&amp;gt; dec; vec_dec(n, dec); std::reverse(dec.</description>
    </item>
    <item>
      <title>56.merge intervals</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals/</guid>
      <description>Description 56.merge-intervals&#xA;Solution The solution is similar to 452.minimum-number-of-arrows-to-burst-balloons, if there is common space, change the res.back()[1] to intervals[i][1], while intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); if there is not common space, res.push_back().&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>56.合并区间</title>
      <link>http://localhost:1313/posts/leet/56.merge-intervals.zh/</link>
      <pubDate>Sun, 06 Nov 2022 17:05:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/56.merge-intervals.zh/</guid>
      <description>问题描述 56.合并区间&#xA;解题思路 思路与452.用最少的箭引爆气球，只不过这里intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])，如果存在重叠，修改res最后一个元素的右端点值；如果不存在重叠，就往res里添加一个新的区间。&#xA;代码 class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; res.push_back(intervals[0]); for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i - 1][1] &amp;lt; intervals[i][0]) res.push_back(intervals[i]); else { intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]); res[res.size() - 1][1] = intervals[i][1]; } } return res; } }; </description>
    </item>
    <item>
      <title>763.partition labels</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels/</guid>
      <description>Description 763.partition-label&#xA;Solution solution 1 First, we need traverse the string, record the maximum index of each letter in the string.&#xA;Then we need declare a variable right to record the maximum index of letter traversed. When the maximum index is the same as current index, we can partition the string.&#xA;solution 2 First, we need traverse the string, record the number of occurrence of each letter, and record whether the letter occur.</description>
    </item>
    <item>
      <title>763.划分字母区间</title>
      <link>http://localhost:1313/posts/leet/763.partition-labels.zh/</link>
      <pubDate>Sat, 05 Nov 2022 17:11:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/763.partition-labels.zh/</guid>
      <description>问题描述 763.划分字母区间&#xA;解题思路 思路一 首先遍历一遍数组，记录每个字母在字符串中出现的最远位置。&#xA;声明一个变量right，用来记录已经遍历的字符中，最远的位置，当遍历到的位置与记录的最远位置重叠时，就说明可以划分数组了。&#xA;思路二 首先遍历一遍数组，记录每个字母出现的次数，并记录是否出现；&#xA;再遍历一次数组，当第一次碰到该字符时，该字符入栈，最后一次碰到该字符时，弹出栈顶的字符，栈空时，说明可以分割了。&#xA;代码 代码一 class Solution { public: vector&amp;lt;int&amp;gt; partitionLabels(string S) { int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置 for (int i = 0; i &amp;lt; S.size(); i++) { // 统计每一个字符最后出现的位置 hash[S[i] - &amp;#39;a&amp;#39;] = i; } vector&amp;lt;int&amp;gt; result; int left = 0; int right = 0; for (int i = 0; i &amp;lt; S.size(); i++) { right = max(right, hash[S[i] - &amp;#39;a&amp;#39;]); // 找到字符出现的最远边界 if (i == right) { result.</description>
    </item>
    <item>
      <title>基于 hugo 和 papermod 主题搭建自己的博客</title>
      <link>http://localhost:1313/posts/blog/create_blog_with_papermod.zh/</link>
      <pubDate>Fri, 04 Nov 2022 18:22:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/create_blog_with_papermod.zh/</guid>
      <description>部署博客到vercel FreeNom申请域名 首先，梯子最好选择美国的，并且freenom选择地址时最好与ip所在州可以对应得上； 进入FreeNom，输入zwyb.tk，然后点击检查可用性，这里要记得输入后缀，能避免点击现在获取显示不可用的问题。 如下图所示: Cloudfare管理域名 cloudfare添加站点zwyyy456.ml，然后添加DNS record，内容如下图所示： 下一步，进入freenom, Services-&amp;gt;My Domains-&amp;gt;Manage Domain-&amp;gt;Management Tools-&amp;gt;Nameservers，选择Use custom nameservers(enter blow)，填入cloudfare生成的nameservers。注意cloudfare的SSL/TLS策略必须是Full。&#xA;vercel部署博客和绑定域名 将整个项目，如papermod这个文件夹，作为一个git仓库上传到github，然后vercel创建新项目，选择continue with github，就能将对应的仓库导入到vercel，部署的时候注意添加Environment Variables&#xA;HUGO_VERSION 0.93.0 项目部署好之后，点击该项目，Settings-&amp;gt;Domains，添加之前FreeNom申请的域名，DNS record在上一步cloudfare管理域名那里已经添加过了。</description>
    </item>
    <item>
      <title>基于 Hugo 搭建自己的博客</title>
      <link>http://localhost:1313/posts/blog/create_blog_with_hugo.zh/</link>
      <pubDate>Fri, 04 Nov 2022 18:22:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/create_blog_with_hugo.zh/</guid>
      <description>前言 Hugo 是用 Go 语言写的静态网站生成器（Static Site Generator）。可以把 Markdown 文件转化成 HTML 文件，因此有很多人利用 Hugo 来搭建自己的博客网站。&#xA;安装 Hugo Mac 上，执行 brew install hugo，Win 上执行 scoop install hugo 即可。使用 hugo new site test-coder 即可创建博客，该命令会在当前目录创建一个名为 test-coder 的子目录，该目录就是创建的博客的源文件仓库。其中，test-coder 可以自行修改为你希望的名称。该目录中的内容如下：&#xA;test-coder on  main [+?] ❯ ls archetypes assets content data hugo.toml i18n layouts public resources static themes archetypes：存放 front matter 模板，hugo 命令创建 .md 文件时会根据该模板来创建； content：存放博客内容； layouts：存放定义为网站的样式，写在 layouts 目录下的样式文件会覆盖安装的主题中的 layouts 目录下的同名样式文件； static：存放静态文件，static 目录中的内容会在编译时会被移动到 public 目录，而本地的 public 目录对应着网站的根目录； public：存放 hugo 生成的静态网页； themes：存放主题文件； config.</description>
    </item>
    <item>
      <title>435.non overlapping intervals</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals/</guid>
      <description>Description 435.non-overlapping-intervals&#xA;Solution This problem is almost the same with 452.minimum-number-of-arrows-to-burst-balloons, the number intervals minus the result of 452.minimum-number-of-arrows-to-burst-balloons is the result of this problem.&#xA;Attention, [1, 3], [3, 5] is not overlapping intervals in this problem.&#xA;Code class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.</description>
    </item>
    <item>
      <title>435.无重叠区间</title>
      <link>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</link>
      <pubDate>Fri, 04 Nov 2022 09:35:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/435.non-overlapping-intervals.zh/</guid>
      <description>问题描述 435.无重叠区间&#xA;解题思路 本题和452.用最少数量的箭引爆气球可以说解题思路一模一样，区间数减去452.用最少数量的箭引爆气球就可以说是本题要求的答案，但是要注意的是，在本题中，区间端点相同是不认为重叠的。&#xA;代码 class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;lt; b[0]; } public: int eraseOverlapIntervals(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) { std::sort(intervals.begin(), intervals.end(), cmp); int cnt = 1; for (int i = 1; i &amp;lt; intervals.size(); i++) { if (intervals[i][0] &amp;gt;= intervals[i - 1][1]) cnt++; else { intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); } } return intervals.size() - cnt; } }; </description>
    </item>
    <item>
      <title>452.minimum number of arrows to burst balloons</title>
      <link>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons/</link>
      <pubDate>Thu, 03 Nov 2022 13:56:02 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons/</guid>
      <description>Description [452.minimum-number-of-arrows-to-burst-balloons]&#xA;Solution First, sort points array by x_start from smallest to largest, then we need analyze how many arrows we need.&#xA;if (points[i][0] &amp;gt; points[i - 1]), there is no common space between two balloons, we need to arrow, result++; else, then there is common space between two balloons, we need a new arrow. How about the next balloon? if (points[i + 1][0] &amp;gt; min(points[i - 1][1], points[i][1])), then we need new arrow; if not , we don&amp;rsquo;t need.</description>
    </item>
    <item>
      <title>452.用最少数量的箭引爆气球</title>
      <link>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</link>
      <pubDate>Thu, 03 Nov 2022 13:55:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/452.minimum-number-of-arrows-to-burst-balloons.zh/</guid>
      <description>问题描述 452.用最少数量的箭引爆气球&#xA;解题思路 首先，按照$x_start$从小到大的顺序排序，然后开始分析需要的弓箭数。&#xA;if (points[i][0] &amp;gt; points[i - 1])，说明两个气球不存在重叠，需要两支箭，箭数result++; else，说明两个气球存在重叠，只需要一支箭，但此时，如何判断下一个气球是否需要新的箭呢: if (points[i + 1][0] &amp;gt; min(points[i - 1][1], points[i][1]))，那么就需要新的箭，反之就不需要，因此，令points[i][1] = min(points[i - 1][1], points[i][1])。 代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::sort; using std::vector; class Solution { private: static bool cmp(vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { return a[0] &amp;lt; b[0]; } public: int findMinArrowShots(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;points) { int result = 1; sort(points.begin(), points.end(), cmp); for (int i = 1; i &amp;lt; points.size(); i++) { if (points[i - 1][1] &amp;lt; points[i][0]) result++; else { points[i][1] = min(points[i][1], points[i - 1][1]); } } return result; } }; </description>
    </item>
    <item>
      <title>Sort_in_cpp</title>
      <link>http://localhost:1313/posts/tech/sort_in_cpp/</link>
      <pubDate>Tue, 01 Nov 2022 15:14:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/sort_in_cpp/</guid>
      <description></description>
    </item>
    <item>
      <title>Sort_in_cpp</title>
      <link>http://localhost:1313/posts/tech/sort_in_cpp.zh/</link>
      <pubDate>Tue, 01 Nov 2022 15:14:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/sort_in_cpp.zh/</guid>
      <description></description>
    </item>
    <item>
      <title>406.queue reconstruction by height</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height/</guid>
      <description>Description 406.queue-reconstruction-by-height&#xA;Solution First, we need sort the vector by height, then do insertion according to ki.&#xA;When sorting, we need rewrite the comparing method, in reference to the use of sort() method in C++&#xA;Since there may be performance problem when doing insertion frequently in vector, we should use list based on linked list.&#xA;Code class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.</description>
    </item>
    <item>
      <title>406.根据身高重建队列</title>
      <link>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</link>
      <pubDate>Tue, 01 Nov 2022 15:07:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/406.queue-reconstruction-by-height.zh/</guid>
      <description>问题描述 406.根据身高重建队列&#xA;解题思路 首先根据身高对数组重新排序，再根据ki进行插入操作。&#xA;排序时，需要对排序的比较方法重写，参见C++ sort排序函数用法。&#xA;同时，考虑到基于使用vector来进行频繁的插入操作可能会存在性能问题，应该使用基于链表的list。&#xA;代码 class Solution { public: static bool cmp(const vector&amp;lt;int&amp;gt; &amp;amp;a, const vector&amp;lt;int&amp;gt; &amp;amp;b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;people) { sort(people.begin(), people.end(), cmp); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; queue; for (int i = 0; i &amp;lt; people.size(); i++) { int tmp = people[i][1]; queue.insert(tmp + queue.begin(), people[i]); } return queue; } }; class Solution { public: // 身高从大到小排（身高相同k小的站前面） static bool cmp(const vector&amp;lt;int&amp;gt;&amp;amp; a, const vector&amp;lt;int&amp;gt;&amp;amp; b) { if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; people) { sort (people.</description>
    </item>
    <item>
      <title>860.lemonade change</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change/</guid>
      <description>Description 860.lemonade-change&#xA;Solution We can create an array to show the number of $5, $10, $20. When the number of $5 is less than 0, return false. When we receive $20, we should provide change with $10 preferentially.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>860.柠檬水找零</title>
      <link>http://localhost:1313/posts/leet/860.lemonade-change.zh/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/860.lemonade-change.zh/</guid>
      <description>问题描述 860.柠檬水找零&#xA;解题思路 创建一个数组，表示手中的5元纸币、10元纸币、20元纸币的数目，当其中5元纸币数目小于0，说明无法找零，遇到20元纸币时，优先使用10元纸币找零。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool lemonadeChange(vector&amp;lt;int&amp;gt; &amp;amp;bills) { vector&amp;lt;int&amp;gt; num(3, 0); for (int i = 0; i &amp;lt; bills.size(); i++) { if (bills[i] == 5) num[0]++; else if (bills[i] == 10) { if (num[0] &amp;gt; 0) { num[0]--; num[1]++; } else { return false; } } else { if (num[1] &amp;gt; 0) { if (num[0] &amp;gt; 0) { num[1]--; num[0]--; } else return false; } else { if (num[0] &amp;gt; 2) num[0] -= 3; else return false; } } } return true; } }; </description>
    </item>
    <item>
      <title>135.candy</title>
      <link>http://localhost:1313/posts/leet/135.candy/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy/</guid>
      <description>Description 135.candy&#xA;Solution The key point of this problem is that we need traverse two times, one from front to back, the other from back to front.&#xA;Code class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // front to back for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // back to front for (int i = ratings.</description>
    </item>
    <item>
      <title>135.分发糖果</title>
      <link>http://localhost:1313/posts/leet/135.candy.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:33:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/135.candy.zh/</guid>
      <description>问题描述 135.分发糖果&#xA;解题思路 本题的关键在于，需要一次从前往后的遍历，第一次确定最少糖果数，同时还需要从后往前遍历，再一次确定最少糖果数。&#xA;代码 class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { vector&amp;lt;int&amp;gt; candyVec(ratings.size(), 1); // 从前向后 for (int i = 1; i &amp;lt; ratings.size(); i++) { if (ratings[i] &amp;gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // 从后向前 for (int i = ratings.size() - 2; i &amp;gt;= 0; i--) { if (ratings[i] &amp;gt; ratings[i + 1] ) { candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1); } } // 统计结果 int result = 0; for (int i = 0; i &amp;lt; candyVec.</description>
    </item>
    <item>
      <title>1005.maximize sum of array after k negations</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations/</guid>
      <description>Description 1005.maximize-sum-of-array-after-k-negations&#xA;Solution Greedy algorithm.&#xA;Code class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // first step for (int i = 0; i &amp;lt; A.size(); i++) { // second step if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // third step int result = 0; for (int a : A) result += a; // forth step return result; } }; </description>
    </item>
    <item>
      <title>1005.K次取反后的最大化的数组和</title>
      <link>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:28:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1005.maximize-sum-of-array-after-k-negations.zh/</guid>
      <description>问题描述 1005.K次取反后最大化的数组和&#xA;解题思路 贪心算法&#xA;代码 class Solution { static bool cmp(int a, int b) { return abs(a) &amp;gt; abs(b); } public: int largestSumAfterKNegations(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { sort(A.begin(), A.end(), cmp); // 第一步 for (int i = 0; i &amp;lt; A.size(); i++) { // 第二步 if (A[i] &amp;lt; 0 &amp;amp;&amp;amp; K &amp;gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步 int result = 0; for (int a : A) result += a; // 第四步 return result; } }; </description>
    </item>
    <item>
      <title>45.jump game ii</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii/</guid>
      <description>Description 45.jump-game-ii&#xA;Solution In outer loop, we traverse from back to front, while in inner loop, we traverse from front to back, to find the station with minimum index that can arrive at destination. Make the station the new destination, and cnt++.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>45.跳跃游戏II</title>
      <link>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:17:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/45.jump-game-ii.zh/</guid>
      <description>问题描述 45.跳跃游戏II&#xA;解题思路 外循环还是从末尾向前遍历，内循环从前往后遍历，每次找能到达终点的索引最小的位置，该位置作为新的终点，同时步数cnt++。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int jump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int cur_end = nums.size() - 1; int cnt = 0; while (cur_end != 0) { for (int i = 0; i &amp;lt; nums.size(); i++) { if (nums[i] + i &amp;gt;= cur_end) { cur_end = i; cnt++; break; } } } return cnt; } }; </description>
    </item>
    <item>
      <title>55.jump game</title>
      <link>http://localhost:1313/posts/leet/55.jump-game/</link>
      <pubDate>Sun, 30 Oct 2022 16:04:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game/</guid>
      <description>Description 55.jump-game&#xA;Solution Traversing from back to front, if nums[j] can be achieved from nums[j - 1] or nums in the front, then destination change from nums[j] to nums[j - 1] or num in the front.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r !</description>
    </item>
    <item>
      <title>55.跳跃游戏</title>
      <link>http://localhost:1313/posts/leet/55.jump-game.zh/</link>
      <pubDate>Sun, 30 Oct 2022 16:03:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/55.jump-game.zh/</guid>
      <description>问题描述 55.跳跃游戏&#xA;解题思路 从后向前遍历，只要nums[j]能由nums[j - 1]或者更前面的点跳到，那么终点就从nums[j]变成nums[j - 1]或更前面的点。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: bool canJump(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int r = nums.size() - 1; for (int i = nums.size() - 2; i &amp;gt;= 0; i--) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] + i &amp;gt;= r) { r = i; i--; } } if (r != 0) return false; else return true; } }; </description>
    </item>
    <item>
      <title>72.edit distance</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance/</guid>
      <description>Description 72.edit-distance&#xA;Solution It&amp;rsquo;s easy to consider what dp[i][j] should denotes.&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else, we can consider in three cases: replace the word1[i - 1]: dp[i][j] = dp[i - 1][j - 1] + 1; remove word1[i - 1]: dp[i][j] = dp[i - 1][j] + 1; insert word2[j - 1] between word[i - 1] and word[i], it&amp;rsquo;s the same as remove word2[j - 1]: dp[i][j] = dp[i][j - 1] + 1; We should also pay attention to the initialzation of dp[i][j].</description>
    </item>
    <item>
      <title>72.编辑距离</title>
      <link>http://localhost:1313/posts/leet/72.edit-distance.zh/</link>
      <pubDate>Sun, 30 Oct 2022 15:08:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/72.edit-distance.zh/</guid>
      <description>问题描述 72.编辑距离&#xA;解题思路 dp[i][j]的含义不再赘述:&#xA;if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else,分为三种操作情况: 替换末尾字符: dp[i][j] = dp[i - 1][j - 1] + 1; 删除word1的第i个字符: dp[i][j] = dp[i - 1][j] + 1; 删除word2的第j个字符，即相当于在第i个字符后插入word2[j - 1]: dp[i][j] = dp[i][j - 1] 代码 class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 1; i &amp;lt;= word1.</description>
    </item>
    <item>
      <title>583.delete operations for two strings</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings/</guid>
      <description>Description 583.delete-operation-for-two-strings&#xA;Solution dp[i][j] denotes minimum number of options to make strings the same when considering the first i characters of word1 and the first j characters of word2.&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; Code class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.</description>
    </item>
    <item>
      <title>583.两个字符串的删除操作</title>
      <link>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:58:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/583.delete-operations-for-two-strings.zh/</guid>
      <description>问题描述 583.两个字符串的删除操作&#xA;解题思路 dp[i][j]表示对word1的前i个字符，word2的前j个字符，使得它们相同的最小步数:&#xA;if (word1[i - 1] == word2[j - 1]), dp[i][j] = dp[i - 1][j - 1]; else, dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; 代码 class Solution { public: int minDistance(string word1, string word2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(word1.size() + 1, vector&amp;lt;int&amp;gt;(word2.size() + 1, 0)); for (int i = 0; i &amp;lt;= word1.size(); i++) { dp[i][0] = i; } for (int j = 0; j &amp;lt;= word2.</description>
    </item>
    <item>
      <title>115.distinct subsequences</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences/</guid>
      <description>Description 115.distinct-subsequence&#xA;Solution dp[i][j] denotes the occurrences of the first j characters of t in the first i characters of s:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(uses[i - 1] and not use s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; Code class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.</description>
    </item>
    <item>
      <title>115.不同的子序列</title>
      <link>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:46:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/115.distinct-subsequences.zh/</guid>
      <description>问题描述 115.不同的子序列&#xA;解题思路 dp[i][j]表示考虑考虑t的前j个字符在s的前i个字符中的出现个数:&#xA;if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];(表示使用s[i - 1]匹配和不使用s[i - 1]匹配) else dp[i][j] = dp[i - 1][j]; 代码 class Solution { public: int numDistinct(string s, string t) { if (s.size() &amp;lt; t.size()) return 0; vector&amp;lt;vector&amp;lt;uint32_t&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;uint32_t&amp;gt;(t.size() + 1, 0)); // dp[0][0] = 1; for (int i = 0; i &amp;lt;= s.size(); i++) { dp[i][0] = 1; } for (int i = 1; i &amp;lt;= s.</description>
    </item>
    <item>
      <title>392.is subsequence</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence/</guid>
      <description>Description 392.is-subsequence&#xA;Solution It&amp;rsquo;s similar to 1143.longest-common-subsequence. We just need to judge whether the result is equal to s.size().&#xA;Code class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>392.判断子序列</title>
      <link>http://localhost:1313/posts/leet/392.is-subsequence.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:40:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/392.is-subsequence.zh/</guid>
      <description>问题描述 392.判断子序列&#xA;解题思路 与1143.最长公共子序列基本一样，只需要再判断结果是否和s.size()相等就好了。&#xA;代码 class Solution { public: bool isSubsequence(string s, string t) { if (s.size() &amp;gt; t.size()) return false; else { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.size() + 1, vector&amp;lt;int&amp;gt;(t.size() + 1, 0)); for (int i = 1; i &amp;lt;= s.size(); i++) { for (int j = 1; j &amp;lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[s.</description>
    </item>
    <item>
      <title>53.maximum subarray</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray/</link>
      <pubDate>Sun, 30 Oct 2022 14:30:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray/</guid>
      <description>Description 53.maximum-subarray&#xA;Solution dp[i] denotes maximum sum of subarray ending with nums[i - 1], then: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;Code class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>53.最大子数组和</title>
      <link>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</link>
      <pubDate>Sun, 30 Oct 2022 14:26:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/53.maximum-subarray.zh/</guid>
      <description>问题描述 53.最大子数组和&#xA;解题思路 动态规划 令dp[i]表示以nums[i - 1]结尾的连续子数组的最大和，则: dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]);&#xA;贪心算法 以第一个正数为起点，开始记录和sum_temp，同时记录最大和sum，当sum_temp小于0时，起点变为新的正数。&#xA;代码 class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; int m = nums[0]; for (int i = 1; i &amp;lt;= nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1]); if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>1035.uncrossed lines</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines/</link>
      <pubDate>Sat, 29 Oct 2022 20:45:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines/</guid>
      <description>Description 1035.uncrossed-lines&#xA;Solution The same as 1143.longest-common-subsequence&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1035.不相交的线</title>
      <link>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:44:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1035.uncrossed-lines.zh/</guid>
      <description>问题描述 1035.不相交的线&#xA;解题思路 只是1143.最长公共子序列的另一种描述&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[nums1.</description>
    </item>
    <item>
      <title>1143.longest common subsequence</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence/</guid>
      <description>Description 1143.longest-common-subsequence&#xA;Solution dp[i][j] denotes the length of longest common subsequence of first i characters of text1 and first j characters of text2:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.</description>
    </item>
    <item>
      <title>1143.最长公共子序列</title>
      <link>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:33:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1143.longest-common-subsequence.zh/</guid>
      <description>问题描述 1143.最长公共子序列&#xA;解题思路 dp[i][j]表示text1的前i个字符和text2的前j个字符里最长公共子序列长度:&#xA;if (text[i - 1] == text2[j - 1]), dp[i][j] = dp[i - 1][j - 1] + 1; if (text[i - 1] != text2[j - 1]), dp[i][j] = max(dp[i - 1][j], dp[i][j - ]); 代码 #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(text1.size() + 1, vector&amp;lt;int&amp;gt;(text2.size() + 1, 0)); int m = 0; int res = 0; for (int i = 1; i &amp;lt;= text1.</description>
    </item>
    <item>
      <title>134.gas station</title>
      <link>http://localhost:1313/posts/leet/134.gas-station/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station/</guid>
      <description>Description 134.gas-station&#xA;Solution We should consider total oil consumption total_oil, and remaining oil from new start station cur_oil(not replenish oil in new station):&#xA;total_oil &amp;lt; 0, can&amp;rsquo;t complete; cur_oil &amp;lt; 0, start at the new station; Code class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //total_oil need &amp;gt; 0, or can&amp;#39;t complete total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // start from i + 1 starting_station = i + 1; // restore to first state cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
    <item>
      <title>134.加油站</title>
      <link>http://localhost:1313/posts/leet/134.gas-station.zh/</link>
      <pubDate>Sat, 29 Oct 2022 20:04:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/134.gas-station.zh/</guid>
      <description>问题描述 134.加油站&#xA;解题思路 考虑两个变量，一个是总油耗total_oil，一个是从起点到下一个站点后汽车内部剩余的汽油cur_oil(没有在目标站点补充油耗)。 总油耗total_oil &amp;lt; 0，说明不可能到; cur_oil &amp;lt; 0，则以到达的站点作为新的起点再出发;&#xA;代码 class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; int total_tank = 0; int curr_tank = 0; int starting_station = 0; for (int i = 0; i &amp;lt; n; ++i) { //总和必须大于等于0，否则不能完成绕行 total_oil += gas[i] - cost[i]; cur_oil += gas[i] - cost[i]; if (curr_tank &amp;lt; 0) { // 一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。 starting_station = i + 1; // 还原到初始状态 cur_oil = 0; } } return total_oil &amp;gt;= 0 ?</description>
    </item>
    <item>
      <title>718.maximum length of repeated subarray</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray/</guid>
      <description>Description 718.maximum-length-of-repeated-subarray&#xA;Solution dp[i][j] denotes the length of longest public subarray of two subarray ending with nums1[i - 1], nums2[j - 1];&#xA;Recurrence formula&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; Code class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.</description>
    </item>
    <item>
      <title>718.最长重复子数组</title>
      <link>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</link>
      <pubDate>Mon, 17 Oct 2022 21:06:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/718.maximum-length-of-repeated-subarray.zh/</guid>
      <description>问题描述 718.最长重复子数组&#xA;解题思路 dp[i][j]表示分别以nums1[i - 1], nums2[j - 1]结尾的两个子数组的最长公共子数组的长度；&#xA;递推关系:&#xA;if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; 代码 class Solution { public: int findLength(vector&amp;lt;int&amp;gt; &amp;amp;nums1, vector&amp;lt;int&amp;gt; &amp;amp;nums2) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums1.size() + 1, vector&amp;lt;int&amp;gt;(nums2.size() + 1, 0)); int m = 0; for (int i = 1; i &amp;lt;= nums1.size(); i++) { for (int j = 1; j &amp;lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) // dp[i][j] = max(dp[i - 1][j - 1] + 1, dp[i][j]); dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] &amp;gt; m) m = dp[i][j]; } } return m; } }; </description>
    </item>
    <item>
      <title>674.longest continuous increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence/</guid>
      <description>Description 674.longest-continuous-increasing-subsequence&#xA;Solution dp[i] denotes the length of longest continuous increasing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; Code class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>674.最长连续递增序列</title>
      <link>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:50:40 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/674.longest-continuous-increasing-subsequence.zh/</guid>
      <description>问题描述 674.最长连续递增序列&#xA;解题思路 dp[i]表示以nums[i - 1]结尾的最长连续递增子序列长度;&#xA;递推关系为:&#xA;if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; 代码 class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); int m = 1; for (int i = 2; i &amp;lt;= nums.size(); i++) { if (nums[i - 1] &amp;gt; nums[i - 2]) dp[i] = dp[i - 1] + 1; if (dp[i] &amp;gt; m) m = dp[i]; } return m; } }; </description>
    </item>
    <item>
      <title>300.longest increasing subsequence</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence/</guid>
      <description>Description 300.longest-increasing-subsequence&#xA;Solution The key point is: what dp[i] means is conducive to solving this problem. Since subsequence may be not continuous, dp[i] should denotes maximum length increaing subsequence ending with nums[i - 1];&#xA;Recurrence formula:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; i dp[i] = max(dp[j] + 1, dp[i]) Code class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // initialize dp[i] as 1 since there is one element at least // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>300.最长递增子序列</title>
      <link>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</link>
      <pubDate>Mon, 17 Oct 2022 19:35:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/300.longest-increasing-subsequence.zh/</guid>
      <description>问题描述 300.最长递增子序列 本题简写为LIS问题，与LCS问题（最长公共子序列）相对。&#xA;解题思路 动态规划 关键在于，dp[i]表示什么含义便于解这道题，子序列不一定连续，所以为了便于求解，dp[i]应该表示为以nums[i - 1]结尾的最长严格递增子序列的长度；&#xA;递推关系为:&#xA;if (nums[i - 1] &amp;gt; nums[j - 1]) // j &amp;lt; i，表示nums[i - 1]前的任意一个元素 dp[i] = max(dp[j] + 1, dp[i]) 贪心 动态规划的时间复杂度为$O(n^2)$，这里存在一个时间复杂度更低的贪心解法：&#xA;动态规划的时间$O(n^2)$的时间复杂度中，$O(n)$的时间复杂度在与遍历整个数组，这是无法避免的；剩下的$O(n)$的时间复杂度，实际上在找一个满足j &amp;lt; i以及nums[j] &amp;lt; nums[i]的并且使dp[j]最大的j；&#xA;那么，可以转化为找dp[j]固定的情况下，最小的一个nums[j]，这样必然能够优先满足，nums[i] &amp;gt; nums[j]；因此我们构造一个贪心数组：min_len，min_len[i] = x表示长度为i的上升子序列的最小结尾元素为x。考虑到min_len一定是个单调递增的数组（易证），那么我们可以基于这个单调递增的特性，利用二分查找，找到满足min_len[j] &amp;lt; nums[i]的最大的j，即利用$O(\log n)$找到最佳转移位置。&#xA;代码 动态规划 class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 1); // dp[0]不考虑，至少有一个元素，所以初始化为1 // dp[1] = 1; // int index = 0; int m = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>714.买卖股票的最佳时机含手续费</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:04 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee.zh/</guid>
      <description>问题描述 714.买卖股票的最佳时机含手续费&#xA;解题思路 分为手中有股票和无股票两种情况讨论，设定在卖出股票时支出手续费:&#xA;手中有股票:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); 手中无股票:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); 初始化:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; 代码 class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); dp[0][0] = -prices[0]; dp[0][1] = -fee; for (int i = 1; i &amp;lt;= prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); } return dp[prices.</description>
    </item>
    <item>
      <title>714.best time to buy and sell stock with transaction fee</title>
      <link>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</link>
      <pubDate>Fri, 14 Oct 2022 16:48:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/714.best-time-to-buy-and-sell-stock-with-transaction-fee/</guid>
      <description>Description 714.best-time-to-buy-and-sell-stock-with-transaction-fee&#xA;解题思路 We can consider this problem in two cases: owning stock and not owning stock, assuming that you need to pay transaction fee when selling stock.&#xA;owning stock:dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]); not owning stock:dp[i][1] = max(0, max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1] - fee)); Initializing dp:&#xA;dp[0][0] = -prices[0]; dp[0][1] = -fee; Code class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices, int fee) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>309.best time to buy and sell stock with cooldown</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>Description 309.best-time-to-buy-and-sell-stock-with-cooldown&#xA;Solution The key point is find what dp should denote and its recurrence formula.&#xA;dp[i] indicates only considering first i days, and is devided into five cases: no operation, bought but not sold (stock in hand), exactly sold, cooling off period, and idle, which are noted as dp[i][0], dp[i][1], dp[i][2], dp[i][3], and dp[i][4] correspondingly.&#xA;Recurrence formula:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // last day can be on operation, bought but not sold, cooling off period, idle dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // last day can be cooling off period adn idle.</description>
    </item>
    <item>
      <title>309.最佳买卖股票时机含冷冻期</title>
      <link>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</link>
      <pubDate>Thu, 13 Oct 2022 21:54:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/309.best-time-to-buy-and-sell-stock-with-cooldown.zh/</guid>
      <description>问题描述 309.最佳买卖股票时机含冷冻期&#xA;解题思路 本题的关键在于找到dp的实际含义，以及它的递推关系; dp[i]表示只考虑前i天的情况，分为无操作、买入未卖出(手中有股票)、正好卖出、冷静期、空闲五种情况，分别记为dp[i][0], dp[i][1], dp[i][2], dp[i][3], dp[i][4].&#xA;递推关系如下:&#xA;dp[i][0] = dp[i - 1][0]; dp[i][1] = max4(dp[i - 1][1], dp[i - 1][0] - prices[i - 1], dp[i - 1][4] - prices[i - 1], dp[i - 1][3] - prices[i - 1]); // 上一天的可能情况有无操作、买入未卖出、冷静期、空闲四种情况 dp[i][2] = dp[i - 1][1] + prices[i - 1]; dp[i][3] = dp[i - 1][2]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]); // 上一天可能有冷静期和空闲两种情况 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max3(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ?</description>
    </item>
    <item>
      <title>solve the problem of downloading assets from github</title>
      <link>http://localhost:1313/posts/leet/webots_assets_dl/</link>
      <pubDate>Thu, 13 Oct 2022 21:38:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/webots_assets_dl/</guid>
      <description>Description After version 2021a, in order to reduce the file size, Webots set resource files such as textures and sounds up for network download by github. However, for well-known reasons, github is very inaccessible in China, so there will be errors like:&#xA;ERROR: Error downloading EXTERNPROTO &amp;#39;StraightStairs&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/objects/stairs/protos/StraightStairs.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;Spot&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/robots/boston_dynamics/spot/protos/Spot.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;Roughcast&amp;#39;: Cannot download &amp;#39;https://raw.</description>
    </item>
    <item>
      <title>解决webots无法从github下载外部资源的问题</title>
      <link>http://localhost:1313/posts/leet/webots_assets_dl.zh/</link>
      <pubDate>Thu, 13 Oct 2022 10:25:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/webots_assets_dl.zh/</guid>
      <description>问题描述 Webots在2021a版本后，为了缩小文件大小，将纹理、声音等资源文件设置成网络下载，即需要通过github进行下载，然而由于众所周知的原因，github在国内的可访问性非常差，因此会出现&#xA;ERROR: Error downloading EXTERNPROTO &amp;#39;StraightStairs&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/objects/stairs/protos/StraightStairs.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;Spot&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/robots/boston_dynamics/spot/protos/Spot.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;Roughcast&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/appearances/protos/Roughcast.proto&amp;#39;, error code: 1: Connection refused ERROR: Error downloading EXTERNPROTO &amp;#39;ThreadMetalPlate&amp;#39;: Cannot download &amp;#39;https://raw.githubusercontent.com/cyberbotics/webots/R2022b/projects/appearances/protos/ThreadMetalPlate.proto&amp;#39;, error code: 1: Connection refused 即无法从github上把资源文件下载下来。&#xA;解决方案 webots的preferences中有关于代理的设置(这也就是为什么系统代理没有生效)，点击preferences-&amp;gt;network，在proxy那一栏，勾选SOCKS v5, Hostname填入127.0.0.1，Port填入7890。 注:首先你自己的电脑要有代理，端口(Port)与你自己的设置有关系。</description>
    </item>
    <item>
      <title>123.买卖股票的最佳时机III</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</link>
      <pubDate>Wed, 12 Oct 2022 20:04:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii.zh/</guid>
      <description>问题描述 123.买卖股票的最佳时机III&#xA;解题思路 本题的关键在于找到dp的实际含义，以及它的递推关系;&#xA;dp[i]表示只考虑前i天的情况，那么到了第i天，有五种可能的情况:&#xA;没有做任何操作，记为dp[i][0]; 前i天发生了一次买入，记为dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) 前i天发生了一次卖出，记为dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) 前i天发生了两次买入，记为dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) 前i天发生了两次卖出，记为dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) 初始化:&#xA;dp[0][0] = 0; dp[0][1] = -prices[0]; // 发生了一次买入 dp[0][2] = 0; // 买入又卖出 dp[0][3] = -prices[0]; // 买入-&amp;gt;卖出-&amp;gt;买入 dp[0][4] = 0; // 买入-&amp;gt;卖出-&amp;gt;买入-&amp;gt;卖出 代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.</description>
    </item>
    <item>
      <title>122.best time to buy and sell stock ii</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sat, 08 Oct 2022 08:14:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Description 122.best-time-to-buy-and-sell-stock-ii&#xA;Solution The key point of this problem is to find the recurrence formula of dp[i]. Let&amp;rsquo;s discuss this problem in two cases.&#xA;if prices[i - 1] is not selected, then dp[i] = dp[i - 1]. It shows that: prices[i - 1] &amp;lt; prices[i - 2]; if prices[i - 1] is selected, then prices[i - 1] &amp;gt;= prices[i - 2], dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2].</description>
    </item>
    <item>
      <title>122.买卖股票的最佳时机II</title>
      <link>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/122.best-time-to-buy-and-sell-stock-ii.zh/</guid>
      <description>问题描述 122.买卖股票的最佳时机II&#xA;解题思路 本题的关键是要找dp的递推关系，分两种情况讨论:&#xA;prices[i - 1]不会被选择，那么dp[i] = dp[i - 1]，其实也说明，prices[i - 1] &amp;lt; prices[i - 2]； prices[i - 1]被选择，那么prices[i - 1] &amp;gt;= prices[i - 2]，dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]。 代码 class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.size() == 1) return 0; vector&amp;lt;int&amp;gt; dp(prices.size() + 1, 0); for (int i = 2; i &amp;lt;= prices.size(); i++) { if (prices[i - 1] &amp;gt;= prices[i - 2]) dp[i] = dp[i - 1] + prices[i - 1] - prices[i - 2]; else dp[i] = dp[i - 1]; } return dp[prices.</description>
    </item>
    <item>
      <title>123.best time to buy and sell stock iii</title>
      <link>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Sat, 08 Oct 2022 08:13:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/123.best-time-to-buy-and-sell-stock-iii/</guid>
      <description>Description 123.best-time-to-buy-and-sell-stock-iii&#xA;Solution The key point is to find what dp should denotes and the recursion formula:&#xA;dp[i] denotes only considering first i days, then by day i, there are five possible cases:&#xA;no operation, written as dp[i][0]; buy stock once in first i days, written as dp[i][1]: dp[i][1] = max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]) sell stock once in first i days, written as dp[i][2]: dp[i][2] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]) by stock twice in first i days, written as dp[i][3]: dp[i][3] = max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]) sell stock twice in first i days, written as dp[i][4]: dp[i][4] = max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]) Initializaiton:</description>
    </item>
    <item>
      <title>121.best time to buy and sell stock</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 07 Oct 2022 16:34:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock/</guid>
      <description>Description 121.best-time-to-buy-and-sell-stock&#xA;Solution dynamic programming dp[i] denotes maximum profit in first i days, so the recurrence relation of dp[i] is: dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0).&#xA;greedy algorithm Let&amp;rsquo;s use cur to record the minimum element and replace the value of cur if the element is smaller, if the element is larger than cur, calculate the profit, save the maximum profit.&#xA;Code class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>121.买卖股票的最佳时机</title>
      <link>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</link>
      <pubDate>Fri, 07 Oct 2022 16:33:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/121.best-time-to-buy-and-sell-stock.zh/</guid>
      <description>问题描述 121.买卖股票的最佳时机&#xA;解题思路 动态规划 dp[i]表示前i天的最大收益，那么dp[i]的递推公式为:dp[i] = min(dp[i - 1], a[i - 1] - min(price[0, i - 1)), 0)。&#xA;贪心算法 利用cur记录最小元素，碰到更小的就替换cur的值，遇到比它大的就进行一次利润计算，保存最大的利润。&#xA;代码 class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } int max(int a, int b, int c) { if (a &amp;gt; b) return a &amp;gt; c ? a : c; else return b &amp;gt; c ? b : c; } public: int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) { if (prices.</description>
    </item>
    <item>
      <title>337.打家劫舍III</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii.zh/</guid>
      <description>问题描述 337.打家劫舍III&#xA;解题思路 严格来说，这一题和198.打家劫舍，213.打家劫舍II的思路并不一致。&#xA;首先，这一道题遍历的是树，而不是一个数组。要比较的是选择目前节点和目前节点左子节点+右子节点，因此在遍历方式上需要采取后序遍历。&#xA;同时，作为二叉树的问题，一般是考虑递归进行处理：&#xA;递归的终止条件： 当前节点为空； 递归函数的返回值： 返回一个长度为2的数组dp，dp[0]表示不偷当前节点的最大金钱，dp[1]表示偷当前节点的最大金钱； 本级递归做什么： 计算偷当前节点的收益val1，不偷当前节点的收益val2，返回{val2, val1}。 代码 class Solution { public: int rob(TreeNode* root) { vector&amp;lt;int&amp;gt; result = robTree(root); return max(result[0], result[1]); } // 长度为2的数组，0：不偷，1：偷 vector&amp;lt;int&amp;gt; robTree(TreeNode* cur) { if (cur == NULL) return vector&amp;lt;int&amp;gt;{0, 0}; vector&amp;lt;int&amp;gt; left = robTree(cur-&amp;gt;left); vector&amp;lt;int&amp;gt; right = robTree(cur-&amp;gt;right); // 偷cur，那么就不能偷左右节点。 int val1 = cur-&amp;gt;val + left[0] + right[0]; // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况 int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; } }; </description>
    </item>
    <item>
      <title>337.house robber iii</title>
      <link>http://localhost:1313/posts/leet/337.house-robber-iii/</link>
      <pubDate>Fri, 07 Oct 2022 04:28:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/337.house-robber-iii/</guid>
      <description>Description 337.house-robber-iii&#xA;Solution Strictly speaking, the idea of this problem is different from 198.house-robber，213.house-robber-ii.&#xA;At first, what this problem need to traverse is tree, rather than an array. We need to compare selecting curent node with selecting left-child node and right-child node rather than current node. So, we should select postorder traversal.&#xA;And as a problem of binary tree, we consider recursion.&#xA;termination conditions of recursion current node is null; return value of recursion function return an array dp of length 2, dp[0] denotes maximum amount when not stealing current node, dp[1] denotes maximum amount when stealing current node; what this level of recursion does calculate the amount val1 when stealing current node, val2 for not stealing current node, return {val2, val1}.</description>
    </item>
    <item>
      <title>213.house robber ii</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii/</guid>
      <description>Description 213.house-robber-ii&#xA;Solution Referring to 198.house-robber, there be another constraint that first and last can&amp;rsquo;t be selected at the same time. So we can split the array into two part: one for [0, n - 1), another for [1, n), corresponding to dp0 and dp1 respectively, just return max(dp0, dp1).&#xA;Code class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.</description>
    </item>
    <item>
      <title>213.打家劫舍II</title>
      <link>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:43:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/213.house-robber-ii.zh/</guid>
      <description>问题描述 213.打家劫舍II&#xA;解题思路 参照198.打家劫舍，但是这里多了一个首尾不能同时选择的选项，因此可以考虑将数组分成两部分，一个包含[0, n - 1)，一个包含[1, n)，分别对应dp0和dp1，取最后两者的最大值即可。&#xA;代码 class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.size() - 2); int result2 = robRange(nums, 1, nums.size() - 1); return max(result1, result2); } int robRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int end) { if (end == start) return nums[start]; vector&amp;lt;int&amp;gt; dp(nums.size()); dp[start] = nums[start]; dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i &amp;lt;= end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; } }; </description>
    </item>
    <item>
      <title>198.house robber</title>
      <link>http://localhost:1313/posts/leet/198.house-robber/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber/</guid>
      <description>Description 198.house-robber&#xA;Solution dp[i] denotes the maximum amount when the first i houses are considered.&#xA;Let&amp;rsquo;s consider the recursive relationship:&#xA;If the i-th house was stolen, it means that the i - 1th house was not stolen, so dp[i] = dp[i - 2] + a[i - 1]. If the i-th house was not stolen, then dp[i] = dp[i - 1]. So, dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]).</description>
    </item>
    <item>
      <title>198.打家劫舍</title>
      <link>http://localhost:1313/posts/leet/198.house-robber.zh/</link>
      <pubDate>Fri, 07 Oct 2022 02:28:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/198.house-robber.zh/</guid>
      <description>问题描述 198.打家劫舍&#xA;解题思路 dp[i]表示考虑前i个房间，能窃取到的最大金额。&#xA;考虑递推关系:&#xA;假设第要窃取第i个房间，那么说明第i - 1个房间，肯定没有被窃取，dp[i] = dp[i - 2] + nums[i - 1]。 假设不窃取第i个房间，则dp[i] = dp[i - 1]。 综上，dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1])。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int rob(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;int&amp;gt; dp(nums.size() + 1, 0); if (nums.size() == 1) return nums[0]; if (nums.</description>
    </item>
    <item>
      <title>139.word Break</title>
      <link>http://localhost:1313/posts/leet/139.word-break/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break/</guid>
      <description>Description 139.word-break&#xA;Solution First, we should determine what dp array means. In this problem, dp[i] = 1 denotes that a string of length i can be split into words that appear in the dictionary.&#xA;So, we can get the recursive relationship:dp[j] = dp[i] &amp;amp;&amp;amp; substr in [i, j) can be split.&#xA;To initialize dp array: dp[0] = 1.&#xA;Attention: we should traverse volume first, then traverse items; if in the reverse order, it&amp;rsquo;s not convenient to judge whether string can be split.</description>
    </item>
    <item>
      <title>139.单词拆分</title>
      <link>http://localhost:1313/posts/leet/139.word-break.zh/</link>
      <pubDate>Wed, 05 Oct 2022 17:28:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/139.word-break.zh/</guid>
      <description>问题描述 139.单词拆分&#xA;解题思路 首先确定dp数组的含义，dp[i] = 1应该表示长度为i的字符串，可以拆分成字典中出现的单词;&#xA;则，dp的递推公式为:dp[j] = dp[i] &amp;amp;&amp;amp; [i, j]区间的字串可以拆分成字典中的单词&#xA;初始化dp数组:dp[0] = 1。&#xA;这里要注意，先遍历体积，再遍历物品；如果倒过来，是不方便判断字串是否可以拆分的。&#xA;代码 #include &amp;lt;string&amp;gt; #include &amp;lt;unordered_set&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::unordered_set; using std::vector; class Solution { public: bool wordBreak(string s, vector&amp;lt;string&amp;gt; &amp;amp;wordDict) { unordered_set&amp;lt;string&amp;gt; wordSet(wordDict.begin(), wordDict.end()); vector&amp;lt;int&amp;gt; dp(s.length() + 1, 0); // 0 为false dp[0] = 1; // 先遍历体积，再遍历物品 for (int j = 0; j &amp;lt;= s.length(); j++) { for (int i = 0; i &amp;lt;= j; i++) { string word = s.</description>
    </item>
    <item>
      <title>279.perfect Squares</title>
      <link>http://localhost:1313/posts/leet/279.perfect-squares/</link>
      <pubDate>Wed, 05 Oct 2022 17:07:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/279.perfect-squares/</guid>
      <description></description>
    </item>
    <item>
      <title>279.完全平方数</title>
      <link>http://localhost:1313/posts/leet/279.perfect-squares.zh/</link>
      <pubDate>Wed, 05 Oct 2022 17:07:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/279.perfect-squares.zh/</guid>
      <description>问题描述 279.完全平方数&#xA;解题思路 本题可以转化成一个完全背包问题，“物品”即{1, 4, 9, 16,...}等完全平方数，体积限制即所给的整数$n$。&#xA;代码 class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } public: int numSquares(int n) { int num = 1; for (int i = 1; i * i &amp;lt;= n; i++) num = i; vector&amp;lt;int&amp;gt; nums(num, 0); for (int i = 0; i &amp;lt; num; i++) // nums[i] &amp;lt;= n nums[i] = (i + 1) * (i + 1); vector&amp;lt;int&amp;gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; num; i++) { for (int j = nums[i]; j &amp;lt;= n; j++) { if (dp[j - nums[i]] &amp;lt; INT_MAX) dp[j] = min(dp[j], dp[j - nums[i]] + 1); } } return dp[n]; } }; </description>
    </item>
    <item>
      <title>322.coin change</title>
      <link>http://localhost:1313/posts/leet/322.coin-change/</link>
      <pubDate>Wed, 05 Oct 2022 03:53:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change/</guid>
      <description>Description 322.coin-change&#xA;Solution The recursive relationship change from max to min: dp[j] = min(dp[j], dp[j - coins[i]] + 1).&#xA;We need pay attention to issue about initializing dp array. To ensure that if j - coins[i] can&amp;rsquo;t be come up with, dp[j] is still dp[j] in last loop, we should initialize dp as INT_MAX, and dp[0] = 0.&#xA;Attention: INT_MAX + 1 &amp;lt; INT_MAX(in C++)&#xA;Code #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ?</description>
    </item>
    <item>
      <title>322.零钱兑换</title>
      <link>http://localhost:1313/posts/leet/322.coin-change.zh/</link>
      <pubDate>Wed, 05 Oct 2022 03:52:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/322.coin-change.zh/</guid>
      <description>问题描述 322.零钱兑换&#xA;解题思路 首先，递推关系从最大变成了最小，即dp[j] = min(dp[j], dp[j - coins[i]] + 1)。&#xA;同时，要注意对dp数组的初始化问题，为了保证j - coins[i]无法组成时，dp[j]选择的仍是上一次i循环的dp[j]，因此要将dp数组初始化为INT_MAX，同时dp[0] = 0。&#xA;要注意INT_MAX + 1 &amp;lt; INT_MAX(在C++中)&#xA;代码 #include &amp;lt;limits.h&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int min(int a, int b) { return a &amp;lt; b ? a : b; } public: int coinChange(vector&amp;lt;int&amp;gt; &amp;amp;coins, int amount) { if (amount == 0) return 0; vector&amp;lt;int&amp;gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; coins.</description>
    </item>
    <item>
      <title>377.combination sum iv</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv/</guid>
      <description>Description 377.combination-sum-iv&#xA;Solution This problem is still a unbounded-knapsack-problem, however, what this problem want to get is permutations rather than combinations.&#xA;With reference to 518.coin-change-ii, traverse volume first, than traverse items.&#xA;代码 class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // prevent overflow, not dp[j] + dp[j - nums[i]] &amp;lt; INT_MAX if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>377.组合总和IV</title>
      <link>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</link>
      <pubDate>Wed, 05 Oct 2022 02:19:20 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/377.combination-sum-iv.zh/</guid>
      <description>问题描述 377.组合总和IV&#xA;解题思路 本题依旧是一个完全背包问题，但是本题求的是排列而非组合。&#xA;参考518.零钱兑换II，先遍历体积，再遍历物品。&#xA;代码 class Solution { public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;dp (target + 1, 0); dp[0] = 1;&#x9;for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; nums.size(); i++) { // 防止溢出 if (j &amp;gt;= nums[i] &amp;amp;&amp;amp; dp[j] &amp;lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; } } return dp[target]; } }; </description>
    </item>
    <item>
      <title>518.coin change ii</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii/</guid>
      <description>Description 518.coin-change-ii&#xA;Solution This problem is still a unbounded-knapsack-problem. What this problem need to solve is combination rather than combination.&#xA;If we want to get the number of combination, we should traverse items first, than traverse volume. But if you want to get the number of permutation, you should traverse volume first, than traverse items.&#xA;For example, assume that nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2, combnations: {1, 1, 1}, {1, 2}.</description>
    </item>
    <item>
      <title>518.零钱兑换II</title>
      <link>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</link>
      <pubDate>Wed, 05 Oct 2022 00:58:22 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/518.coin-change-ii.zh/</guid>
      <description>问题描述 518.零钱兑换II&#xA;解题思路 本题依旧是一个完全背包问题，但是本题求的是组合而非排列。&#xA;求组合时，先遍历物品，再遍历体积；求排列时，则是先遍历体积，再遍历物品。&#xA;例如：假设nums = {1, 2}, target = 3&#xA;dp[0] = 1; for (int i = 0; i &amp;lt; 2; i++) { for (int j = nums[i]; j &amp;lt;= target; j++) dp[j] = dp[j] + dp[j - nums[i]]; } dp[3] == 2，选择组合方式为{1, 1, 1}, {1, 2}。&#xA;dp[0] = 1; for (int j = 0; j &amp;lt;= target; j++) { for (int i = 0; i &amp;lt; 2; i++) { if (j &amp;gt;= nums[i]) dp[j] = dp[j] + dp[j - nums[i]]; } } dp[3] = 3，选择的排列方式为{1, 1, 1}, {1, 2}, {2, 1}。</description>
    </item>
    <item>
      <title>474.ones and zeroes</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes/</link>
      <pubDate>Wed, 05 Oct 2022 00:34:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes/</guid>
      <description>Description 474.ones-and-zeroes&#xA;Solution This problem can be viewed as a two-dimensional 01-knapsack-problem. There are two-dimensional limits about &amp;ldquo;volume&amp;rdquo;: numbers of $0$ can not exceed $m$ and numbers of $1$ can not exceed $n$.&#xA;Recursive relation: dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;Code #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ?</description>
    </item>
    <item>
      <title>474.一和零</title>
      <link>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:37:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/474.ones-and-zeroes.zh/</guid>
      <description>问题描述 474.一和零&#xA;解题思路 本题可以看成一个二维的01背包问题，体积存在两个维度的限制，即$0$的个数不能超过$m$，$1$的个数不超过$n$。&#xA;递推关系:dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - str_num[i][0]][k - str_num[i][1]] + 1)&#xA;代码 #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using std::string; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: int findMaxForm(vector&amp;lt;string&amp;gt; &amp;amp;strs, int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; str_num(strs.size() + 1, vector&amp;lt;int&amp;gt;(2, 0)); for (int i = 0; i &amp;lt; strs.size(); i++) { for (int j = 0; j &amp;lt; strs[i].</description>
    </item>
    <item>
      <title>494.target sum</title>
      <link>http://localhost:1313/posts/leet/494.target-sum/</link>
      <pubDate>Tue, 04 Oct 2022 04:22:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum/</guid>
      <description>Description 494.target-sum&#xA;Solution Actually, what we need to do is choose some numbers whose sum is $\max((sum + target) / 2, (sum - target) / 2)$ in this array. So we can change this problem to a 01-knapsack-problem, and dynamic programming can be used to solve this problem. Also, backtracking can be used to solve this problem.&#xA;In this problem, dp[i][j] should denotes the number of methods to make the sum of number selected to be j when considering the first i numbers.</description>
    </item>
    <item>
      <title>494.目标和</title>
      <link>http://localhost:1313/posts/leet/494.target-sum.zh/</link>
      <pubDate>Tue, 04 Oct 2022 04:09:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/494.target-sum.zh/</guid>
      <description>问题描述 494.目标和&#xA;解题思路 本题表面上说添加&amp;rsquo;+&amp;lsquo;或者&amp;rsquo;-&amp;rsquo;，实际上就是在这个数组中选择一些数，使这些数的总和为$\max((sum + target) / 2, (sum - target) / 2)$。从而转换成01背包问题，利用动态规划求解，当然也可以利用回溯法求解。&#xA;在本题中，dp[i][j]应该表示为考虑前i个数时，使选择的数总和为j的方法数。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int findTargetSumWays(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int sum = 0; vector&amp;lt;int&amp;gt; my_num(nums.size() + 1, 0); for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; my_num[i + 1] = nums[i]; } if ((sum + target) % 2 == 1) return 0; vector&amp;lt;int&amp;gt; res(1001, 0); res[0] = 1; target = max((sum + target) / 2, (sum - target) / 2); // int cnt = 0; for (int i = 1; i &amp;lt;= nums.</description>
    </item>
    <item>
      <title>unbounded knapsack problem</title>
      <link>http://localhost:1313/posts/tech/unbounded-knapsack-problem/</link>
      <pubDate>Tue, 04 Oct 2022 01:33:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/unbounded-knapsack-problem/</guid>
      <description>Description Unbounded Knapsack Problem&#xA;There are $N$ kinds of items and a knapsack with the capacity of $V$, each item has unlimited pieces available.&#xA;The volume of the $i$-th item is $v_i$, and value is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen&amp;rsquo;t exceed the capacity of the pack.&#xA;Solution It&amp;rsquo;s a classic problem of dynamic programming and knapsack problem.</description>
    </item>
    <item>
      <title>完全背包问题</title>
      <link>http://localhost:1313/posts/tech/unbounded-knapsack-problem.zh/</link>
      <pubDate>Mon, 03 Oct 2022 13:50:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/unbounded-knapsack-problem.zh/</guid>
      <description>问题描述 完全背包问题&#xA;有$N$件物品和一个容量是$V$的背包，每件物品都有无限件可用。&#xA;第$i$种物品的体积是$v_i$，价值是$w_i$。求解将哪些物品装入背包，可使这些物品总体积不超过背包容量，且总价值最大。&#xA;解题思路 内层嵌套循环 01背包问题 每样物品只能使用一件，而针对完全背包问题，我们只需要在内层有关体积的循环中，再添加一层循环，枚举一共使用了多少件物品$i$即可。&#xA;for (int i = 1; i &amp;lt;= n; i++) { for (int j = m; j &amp;gt;= v[i]; j--) { for (k = 1; k * v[i] &amp;lt;= j; k++) { dp[j] = max(dp[j], dp[j - k * v[i] + k * w[i]); } } } 更改遍历方向 在01背包问题中，我们内层关于体积的循环，是从大到小的，这是为了保证在比较max(dp[j], dp[j - v[i]] + w[i])时，使用的是上一次i循环的数值；&#xA;而在完全背包问题中，内层关于体积的循环，修改成从小到大即可，此时dp = max(dp[j], dp[j - v[i]] + w[i])中，dp[j - v[i]] + w[i]使用的就是本次i循环中的数值，而i循环中,dp[j - v[i]] = max(dp[j - v[i]], dp[(j - v[i]) - v[i]] + w[i]),依次往前递推，总能找到那个最大值dp[j - k * v[i]] + k * w[i]。</description>
    </item>
    <item>
      <title>1049.last stone weight ii</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</link>
      <pubDate>Sat, 01 Oct 2022 19:28:01 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii/</guid>
      <description>Description 1049.last-stone-weight-ii&#xA;Solution In reality, it&amp;rsquo;s still a 01-pack-problem.&#xA;What it want to get is when you divide the array into two part with least difference of their sum, what the difference is. If you are aware of this, just write code similar to 416.partition-equal-subset-sum.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.</description>
    </item>
    <item>
      <title>1049.最后一块石头的重量II</title>
      <link>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:22:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/1049.last-stone-weight-ii.zh/</guid>
      <description>问题描述 1049.最后一块石头的重量II&#xA;解题思路 实际上还是一个01背包问题。本质上是在求将数组分成差值最小的两部分之后，这两部分的差值，理解了这一点之后，参照416.分割等和子集写代码就好了。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt; b ? a : b; } public: int lastStoneWeightII(vector&amp;lt;int&amp;gt; &amp;amp;stones) { int sum = 0; for (int i = 0; i &amp;lt; stones.size(); i++) { sum += stones[i]; } vector&amp;lt;int&amp;gt; dp(sum / 2 + 1, 0); for (int i = 0; i &amp;lt; stones.size(); i++) { for (int j = sum / 2; j &amp;gt;= stones[i]; j--) dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); } return sum - 2 * dp[sum / 2]; } }; </description>
    </item>
    <item>
      <title>416.分割等和子集</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum.zh/</guid>
      <description>问题描述 416.分割等和子集&#xA;解题思路 本题实际上是一个01背包问题，在这个问题中，背包的体积$V$是数组中所有数的的和的一半(向下取整)，物品的价值就是数组中数的取值：&#xA;代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { sum += nums[i]; } if (sum % 2 == 1) return false; sum_half = sum / 2; vector&amp;lt;int&amp;gt; dp(sum_half + 1, 0); for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>416.partition equal subset sum</title>
      <link>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</link>
      <pubDate>Sat, 01 Oct 2022 19:06:48 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/416.partition-equal-subset-sum/</guid>
      <description>Description 416.partition-equal-subset-sum&#xA;Solution This problem can be viewed as one case of 01-pack-problem&#xA;In this problem, the volume of pack $V$ is half of sum of all integers in the array(rounded down), the value of item is just value of integer in the array.&#xA;Code #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using std::vector; class Solution { private: int max(int a, int b) { return a &amp;gt;= b ? a : b; } public: bool canPartition(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int sum = 0; int sum_half = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>01背包问题</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem.zh/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem.zh/</guid>
      <description>问题描述 01背包问题 有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。&#xA;第$i$件物品的体积是$v_i$，价值是$w_i$，求解将哪些物品装入背包，可使这些物品总体积不超过背包容量，并且总价值最大。&#xA;解题思路 动态规划的经典例题，首先考虑dp[i][j]的含义，这里i表示只考虑前i个物品(i从$1\sim N$)，dp[i][j]表示总体积为j的情况下，考虑前i个物品时，背包里的物品的最大价值。&#xA;可以分成两种情况考虑dp[i][j]的递推关系：&#xA;第i个物品不在背包中时，dp[i][j] = dp[i - 1][j] 此时只有前i - 1个物品，背包中物品体积仍为j。 第i个物品在背包中时，dp[i][j] = dp[i - 1][j - v[i]] + w[i] 前i - 1个物品的体积为j - v[i]。 初始化，显然dp[0][0] = 0。&#xA;根据递推关系和初始化条件写for循环遍历即可。&#xA;代码 #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; const int N = 1010; // 体积不超过1000， 物品件数也不超过1000 int main() { int n, m; // n为物品数量，m为背包体积 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int dp[N][N] = {0}; int v[N] = {0}; // 体积 int w[N] = {0}; // 价值 for (int i = 1; i &amp;lt;=n; i++) cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i]; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { dp[i][j] = dp[i - 1][j]; if (j &amp;gt;= v[i]) // 当前总体积肯定不能小于v[i]，如果小于的话，第i个物品不能放 dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } // int res = 0; // for (int j = 1; j &amp;lt;=m; j++) { // res = max(res, dp[n][j]); // 不需要遍历，直接输出dp[n][m]即可 // } cout &amp;lt;&amp;lt; dp[n][m] &amp;lt;&amp;lt; endl; return 0; } 优化 分析上面的代码，实际上dp[i][j]递推时只会用到dp[i - 1][j]，而不会用到dp[i - 2][j], dp[i - 3][j]等，因此dp数组实际上只需要一维即可，索引为当前总体积。</description>
    </item>
    <item>
      <title>01 kanpsack problem</title>
      <link>http://localhost:1313/posts/leet/01-pack-problem/</link>
      <pubDate>Sat, 01 Oct 2022 15:08:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/01-pack-problem/</guid>
      <description>Description 01-pack-problem&#xA;There are $N$ items and a pack with capacity of $V$, and each item can only be used once.&#xA;The volume of the $i$-th item is $v_i$, and vaule is $w_i$. Please solve which items can be put into the pack so that the value is the greatest and the total volume of these items dosen&amp;rsquo;t exceed the capacity of the pack.&#xA;Solution It&amp;rsquo;s a classic problem of dynamic programming.</description>
    </item>
    <item>
      <title>Dynamic Programming</title>
      <link>http://localhost:1313/posts/tech/dynamic-programming/</link>
      <pubDate>Thu, 29 Sep 2022 16:25:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dynamic-programming/</guid>
      <description>Description Usually, One-dimensional dynamic planning problem, the parameter is always $n$, the result is similar to number sequence $a_n$, or $f(n)$($f$ can be viewed as function or corresponding relationship). At the same time, there will be certain corresponding relationship between $a_n$ and $a_{n - 1}, a_{n - 2}&amp;hellip;a_{1}$, such as $a_n = a_{n-1} + a_{n-2}$(fibonacci sequence).&#xA;Solution Number sequence can be corresponded with array in programming language such as C++. If you find the recursive relationship among number sequence, you can write traversal code using for loop to get the answer.</description>
    </item>
    <item>
      <title>746.min cost climbing stairs</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 16:13:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs/</guid>
      <description>Description 746.min-cost-climbing-stairs&#xA;Solution It&amp;rsquo;s like 70.climbing-stairs plus, the recursive relationship becomes more complicated, but the essence is the same.&#xA;$$dp_n = \min[dp_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2]]$$&#xA;After get the recursive relationship, we can write traversal code to get the answer using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ?</description>
    </item>
    <item>
      <title>509.fibonacci number</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number/</link>
      <pubDate>Thu, 29 Sep 2022 16:10:38 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number/</guid>
      <description>Description 509.fibonacci number&#xA;Solution $a_n = a_{n - 1} + a_{n - 2}$.&#xA;Based on the recursive relationship, we can easily write traversal code using for loop.&#xA;Code class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>343.integer break</title>
      <link>http://localhost:1313/posts/leet/343.integer-break/</link>
      <pubDate>Thu, 29 Sep 2022 16:05:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break/</guid>
      <description>Description 343.integer-break&#xA;Solution The key point is still find the recursive relationship.&#xA;Notice that when $n &amp;gt; 4$, $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$.&#xA;So we can easily write traversal code using for loop.&#xA;Code class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>70.climbing stairs</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs/</link>
      <pubDate>Thu, 29 Sep 2022 15:55:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs/</guid>
      <description>Description 70.climbing-stairs&#xA;Solution Actually, it&amp;rsquo;s the same with 509.fibonacci-number. Let $dp_n$ be the number of ways to get to the top, then we have: $$dp_n = dp_{n - 1} + dp_{n - 2}$$ So we can write the traversal code of for loop.&#xA;Code class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>63.unique paths ii</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii/</link>
      <pubDate>Thu, 29 Sep 2022 15:39:34 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii/</guid>
      <description>Description 63.unique-paths-ii&#xA;Solution Compared with 62.unique-paths, the main difference is that you need to change $dp_{mn}$ when hitting an obstacle(obstacleGrid[i][j] = 0). Just set dp[i][j] = 0.&#xA;And you need pay attention to judging the conditionality in for loop.&#xA;When i = 0 or j = 0, dp[i][j] = dp[i][j - 1] or dp[i][j] = dp[i - 1][j]. dp[0][0] = 0.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.</description>
    </item>
    <item>
      <title>62.unique paths</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths/</link>
      <pubDate>Thu, 29 Sep 2022 15:28:54 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths/</guid>
      <description>Description 62.unique-paths&#xA;Solution $dp_{mn}$ means the number of paths from (1, 1) to (m, n). Just find the connection among $dp_{mn}, dp_{(m-1)n}, dp_{m(n-1)}$.&#xA;We have: $$dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$$ Based on the relationship, we can write the traversal code using for loop.&#xA;Code #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>343.整数拆分</title>
      <link>http://localhost:1313/posts/leet/343.integer-break.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:59:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/343.integer-break.zh/</guid>
      <description>题目描述 343.整数拆分&#xA;解题思路 还是寻找递推关系,设$dp_n$为正整数$n$所求的最大乘积。 这里可以注意到:$n &amp;gt; 4$时， $dp_n = \max[dp_{n - 3} * 3,\ dp_{n - 4} * 4]$。 根据递推关系写出for循环递推求解。&#xA;代码 class Solution { public: int get_max(int a, int b) { return a &amp;gt; b ? a : b; } int integerBreak(int n) { vector&amp;lt;int&amp;gt; res(n); if (n == 1 || n == 4) return n; else if (n == 2 || n == 3) return 1 * (n - 1); else { for (int i = 0; i &amp;lt; 4; i++) res[i] = i + 1; for (int i = 4; i &amp;lt; n; i++) { res[i] = get_max(res[i - 3] * 3, res[i - 4] * 4); } return res[n - 1]; } } }; </description>
    </item>
    <item>
      <title>63.不同路径II</title>
      <link>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:55:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/63.unique-paths-ii.zh/</guid>
      <description>题目描述 63.不同路径II&#xA;解题思路 相比62.不同路径II， 主要是多了障碍物地判断，设$obstacleGrid[i][j] = 0$，则$dp_{{i}{j}} = 0$，其余递推关系相同。 注意for循环遍历地过程中的条件判断。当i = 0或j = 0，dp[i][j] = dp[i][j - 1]或dp[i][j] = dp[i - 1][j]。 dp[0][0] = 0。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m, vector&amp;lt;int&amp;gt;(n, 0)); dp[0][0] = 1; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (i == 0 &amp;amp;&amp;amp; j == 0) { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else dp[i][j] = 1; } else { if (obstacleGrid[i][j] == 1) dp[i][j] = 0; else { if (i == 0) dp[i][j] = dp[i][j - 1]; else if (j == 0) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } } return dp[m - 1][n - 1]; } }; </description>
    </item>
    <item>
      <title>62.不同路径</title>
      <link>http://localhost:1313/posts/leet/62.unique-paths.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:51:33 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/62.unique-paths.zh/</guid>
      <description>问题描述 62.不同路径&#xA;解题思路 还是找递推关系： $dp_{mn} = dp_{(m-1)n} + dp_{m(n-1)}$&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m + 1, vector&amp;lt;int&amp;gt;(n + 1, 0)); dp[1][1] = 1; // dp[1][2] = 1; // dp[2][1] = 1; for (int i = 1; i &amp;lt;= m; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (i == 1 &amp;amp;&amp;amp; j == 1) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } }; </description>
    </item>
    <item>
      <title>746.使用最小花费爬楼梯</title>
      <link>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</link>
      <pubDate>Thu, 29 Sep 2022 10:36:16 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/746.min-cost-climbing-stairs.zh/</guid>
      <description>题目描述 746.使用最小花费爬楼梯&#xA;解题思路 相当于爬楼梯的进阶版，递推关系变复杂了一些，但本质没有变。 $a_n = min(a_{n - 1} + cost[i - 1], a_{n - 2} + cost[i - 2])$ 写出递推关系后就能很方便地写出for循环来遍历求解。&#xA;代码 #include &amp;lt;vector&amp;gt; using std::vector; class Solution { public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt; &amp;amp;cost) { int sz = cost.size(); vector&amp;lt;int&amp;gt; dp(2); dp[0] = dp[1] = 0; // dp[2] = cost[0] &amp;lt; cost[1] ? cost[0] : cost[1]; for (int i = 2; i &amp;lt;= sz; i++) { // 原始版本 // dp[i] = (dp[i - 2] + cost[i - 2]) &amp;lt; (dp[i - 1] + cost[i - 1]) ?</description>
    </item>
    <item>
      <title>70.爬楼梯</title>
      <link>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:56:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/70.climbing-stairs.zh/</guid>
      <description>题目描述 70.爬楼梯&#xA;解题思路 本质上与斐波那契数是一样的：$a_n = a_{n - 1} + a_{n - 2}$ 构建for循环来遍历。&#xA;代码 class Solution { public: int climbStairs(int n) { int cnt[2] = {1, 1}; if (n == 1) return 1; for (int i = 1; i &amp;lt; n; i++) { int sum = cnt[0] + cnt[1]; cnt[0] = cnt[1]; cnt[1] = sum; } return cnt[1]; } }; </description>
    </item>
    <item>
      <title>509.斐波那契数</title>
      <link>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</link>
      <pubDate>Wed, 28 Sep 2022 23:52:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/509.fibonacci-number.zh/</guid>
      <description>题目描述 509.斐波那契数&#xA;解题思路 $a_n = a_{n-1} + a_{n-2}$，利用这一递推关系构建for循环即可，实际上只需要容量为2的数组。&#xA;代码 class Solution { public: int fib(int N) { if (N &amp;lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; </description>
    </item>
    <item>
      <title>一维动态规划-基础版</title>
      <link>http://localhost:1313/posts/tech/dynamic-programming.zh/</link>
      <pubDate>Wed, 28 Sep 2022 19:23:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/dynamic-programming.zh/</guid>
      <description>问题描述 一般来说，一维动态规划的问题，其输入的参数一般是$n$，而所求结果有点像数列$a_n$，或者说$f(n)$($f$可以认为是函数或者说对应关系)，同时$a_n$与之前的$a_{n-1},a_{n-2},&amp;hellip;a_{1}$有一个确定的对应的关系，例如$a_n = a_{n-1} + a_{n-2}$(斐波那契数列)&#xA;解题步骤 数列即可与编程语言中的数组对应起来，在找到数列之间的迭代关系时，即可编写for循环来求解。&#xA;例题 509.斐波那契数 509.斐波那契数-题解 70.爬楼梯 70.爬楼梯-题解 746.使用最小花费爬楼梯 746.使用最小花费爬楼梯-题解 343.整数拆分 343.整数拆分-题解 62.不同路径 62.不同路径-题解 63.不同路径II 63.不同路径II-题解 </description>
    </item>
    <item>
      <title>Vscdoe 通过cookie 登陆美区 LeetCode</title>
      <link>http://localhost:1313/posts/blog/vscode-leetcode-cookie.zh/</link>
      <pubDate>Tue, 27 Sep 2022 22:47:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/vscode-leetcode-cookie.zh/</guid>
      <description>安装插件 vscode 安装leetcode插件。&#xA;使用cookie登陆 如果选择使用github登陆leetcode.com，似乎会有无法提交和测试的bug，而用cookie登陆就没有这个问题&#xA;使用edge获取cookie 使用Firefox获取的cookie有问题，无法正常登陆&#xA;右键，选择检查 选择网络 打开leetcode的problem页面 下滑找到cookie那一栏，复制cookie </description>
    </item>
    <item>
      <title>My_blog_powered_by_Hugo&amp;PaperMod</title>
      <link>http://localhost:1313/posts/blog/my_blog_powered_by_hugopapermod/</link>
      <pubDate>Mon, 26 Sep 2022 20:30:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/my_blog_powered_by_hugopapermod/</guid>
      <description>安装Hugo mac非常方便，</description>
    </item>
    <item>
      <title>My_blog_powered_by_Hugo&amp;PaperMod</title>
      <link>http://localhost:1313/posts/blog/my_blog_powered_by_hugopapermod.zh/</link>
      <pubDate>Mon, 26 Sep 2022 20:30:31 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/my_blog_powered_by_hugopapermod.zh/</guid>
      <description>安装Hugo mac非常方便，</description>
    </item>
    <item>
      <title>37.sudoku Solver 解数独</title>
      <link>http://localhost:1313/posts/leet/37.sudoku-solver.zh/</link>
      <pubDate>Mon, 26 Sep 2022 15:03:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/37.sudoku-solver.zh/</guid>
      <description>题目描述 链接：37.Sodoku Solver&#xA;解题思路 相比一般的回溯，需要两层for循环，一个处理行，一个处理列，递归的过程来决定，空格处到底填哪个数字； 本递归函数用bool作为返回值类型，要注意返回值在递归中的作用； 另外还有一个判断board是否合规的函数。&#xA;代码 class Solution { private: bool isValid(int row, int col, char val, vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // 判断行里是否重复 if (board[row][i] == val) { return false; } } for (int j = 0; j &amp;lt; 9; j++) { // 判断列里是否重复 if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i &amp;lt; startRow + 3; i++) { // 判断9方格里是否重复 for (int j = startCol; j &amp;lt; startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // 逐行 for (int j = 0; j &amp;lt; 9; j++) { // 逐列 if (board[i][j] !</description>
    </item>
    <item>
      <title>37.解数独</title>
      <link>http://localhost:1313/posts/leet/37.sudoku-solver/</link>
      <pubDate>Mon, 26 Sep 2022 15:03:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/37.sudoku-solver/</guid>
      <description>Description 链接：37.Sodoku Solver&#xA;Solution Compared with usual backtracking, we need for loop of two layers, one for row and another for column. A recursive process is used to determine exactly which number to fill in the space.&#xA;This return type of this function is bool, please pay attention to the role of return value in recursion.&#xA;Also a function to determine whether board is legal is required.&#xA;Code class Solution { private: bool isValid(int row, int col, char val, vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // judge whether there are duplicates in a row if (board[row][i] == val) { return false; } } for (int j = 0; j &amp;lt; 9; j++) { // judge whether there are duplicates in a column if (board[j][col] == val) { return false; } } int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; // judge whether there are duplicates in ninepin for (int i = startRow; i &amp;lt; startRow + 3; i++) { for (int j = startCol; j &amp;lt; startCol + 3; j++) { if (board[i][j] == val) { return false; } } } return true; } bool track_back(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board) { for (int i = 0; i &amp;lt; 9; i++) { // traverse in row for (int j = 0; j &amp;lt; 9; j++) { // traverse in column if (board[i][j] !</description>
    </item>
    <item>
      <title>为 papermod 主题添加 Latex 支持</title>
      <link>http://localhost:1313/posts/blog/latex_support_papermod.zh/</link>
      <pubDate>Mon, 26 Sep 2022 11:42:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/latex_support_papermod.zh/</guid>
      <description>steps to follow 在themes/PaperMod/layouts/partials目录下创建math.html文件，文件内容如下&#xA;&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css&amp;#34; integrity=&amp;#34;sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt; &amp;lt;script defer src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js&amp;#34; integrity=&amp;#34;sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script defer src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js&amp;#34; integrity=&amp;#34;sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; document.addEventListener(&amp;#34;DOMContentLoaded&amp;#34;, function() { renderMathInElement(document.body, { // customised options // • auto-render specific keys, e.g.: delimiters: [ {left: &amp;#39;$$&amp;#39;, right: &amp;#39;$$&amp;#39;, display: true}, {left: &amp;#39;$&amp;#39;, right: &amp;#39;$&amp;#39;, display: false}, {left: &amp;#39;\\(&amp;#39;, right: &amp;#39;\\)&amp;#39;, display: false}, {left: &amp;#39;\\[&amp;#39;, right: &amp;#39;\\]&amp;#39;, display: true} ], // • rendering keys, e.g.: throwOnError : false }); }); &amp;lt;/script&amp;gt; 编辑themes/PaperMod/layouts/partials目录下的extend_head.</description>
    </item>
    <item>
      <title>为 PaperMod 主题添加 LaTeX 支持</title>
      <link>http://localhost:1313/posts/blog/latex_support_papermod/</link>
      <pubDate>Mon, 26 Sep 2022 11:42:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/blog/latex_support_papermod/</guid>
      <description>steps to follow 在themes/PaperMod/layouts/partials目录下创建math.html文件，文件内容如下&#xA;&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css&amp;#34; integrity=&amp;#34;sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt; &amp;lt;script defer src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js&amp;#34; integrity=&amp;#34;sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script defer src=&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js&amp;#34; integrity=&amp;#34;sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; document.addEventListener(&amp;#34;DOMContentLoaded&amp;#34;, function() { renderMathInElement(document.body, { // customised options // • auto-render specific keys, e.g.: delimiters: [ {left: &amp;#39;$$&amp;#39;, right: &amp;#39;$$&amp;#39;, display: true}, {left: &amp;#39;$&amp;#39;, right: &amp;#39;$&amp;#39;, display: false}, {left: &amp;#39;\\(&amp;#39;, right: &amp;#39;\\)&amp;#39;, display: false}, {left: &amp;#39;\\[&amp;#39;, right: &amp;#39;\\]&amp;#39;, display: true} ], // • rendering keys, e.g.: throwOnError : false }); }); &amp;lt;/script&amp;gt; 编辑themes/PaperMod/layouts/partials目录下的extend_head.</description>
    </item>
    <item>
      <title>Math_test</title>
      <link>http://localhost:1313/posts/tech/math_test/</link>
      <pubDate>Mon, 26 Sep 2022 11:40:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/tech/math_test/</guid>
      <description>math_test 中文测试 $a_b$ $$a_b + c_d$$&#xA;aaa</description>
    </item>
    <item>
      <title>47.permutations-ii</title>
      <link>http://localhost:1313/posts/leet/47.permutations-ii/</link>
      <pubDate>Sun, 25 Sep 2022 22:05:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/47.permutations-ii/</guid>
      <description>Description 47.permutations-ii&#xA;Solution Compared with 47.permutations, there is interference from duplicate numbers. So we should de-duplicate such as combination-sum-ii&#xA;Judge whether nums[i] is in path by if (used[i] == 1), de-duplicate by if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0).&#xA;Attention: we should sort the array first.&#xA;Code #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; using std::vector; class Solution { private: vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int used[8] = {0}; void track_back(vector&amp;lt;int&amp;gt; nums, int index) { if (path.</description>
    </item>
    <item>
      <title>47.permutations-ii 全排列II</title>
      <link>http://localhost:1313/posts/leet/47.permutations-ii.zh/</link>
      <pubDate>Sun, 25 Sep 2022 22:05:03 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/47.permutations-ii.zh/</guid>
      <description>问题描述 47.全排列II&#xA;解题思路 相比全排列，多了重复数字的干扰，可以参照带重复数字的组合问题来进行去重:&#xA;if (used[i] == 1)判断nums[i]是否已经在path中，if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0)来进行去重。&#xA;注意，要先对目标数组排序。&#xA;代码 #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; using std::vector; class Solution { private: vector&amp;lt;int&amp;gt; path; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int used[8] = {0}; void track_back(vector&amp;lt;int&amp;gt; nums, int index) { if (path.size() &amp;gt;= nums.size()) { res.push_back(path); return; } for (int i = 0; i &amp;lt; nums.size(); i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; used[i - 1] == 0) continue; if (used[i] == 1) continue; path.</description>
    </item>
    <item>
      <title>51.n Queens</title>
      <link>http://localhost:1313/posts/leet/51.n-queens/</link>
      <pubDate>Sun, 25 Sep 2022 21:42:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/51.n-queens/</guid>
      <description>Description 51.n-queens&#xA;Solution Backtracking, please pay attention to how to judge whether chess is in the same diagonal.&#xA;Code class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = &amp;#34;.........&amp;#34;; vector&amp;lt;string&amp;gt; row_str; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; void track_back(int n, int index) { if (index &amp;gt;= n) { res.</description>
    </item>
    <item>
      <title>51.n皇后</title>
      <link>http://localhost:1313/posts/leet/51.n-queens.zh/</link>
      <pubDate>Sun, 25 Sep 2022 21:42:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/leet/51.n-queens.zh/</guid>
      <description>问题描述 51.n皇后&#xA;解题思路 典型的回溯，注意如何判断棋子在同一斜线上。&#xA;代码 class Solution { private: int row_col[17] = {0}; int row_plus_col[17] = {0}; int row_arr[9] = {9, 9, 9, 9, 9, 9, 9, 9, 9}; int col_arr[9] = {0}; // int col = 0; string path = &amp;#34;.........&amp;#34;; vector&amp;lt;string&amp;gt; row_str; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; void track_back(int n, int index) { if (index &amp;gt;= n) { res.push_back(row_str); return; } for (int i = 0; i &amp;lt; n; i++) { // i表示在第几列，index表示在第几行 if (col_arr[i] !</description>
    </item>
    <item>
      <title>Leetcode</title>
      <link>http://localhost:1313/posts/leet/_index.zh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leet/_index.zh/</guid>
      <description></description>
    </item>
    <item>
      <title>技术</title>
      <link>http://localhost:1313/posts/tech/_index.zh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tech/_index.zh/</guid>
      <description></description>
    </item>
    <item>
      <title>折腾</title>
      <link>http://localhost:1313/posts/blog/_index.zh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/blog/_index.zh/</guid>
      <description></description>
    </item>
    <item>
      <title>生活</title>
      <link>http://localhost:1313/posts/life/_index.zh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/life/_index.zh/</guid>
      <description></description>
    </item>
    <item>
      <title>阅读</title>
      <link>http://localhost:1313/posts/read/_index.zh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/read/_index.zh/</guid>
      <description></description>
    </item>
  </channel>
</rss>
